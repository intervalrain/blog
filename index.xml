<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Rain's Blog</title><link>http://intervalrain.github.io/</link><description>Recent content on Rain's Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 18 Feb 2023 14:28:24 +0800</lastBuildDate><atom:link href="http://intervalrain.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>[Life] 原子習慣</title><link>http://intervalrain.github.io/posts/life/20230218/</link><pubDate>Sat, 18 Feb 2023 14:28:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/life/20230218/</guid><description>對習慣演成的一些隨筆</description></item><item><title>[Algo] 2-4. 回溯法 Backtracking</title><link>http://intervalrain.github.io/posts/cs/algo/backtracking/</link><pubDate>Fri, 27 Jan 2023 10:50:26 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/backtracking/</guid><description>演算法設計，介紹什麼是回溯法，並示範運用回溯法的思維解題</description></item><item><title>[Algo] 2-3. 分治法 Divide and Conquer</title><link>http://intervalrain.github.io/posts/cs/algo/divide_and_conquer/</link><pubDate>Fri, 27 Jan 2023 10:48:42 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/divide_and_conquer/</guid><description>演算法設計，介紹什麼是分治法，分治法的核心思想與例題，與常見的一些技巧。</description></item><item><title>[Algo] 2-2. 貪心演算法 Greedy</title><link>http://intervalrain.github.io/posts/cs/algo/greedy/</link><pubDate>Tue, 24 Jan 2023 18:31:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/greedy/</guid><description>演算法設計，介紹什麼是貪心法，貪心法的解題思維</description></item><item><title>[Algo] 2-1. 暴力演算法 Brute Force</title><link>http://intervalrain.github.io/posts/cs/algo/brute_force/</link><pubDate>Tue, 24 Jan 2023 15:57:40 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/brute_force/</guid><description>演算法設計，介紹什麼是暴力演算法，並示範幾種資料結構的遍歷與枚舉</description></item><item><title>[LeetCode] 491. Non-decreasing Subsequences</title><link>http://intervalrain.github.io/posts/leetcode/491/</link><pubDate>Fri, 20 Jan 2023 21:39:50 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/491/</guid><description>491. Non-decreasing Subsequences
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、Backtracking、Bit Manipulation 一、題目 Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.
Example 1:
Input: nums = [4,6,7,7] Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] Explanation: Example 2:
Input: nums = [4,4,3,2,1] Output: [[4,4]] Constraints:
&amp;lt;= nums.length &amp;lt;= 15 -100 &amp;lt;= nums[i] &amp;lt;= 100 二、分析 這一很典型的是一個 backtrack 的問題，只要熟悉回溯法的框架並注意終止條件與處理重覆子序列即可。 終止條件為 i == nums.</description></item><item><title>[IT] C# Depth Ch.2 C# 2</title><link>http://intervalrain.github.io/posts/it/csharp_depth_ch2/</link><pubDate>Fri, 20 Jan 2023 10:10:46 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/csharp_depth_ch2/</guid><description>C# 2 一、泛型 使用泛型(generic type)可以在編寫在編譯時類型安全的通用程式碼，無須事先知道要使用的具體類型。 示例1: array類型: 大小需預先設定，若要添加需要重新分配 public static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(string[] names) { foreach (string name in names) { Console.WriteLine(name); } } public static string[] GenerateNames() { string[] names = new string[4]; names[0] = &amp;#34;Mike&amp;#34;; names[1] = &amp;#34;Rain&amp;#34;; names[2] = &amp;#34;Jessica&amp;#34;; names[3] = &amp;#34;Billy&amp;#34;; return names; } 示例2: ArrayList類型: ArrayList.Add是Object的方法，但如果塞入不適合的參數類型，可能會引發InvalidCastException
public static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(ArrayList names) { foreach (object name in names) { Console.</description></item><item><title>[LeetCode] 974. Subarray Sums Divisible by K</title><link>http://intervalrain.github.io/posts/leetcode/974/</link><pubDate>Thu, 19 Jan 2023 13:50:19 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/974/</guid><description>974. Subarray Sums Divisible by K
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、Prefix Sum 一、題目 Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.
A subarray is a contiguous part of an array.
Example 1:
Input: nums = [4,5,0,-2,-3,1], k = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by k = 5:
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Example 2:</description></item><item><title>[LeetCode] 53. Maximum Subarray</title><link>http://intervalrain.github.io/posts/leetcode/53/</link><pubDate>Wed, 18 Jan 2023 23:20:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/53/</guid><description>53. Maxmimum Subarray
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Divide and Conquer、Dynamic Programming 一、題目 Given an integer array num, find the subarray with the largest sum, and return its sum.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: The subarray [4,-1,2,1] has the largest sum 6. Example 2:
Input: nums = [1] Output: 1 Explanation: The subarray [1] has the largest sum 1. Example 3:
Input: [5,4,-1,7,8] Output: 23 Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.</description></item><item><title>[LeetCode] 918. Maximum Sum Circular Subarray</title><link>http://intervalrain.github.io/posts/leetcode/918/</link><pubDate>Wed, 18 Jan 2023 23:07:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/918/</guid><description>918. Maximum Sum Circular Subarray
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Divide and Conquer、Dynamic Programming、Queue、Monotonic Queue 一、題目 Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.
A circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].</description></item><item><title>[IT] C# Depth Ch.1 與時俱進的語言</title><link>http://intervalrain.github.io/posts/it/csharp_depth_ch1/</link><pubDate>Tue, 17 Jan 2023 22:27:58 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/csharp_depth_ch1/</guid><description>與時俱進的語言 一、System Class 1. 泛型(genric) 可更清楚的描述序列中每個元素的類型。 C#1 示例
public class Bookshelf { public IEnumerable Books { get { ... } } } C#2 示例：泛型
public class Bookshelf { public IEnumerable&amp;lt;Book&amp;gt; Books { get { ... } } } 2. 可空值類型(nullable value type) 可有效的表示未定的變量值，以擺脫魔數(用-1當集合索引，用 MinValue 或 MaxValue 做為初始值)。 示例
string? a = null; Console.WriteLine(a ?? &amp;#34;null&amp;#34;); // null a = &amp;#34;abc&amp;#34;; Console.WriteLine(a ?? &amp;#34;null&amp;#34;); // abc 3. 匿名類型(anonymous type)、隱式局部變數(var) 兩者皆可解決靜態類型語言的缺陷：程式碼冗長。 示例1: 匿名類型(anonymous type)</description></item><item><title>[LeetCode] 926. Flip String to Monotone Increasing</title><link>http://intervalrain.github.io/posts/leetcode/926/</link><pubDate>Tue, 17 Jan 2023 16:36:26 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/926/</guid><description>926. Flip String to Monotone Increasing
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String、Dynamic Programming 一、題目 A binary string is monotone increasing if it consists of some number of 0&amp;rsquo;s (possibly none), followed by some number of 1&amp;rsquo;s (also possibly none).
You are given a binary string s. You can flip s[i] changing 0 to 1 or from 1 to 0.
Return the minimum number of flips to make s monotone increasing.
Example 1:</description></item><item><title>[IT] Shell 筆記</title><link>http://intervalrain.github.io/posts/it/shell/</link><pubDate>Thu, 12 Jan 2023 23:34:41 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/shell/</guid><description>Reference
https://blog.csdn.net/w918589859/article/details/108752592
https://www.w3cschool.cn/linux/linux-Shell.html
一、Shell 簡介 什麼是 Shell?
Shell 是一個用 C 語言編寫的程式，它是使用者使用 Linux 的橋樑。Shell 既是一種命令語言，又是一種程式設計語言。
Shell 是指一種應用程式，這個應用程式提供了一個界面，使用者通過這個界面訪問作業系統核心(kernel)的服務。 為什麼要學習和使用 Shell?
Shell 屬於內建的腳本，程序開發的效率非常高，依賴於功能強大的命令可以迅速的完成開發任務(批次處理)。 Shell 腳本(Shell script)
是一種為 Shell 編寫的腳本程式。業界所說的 Shell 通常都是指 Shell 腳本。 二、 Shell 入門 1. Shell 環境 Shell 編程需要能編寫程式碼的文本編輯器和一個能解釋執行的腳本解釋器。 在 linux 中有很多類型的 Shell，不同的 Shell 具備不同的功能，Shell 還決定了腳本中函數的語法。 Bash 是 Linux 中默認的 Shell。一般情況下，人們不區分 Bourne Shell 和 Bourne Again Shell，所以 #!/bin/sh 也可以被替換成 #!/bin/bash Linux 的 Shell 種類眾多，不同的 Shell 都有自己的特點以及用途，常見的有： Bourne Shell (/usr/bin/sh 或 /bin/sh) Bourne Again Shell (/bin/bash) C Shell (/usr/bin/csh) K Shell (/usr/bin/ksh) Shell for Root(sbin/sh) &amp;hellip;&amp;hellip; 2.</description></item><item><title>[LeetCode] 1519. Number of Nodes in the Sub-Tree With the Same Level</title><link>http://intervalrain.github.io/posts/leetcode/1519/</link><pubDate>Thu, 12 Jan 2023 22:56:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1519/</guid><description>1519. Number of Nodes in the Sub-Tree With the Same Level
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table、Tree、Depth-First Search、Breadth-First Search、Counting 一、題目 You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.</description></item><item><title>[LeetCode] 100. Same Tree</title><link>http://intervalrain.github.io/posts/leetcode/100/</link><pubDate>Tue, 10 Jan 2023 21:48:09 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/100/</guid><description>100. Same Tree
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Tree、Depth-First Search、Breadth-First Search、Binary Tree 一、題目 Given the roots of two binary tree p and q, write a function to check if they are the same or not.
Two binary tree are considered the same if they are structurally iedntical, and the nodes have the same value.
Example 1:
Input: p = [1,2,3], q = [1,2,3] Output: true Example 2:
Input: p = [1,2], q = [1,null,2] Output: false Example 3: Input: p = [1,2,1], q = [1,1,2] Output: false Constraints:</description></item><item><title>[LeetCode] 149. Max Points on a Line</title><link>http://intervalrain.github.io/posts/leetcode/149/</link><pubDate>Sun, 08 Jan 2023 23:44:07 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/149/</guid><description>149. Max Points on a Line
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Hash Table、Math、Geometry 一、題目 Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.
Example 1:
Input: points = [[1,1],[2,2],[3,3]] Output: 3 Example 2: Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Constraints:
1 &amp;lt;= points.length &amp;lt;= 300 points[i].length == 2 -10^4 &amp;lt;= xi, yi &amp;lt;= 10^4 All the points are unique.</description></item><item><title>[LeetCode] 452. Minimum Number of Arrows to Burst Balloons</title><link>http://intervalrain.github.io/posts/leetcode/452/</link><pubDate>Thu, 05 Jan 2023 20:19:49 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/452/</guid><description>452. Minimum Number of Arrows to Burst Balloons
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array,Greedy,Sorting 一、題目 There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [x_start, x_end] denotes a balloon whose horizontal diameter stretches between x_start and x_end. You do not know the exact y-coordinates of the balloons.
Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis.</description></item><item><title>[Algo] 1-9. Algorithm</title><link>http://intervalrain.github.io/posts/cs/algo/algorithm/</link><pubDate>Tue, 03 Jan 2023 21:49:42 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/algorithm/</guid><description>C++ 的內建演算法庫使用與範例</description></item><item><title>[LeetCode] 944. Delete Columns to Make Sorted</title><link>http://intervalrain.github.io/posts/leetcode/944/</link><pubDate>Tue, 03 Jan 2023 20:09:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/944/</guid><description>944. Delete Columns to Make Sorted
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、String 一、題目 You are given an array of n string strs, all of the same length.
The string s can be arranged such that there is one on each line, making a grid. For example, strs = [&amp;quot;abc&amp;quot;, &amp;quot;bce&amp;quot;, &amp;quot;cae&amp;quot; can be arranged as :
abc bce cae You want to delete the columns that are not sorted lexicographically. In the aove example (0-indexed), columns 0('a','b','c') and 2('c','e','e') are sorted while column 1('b','c','a') is not, so you would delete column 1.</description></item><item><title>[LeetCode] 2522. Partition String Into Substrings With Values at Most K</title><link>http://intervalrain.github.io/posts/leetcode/2522/</link><pubDate>Mon, 02 Jan 2023 23:15:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2522/</guid><description>2522. Partition String Into Substrings With Values at Most K
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 You are given a string s consisting of digits from 1 to 9 and an integer k.
A partition of a string s is called good if:
Each digit of s is part of exactly one substring. The value of each substring is less than or equal to k. Return the minimum number of substrings in a good partition of s.</description></item><item><title>[LeetCode] 2523. Closest Prime Numbers in Range</title><link>http://intervalrain.github.io/posts/leetcode/2523/</link><pubDate>Mon, 02 Jan 2023 16:33:40 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2523/</guid><description>2523. Closest Prime Numbers in Range
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 Given two positive integers left and right, find the two integers num1 and num2 such that:
left &amp;lt;= nums1 &amp;lt; nums2 &amp;lt;= right. nums1 and nums2 are both prime numbers. nums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.
Return the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.</description></item><item><title>[LeetCode] 520. Detect Capital</title><link>http://intervalrain.github.io/posts/leetcode/520/</link><pubDate>Mon, 02 Jan 2023 11:05:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/520/</guid><description>520. Detect Capital
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String 一、題目 We define the usage of capitals in a word to be right when one of the following cases holds:
All letters in this word are capitals, like &amp;quot;USA&amp;quot;. All letters in this word are not capitals, like &amp;quot;leetcode&amp;quot;. Only the first letter in this word is capital, like &amp;quot;Google&amp;quot;.
Given a string word, return true if the usage of capitals in it is right.</description></item><item><title>[LeetCode] 2521. Distinct Prime Factors of Product of Array</title><link>http://intervalrain.github.io/posts/leetcode/2521/</link><pubDate>Sun, 01 Jan 2023 23:52:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2521/</guid><description>2521. Distinct Prime Factors of Product of Array
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.
Note that:
A number greater than 1 is called prime if it is divisible by only 1 and itself. An integer val1 is a factor of another integer val2 if val2 / val1 is an integer.</description></item><item><title>[LeetCode] 2520. Count the Digits That Divide a Number</title><link>http://intervalrain.github.io/posts/leetcode/2520/</link><pubDate>Sun, 01 Jan 2023 23:41:54 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2520/</guid><description>2520. Count the Digits That Divide a Number
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 Given an integer num, return the number of digits in num that divide num. An integer val divides nums if nums % val == 0.
Example 1:
Input: num = 7 Output: 1 Explanation: 7 divides itself, hence the answer is 1. Example 2:
Input: num = 121 Output: 2 Explanation: 121 is divisible by 1, but not 2.</description></item><item><title>[LeetCode] 290. Word Pattern</title><link>http://intervalrain.github.io/posts/leetcode/290/</link><pubDate>Sun, 01 Jan 2023 23:14:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/290/</guid><description>290. Word Pattern
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Hash Table、String 一、題目 Given a pattern and a string s, find if s follows the same pattern.
Here follow means a full match, such that there is a bijection between a letter in pattern and non-empty word in s.
Example 1:
Input: pattern = &amp;ldquo;abba&amp;rdquo;, s = &amp;ldquo;dog cat cat dog&amp;rdquo; Output: true Example 2:
Input: pattern = &amp;ldquo;abba&amp;rdquo;, s = &amp;ldquo;dog cat cat fish&amp;rdquo; Output: false Example 3:</description></item><item><title>[IT] C# Yield Return</title><link>http://intervalrain.github.io/posts/it/csharp_yield/</link><pubDate>Sun, 01 Jan 2023 21:40:25 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/csharp_yield/</guid><description>Introduction to yield return in C#</description></item><item><title>[LeetCode] 1834. Single-Threaded CPU</title><link>http://intervalrain.github.io/posts/leetcode/1834/</link><pubDate>Thu, 29 Dec 2022 22:49:27 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1834/</guid><description>1834. Single-Threaded CPU
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Sorting、Heap (Priority Queue&amp;gt; 一、題目 You are given n​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.
You have a single-threaded CPU that can process at most one task at a time and will act in the following way:</description></item><item><title>[LeetCode] 1962. Remove Stones to Minimize the Total</title><link>http://intervalrain.github.io/posts/leetcode/1962/</link><pubDate>Thu, 29 Dec 2022 00:03:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1962/</guid><description>1962. Remove Stones to Minimize the Total
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Heap (Priority Queue) 一、題目 You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:
Choose any piles[i] and remove floor(piles[i] / 2) stones from it. Notice that you can apply the operation on the same pile more than once.</description></item><item><title>[LeetCode] 2279. Maximum Bags With Full Capacity of Rocks</title><link>http://intervalrain.github.io/posts/leetcode/2279/</link><pubDate>Tue, 27 Dec 2022 20:48:32 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2279/</guid><description>2279. Maximum Bags With Full Capacity of Rocks
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Greedy、Sorting 一、題目 You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.</description></item><item><title>[LeetCode] 2389. Longest Subsequence With Limited Sum</title><link>http://intervalrain.github.io/posts/leetcode/2389/</link><pubDate>Sun, 25 Dec 2022 20:07:51 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2389/</guid><description>2389. Longest Subsequence With Limited Sum
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Binary Search、Greedy、Sorting、Prefix Sum 一、題目 You are given an integer array nums of length n, and an integer array queries of length m.
Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</description></item><item><title>[LeetCode] 790. Domino and Tromino Tiling</title><link>http://intervalrain.github.io/posts/leetcode/790/</link><pubDate>Sat, 24 Dec 2022 23:53:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/790/</guid><description>790. Domino and Tromino Tiling
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Dynamic Programming 一、題目 You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.
Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 10^9 + 7.
In a tiling, every square must be covered by a tile.</description></item><item><title>[LeetCode] 841. Keys and Rooms</title><link>http://intervalrain.github.io/posts/leetcode/841/</link><pubDate>Tue, 20 Dec 2022 23:00:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/841/</guid><description>841. Keys and Rooms
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Depth-First Search、Breadth-First Search、Graph 一、題目 There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.
When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</description></item><item><title>[LeetCode] 25. Reverse Nodes in k-Group</title><link>http://intervalrain.github.io/posts/leetcode/25/</link><pubDate>Fri, 16 Dec 2022 23:32:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/25/</guid><description>25. Reverse Nodes in k-Group
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Linked List、Recursion 一、題目 Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</description></item><item><title>[LeetCode] 24. Swap Nodes in Pairs</title><link>http://intervalrain.github.io/posts/leetcode/24/</link><pubDate>Wed, 14 Dec 2022 23:35:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/24/</guid><description>24. Swap Nodes in Pairs
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Recursion 一、題目 Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&amp;rsquo;s nodes (i.e., only nodes themselves may be changed.)
Example 1:
Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2:
Input: head = [] Output: [] Example 3:
Input: head = [1] Output: [1] Constraints:</description></item><item><title>[LeetCode] 931. Minimum Falling Path Sum</title><link>http://intervalrain.github.io/posts/leetcode/931/</link><pubDate>Tue, 13 Dec 2022 21:53:27 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/931/</guid><description>931. Minimum Falling Path Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Matrix 一、題目 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.
A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).</description></item><item><title>[LeetCode] 70. Climbing Stairs</title><link>http://intervalrain.github.io/posts/leetcode/70/</link><pubDate>Mon, 12 Dec 2022 22:43:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/70/</guid><description>70. Climbing Stairs
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math、Dynamic Programming、Memoization 一、題目 You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps Example 2:</description></item><item><title>[LeetCode] 2501. Longest Square Streak in an Array</title><link>http://intervalrain.github.io/posts/leetcode/2501/</link><pubDate>Sun, 11 Dec 2022 22:42:14 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2501/</guid><description>2501. Longest Square Streak in an Array
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、Binary Search、Dynamic Programming、Sorting \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 You are given an integer array nums. A subsequence of nums is called a square streak if:
The length of the subsequence is at least 2, and after sorting the subsequence, each element (except the first element) is the square of the previous number.
Return the length of the longest square streak in nums, or return -1 if there is no square streak.</description></item><item><title>[LeetCode] 2500. Delete Greatest Value in Each Row</title><link>http://intervalrain.github.io/posts/leetcode/2500/</link><pubDate>Sun, 11 Dec 2022 22:42:12 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2500/</guid><description>2500. Delete Greatest Value in Each Row
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Hash Table、Binary Search、Dynamic Programming、Sorting \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 You are given an m x n matrix grid consisting of positive integers.
Perform the following operation until grid becomes empty:
Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them. Add the maximum of deleted elements to the answer.
Note that the number of columns decreases by one after each operation.</description></item><item><title>[LeetCode] 124. Binary Tree Maximum Path Sum</title><link>http://intervalrain.github.io/posts/leetcode/124/</link><pubDate>Sun, 11 Dec 2022 21:53:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/124/</guid><description>124. Binary Tree Maximum Path Sum
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Dynamic Programming、Tree、Depth-First Search、Binary Tree 一、題目 A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node&amp;rsquo;s values in the path.</description></item><item><title>[JP] 初級日語#3</title><link>http://intervalrain.github.io/posts/jp/jp03/</link><pubDate>Sun, 11 Dec 2022 17:22:44 +0800</pubDate><guid>http://intervalrain.github.io/posts/jp/jp03/</guid><description>初級日語第 3 課 1. ここ/そこ/あそこ は[名詞] です 這裡、那裡(近的)、那裡(遠的)
ここは食堂です。 あそこは図書館です。 ここは入り口[いりくち]ですか。
はい、そうです。ここは入り口です。 こちら/そちら/あちら/どちら 為較有禮貌的說法
2. [名詞] は [名詞(場所)] です &amp;hellip;在&amp;hellip;
図書館はあそこです。 入り口はここです。 出口[でくち]はここです。 お手洗い[おてあらい]は一階です。 森さんは会議室です。 3. [名詞] はどこですか &amp;hellip;在哪裡?
出口はどこですか。
出口は一階です。 お手洗いはどこですか。
お手洗いはあそこです。 受付[うけつけ]はどちらですか。 4. [名詞] も [名詞] &amp;hellip;也&amp;hellip;
ここは会議室です。
あそこも会議室です。 図書館は一階です。
お手洗いも一階です。 私は日本人です。
田中さんも日本人です。 森さんは会社員です。
王さんも会社員です。</description></item><item><title>[JP] 初級日語#2</title><link>http://intervalrain.github.io/posts/jp/jp02/</link><pubDate>Sun, 11 Dec 2022 17:10:36 +0800</pubDate><guid>http://intervalrain.github.io/posts/jp/jp02/</guid><description>初級日語第 2 課 1. これ、それ、あれ 這個、那個(近的)、那個(遠的)
これは、私のパソコン[電腦]です。 あれは、日本の漫画です。 2. 〜はどれですか 哪個
日本の漫画はどれですか。 すみません。アイスコーヒー[冰咖啡]はどれですか。
これです。 おすすめ[推薦]はどれですか。 3. 〜は何[なん]ですか &amp;hellip;是什麼
これは何ですか。 それは何ですか。 あれは何ですか。 4. 〜は誰[だれ]ですか＝どなたですか 誰
彼は誰ですか。 これは誰ですか。 これは私の先生位です。</description></item><item><title>[JP] 初級日語#1</title><link>http://intervalrain.github.io/posts/jp/jp01/</link><pubDate>Sun, 11 Dec 2022 13:27:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/jp/jp01/</guid><description>初級日語第 1 課 1. [名詞]は[名詞]です &amp;hellip;是&amp;hellip;
私は日本人です。 私は先生です。 彼は学生です。 彼女は留学生[りゅうがくせい]です。 森さんは先生です。 2. [名詞]は[名詞]ではありません＝[名詞]は[名詞]じゃありません &amp;hellip;不是&amp;hellip;
私は中国人ではありません。 彼は学生ではありません。 王さんは会社員[かいしゃいん]ではありません。 私は王ではありません、田中です。 3. [名詞]は[名詞]ですか &amp;hellip;是&amp;hellip;嗎?
彼は学生ですか。 田中さんは会社員ですか。 王さんは留学生ですか。
はい、そうです。
いいえ、違います。 4. [名詞]の[名詞] &amp;hellip;的&amp;hellip;
日本の大学 海外の企業[きぎょう] 東京大学は日本の大学ですか。 北京大学は中国の大学ですか。</description></item><item><title>[LeetCode] 1339. Maximum Product of Splitted Binary Tree</title><link>http://intervalrain.github.io/posts/leetcode/1339/</link><pubDate>Sat, 10 Dec 2022 20:12:36 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1339/</guid><description>1339. Maximum Product of Splitted Binary Tree
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.
Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.
Note that you need to maximize the answer before taking the mod and not after taking it.</description></item><item><title>[LeetCode] 1026. Maximum Difference Between Node and Ancestor</title><link>http://intervalrain.github.io/posts/leetcode/1026/</link><pubDate>Sat, 10 Dec 2022 00:49:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1026/</guid><description>1026. Maximum Difference Between Node and Ancestor
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.
A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.</description></item><item><title>[LeetCode] 872. Leaf-Similar Trees</title><link>http://intervalrain.github.io/posts/leetcode/872/</link><pubDate>Thu, 08 Dec 2022 21:41:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/872/</guid><description>872. Leaf-Similar Trees
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).
Two binary trees are considered leaf-similar if their leaf value sequence is the same.
Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.</description></item><item><title>[LeetCode] 938. Range Sum of BST</title><link>http://intervalrain.github.io/posts/leetcode/938/</link><pubDate>Wed, 07 Dec 2022 23:41:31 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/938/</guid><description>938. Range Sum of BST
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Tree、Depth-First Search、Binary Search Tree、Binary Tree 一、題目 Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].
Example 1:
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15].</description></item><item><title>[LeetCode] 328. Odd Even Linked List</title><link>http://intervalrain.github.io/posts/leetcode/328/</link><pubDate>Tue, 06 Dec 2022 23:56:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/328/</guid><description>328. Odd Even Linked List
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List 一、題目 Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.</description></item><item><title>[LeetCode] 2472. Maximum Number of Non-overlapping Palindrome Substrings</title><link>http://intervalrain.github.io/posts/leetcode/2472/</link><pubDate>Tue, 29 Nov 2022 23:55:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2472/</guid><description>2472. Maximum Number of Non-overlapping Palindrome Substrings
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: String、Dynamic Programming \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 You are given a string s and a positive integer k. Select a set of non-overlapping substrings from the string s that satisfy the following conditions:
The length of each substring is at least k. Each substring is a palindrome. Return the maximum number of substrings in an optimal selection. A substring is a contiguous sequence of characters within a string.</description></item><item><title>[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level</title><link>http://intervalrain.github.io/posts/leetcode/2471/</link><pubDate>Tue, 29 Nov 2022 23:55:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2471/</guid><description>2471. Minimum Number of Operations to Sort a Binary Tree by Level
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Breadth-First Search、Binary Tree \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.</description></item><item><title>[LeetCode] 2470. Number of Subarrays With LCM Equal to K</title><link>http://intervalrain.github.io/posts/leetcode/2470/</link><pubDate>Tue, 29 Nov 2022 23:55:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2470/</guid><description>2470. Number of Subarrays With LCM Equal to K
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Math、Number Theory \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray&amp;rsquo;s elements is k. A subarray is a contiguous non-empty sequence of elements within an array. The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.</description></item><item><title>[LeetCode] 2469. Convert the Temperature</title><link>http://intervalrain.github.io/posts/leetcode/2469/</link><pubDate>Tue, 29 Nov 2022 23:55:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2469/</guid><description>2469. Convert the Temperature
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius. You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit]. Return the array ans. Answers within 10^-5 of the actual answer will be accepted. Note that:
Kelvin = Celsius + 273.</description></item><item><title>[LeetCode] 446. Arithmetic Slices II - Subsequence</title><link>http://intervalrain.github.io/posts/leetcode/446/</link><pubDate>Mon, 28 Nov 2022 23:39:03 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/446/</guid><description>446. Arithmetic Slices II - Subsequence
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Dynamic Programming 一、題目 Given an integer array nums, return the number of all the arithmetic subsequences of nums. A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.</description></item><item><title>[LeetCode] 2488. Count Subarrays With Median K</title><link>http://intervalrain.github.io/posts/leetcode/2488/</link><pubDate>Sun, 27 Nov 2022 21:04:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2488/</guid><description>2488. Count Subarrays With Median K
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Hash Table、Prefix Sum \(\color{blue}\textsf{Weekly Contest 321}\) 一、題目 You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.
Return the number of non-empty subarrays in nums that have a median equal to k. Note:
The median of an array is the middle element after sorting the array in ascending order.</description></item><item><title>[LeetCode] 2487. Remove Nodes From Linked List</title><link>http://intervalrain.github.io/posts/leetcode/2487/</link><pubDate>Sun, 27 Nov 2022 21:04:51 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2487/</guid><description>2487. Remove Nodes From Linked List
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Stack、Recursion、Monotonic Stack \(\color{blue}\textsf{Weekly Contest 321}\) 一、題目 You are given the head of a linked list.
Remove every node which has a node with strictly greater value anywhere to the right side of it.
Return the head of the modified linked list.
Example 1:
Input: head = [5,2,13,3,8] Output: [13,8] Explanation: The nodes that should be removed are 5, 2 and 3.</description></item><item><title>[LeetCode] 2486. Accept Characters to String to Make Subsequence</title><link>http://intervalrain.github.io/posts/leetcode/2486/</link><pubDate>Sun, 27 Nov 2022 21:04:50 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2486/</guid><description>2486. Accept Characters to String to Make Subsequence
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Two Pointer、String、Greedy \(\color{blue}\textsf{Weekly Contest 321}\) 一、題目 You are given two strings s and t consisting of only lowercase English letters. Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</description></item><item><title>[LeetCode] 2485. Find the Pivot Integer</title><link>http://intervalrain.github.io/posts/leetcode/2485/</link><pubDate>Sun, 27 Nov 2022 21:04:47 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2485/</guid><description>2485. Find the Pivot Integer
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math、Prefix Sum \(\color{blue}\textsf{Weekly Contest 321}\) 一、題目 Given a positive integer n, find the pivot integer x such that:
The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively. Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.</description></item><item><title>[LeetCode] 1235. Maximum Profit in Job Scheduling</title><link>http://intervalrain.github.io/posts/leetcode/1235/</link><pubDate>Sat, 26 Nov 2022 14:09:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1235/</guid><description>1235. Maximum Profit in Job Scheduling
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Binary Search、Dynamic Programming、Sorting 一、題目 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&amp;rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X.</description></item><item><title>[LeetCode] 1143. Longest Common Subsequence</title><link>http://intervalrain.github.io/posts/leetcode/1143/</link><pubDate>Thu, 24 Nov 2022 23:15:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1143/</guid><description>1143. Longest Common Subsequence
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String、Dynamic Programming 一、題目 Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
For example, &amp;quot;ace&amp;quot; is a subsequence of &amp;quot;abcde&amp;quot;.</description></item><item><title>[LeetCode] 300. Longest Increasing Subsequence</title><link>http://intervalrain.github.io/posts/leetcode/300/</link><pubDate>Thu, 24 Nov 2022 20:59:40 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/300/</guid><description>300. Longest Increasing Subsequence
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Binary Search、Dynamic Programming 一、題目 Given an integer array nums, return the length of the longest strictly increasing subsequence
Example 1:
Input: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Example 2:
Input: nums = [0,1,0,3,2,3] Output: 4 Example 3:
Input: nums = [7,7,7,7,7,7,7] Output: 1 Constraints:
1 &amp;lt;= nums.length &amp;lt;= 2500 -104 &amp;lt;= nums[i] &amp;lt;= 104 Follow up: Can you come up with an algorithm that runs in O(n log n) time complexity</description></item><item><title>[LeetCode] 2468. Split Message Based on Limit</title><link>http://intervalrain.github.io/posts/leetcode/2468/</link><pubDate>Thu, 24 Nov 2022 01:09:57 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2468/</guid><description>2468. Split Message Based on Limit
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: String、Binary Search \(\color{blue}\textsf{Biweekly Contest 91}\) 一、題目 You are given a string, message, and a positive integer, limit.
You must split message into one or more parts based on limit. Each resulting part should have the suffix &amp;quot;&amp;lt;a/b&amp;gt;&amp;quot;, where &amp;quot;b&amp;quot; is to be replaced with the total number of parts and &amp;quot;a&amp;quot; is to be replaced with the index of the part, starting from 1 and going up to b.</description></item><item><title>[LeetCode] 2467. Most Profitable Path in a Tree</title><link>http://intervalrain.github.io/posts/leetcode/2467/</link><pubDate>Thu, 24 Nov 2022 01:09:51 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2467/</guid><description>2467. Most Profitable Path in a Tree
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Tree、Depth-First Search、Breadth-First Search、Graph \(\color{blue}\textsf{Biweekly Contest 91}\) 一、題目 There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. At every node i, there is a gate.</description></item><item><title>[LeetCode] 1926. Nearest Exit from Entrance in Maze</title><link>http://intervalrain.github.io/posts/leetcode/1926/</link><pubDate>Tue, 22 Nov 2022 23:41:58 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1926/</guid><description>1926. Nearest Exit from Entrance in Maze
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.
In one step, you can move one cell up, down, left, or right.</description></item><item><title>[LeetCode] 279. Perfect Squares</title><link>http://intervalrain.github.io/posts/leetcode/279/</link><pubDate>Tue, 22 Nov 2022 19:40:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/279/</guid><description>279. Perfect Squares
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Math、Dynamic Programming、Breadth-First Search 一、題目 Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.
Example 1:</description></item><item><title>[LeetCode] 337. House Robber III</title><link>http://intervalrain.github.io/posts/leetcode/337/</link><pubDate>Sat, 19 Nov 2022 21:43:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/337/</guid><description>337. House Robber III
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Dynamic Programming、Tree、Depth-First Search、Binary Tree 一、題目 The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description></item><item><title>[LeetCode] 587. Erect the Fence</title><link>http://intervalrain.github.io/posts/leetcode/587/</link><pubDate>Sat, 19 Nov 2022 16:56:09 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/587/</guid><description>587. Erect the Rence
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Math、Geometry 一、題目 You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden. You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Return the coordinates of trees that are exactly located on the fence perimeter.</description></item><item><title>[LeetCode] 322. Coin Change</title><link>http://intervalrain.github.io/posts/leetcode/322/</link><pubDate>Thu, 17 Nov 2022 21:31:45 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/322/</guid><description>322. Coin Change
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Breadth-First Search 一、題目 You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.</description></item><item><title>[LeetCode] 2466. Count Ways To Build Good Strings</title><link>http://intervalrain.github.io/posts/leetcode/2466/</link><pubDate>Thu, 17 Nov 2022 21:23:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2466/</guid><description>2466. Count Ways To Build Good Strings
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Dynamic Programming \(\color{blue}\textsf{Biweekly Contest 91}\) 一、題目 Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:
Append the character '0' zero times. Append the character '1' one times. This can be performed any number of times. A good string is a string constructed by the above process having a length between low and high (inclusive).</description></item><item><title>[LeetCode] 2465. Number of Distinct Averages</title><link>http://intervalrain.github.io/posts/leetcode/2465/</link><pubDate>Thu, 17 Nov 2022 21:00:05 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2465/</guid><description>2465. Number of Distinct Averages
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Hash Table、Two Pointers、Sorting \(\color{blue}\textsf{Biweekly Contest 91}\) 一、題目 You are given a 0-indexed integer array nums of even length. As long as nums is not empty, you must repetitively:
Find the minimum number in nums and remove it. Find the maximum number in nums and remove it. Calculate the average of the two removed numbers. The average of two numbers a and b is (a + b) / 2.</description></item><item><title>[LeetCode] 223. Rectangle Area</title><link>http://intervalrain.github.io/posts/leetcode/223/</link><pubDate>Thu, 17 Nov 2022 20:39:17 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/223/</guid><description>223. Rectangle Area
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Math、Geometry 一、題目 Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles. The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2). The second rectangle is defined by its bottom-left corner (bx1, by1) and tis top-right corner (bx2, by2).
Example 1:
Input: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2 Output: 45 Example 2:</description></item><item><title>[LeetCode] 374. Guess Number Higher or Lower</title><link>http://intervalrain.github.io/posts/leetcode/374/</link><pubDate>Wed, 16 Nov 2022 22:57:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/374/</guid><description>374. Guess Number Higher or Lower
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Binary Search、Interactive 一、題目 We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results:</description></item><item><title>[LeetCode] 213. House Robber II</title><link>http://intervalrain.github.io/posts/leetcode/213/</link><pubDate>Tue, 15 Nov 2022 23:45:49 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/213/</guid><description>213. House Robber II
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming 一、題目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.</description></item><item><title>[LeetCode] 198. House Robber</title><link>http://intervalrain.github.io/posts/leetcode/198/</link><pubDate>Tue, 15 Nov 2022 23:33:01 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/198/</guid><description>198. House Robber
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming 一、題目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</description></item><item><title>[Algo] 2-5. 動態規劃 Dynamic Programming</title><link>http://intervalrain.github.io/posts/cs/algo/dp/</link><pubDate>Tue, 15 Nov 2022 16:10:53 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/dp/</guid><description>演算法設計，介紹什麼是動態規劃，並介紹幾種動態規劃常見的題型，與解題框架</description></item><item><title>[LeetCode] 947. Most Stones Removed with Same Row or Column</title><link>http://intervalrain.github.io/posts/leetcode/947/</link><pubDate>Tue, 15 Nov 2022 00:12:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/947/</guid><description>947. Most Stones Removed with Same Row or Column
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Depth-First Search、Union Find、Graph 一、題目 On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.</description></item><item><title>[LeetCode] 151. Reverse Words in a String</title><link>http://intervalrain.github.io/posts/leetcode/151/</link><pubDate>Sun, 13 Nov 2022 17:35:59 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/151/</guid><description>151. Reverse Words in a String
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Two Pointers、String 一、題目 Given an input string s, reverse the order of the words.
A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.
Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words.</description></item><item><title>[LeetCode] 23. Merge k Sorted Lists</title><link>http://intervalrain.github.io/posts/leetcode/23/</link><pubDate>Fri, 11 Nov 2022 00:24:47 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/23/</guid><description>23. Merge k Sorted Lists
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Linked List、Divide and Conquer、Heap (Priority Queue)、Merge Sort 一、題目 You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.
Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are:
[
1-&amp;gt;4-&amp;gt;5,
1-&amp;gt;3-&amp;gt;4,
2-&amp;gt;6
]
merging them into one sorted list:
1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 Example 2:</description></item><item><title>[LeetCode] 22. Generate Parentheses</title><link>http://intervalrain.github.io/posts/leetcode/22/</link><pubDate>Thu, 10 Nov 2022 23:44:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/22/</guid><description>22. Generate Parentheses
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String、Dynamic Programming、Backtracking 一、題目 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Constraints:
1 &amp;lt;= n &amp;lt;= 8 二、分析 DFS 演算法是在遍歷「節點」，而回溯法是在遍歷「樹枝」。站在一個節點上，需思考三個問題： 路徑(PATH)：已做出的選擇。 選項(OPTION)：當前可以做的選擇。 終止條件(TERMINATE)：到達決策樹的底層，無法再做其它選擇。 以下為回溯法的框架： vector&amp;lt;PATH&amp;gt; res; void backtrack(PATH, OPTION) { if (TERMINATE) { res.push_back(PATH); return; } for (CHOICE : OPTION) { DO OPTION; backtrack(PATH, OPTION); CANCEL OPTION; } } 本題的終止條件是當 path 的長度為 2n 的時候。 而選項是增加左括號 ( 與增加右括號 )。 加上兩個子節點的條件便完成， 左節點需滿足 left &amp;lt; n。 右節點需滿足 right &amp;lt; n &amp;amp;&amp;amp; right &amp;lt; left。 DP 動態規劃則需觀察轉移方程式。 dp[0] base case： `` dp[1] 很容易得到：() dp[2] 也不難：()()、(()) 接下來觀察 dp[3]，可以分解為下面三個： ( + dp[0] + ) + dp[2]：()()()、()(()) ( + dp[1] + ) + dp[1]：(())() ( + dp[2] + ) + dp[0]：(()())、((())) 換句話說，轉移方程式可以寫成：dp[i] = &amp;quot;(&amp;quot; + dp[j] + &amp;quot;)&amp;quot; + dp[i-j-1] 三、解題 1.</description></item><item><title>[LeetCode] 21. Merge Two Sorted Lists</title><link>http://intervalrain.github.io/posts/leetcode/21/</link><pubDate>Thu, 10 Nov 2022 20:25:07 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/21/</guid><description>21. Merge Two Sorted Lists
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Linked List、Recursion 一、題目 You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:</description></item><item><title>[LeetCode] 1047. Remove All Adjacent Duplicates In String</title><link>http://intervalrain.github.io/posts/leetcode/1047/</link><pubDate>Thu, 10 Nov 2022 20:01:29 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1047/</guid><description>1047. Remove All Adjacent Duplicates In String
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String、Stack 一、題目 You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.
We repeatly make duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.</description></item><item><title>[LeetCode] 901. Online Stock Span</title><link>http://intervalrain.github.io/posts/leetcode/901/</link><pubDate>Wed, 09 Nov 2022 23:35:42 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/901/</guid><description>901. Online Stock Span
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Stack、Design、Monotonic Stack、Data Stream 一、題目 Design an algorithm that collects daily price quotes for some stock and returns the span of that stock&amp;rsquo;s price for the current day.
The span of the stock&amp;rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today&amp;rsquo;s price.</description></item><item><title>[LeetCode] 1544. Make The String Great</title><link>http://intervalrain.github.io/posts/leetcode/1544/</link><pubDate>Tue, 08 Nov 2022 23:14:34 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1544/</guid><description>1544. Make The String Great
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String、Stack 一、題目 Given a string s of lower and upper case English letters.
A good string is a string which doesn&amp;rsquo;t have two adjacent characters s[i] and s[i + 1] where:
0 &amp;lt;= i &amp;lt;= s.length - 2 s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
To make the string good, you can choose two adjacent characters that make the string bad and remove them.</description></item><item><title>[LeetCode] 2463. Minimum Total Distance Traveled</title><link>http://intervalrain.github.io/posts/leetcode/2463/</link><pubDate>Tue, 08 Nov 2022 23:13:52 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2463/</guid><description>2463. Minimum Total Distance Traveled
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Dynamic Programming、Sorting \(\color{blue}\textsf{Weekly Contest 318}\) 一、題目 There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.</description></item><item><title>[LeetCode] 2462. Total Cost to Hire K</title><link>http://intervalrain.github.io/posts/leetcode/2462/</link><pubDate>Tue, 08 Nov 2022 00:53:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2462/</guid><description>2462. Total Cost to Hire K
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Heap (Priority Queue)、Simulation \(\color{blue}\textsf{Weekly Contest 318}\) 一、題目 You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker. You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:
You will run k sessions and hire exactly one worker in each session. In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.</description></item><item><title>[LeetCode] 2461. Maximum Sum of Distinct Subarrays With Length K</title><link>http://intervalrain.github.io/posts/leetcode/2461/</link><pubDate>Tue, 08 Nov 2022 00:36:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2461/</guid><description>2461. Maximum Sum of Distinct Subarrays With Length K
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、Sliding Window \(\color{blue}\textsf{Weekly Contest 318}\) 一、題目 You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:
The length of the subarray is k, and All the elements of the subarray are distinct. Return the maximum subarray sum of all the subarrays that meet the conditions.</description></item><item><title>[LeetCode] 2460. Apply Operations to an Array</title><link>http://intervalrain.github.io/posts/leetcode/2460/</link><pubDate>Tue, 08 Nov 2022 00:09:13 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2460/</guid><description>2460. Apply Operations to an Array
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Simulation \(\color{blue}\textsf{Weekly Contest 318}\) 一、題目 You are given a 0-indexed array nums of size n consisting of non-negative integers. You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:
If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0.</description></item><item><title>[LeetCode] 1323. Maximum 69 Number</title><link>http://intervalrain.github.io/posts/leetcode/1323/</link><pubDate>Mon, 07 Nov 2022 23:55:31 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1323/</guid><description>1323. Maximum 69 Number
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math、Greedy 一、題目 You are given a positive integer num consisting only of digits 6 and 9.
Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).
Example 1:
Input: num = 9669 Output: 9969 Explanation:
Changing the first digit results in 6669.
Changing the second digit results in 9969.
Changing the third digit results in 9699.</description></item><item><title>[ML] 機器學習與統計學</title><link>http://intervalrain.github.io/posts/ml/lec1/</link><pubDate>Mon, 07 Nov 2022 18:18:52 +0800</pubDate><guid>http://intervalrain.github.io/posts/ml/lec1/</guid><description>Introduction to Machine Learning</description></item><item><title>[LeetCode] 79. Word Search</title><link>http://intervalrain.github.io/posts/leetcode/79/</link><pubDate>Sat, 05 Nov 2022 21:12:17 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/79/</guid><description>79. Word Search
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Backtracking、Matrix 一、題目 Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example 1:
Input: board = [[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;E&amp;rdquo;],[&amp;ldquo;S&amp;rdquo;,&amp;ldquo;F&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;S&amp;rdquo;],[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;D&amp;rdquo;,&amp;ldquo;E&amp;rdquo;,&amp;ldquo;E&amp;rdquo;]], word = &amp;ldquo;ABCCED&amp;rdquo; Output: true Example 2:</description></item><item><title>[LeetCode] 212. Word Search II</title><link>http://intervalrain.github.io/posts/leetcode/212/</link><pubDate>Sat, 05 Nov 2022 20:58:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/212/</guid><description>212. Word Search II
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、String、Backtracking、Trie、Matrix 一、題目 Given an m x n board of characters and a list of strings words, return all words on the board.
Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
Example 1:
Input: board = [[&amp;ldquo;o&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;],[&amp;ldquo;e&amp;rdquo;,&amp;ldquo;t&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;e&amp;rdquo;],[&amp;ldquo;i&amp;rdquo;,&amp;ldquo;h&amp;rdquo;,&amp;ldquo;k&amp;rdquo;,&amp;ldquo;r&amp;rdquo;],[&amp;ldquo;i&amp;rdquo;,&amp;ldquo;f&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;v&amp;rdquo;]], words = [&amp;ldquo;oath&amp;rdquo;,&amp;ldquo;pea&amp;rdquo;,&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;rain&amp;rdquo;] Output: [&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;oath&amp;rdquo;] Example 2:</description></item><item><title>[LeetCode] 2131. Longest Palindrome by Concatenating Two Letter Words</title><link>http://intervalrain.github.io/posts/leetcode/2131/</link><pubDate>Thu, 03 Nov 2022 23:10:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2131/</guid><description>2131. Longest Palindrome by Concatenating Two Letter Words
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、String、Greedy、Counting 一、題目 You are given an array of strings words. Each element of words consists of two lowercase English letters.
Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.
Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.</description></item><item><title>[LeetCode] 433. Minimum Genetic Mutation</title><link>http://intervalrain.github.io/posts/leetcode/433/</link><pubDate>Wed, 02 Nov 2022 23:36:32 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/433/</guid><description>433. Minimum Genetic Mutation
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table、String、Breadth-First Search 一、題目 A gene string can be represented by an 8-character long string, with choices from A, C, G, and T.
Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.
For example, &amp;quot;AACCGGTT&amp;quot; --&amp;gt; &amp;quot;AACCGGTA&amp;quot; is one mutation.</description></item><item><title>[LeetCode] 20. Valid Parentheses</title><link>http://intervalrain.github.io/posts/leetcode/20/</link><pubDate>Tue, 01 Nov 2022 20:51:49 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/20/</guid><description>20. Valid Parentheses
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String、Stack 一、題目 Given a string s containing just the characters (, ), {, }, [ and ], determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:</description></item><item><title>[LeetCode] 1706. Where Will the Ball Fall</title><link>http://intervalrain.github.io/posts/leetcode/1706/</link><pubDate>Tue, 01 Nov 2022 19:02:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1706/</guid><description>1706. Where Will the Ball Fall
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Depth-First Search、Matrix、Simulation 一、題目 You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.
Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.
A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.</description></item><item><title>[LeetCode] 766. Toeplitz Matrix</title><link>http://intervalrain.github.io/posts/leetcode/766/</link><pubDate>Tue, 01 Nov 2022 00:40:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/766/</guid><description>766. Toeplitz Matrix
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Matrix 一、題目 Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.
Example 1:
Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] Output: true Explanation:
In the above grid, the diagonals are:
&amp;ldquo;[9]&amp;rdquo;, &amp;ldquo;[5, 5]&amp;rdquo;, &amp;ldquo;[1, 1, 1]&amp;rdquo;, &amp;ldquo;[2, 2, 2]&amp;rdquo;, &amp;ldquo;[3, 3]&amp;rdquo;, &amp;ldquo;[4]&amp;rdquo;.
In each diagonal all elements are the same, so the answer is True.</description></item><item><title>[LeetCode] 19. Remove Nth Node From End of List</title><link>http://intervalrain.github.io/posts/leetcode/19/</link><pubDate>Mon, 31 Oct 2022 00:05:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/19/</guid><description>19. Remove Nth Node From End of List
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Two Pointers 一、題目 Given the head of a linked list, remove the nth node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Example 3:
Input: head = [1,2], n = 1 Output: [1] Constraints:</description></item><item><title>[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination</title><link>http://intervalrain.github.io/posts/leetcode/1293/</link><pubDate>Sun, 30 Oct 2022 21:29:37 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1293/</guid><description>1293. Shortest Path in a Grid with Obstacles Elimination
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.
Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles.</description></item><item><title>[LeetCode] 2136. Earliest Possible Day of Full Bloom</title><link>http://intervalrain.github.io/posts/leetcode/2136/</link><pubDate>Sun, 30 Oct 2022 00:25:25 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2136/</guid><description>2136. Earliest Possible Day of Full Bloom
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Greedy、Sorting 一、題目 You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed take time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:
plantTime[i] is the number of full days it takes you to plant the ith seed.</description></item><item><title>[LeetCode] 18. 4Sum</title><link>http://intervalrain.github.io/posts/leetcode/18/</link><pubDate>Fri, 28 Oct 2022 23:58:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/18/</guid><description>18. 4Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Sorting 一、題目 Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
0 &amp;lt;= a, b, c, d &amp;lt; n a, b, c and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Example 1:
Input: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2:</description></item><item><title>[LeetCode] 17. Letter Combinations of a Phone Number</title><link>http://intervalrain.github.io/posts/leetcode/17/</link><pubDate>Fri, 28 Oct 2022 22:59:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/17/</guid><description>17. Letter Combinations of a Phone Number
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table,String,Backtracking 一、題目 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = &amp;ldquo;23&amp;rdquo; Output: [&amp;ldquo;ad&amp;rdquo;,&amp;ldquo;ae&amp;rdquo;,&amp;ldquo;af&amp;rdquo;,&amp;ldquo;bd&amp;rdquo;,&amp;ldquo;be&amp;rdquo;,&amp;ldquo;bf&amp;rdquo;,&amp;ldquo;cd&amp;rdquo;,&amp;ldquo;ce&amp;rdquo;,&amp;ldquo;cf&amp;rdquo;] Example 2:</description></item><item><title>[LeetCode] 16. 3Sum Closet</title><link>http://intervalrain.github.io/posts/leetcode/16/</link><pubDate>Fri, 28 Oct 2022 21:51:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/16/</guid><description>no. Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointers、Sorting 一、題目 Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closet to target.
Return *the sum of the three integers`.
You may assume that each input would have exactly one solution.
Example 1:
Input: nums = [-1,2,1,-4], target = 1 Output: 2 Explanation: The sum that is closet to the target is 2.</description></item><item><title>[LeetCode] 15. 3Sum</title><link>http://intervalrain.github.io/posts/leetcode/15/</link><pubDate>Fri, 28 Oct 2022 13:30:19 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/15/</guid><description>15. 3Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Sorting 一、題目 Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.</description></item><item><title>[Leetcode] 14. Longest Common Prefix</title><link>http://intervalrain.github.io/posts/leetcode/14/</link><pubDate>Fri, 28 Oct 2022 00:00:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/14/</guid><description>14. Longest Common Prefix
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String 一、題目 Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;ldquo;flower&amp;rdquo;, &amp;ldquo;flow&amp;rdquo;, &amp;ldquo;flight&amp;rdquo;] Output: &amp;ldquo;fl&amp;rdquo; Example 2:
Input: strs = [&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;racecar&amp;rdquo;, &amp;ldquo;car&amp;rdquo;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. Constraints:
1 &amp;lt;= strs.length &amp;lt;= 200 0 &amp;lt;= strs[i].</description></item><item><title>[Leetcode] 13. Roman to Integer</title><link>http://intervalrain.github.io/posts/leetcode/13/</link><pubDate>Thu, 27 Oct 2022 21:58:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/13/</guid><description>13. Roman to Integer
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.
\(\boxed{\begin{array}{ll} \textbf{Symbol}&amp;amp;\textbf{Value}\\ \texttt{I}&amp;amp;1\\ \texttt{V}&amp;amp;5\\ \texttt{X}&amp;amp;10\\ \texttt{L}&amp;amp;50\\ \texttt{C}&amp;amp;100\\ \texttt{D}&amp;amp;500\\ \texttt{M}&amp;amp;1000\\ \end{array}}\)
For example, 2 is written as II in Roman numeral, just two one&amp;rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description></item><item><title>[Leetcode] 835. Image Overlap</title><link>http://intervalrain.github.io/posts/leetcode/835/</link><pubDate>Thu, 27 Oct 2022 17:35:25 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/835/</guid><description>835. Image Overlap
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Matrix 一、題目 You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.
We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images.</description></item><item><title>[Leetcode] 12. Integer to Roman</title><link>http://intervalrain.github.io/posts/leetcode/12/</link><pubDate>Wed, 26 Oct 2022 20:36:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/12/</guid><description>12. Integer to Roman
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.
\(\boxed{\begin{array}{ll} \textbf{Symbol}&amp;amp;\textbf{Value}\\ \texttt{I}&amp;amp;1\\ \texttt{V}&amp;amp;5\\ \texttt{X}&amp;amp;10\\ \texttt{L}&amp;amp;50\\ \texttt{C}&amp;amp;100\\ \texttt{D}&amp;amp;500\\ \texttt{M}&amp;amp;1000\\ \end{array}}\)
For example, 2 is written as II in Roman numeral, just two one&amp;rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description></item><item><title>[Leetcode] 11. Container With Most Water</title><link>http://intervalrain.github.io/posts/leetcode/11/</link><pubDate>Wed, 26 Oct 2022 19:36:06 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/11/</guid><description>11. Container With Most Water
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Greedy 一、題目 You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
Find two lines that together with the x-axis form a container, such that the container contains the most water.
Return the maximum amount of water a container can store.</description></item><item><title>[Leetcode] 10. Regular Expression Matching</title><link>http://intervalrain.github.io/posts/leetcode/10/</link><pubDate>Wed, 26 Oct 2022 18:36:01 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/10/</guid><description>10. Regular Expression Matching
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: String、Dynamic Programming、Recursion 一、題目 Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:
'.' Matches any single character. '*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial). Example 1:
Input: s = &amp;ldquo;aa&amp;rdquo;, p = &amp;ldquo;a&amp;rdquo; Output: false Explanation: &amp;ldquo;a&amp;rdquo; does not match the entire string &amp;ldquo;aa&amp;rdquo;.</description></item><item><title>[Leetcode] 9. Palindrome Number</title><link>http://intervalrain.github.io/posts/leetcode/9/</link><pubDate>Wed, 26 Oct 2022 10:20:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/9/</guid><description>9. Palindrome Number
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math 一、題目 Given an integer x, return true if x is palindrome number.
An integer is a palindrome when it reads the same backward as forward.
For example, 121 is a palindrome while 123 is not. Example 1:
Input: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left. Example 2:
Input: x = -121 Output: false Explanation: From left to right, it reads -121.</description></item><item><title>[Leetcode] 8. String to Integer (atoi)</title><link>http://intervalrain.github.io/posts/leetcode/8/</link><pubDate>Wed, 26 Oct 2022 00:21:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/8/</guid><description>8. String to Integer (atoi)
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String 一、題目 Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++&amp;rsquo;s atoi function).
The algorithm for myAtoi(string s) is as follows:
Read in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either.</description></item><item><title>[Leetcode] 7. Reverse Integer</title><link>http://intervalrain.github.io/posts/leetcode/7/</link><pubDate>Tue, 25 Oct 2022 23:47:53 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/7/</guid><description>7. Reverse Integer
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Math 一、題目 Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31-1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321 Example 2:
Input: x = -123 Output: -321 Example 3:</description></item><item><title>[Leetcode] 6. Zigzag Conversion</title><link>http://intervalrain.github.io/posts/leetcode/6/</link><pubDate>Tue, 25 Oct 2022 21:40:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/6/</guid><description>6. Zigzag Conversion
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String 一、題目 The string &amp;quot;PAYPALISHIRING&amp;quot; is written in a zigzag pattern on a given number of rows like this: (you may want to dispaly this pattern in a fixed font for better legibility)
\( \quad\texttt{P A H N}\\ \quad\texttt{APLSIIG}\\ \quad\texttt{Y I R}\\ \)
And then read line by line: &amp;quot;PAHNAPLSIIGYIR&amp;quot;
Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows</description></item><item><title>[LeetCode] 5. Longest Palindromic Substring</title><link>http://intervalrain.github.io/posts/leetcode/5/</link><pubDate>Tue, 25 Oct 2022 16:32:51 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/5/</guid><description>5. Longest Substring Without Repeating Characters
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String、Dynamic Programming 一、題目 Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same of the original string.
Example 1:
Input: s = &amp;ldquo;babad&amp;rdquo; Output: &amp;ldquo;bab&amp;rdquo; Explanation: &amp;ldquo;aba&amp;rdquo; is also a valid answer. Example 2:
Input: s = &amp;ldquo;cbbd&amp;rdquo; Output: &amp;ldquo;bb&amp;rdquo; Constraints:
1 &amp;lt;= s.</description></item><item><title>[LeetCode] 4. Median of Two Sorted Arrays</title><link>http://intervalrain.github.io/posts/leetcode/4/</link><pubDate>Tue, 25 Oct 2022 14:52:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/4/</guid><description>4. Median of Two Sorted Arrays
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Binary Search、Divide and Conquer 一、題目 Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the sorted arrays.
The overall run time complexity should be O(log (m+n)).
Example 1:
Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2:
Input: nums1 = [1,2], nums2 = [3,4] Output: 2.</description></item><item><title>[LeetCode] 3. Longest Substring Without Repeating Characters</title><link>http://intervalrain.github.io/posts/leetcode/3/</link><pubDate>Tue, 25 Oct 2022 14:20:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/3/</guid><description>3. Longest Substring Without Repeating Characters
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table、String、Sliding Window 一、題目 Given a string s, find the length of the longest substring without repeating characters.
Example 1:
Input: s = &amp;ldquo;abcabcbb&amp;rdquo; Output: 3 Explanation: The answer is &amp;ldquo;abc&amp;rdquo;, with the length of 3. Example 2:
Input: s = &amp;ldquo;bbbbb&amp;rdquo; Output: 1 Explanation: The answer is &amp;ldquo;b&amp;rdquo;, with the length of 1. Example 3:
Input: s = &amp;ldquo;pwwkew&amp;rdquo; Output: 3 Explanation: The answer is &amp;ldquo;wke&amp;rdquo;, with the length of 3.</description></item><item><title>[LeetCode] 2. Add Two Numbers</title><link>http://intervalrain.github.io/posts/leetcode/2/</link><pubDate>Tue, 25 Oct 2022 13:38:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2/</guid><description>2. Add Two Numbers
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Math、Recursion 一、題目 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807 Example 2:</description></item><item><title>[LeetCode] 1. Two Sum</title><link>http://intervalrain.github.io/posts/leetcode/1/</link><pubDate>Tue, 25 Oct 2022 12:41:32 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1/</guid><description>1. Two Sum
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Hash Table 一、題目 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], taget = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0,1].</description></item><item><title>[LeetCode] Catalog</title><link>http://intervalrain.github.io/posts/leetcode/</link><pubDate>Tue, 25 Oct 2022 11:30:32 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/</guid><description>Catalog 一、依題號 1-500(44) 1. Two Sum
2. Add Two Numbers
3. Longest Substring Without Repeating Characters
4. Median of Two Sorted Array
5. Longest Palindromic Substring
6. Zigzag Conversion
7. Reverse Integer
8. String to Integer (atoi)
9. Palindrome Number
10. Regular Expression Matching
11. Container With Most Water
12. Integer to Roman
13. Roman to Integer
14. Longest Common Prefix
15. 3Sum
16. 3Sum Closet
17. Letter Combinations of a Phone Number</description></item><item><title>[Problem] Version Query</title><link>http://intervalrain.github.io/posts/leetcode/versionquery/</link><pubDate>Thu, 20 Oct 2022 22:29:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/versionquery/</guid><description>Version Query
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Binary Search、Segment Tree、Heap (Priority Queue、Hash Table 一、題目 Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.
The given apk_info structure is given as below.
struct apk_info {
int apk_version;
int min_version = 1;
int max_version = INT_MAX;
}</description></item><item><title>[C++] Segment Tree</title><link>http://intervalrain.github.io/posts/c++/segtree/</link><pubDate>Tue, 18 Oct 2022 23:14:38 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/segtree/</guid><description>用 C++ 介紹資料結構線段樹</description></item><item><title>[C++] stringstream 類範例 - split 與 concat</title><link>http://intervalrain.github.io/posts/c++/stringstream/</link><pubDate>Fri, 14 Oct 2022 00:21:23 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stringstream/</guid><description>C++ 中字拆的 split 實作與 concatenate 實作</description></item><item><title>[Algo] 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis</title><link>http://intervalrain.github.io/posts/cs/algo/bigo/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/bigo/</guid><description>演算法的複雜度分析，與複雜度的表示法</description></item><item><title>[Algo] 0-4. 二叉樹(Binary Tree)</title><link>http://intervalrain.github.io/posts/cs/algo/binary_tree/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/binary_tree/</guid><description>演算法思維，介紹二叉樹這種資料結構以及如何使用它與 Leetcode 相關範例介紹</description></item><item><title>[Algo] 0-3. 鏈表(Linked List)</title><link>http://intervalrain.github.io/posts/cs/algo/linked_list/</link><pubDate>Thu, 06 Oct 2022 22:30:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/linked_list/</guid><description>演算法結構介紹，介紹鏈表的遍歷，與常見的經典考題與常用到的操作手法</description></item><item><title>[Algo] 0-2. 算法思維</title><link>http://intervalrain.github.io/posts/cs/algo/concept/</link><pubDate>Thu, 06 Oct 2022 22:15:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/concept/</guid><description>演算法的思維，在深入 Leetcode 世界前的一些基礎引導</description></item><item><title>CS 學習筆記</title><link>http://intervalrain.github.io/posts/csindex/</link><pubDate>Thu, 06 Oct 2022 22:01:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/csindex/</guid><description>rainhu的資工學習筆記</description></item><item><title>[DS] 演算法筆記</title><link>http://intervalrain.github.io/posts/cs/algo/</link><pubDate>Thu, 06 Oct 2022 22:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/</guid><description>前言：此系列文章為參考 labuladong 的 fucking algorithm與 Leetcode101(高暢) 作為基底，簡化核心內容，並將程式碼以自己的 C++ code 替代，作為自己的學習筆記。
第零章、核心框架 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis 0-2. 算法思維 0-3. 鏈表 Linked List 0-4. 二叉樹 Binary Tree 第一章、資料結構、STL 1-1. vector 1-2. list, forward_list 1-3. stack 1-4. queue 1-5. set, multiset, unordered_set, unordered_multiset 1-6. map, multimap, unordered_map, unordered_multimap 1-7. deque 1-8. priority_queue 1-9. algorithm 第二章、演算法設計 2-1. 暴力演算法 Brute Force 2-2. 貪心演算法 Greedy 2-3. 分治法 Divide and Conquer 2-4.</description></item><item><title>[IT] 動態鏈結庫(DDL)</title><link>http://intervalrain.github.io/posts/it/ddl/</link><pubDate>Sun, 18 Sep 2022 22:45:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/ddl/</guid><description>Command to construct DDL</description></item><item><title>[IT] MySQL Functions</title><link>http://intervalrain.github.io/posts/it/mysql/</link><pubDate>Thu, 01 Sep 2022 13:28:14 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/mysql/</guid><description>Built-in function in MySQL</description></item><item><title>[IT] SQL</title><link>http://intervalrain.github.io/posts/it/sql/</link><pubDate>Thu, 01 Sep 2022 13:28:14 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/sql/</guid><description>Base command of SQL</description></item><item><title>[Leetcode] 347. Top K Frequent Elements</title><link>http://intervalrain.github.io/posts/leetcode/347/</link><pubDate>Sat, 23 Jul 2022 23:48:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/347/</guid><description>347. Top K Frequent Elements
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、Divide and Conquer、Sorting、Heap (Priority Queue)、Bucket Sort、Counting、Quickselect 一、題目 Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
Example 1:
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:
Input: nums = [1], k = 1 Output: [1] Constraints:
1 &amp;lt;= nums.length &amp;lt;= 10^5 -10^4 &amp;lt;= nums[i] &amp;lt;= 10^4 k is in the range [1, the number of unique elements in the array].</description></item><item><title>[Life] July's plan</title><link>http://intervalrain.github.io/posts/life/prepare/</link><pubDate>Sat, 16 Jul 2022 17:48:09 +0800</pubDate><guid>http://intervalrain.github.io/posts/life/prepare/</guid><description>Study plan for July</description></item><item><title>[統計] 統計學概要</title><link>http://intervalrain.github.io/posts/device/statistics/</link><pubDate>Sat, 09 Jul 2022 20:02:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/device/statistics/</guid><description>用自身工經驗簡述實務上應用的統計學</description></item><item><title>[CA] 記憶體</title><link>http://intervalrain.github.io/posts/cs/ca/memory/</link><pubDate>Sun, 03 Jul 2022 01:54:06 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/memory/</guid><description>準備中</description></item><item><title>[CA] Pipeline</title><link>http://intervalrain.github.io/posts/cs/ca/pipeline/</link><pubDate>Sun, 03 Jul 2022 01:54:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/pipeline/</guid><description>準備中</description></item><item><title>[CA] 處理器</title><link>http://intervalrain.github.io/posts/cs/ca/processor/</link><pubDate>Sun, 03 Jul 2022 01:54:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/processor/</guid><description>準備中</description></item><item><title>[CA] 計算機算術</title><link>http://intervalrain.github.io/posts/cs/ca/arithmetic/</link><pubDate>Sun, 03 Jul 2022 01:53:50 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/arithmetic/</guid><description>準備中</description></item><item><title>[CA] 指令集架構</title><link>http://intervalrain.github.io/posts/cs/ca/isa/</link><pubDate>Sun, 03 Jul 2022 01:53:45 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/isa/</guid><description>準備中</description></item><item><title>[作業系統] 計算機組織與結構</title><link>http://intervalrain.github.io/posts/cs/ca/</link><pubDate>Sun, 03 Jul 2022 01:39:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/</guid><description>計算機組織與結構 計算機抽象化與科技 指令集架構 計算機算術 處理器 Pipeline 記憶體 參考資料 黃婷婷 清大開放式課程 計算機結構 Mr. opengate</description></item><item><title>CPU 個數、CPU 核心數、CPU 執行緒數</title><link>http://intervalrain.github.io/posts/cs/os/cpucorethread/</link><pubDate>Sat, 02 Jul 2022 21:43:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/cpucorethread/</guid><description>Introduction to CPU, core and thread</description></item><item><title>[作業系統] 計算機作業系統</title><link>http://intervalrain.github.io/posts/cs/os/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/</guid><description>計算機作業系統 概述 進程管理 死鎖 記憶體管理 設備管理 鏈接 參考資料 cyc2018 Mr. opengate</description></item><item><title>[計算機作業系統] 概述</title><link>http://intervalrain.github.io/posts/cs/os/intro/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/intro/</guid><description>作業系統 簡介 電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)
硬體(hardware)：為系統提供基本的計算資源。 中央處理器(central processing unit, CPU) 記憶體(memory) I/O 裝置 應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。 使用者(users) 作業系統(Operating system, OS)： 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。
OS 最主要的兩個功能是：
資源分配：根據需求調配資源分配率(resource utilization)與效能(performance) 監控使用者程式的執行，避免不正常的運作造成對系統的危害。 一個標準的 PC 作業系統應該提供以下的功能：
行程管理(Processing management) 記憶體管理(Memory management) 檔案系統(File system) 網路通訊(Networking) 安全機制(Security) 使用者介面(User interface) 驅動程式(Device drivers) PC 基本特徵 1. 並行計算(Concurrent computing) Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 分享(Sharing) 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬(Virtual) 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4.</description></item><item><title>[計算機作業系統] 死鎖</title><link>http://intervalrain.github.io/posts/cs/os/deadlock/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/deadlock/</guid><description>準備中</description></item><item><title>[計算機作業系統] 記憶體管理</title><link>http://intervalrain.github.io/posts/cs/os/memorymanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/memorymanagement/</guid><description>準備中</description></item><item><title>[計算機作業系統] 設備管理</title><link>http://intervalrain.github.io/posts/cs/os/equipmentmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/equipmentmanagement/</guid><description>準備中</description></item><item><title>[計算機作業系統] 進程管理</title><link>http://intervalrain.github.io/posts/cs/os/processmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/processmanagement/</guid><description>進程管理 進程與執行緒 1. 進程(process) 進程是資源分配的基本單位。 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。 2. 執行緒(thread) 執行緒又稱線程，是獨立調度的基本單位。 一個進程可以有多個執行緒，它們共享進程資源。 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。 3. 區別 擁有資源 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。 調度 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。 系統開銷 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。 通訊 執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。 進程狀態的切換 就緒就態(ready)：等待被調度 執行狀態(running) 阻塞狀態(waiting)：等待資源 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。 進程調度演算法 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。 1. 批次處理系統(batch system) 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。 1.1 先來先服務(first-come first-served, FCFS) 非搶占式的調度，按照請求的順序進行調度。 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長 1.2 短作業優先(shortest job first, SJF) 非搶占式的調度算法，按估計運行時間最短的順序進行調度。 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。 1.</description></item><item><title>[計算機作業系統] 鏈接</title><link>http://intervalrain.github.io/posts/cs/os/link/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/link/</guid><description>準備中</description></item><item><title>[ML] introduction</title><link>http://intervalrain.github.io/posts/ml/lec0/</link><pubDate>Sun, 19 Jun 2022 18:18:52 +0800</pubDate><guid>http://intervalrain.github.io/posts/ml/lec0/</guid><description>Introduction to Machine Learning</description></item><item><title>[Life] Some change of road to SWE</title><link>http://intervalrain.github.io/posts/life/nikita_kothari/</link><pubDate>Tue, 14 Jun 2022 22:43:59 +0800</pubDate><guid>http://intervalrain.github.io/posts/life/nikita_kothari/</guid><description>Suggestion from Nikita Kothari at LinkedIn</description></item><item><title>[C++] The C++ Standard Template Library(STL) - deque</title><link>http://intervalrain.github.io/posts/c++/stl_deque/</link><pubDate>Sun, 12 Jun 2022 01:36:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_deque/</guid><description>C++ 中 STL 的 deque 函式與使用範例</description></item><item><title>[C++] Custom Comparator</title><link>http://intervalrain.github.io/posts/c++/custom_comparator/</link><pubDate>Sat, 11 Jun 2022 10:07:49 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/custom_comparator/</guid><description>C++ 中陣列與優先佇列的自定義排序使用方法</description></item><item><title>[C++] The C++ Standard Template Library(STL) - pair</title><link>http://intervalrain.github.io/posts/c++/stl_pair/</link><pubDate>Thu, 02 Jun 2022 01:23:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_pair/</guid><description>C++ 中 STL 的 pair 的函式與使用範例</description></item><item><title>[VHDL] HDLbits 1 - Getting Started</title><link>http://intervalrain.github.io/posts/verilog/hdlbits1/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits1/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 2 - Verilog Language</title><link>http://intervalrain.github.io/posts/verilog/hdlbits2/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits2/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 3 - Circuits</title><link>http://intervalrain.github.io/posts/verilog/hdlbits3/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits3/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 4 - Verification: Reading Simulations</title><link>http://intervalrain.github.io/posts/verilog/hdlbits4/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits4/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 5 - Verification: Writing Testbenches</title><link>http://intervalrain.github.io/posts/verilog/hdlbits5/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits5/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 6 - CS450</title><link>http://intervalrain.github.io/posts/verilog/hdlbits6/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits6/</guid><description>Verilog tutorial</description></item><item><title>[TCAD] 模擬收斂問題</title><link>http://intervalrain.github.io/posts/device/simulationconvergece/</link><pubDate>Wed, 25 May 2022 22:52:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/device/simulationconvergece/</guid><description>TCAD simulation convergence problem</description></item><item><title>[VHDL] Verilog Hardware Description Language</title><link>http://intervalrain.github.io/posts/verilog/intro/</link><pubDate>Sun, 01 May 2022 17:37:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/intro/</guid><description>1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \( \boxed{\text{Full Adder}} \begin{cases} \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{OR}} \end{cases}\\ \text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件} \) 1.</description></item><item><title>[Java] 淺談 Java MVC</title><link>http://intervalrain.github.io/posts/java/java_mvc/</link><pubDate>Fri, 29 Apr 2022 15:38:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/java_mvc/</guid><description>Introduction to Java MVC.</description></item><item><title>[IT] Introduction to Microservices, Docker and Kubernetes</title><link>http://intervalrain.github.io/posts/it/microservices_docker_kubernetes/</link><pubDate>Fri, 29 Apr 2022 11:40:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/microservices_docker_kubernetes/</guid><description>Desc Text.</description></item><item><title>[C++] The C++ Standard Template Library(STL) - map</title><link>http://intervalrain.github.io/posts/c++/stl_map/</link><pubDate>Sat, 23 Apr 2022 22:24:21 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_map/</guid><description>C++ 中 STL 的 map 的函式與使用範例</description></item><item><title>[Java] HashMap中的hashCode設計原理</title><link>http://intervalrain.github.io/posts/java/hashmap/hashcode/</link><pubDate>Fri, 22 Apr 2022 11:22:39 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/hashmap/hashcode/</guid><description>why hashcode &amp;gt;&amp;gt;&amp;gt; 16</description></item><item><title>[C++] 易錯題目收集</title><link>http://intervalrain.github.io/posts/c++/question/</link><pubDate>Sun, 17 Apr 2022 17:34:39 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/question/</guid><description>網路上 C++ 易錯的題目收集</description></item><item><title>[C++] The C++ Standard Template Library(STL) - list, forward_list</title><link>http://intervalrain.github.io/posts/c++/stl_list/</link><pubDate>Sun, 17 Apr 2022 11:45:58 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_list/</guid><description>C++ 中 STL 的 list 的函式與使用範例</description></item><item><title>[C++] The C++ Standard Template Library(STL) - vector</title><link>http://intervalrain.github.io/posts/c++/stl_vector/</link><pubDate>Sat, 16 Apr 2022 22:08:37 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_vector/</guid><description>C++ 中 STL 的 vector 的函式與使用範例</description></item><item><title>[C++] The C++ Standard Template Library(STL) - Container</title><link>http://intervalrain.github.io/posts/c++/stl_container/</link><pubDate>Fri, 15 Apr 2022 01:09:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_container/</guid><description>C++</description></item><item><title>[IDAS+] Optimize Summary Table Function</title><link>http://intervalrain.github.io/posts/vba/idas+_record/</link><pubDate>Thu, 14 Apr 2022 00:39:50 +0800</pubDate><guid>http://intervalrain.github.io/posts/vba/idas+_record/</guid><description>An implementation of dictionary in VBA for searching algorithm</description></item><item><title>[C++] Cout functions</title><link>http://intervalrain.github.io/posts/c++/cout/</link><pubDate>Fri, 08 Apr 2022 10:20:38 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/cout/</guid><description>C++ 的 cout 函式介紹</description></item><item><title>[C++] The C++ Standard Template Library(STL) - Algorithm</title><link>http://intervalrain.github.io/posts/c++/stl_algo/</link><pubDate>Wed, 06 Apr 2022 16:04:36 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_algo/</guid><description>C++ 中 STL 中的 algorithm lib 的函式與範例</description></item><item><title>[C++] The C++ Standard Template Library(STL)</title><link>http://intervalrain.github.io/posts/c++/stl/</link><pubDate>Tue, 05 Apr 2022 01:09:42 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl/</guid><description>C++ 中 STL 的介紹</description></item><item><title>[C++] STL: Vector 的使用與實作</title><link>http://intervalrain.github.io/posts/c++/vector/</link><pubDate>Sun, 03 Apr 2022 18:14:14 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/vector/</guid><description>C++ 中 STL 的 vector 的用法整理</description></item><item><title>[TCAD] 工具語言</title><link>http://intervalrain.github.io/posts/device/tcad/</link><pubDate>Sat, 26 Mar 2022 21:46:26 +0800</pubDate><guid>http://intervalrain.github.io/posts/device/tcad/</guid><description>TCAD learning notes</description></item><item><title>[CA] 計算機的抽象化與科技</title><link>http://intervalrain.github.io/posts/cs/ca/abstraction/</link><pubDate>Thu, 24 Mar 2022 01:12:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/abstraction/</guid><description>計算機的抽象化與科技 1.1 簡介 有賴於科技高速的成長，計算機工業出現了嶄新的型態，計算機導致了文明的第三次革命-資訊革命，與農業革命和工業革命並駕齊驅。如科幻電影般的生活應用，也如雨後出筍般的出現。 汽車 手機 人類基因組計劃(Human genome project) 全球網路(World Wide Web) 搜尋引擎 計算機的應用分類與其特性 個人電腦(Personal Computer, PCs) 伺服器(Servers) 通過網路連接其它的工作站或電腦，通常面向單一且複雜大型的科學或工程應用，也可能是多而小的工作。 成本和功能的差異性也最廣，可以是沒有螢幕沒有鍵盤的桌電，也可以是如超級計算機(supercomputers)這樣的極端。 嵌入式計算機(Embedded Computers) 最大的計算機類別，也涵蓋最廣泛的應用和性能。 通常具有獨特的應用要求，這些要求將最低效能發揮的淋漓盡致，使成本與功耗成為很重要的指標。 後PC時代 個人行動裝置(Poersonal Mobile Device, PMD) 如智慧型手機與平板的出現，取代的 PC 的地位。 雲端計算(Cloud Computing) 取代了傳統伺服器，這些雲端計算建構在「倉庫規模計算機」(Warehouse Scale Computer, WSC)。 企業如Google、Amazon，提供了 WSC 的租借服務，這類通過雲端佈署的「軟體即服務」(Software as a Service, SaaS)，正在改變軟體業。 學習目標 過去在硬體的限制下，程式設計師需要嚴格的考慮程式的效能：減少記憶體空間以使程式更快。 在計算機設計與記憶體科技的進步下，取而代之程式設計師要考量的事情變成：處理器的並行性和記憶體的分層，或諸如在 PMD 或雲端上運行的程式的能源效率問題。 以下是我們將要學習的目標： 用高級語言編寫的程式如何翻譯成硬體語言，以及硬體如何執行生成的程式？藉此可以理解硬體與軟體的關係，也與程式的性能有關聯。 軟體和硬體間的介面是什麼，軟體如何指示硬體執行所需的工作？這些概念對於理解如何編寫多種軟體至關重要。 什麼決定了一個程式的性能，程式設計師如何提高性能？這關係了源始碼編譯成電腦的語言時，硬體執行程式的效率。 硬體設計人員可以使用哪些技術來提高性能(Performance)？ 硬體設計人員可以使用哪些技術來提升能源效率(Energy Efficiency)？程式設計師又如何協助改善？ 什麼理由導致了循序處理(Sequential processing)轉變成了平行處理(Parallel processing)？ 自第一台商用計算機問世以來，計算機架構師提出了哪些想法來奠定現代計算的基礎？ 1.2 計結中八個重要的思想 摩爾定律(Moore&amp;rsquo;s Law)之於設計 摩爾定律源於 Intel 創辦人之一的 Gordon Moore 對 IC 容量增長的預測。 由於計算機設計需耗時數年，而晶片的成長使得計算機架構師在設計時，必須將眼光放到設計完成時的技術狀態，而非當下。 用抽象化(Abstraction)來簡化設計 程式設計師與計算機架構師都必須要不斷發明新的技術以面對日益更新的科技， 抽象化是一種分層設計的概念。對程式設計師而言，低階的細節被忽略，只需要遵從簡單的模型或規範去進行設計。而硬體工程師則是要去實現出這個定義好的模型的硬體、細節部分。 快速處理常見情況 將常使用的指令進行優化(common case fast)，比起其它不常使用的指令，更能提升效能。 何者為最常使用的指令，必須透過嚴密的實驗與測量才以得知。 平行處理(parallelism) Pipeline 預測 某些情況下，將硬體的效能預測的高一點，好過於等到效能滿足才開始設計。 記憶體的結構化(hierarchy) 透過將記憶體分層，將最快、最小、最昂貴的部分置於層狀結構的頂層；而最慢、最大、最便宜的記憶體置於層狀結構的底層。 用多餘創造可靠性(dependability) 計算機不只要速度快，還要具有可靠性。任何物理設備都可能發生故障，此時可以透過引入冗餘的元件來使系統變的更可靠，這些冗餘的元件可以在發生故障時接管工作並協助檢測故障。 1.</description></item><item><title>[Leetcode] Maximum Frequency Stack 最大頻率堆疊</title><link>http://intervalrain.github.io/posts/leetcode/freqstack/</link><pubDate>Sat, 19 Mar 2022 16:53:23 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/freqstack/</guid><description>Maximum Frequency Stack algorithm</description></item><item><title>[Java] 面試常見問題</title><link>http://intervalrain.github.io/posts/java/interviewq/</link><pubDate>Wed, 16 Mar 2022 02:45:45 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/interviewq/</guid><description>針對Java常見面試考題整理，持續更新。</description></item><item><title>[CS50] Lec 1 - C</title><link>http://intervalrain.github.io/posts/cs50/lec1/</link><pubDate>Thu, 10 Mar 2022 02:39:12 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs50/lec1/</guid><description>Introduction to programming language C</description></item><item><title>[Java] transient 關鍵字</title><link>http://intervalrain.github.io/posts/java/transient/</link><pubDate>Tue, 08 Mar 2022 23:53:27 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/transient/</guid><description>Introduction to keyword transient</description></item><item><title>[Device] Mismatch Introduction</title><link>http://intervalrain.github.io/posts/device/mismatch/</link><pubDate>Sat, 05 Mar 2022 21:40:03 +0800</pubDate><guid>http://intervalrain.github.io/posts/device/mismatch/</guid><description>Device mismatch intro.</description></item><item><title>[C++] How to Initialize vector in C++</title><link>http://intervalrain.github.io/posts/c++/newvector/</link><pubDate>Thu, 03 Mar 2022 01:33:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/newvector/</guid><description>C++ 中 vector 的初始化</description></item><item><title>[Java] Integer.bitCount 解析</title><link>http://intervalrain.github.io/posts/java/bitcount/</link><pubDate>Tue, 01 Mar 2022 20:37:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/bitcount/</guid><description>Desc Text.</description></item><item><title>[OS] Lec 1 - Introduction</title><link>http://intervalrain.github.io/posts/os/lec1/</link><pubDate>Thu, 24 Feb 2022 02:43:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/os/lec1/</guid><description>概觀作業系統的歷史發展與進程</description></item><item><title>[Java] Java 的中 HashMap.comparableClassFor(Object x) 的函式解讀</title><link>http://intervalrain.github.io/posts/java/hashmap/hashmap/</link><pubDate>Wed, 23 Feb 2022 01:36:40 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/hashmap/hashmap/</guid><description>認識泛型 generic type、類別 class</description></item><item><title>[CS50] Lec 0 - Introduction to Computer Science</title><link>http://intervalrain.github.io/posts/cs50/lec0/</link><pubDate>Wed, 23 Feb 2022 00:43:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs50/lec0/</guid><description>Intoduction to Computer Science</description></item><item><title>[IT] 在 GitHub Pages 中渲染 KaTex 公式</title><link>http://intervalrain.github.io/posts/it/latexrendering/</link><pubDate>Tue, 22 Feb 2022 01:38:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/latexrendering/</guid><description>如何讓 GitHub Pages 中支援 Latex 語法</description></item><item><title>[Device] Ring Oscillator 環形振盪器</title><link>http://intervalrain.github.io/posts/device/ringoscillator/</link><pubDate>Mon, 21 Feb 2022 01:29:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/device/ringoscillator/</guid><description>A ring circuit with an odd numbers of inverters</description></item><item><title>[Java] List of list of something equality</title><link>http://intervalrain.github.io/posts/java/listequal/</link><pubDate>Fri, 18 Feb 2022 08:59:45 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/listequal/</guid><description>Common Test methodology in Leetcode</description></item><item><title>About me</title><link>http://intervalrain.github.io/posts/aboutme/</link><pubDate>Thu, 17 Feb 2022 17:54:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/aboutme/</guid><description>Who am I?</description></item><item><title>Hello World</title><link>http://intervalrain.github.io/posts/helloworld/</link><pubDate>Thu, 17 Feb 2022 15:15:36 +0800</pubDate><guid>http://intervalrain.github.io/posts/helloworld/</guid><description>How to hello world?</description></item><item><title>[Logic Design] Lec 01 - 數字系統與轉換</title><link>http://intervalrain.github.io/posts/logicdesign/lec1/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec1/</guid><description>Introduction to number systems in computer</description></item><item><title>[Logic Design] Lec 02 - 布林代數</title><link>http://intervalrain.github.io/posts/logicdesign/lec2/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec2/</guid><description>Boolean Algebra operation and theory</description></item><item><title>[Logic Design] Lec 03 - Minterm 與 Maxterm 展開</title><link>http://intervalrain.github.io/posts/logicdesign/lec3/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec3/</guid><description>Minterm and Maxterm expression</description></item><item><title>[Logic Design] Lec 04 - 卡諾圖 Karnaugh Maps</title><link>http://intervalrain.github.io/posts/logicdesign/lec4/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec4/</guid><description>Simplify Boolean function with K-map</description></item><item><title>[Logic Design] Lec 05 - Quine-McClusky Method</title><link>http://intervalrain.github.io/posts/logicdesign/lec5/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec5/</guid><description>Quine-McClusky method - systematic method to simplify boolean algebra for computer.</description></item><item><title>[Logic Design] Lec 06 - Multi-Level Gate Circuits / NAND and NOR Gates</title><link>http://intervalrain.github.io/posts/logicdesign/lec6/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec6/</guid><description>Multi-level gate circuits. nand gates and nor gates introduction.</description></item><item><title>[Logic Design] Lec 07 - 組合電路設計與模擬</title><link>http://intervalrain.github.io/posts/logicdesign/lec7/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec7/</guid><description>Combinational Circuit Design and Simulation Using Gates</description></item><item><title>[Logic Design] Lec 08 - 多工器、編碼器、可程式化邏輯元件</title><link>http://intervalrain.github.io/posts/logicdesign/lec8/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec8/</guid><description>Combinational Circuit Design and Simulation</description></item><item><title>[Logic Design] Lec 09 - Flips-FLops</title><link>http://intervalrain.github.io/posts/logicdesign/lec9/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec9/</guid><description>Flips-Flops</description></item><item><title>[Logic Design] Lec 10 - 暫存器與計數器</title><link>http://intervalrain.github.io/posts/logicdesign/lec10/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec10/</guid><description>Registers and Counters</description></item><item><title>[Logic Design] Lec 11 - 創建圖表與設計電路</title><link>http://intervalrain.github.io/posts/logicdesign/lec11/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec11/</guid><description>Derivation of State Graph and Table</description></item><item><title>[Logic Design] Lec 12 - 電路實現與簡化</title><link>http://intervalrain.github.io/posts/logicdesign/lec12/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec12/</guid><description>Reduction of State Table/State Assignment</description></item><item><title>[Washam] Way to SWE</title><link>http://intervalrain.github.io/posts/washam/</link><pubDate>Sat, 25 May 2019 22:35:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/washam/</guid><description>a study plan to be a software engineer</description></item><item><title>[創作] 關於未來</title><link>http://intervalrain.github.io/posts/music/about_future/</link><pubDate>Fri, 14 Mar 2014 00:01:46 +0800</pubDate><guid>http://intervalrain.github.io/posts/music/about_future/</guid><description>&lt;!DOCTYPE HTML> 詞曲：胡鎮宇
你生活的　都踏踏實實地過了
把曾經走過的路全都擺在記憶了
那憂鬱悲傷快樂歡笑都記得
記在腦海了
你熟悉的　該輕輕鬆鬆地放了
把人生未來的路全都拿在手裡了
那曾經有過的與曾經失去的
都成回憶了
而我將洋洋灑灑邁開步伐地走了
將四年的青春塗上另一種顏色
而我還是無法自拔矯情卻又無法割捨
回想自己的夢　去成就另一種快樂</description></item><item><title>[C++] 如何產生 random 值</title><link>http://intervalrain.github.io/posts/c++/random/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://intervalrain.github.io/posts/c++/random/</guid><description>C++ 中如何產生隨機值</description></item></channel></rss>