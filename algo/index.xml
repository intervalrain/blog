<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Algoes on Rain Hu's Workspace</title><link>https://intervalrain.github.io/algo/</link><description>Recent content in Algoes on Rain Hu's Workspace</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 10 Nov 2023 03:10:09 +0800</lastBuildDate><atom:link href="https://intervalrain.github.io/algo/index.xml" rel="self" type="application/rss+xml"/><item><title>[algo] timeline algorithm</title><link>https://intervalrain.github.io/algo/timeline/</link><pubDate>Fri, 10 Nov 2023 03:10:09 +0800</pubDate><guid>https://intervalrain.github.io/algo/timeline/</guid><description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; class Solution { public: string shortestCommonSupersequence(string a, string b) { int m = a.size(); int n = b.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m+1, vector&amp;lt;int&amp;gt;(n+1, 0)); for (int i = 0; i &amp;lt;= m; i++) { for (int j = 0; j &amp;lt;= n; j++) { if (i == 0 || j == 0) continue; if (a[i-1] == b[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } int i = m; int j = n; string res; while (i &amp;gt; 0 &amp;amp;&amp;amp; j &amp;gt; 0) { if (a[i-1] == b[j-1]) { res += a[i-1]; --i; --j; } else { if (dp[i-1][j] &amp;lt; dp[i][j-1]) { res += b[--j]; } else { res += a[--i]; } } } while (i &amp;gt; 0) res += a[--i]; while (j &amp;gt; 0) res += b[--j]; reverse(res.</description></item></channel></rss>