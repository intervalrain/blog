---
title: "[計算機作業系統] 進程管理"
date: 2022-07-02T04:00:55+08:00
tags: ["OS", "CS"]
draft: false
Categories: CS
author: "Rain Hu"
showToc: true
TocOpen: true
math: true
hidemeta: false
canonicalURL: "https://intervalrain.github.io/"
disableHLJS: true
disableShare: true
disableHLJS: false
hideSummary: false
searchHidden: false
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowCodeCopyButtons: true
---

# 進程管理
## 進程與執行緒
### 1. 進程(process)
+ 進程是資源分配的基本單位。
+ 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。
![PCB](https://www.usna.edu/Users/cs/bilzor/ic411/calendar.php?key=c8bc3778e1e290e4a99e60360fa8c03a340b21ad&type=class&event=6)
### 2. 執行緒(thread)
+ 執行緒又稱線程，是獨立調度的基本單位。
+ 一個進程可以有多個執行緒，它們共享進程資源。
+ 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。
    ![thread](https://4.bp.blogspot.com/-QyEW1jszBJM/UnUsSC-mVOI/AAAAAAAAABY/Z94NgDcWTb4/s640/process-thread.png)

### 3. 區別
1. 擁有資源
    + 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。
2. 調度
    + 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。
3. 系統開銷
    + 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。
    + 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。
4. 溝通
    + 執行緒可以通過直接讀寫同一個進程中的數據進行溝通，但是進程的溝通需要借助 IPC(inter-process communication)。
## 進程狀態的切換
![process state](https://jingtao.fun/images/%E8%AF%BB%E4%B9%A6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20201102105129598.png)
+ 就緒就態(ready)：等待被調度
+ 執行狀態(running)
+ 阻塞狀態(waiting)：等待資源
    + 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。
    + 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。
## 進程調度演算法
+ 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。
### 1. 批次處理系統(batch system)
+ 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。
#### 1.1 先來先服務(first-come first-served, FCFS)
+ 非搶占式的調度，按照請求的順序進行調度。
+ 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長
#### 1.2 短作業優先(shortest job first, SJF)
+ 非搶占式的調度算法，按估計運行時間最短的順序進行調度。
+ 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。
#### 1.3 最短剩餘時間優先(shortest remaining time next, SRTN)
+ 最短作業優先的搶占式版本，按剩餘運行時間的順序進行調度。當一個新的作業到達時，其整個運行時間與當前進程的剩餘時間作比較。如果新的進程需要的時間更少，則夠停當下進程，運行新的進程；否則則讓新的進程進入等待。
### 2. 交互式系統(time sharing system)
+ 交互式系統有大量的用戶交互操作，在該系統中調度演算法的目標是快速地進行響應。
#### 2.1 時間片段輪轉
+ 將所有就緒進程按 FCFS 的原則排成一個佇列，每次調度時，把 CPU 時間分配給佇首進程，該進程可以執行一個時間片段，當時間片段用完時，由計時器發出時鐘中斷，調度程序便停止該進程的執行，並將它送往就緒佇尾，同時繼續把 CPU 時間分配給佇首的進程。
+ 時間片段輪轉演算法的效率和時間片段的大小很有關係：
    + 因為進程切換都要保存進程的訊息並且載入新進程的訊息，如果時間片段太小，會導致頻繁地切換進程，導致時間浪費。
    + 而如果時間片段過長，那麼實時性就不能得到保証。
#### 2.2 優先級調度
+ 為每個進程分配一個優先級，按優先級進行調度。
+ 為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。
#### 2.3 多級反饋佇列
+ 一個進程需要執行 100 個時間片段，如果採用時間片段輪轉調度演算法，那麼需要交換 100 次。
+ 多級佇列是為這種需要連續執行多個時間片段的進程考慮，它設置了多個佇列，每個佇列時間片段大小都不同，例如 1, 2, 4, 8,...。進程在第一個佇列沒執行完，就會被移到下一個佇列。這種方式下，之前的進程只需要交換 7 次。
+ 每個佇列優先權也不同，最上面的優先權最高。因此只有上一個佇列沒有進程在排隊，才能調度當前佇列上的進程。可以將這種調度算法看成是時間片段輪轉調度算法和優先級調度算法的結合。
### 3. 實時系統(real time system)
+ 實時系統要求一個請求在一個確定時間內得到響應。
+ 分為硬實時和軟實時，前者必須滿足絕對的截止時間，後者可以容忍一定的超時。
## 進程同步
### 1. 臨界區
+ 對臨界資源進行訪問的那段代碼稱為臨界區。
+ 為了互斥訪問臨界資源，每個進程在進入臨界區之前，需要先進行檢查。
```
// entry section
// crtical section;
// exit section
```
### 2. 同步與互斥(synchronization and mutex)
+ 同步：
### 3. 訊號量
### 4. 管程
## 經典同步問題
### 1. 哲學家進餐問題
### 2. 讀寫問題
## 進程溝通
### 1. 管道
### 2. FIFO
### 3. 訊息佇列
### 4. 訊號量
### 5. 記憶體共享
### 6. word 套接

