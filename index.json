[{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/csnotes/linux/","summary":"準備中 ","title":"[作業系統] Linux"},{"content":"計算機作業系統 概述 進程管理 死鎖 記憶體管理 設備管理 鏈接 參考資料 cyc2018 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 湯子灜, 哲鳳屏, 湯小丹, 計算機操作系統[M]. 西安電子科技大學出版社, 2001. Bryant, R. E., \u0026amp; O’Hallaron, D. R. (2004). Computer Systems: A Programmer\u0026rsquo;s Perspective. W. Richard Stevens. Advanced Programming in the UNIX Environment. Operating System Notes Operating-System Structures Processes Inter Process Communication Presentation[1] Decoding UCS Invicta – Part 1 ","permalink":"http://intervalrain.github.io/posts/csnotes/os/","summary":"計算機作業系統 概述 進程管理 死鎖 記憶體管理 設備管理 鏈接 參考資料 cyc2018 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 湯子灜, 哲鳳屏, 湯小丹, 計算機操作系統[M]. 西安電子科技大學出版社, 2001. Bryant, R. E., \u0026amp; O’Hallaron, D. R. (2004). Computer Systems: A Programmer\u0026rsquo;s Perspective. W. Richard Stevens. Advanced Programming in the UNIX Environment. Operating System Notes Operating-System Structures Processes Inter Process Communication Presentation[1] Decoding UCS Invicta – Part 1 ","title":"[作業系統] 計算機作業系統"},{"content":"基本特徵 1. 並行計算 並行計算(concurrent computing) 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 共享 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4. 異步(Asynchronous) 異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。 基本功能 1. 進程管理 進程管理、進程同步、進程通信、死鎖處理、處理調度等。 2. 記憶體管理 記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。 3. 文件管理 文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。 4. 設備管理 完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。 主要包含緩衝管理、設備分配、設備處理、虛擬設備等。 系統調用 如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。 Linux 的系統調用主要有以下這些： Task Commands 進程控制 fork(); exit(); wait(); 進程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 設備操作 ioctl(); read(); write(); 訊息維護 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 內核與微內核 1. 內核(kernel) 內核是將作業系統功能作為一個緊密結合的整體放到內核。 由於各模塊共享訊息，因此有很高的性能。 2. 微內核(microkernel) 由於作業系統不斷複雜化，因此將一部分作業系統功能移出內核，從而降低內核的複雜性。移出的部分根據分層的原則劃分成若干服務，相互獨立。 在微內核結構下，作業系統被劃分成小的、定義良好的模塊，只有微內核這一個模塊運行在內核模式，其餘模塊運行時在用戶模式。 因為脫試頻繁地在用戶模式與內核模式間進行切換，所以有一定的性能損失。 中斷分類 1. 中斷(interrupt) 由 CPU 執行指令以外的事件引起，如 I/O 完成中斷，表示設備輸入/輸出處理已經完成，處理器能夠發送下一個輸入/輸出請求。此外還有時鐘中斷、控制台中斷等。 2. 異常(exception) 由 CPU 執行指令的內部事件引起，如非法操作碼、地址越界、算術溢位(overflow)等。 3. 陷入(trap) 在用戶程序中使用系統調用。 ","permalink":"http://intervalrain.github.io/posts/csnotes/os/intro/","summary":"基本特徵 1. 並行計算 並行計算(concurrent computing) 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 共享 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4. 異步(Asynchronous) 異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。 基本功能 1. 進程管理 進程管理、進程同步、進程通信、死鎖處理、處理調度等。 2. 記憶體管理 記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。 3. 文件管理 文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。 4. 設備管理 完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。 主要包含緩衝管理、設備分配、設備處理、虛擬設備等。 系統調用 如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。 Linux 的系統調用主要有以下這些： Task Commands 進程控制 fork(); exit(); wait(); 進程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 設備操作 ioctl(); read(); write(); 訊息維護 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 內核與微內核 1.","title":"[計算機作業系統] 概述"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/csnotes/os/deadlock/","summary":"準備中 ","title":"[計算機作業系統] 死鎖"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/csnotes/os/memorymanagement/","summary":"準備中 ","title":"[計算機作業系統] 記憶體管理"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/csnotes/os/equipmentmanagement/","summary":"準備中 ","title":"[計算機作業系統] 設備管理"},{"content":"","permalink":"http://intervalrain.github.io/posts/csnotes/os/processmanagement/","summary":"","title":"[計算機作業系統] 進程管理"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/csnotes/os/link/","summary":"準備中 ","title":"[計算機作業系統] 鏈接"},{"content":" 演算法 Leetcode 演算法 作業系統 計算機作業系統 Linux 網路 計算機網路 HTTP Socket 資料庫 資料庫系統原理 SQL 語法 SQL 練習 MySQL Redis Java Java 基礎 Java 容器 Java 開發 Java 虛擬機 Java I/O 系統設計 系統設計基礎 分布式 集群 駭客技術 緩存 訊息佇列 物件導向 物件導向概念 設計模式 工具 Git Docker 框架 正則表達式 程式碼實踐 程式碼可讀性 程式碼格規範 ","permalink":"http://intervalrain.github.io/posts/csnotes/","summary":" 演算法 Leetcode 演算法 作業系統 計算機作業系統 Linux 網路 計算機網路 HTTP Socket 資料庫 資料庫系統原理 SQL 語法 SQL 練習 MySQL Redis Java Java 基礎 Java 容器 Java 開發 Java 虛擬機 Java I/O 系統設計 系統設計基礎 分布式 集群 駭客技術 緩存 訊息佇列 物件導向 物件導向概念 設計模式 工具 Git Docker 框架 正則表達式 程式碼實踐 程式碼可讀性 程式碼格規範 ","title":"CS 學習筆記"},{"content":"什麼是 AI \u0026amp; ML \u0026amp; DL 人工智慧是我們想要達成的目標，而機器學習是想要達成目標的手段，希望機器通過學習的方式，變得跟人一樣聰明。 而深度學習就是機器學習的其中一種方法。\n人工智慧(Aritificial Intelligence, AI) → 目標 機器學習(Machine Learning, ML) → 手段 深度學習(Deep Learning, DL) … 在機器學習出現之前 生物的行為取決於兩件事，一個是後天學習的結果，一個是天生的本能。\nHand-crafted rules: 人類為機器設定好的天生本能 僵化，無法超越創造者 需要大量人力，不適合小企業 機器學習 寫程式讓機器可以學習 → 尋找關聯資料的函式 舉例：語音辨識、影像辨識、Alpha Go、對話機器人 框架(Framework) 設定一定量的函數 餵入數據 評估函數的好壞 找出最好的函數\n\\(\\begin{array}{rc} \\text{step1}\u0026amp;\\boxed{\\text{Define a set of function}}\\\\ \u0026amp;\\downarrow\\\\ \\text{step2}\u0026amp;\\boxed{\\text{Evaluate goodness of function}}\\\\ \u0026amp;\\downarrow\\\\ \\text{step3}\u0026amp;\\boxed{\\text{Pick the best function}}\\end{array}\\) 告訴機器 input 和正確的 output 這就叫作 supervised learning。 機器學習相關的技術 任務(Task) 迴歸(Regression) Regression 指的是函數的輸出為 scalar(數值)，如 PM2.5。 分類(Classification) Classification 指的是函數的輸出為 東西的類別。 當分類為 Yes or No，則為 Binary Classificatino，如垃圾郵件。 當分類是多個選項的，則為 Multi-Classification，如新聞分類。 結構性學習(Structured Learning) 讓機器的輸出具有結構性。 如語音辨識，聲音訊號為輸入，句子為輸出。 如影像辨識，圖片是輸入，人名是輸出。 方法(Method) 選不同的 function set 就是選不同的 model。\nModel Linear Model Non-linear model Deep learning SVM, decision tree, K-NN \u0026hellip; 場景(Scenario) 監督式學習 Supervised Learning 需要 inputs 與對應的 outputs(label) 大量的資料需求 半監督式學習 Semi-supervised Learning 同時有 Labelled data 與 Unlabelled data 可減少資料的需求量。 遷移學習 Transfer Leanring 有大量的 Labelled data 與 Unlabelled data 其中包含有關聯的與無關聯的。 無監督學習 Unsuperviesd Learning 只有大量的 inputs 而沒有 outputs 或大量的 outputs 而沒有 inputs 強化學習 沒有告訴機器正確的答案，機器有的只是一個分數，就是它做得好或不好。 Alpha Go 是 Supervised learning + Reinforcement learning (先人工餵棋譜，再讓機器人互相下棋) 利用 reinforcement learning 來訓練聊天機器人，把機器人發到客服電話，讓機器人自己應對客人，若客人的反應勃然大怒，則機器會學到剛才應對的方式是錯的，讓機器自己去檢討哪個步驟做的不好。\n我們為何要學機器學習? 好的 AI 需要好的 AI 訓練師，AI 訓練師討選合適的 model、loss function，不同 model、loss function 適合解決不同的問題。 有些模型的最佳化比較困難，例如深度學習，此時可能就需要有經驗的 AI 訓練師來處理。\n","permalink":"http://intervalrain.github.io/posts/ml/lec0/","summary":"什麼是 AI \u0026amp; ML \u0026amp; DL 人工智慧是我們想要達成的目標，而機器學習是想要達成目標的手段，希望機器通過學習的方式，變得跟人一樣聰明。 而深度學習就是機器學習的其中一種方法。\n人工智慧(Aritificial Intelligence, AI) → 目標 機器學習(Machine Learning, ML) → 手段 深度學習(Deep Learning, DL) … 在機器學習出現之前 生物的行為取決於兩件事，一個是後天學習的結果，一個是天生的本能。\nHand-crafted rules: 人類為機器設定好的天生本能 僵化，無法超越創造者 需要大量人力，不適合小企業 機器學習 寫程式讓機器可以學習 → 尋找關聯資料的函式 舉例：語音辨識、影像辨識、Alpha Go、對話機器人 框架(Framework) 設定一定量的函數 餵入數據 評估函數的好壞 找出最好的函數\n\\(\\begin{array}{rc} \\text{step1}\u0026amp;\\boxed{\\text{Define a set of function}}\\\\ \u0026amp;\\downarrow\\\\ \\text{step2}\u0026amp;\\boxed{\\text{Evaluate goodness of function}}\\\\ \u0026amp;\\downarrow\\\\ \\text{step3}\u0026amp;\\boxed{\\text{Pick the best function}}\\end{array}\\) 告訴機器 input 和正確的 output 這就叫作 supervised learning。 機器學習相關的技術 任務(Task) 迴歸(Regression) Regression 指的是函數的輸出為 scalar(數值)，如 PM2.5。 分類(Classification) Classification 指的是函數的輸出為 東西的類別。 當分類為 Yes or No，則為 Binary Classificatino，如垃圾郵件。 當分類是多個選項的，則為 Multi-Classification，如新聞分類。 結構性學習(Structured Learning) 讓機器的輸出具有結構性。 如語音辨識，聲音訊號為輸入，句子為輸出。 如影像辨識，圖片是輸入，人名是輸出。 方法(Method) 選不同的 function set 就是選不同的 model。","title":"[ML] introduction"},{"content":"陣雨：\n在每日一題 Leetcode 的日常中，看到 LinkedIn 上來自 LinkedIn 自己工程師的建議，一語驚醒夢中人，於是記錄下來，警醒自己：\n作者 Nikita Kothari Software Engineer @ LinkedIn The University of Texas at Dallas 正文 Nikita:\nRecently I interviewed and got 7 offers within two months of preparation and accepted Senior Software Engineer position at LinkedIn. I want to share some useful resources which might help you to land your dream job.\n最近，我在兩個月內準備了面試並錄取了七個職位，且最終且接收了 LinkedIn 的高級軟體工程師一職。我想要分享一些有用的資源，這些資源可能可以幫助你找到你夢寐以求的工作。\n1. 自信 Confidence is the key. Don’t jump into the interview process when you are not fully prepared.\n信心是關鍵。當你還沒有做好充分準備前，不要貿然的進入面試階段。\n2. 刷題 Rather than doing 1000s of leetcode (https://lnkd.in/gyRnXuHQ), do few examples and understand the patterns which will help you to crack any problem. Also, think about all edge cases and test cases.\n比起刷 1000 題 leetcode，做幾個經典例題並瞭解其模式(pattern)，這將會有助於你破解任何問題。同時，請充分考慮邊際條件(edge cases)與測資(test cases)。\n3. 複雜度 At the end, spend some time thinking about time and space complexity. It gets tricky with graph and tree problems.\n在解題的最後，花點時間思考時間複雜度與空間複雜度。特別在棘手的圖形與樹問題。\n4. 應用 Think about the possible use cases of the given problem, for example, flood fill is nothing but the paint app and try to explain that to the interviewer.\n思考題目可能應用的實況，舉例來說，flood-fill 只不過是繪畫應用程式，並嘗試向面試官解釋。\n5. 專案 Create a Google doc and list down all recent/interesting project you worked on. Start with design, implementation, testing, monitoring, your contribution and ask yourself what questions a person can ask if he/she doesn’t have any idea about the project. This will also help you during the system design interview.\n創建一個 Google 文件並列出所有你最近正在著手或有趣的專案。從設計、實作、測試、監控、你的貢獻開始，並問自己，如果一個人對此專案毫無概念時，他/她可以問什麼問題。\n6. STAR Also, create a Google doc for behavior questions (https://lnkd.in/gPp8iE_x) and write down what was the situation, what was your task, what action you took and what was the result. Read more about the STAR approach. Companies like Amazon, pays more attention to these questions so be well-prepared.\n此外，為行為問題創建一個 Google 文件，並寫下情況，你的任務是什麼，你採取了什麼行動，結果是什麼。閱讀更多有關 STAR 的方法。像亞馬遜這類的公司，更在乎這類的問題，所以需要做好充分準備。 註：情境/任務/動作/結果 Situation/Task/Action/Result\n7. 模擬面試 Do practice interviews with your friends and peers, and take feedback seriously.\n與你的朋友、同儕練習面試，並且認真的對待他們的回饋。\n8. 記錄面試 At the end of an onsite interview, make a list of what went well and where you need to put more attention and work on it.\n在現場面試後，列出哪些方面進展順利，哪些需要投入更多的注意力與力氣。\n9. 連結經驗 While practicing system design, try to relate things with your current or past experience. Like how server side configuration has been set up or how APIs are implemented in your current project. This way you will remember things easily.\n在練習系統設計時，試著與你現在或以前的經驗聯繫起來。例如伺服器端配置的方法、API 在你當前的專案中是怎麼被實現的。這些方法會讓你更容易記得這些事。\n10. 參考 Before your onsite interview, visit Glassdoor (https://lnkd.in/gwKXeYQA) and read about other’s experiences. That will give you an idea on what to expect.\n在現場面試前，參考並閱讀其他人的經驗，這將給你多一點面試時的想法。\n11. 保持正向 Lastly, don’t get dejected by rejections. Sometimes it looks difficult, but with enough practice and hard work, you will get your dream job.\n最後，不要因為被拒絕而沮喪。有時候，看起很困難的事情，在經過足夠的練習與努力後，都可以迎刃而解的。\nAll the very best, and feel free to reach out to me if you need any help on anything.\n其他資源 Grokking the Object Oriented Design Interview 系統設計入門 (https://lnkd.in/g6jQaM6e) 軟體結構 (https://lnkd.in/gM8WgW3S) 系統設計 (https://lnkd.in/gYF5saRb)\n#work #softwareengineer #interviewskills #design #job ","permalink":"http://intervalrain.github.io/posts/life/nikita_kothari/","summary":"陣雨：\n在每日一題 Leetcode 的日常中，看到 LinkedIn 上來自 LinkedIn 自己工程師的建議，一語驚醒夢中人，於是記錄下來，警醒自己：\n作者 Nikita Kothari Software Engineer @ LinkedIn The University of Texas at Dallas 正文 Nikita:\nRecently I interviewed and got 7 offers within two months of preparation and accepted Senior Software Engineer position at LinkedIn. I want to share some useful resources which might help you to land your dream job.\n最近，我在兩個月內準備了面試並錄取了七個職位，且最終且接收了 LinkedIn 的高級軟體工程師一職。我想要分享一些有用的資源，這些資源可能可以幫助你找到你夢寐以求的工作。\n1. 自信 Confidence is the key. Don’t jump into the interview process when you are not fully prepared.","title":"[Life] Some change of road to SWE"},{"content":"Deque 不同於 stack 與 queues， deques 兩個端點都支援擴展。 基於 doubly linked list，deques 有幾項額外的特徵： 支援隨機存取 插入元素時間 \\(O(1)\\) 函式 1. push_front() 2. push_back() 3. front() 4. back() 5. begin() 6. end() 7. insert() 8. erase() 9. pop_front() 10. pop_back() 11. empty() 12. clear() 13. random_access() 內部運作原理 上述所有函數和操作都在雙鏈表中以O（1）時間執行，但這些清單不能隨機訪問任何元素。C++中的deque也是如此。這個 O（1） 在 deque 中可以使用圓形陣列來實現。使用循環陣列，可以在O（1）時間內實現從陣列的正面和背面插入和刪除等操作以及元素的隨機訪問。但這帶來了一個問題。當 deque 增長到超出容量時，使用者將需要將數位大小加倍，並將所有數據複製到陣列中。此外，如果數據是某個使用者定義的對象，那麼加倍和複製數據的成本就會變得非常昂貴。 這是一個基本的解決方案。Deque使用一些棘手的實現，當它說O（1）來push_back（）和push_front（）時，它實際上是調用的複製構造函數數量的常數時間。因此，如果數據物件是具有多個成員的某個類物件，則最小化複製構造函數調用的數量將節省時間。此外，複製構造函數調用的次數是恆定的。現在讓我們看看如何實現這一點。 這可以通過使用指向一些固定大小的塊的指標數位來實現，這些塊包含deque數據。下面是一個說明性示例。 這些 Deque 數據被劃分為固定大小的塊。在這裡，我們考慮了將數據劃分為大小為5的固定塊。 塊的填充從指標的兩個 deque 陣列的中間開始，並使用push_front和push_back操作向前和向後擴展。中間塊通常是滿的，當它被填滿時，數據被移動到上部或下部塊。 在上部塊中，元素以相反的順序推送，因為在這種情況下，填充數據的第一個位置將是4，然後是3，2，1，0。但是在中間和下部塊中，數據按正向順序填充，如0，1，2，3，4等。 當上面的塊被填滿時，指標將創建一個新塊並開始指向一個新的數位塊。這為更多數據創造了空間。在這種情況下，也可以填充指標塊。這會導致一個問題。 這是加倍來救援的時候。在加倍時，指標陣列的大小加倍。這不會複製整個數據，而只會複製指標。這是許多人在討論恆定時間時提出的一般論點。時間在調用的複製構造函數數方面保持不變。 如果數據集非常大，則指標塊幾乎不會執行加倍，因為單個指標可以指向大量數據塊。因此，指標陣列被填充並加倍的可能性非常小。 ","permalink":"http://intervalrain.github.io/posts/c++/stl_deque/","summary":"Deque 不同於 stack 與 queues， deques 兩個端點都支援擴展。 基於 doubly linked list，deques 有幾項額外的特徵： 支援隨機存取 插入元素時間 \\(O(1)\\) 函式 1. push_front() 2. push_back() 3. front() 4. back() 5. begin() 6. end() 7. insert() 8. erase() 9. pop_front() 10. pop_back() 11. empty() 12. clear() 13. random_access() 內部運作原理 上述所有函數和操作都在雙鏈表中以O（1）時間執行，但這些清單不能隨機訪問任何元素。C++中的deque也是如此。這個 O（1） 在 deque 中可以使用圓形陣列來實現。使用循環陣列，可以在O（1）時間內實現從陣列的正面和背面插入和刪除等操作以及元素的隨機訪問。但這帶來了一個問題。當 deque 增長到超出容量時，使用者將需要將數位大小加倍，並將所有數據複製到陣列中。此外，如果數據是某個使用者定義的對象，那麼加倍和複製數據的成本就會變得非常昂貴。 這是一個基本的解決方案。Deque使用一些棘手的實現，當它說O（1）來push_back（）和push_front（）時，它實際上是調用的複製構造函數數量的常數時間。因此，如果數據物件是具有多個成員的某個類物件，則最小化複製構造函數調用的數量將節省時間。此外，複製構造函數調用的次數是恆定的。現在讓我們看看如何實現這一點。 這可以通過使用指向一些固定大小的塊的指標數位來實現，這些塊包含deque數據。下面是一個說明性示例。 這些 Deque 數據被劃分為固定大小的塊。在這裡，我們考慮了將數據劃分為大小為5的固定塊。 塊的填充從指標的兩個 deque 陣列的中間開始，並使用push_front和push_back操作向前和向後擴展。中間塊通常是滿的，當它被填滿時，數據被移動到上部或下部塊。 在上部塊中，元素以相反的順序推送，因為在這種情況下，填充數據的第一個位置將是4，然後是3，2，1，0。但是在中間和下部塊中，數據按正向順序填充，如0，1，2，3，4等。 當上面的塊被填滿時，指標將創建一個新塊並開始指向一個新的數位塊。這為更多數據創造了空間。在這種情況下，也可以填充指標塊。這會導致一個問題。 這是加倍來救援的時候。在加倍時，指標陣列的大小加倍。這不會複製整個數據，而只會複製指標。這是許多人在討論恆定時間時提出的一般論點。時間在調用的複製構造函數數方面保持不變。 如果數據集非常大，則指標塊幾乎不會執行加倍，因為單個指標可以指向大量數據塊。因此，指標陣列被填充並加倍的可能性非常小。 ","title":"[C++] The C++ Standard Template Library(STL) - deque"},{"content":"C++ Custom Comparator sort(iter, iter, comp) Lambda function int main(){ auto comp = [](int a, int b){ return a \u0026lt; b; } vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Usual boolean function bool comp(const int\u0026amp; a, const int\u0026amp; b){ return a \u0026lt; b; } int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Old solution using struct/class with () operator struct cmp { bool operator() (int a, int b) const { return a \u0026lt; b; } }; int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp()); // 1,2,3,4,5,6,7,8,9 } priority_queue(element, container, comp) Modern C++20 Solution(lambda) We can use lambda function as comparator. As usual, comparator should return boolean value, indicating whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines. int main(){ auto comp = [](int a, int b){ return a \u0026lt; b; } vector\u0026lt;int\u0026gt; vec = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int, decltype(comp)\u0026gt; pq; for (int num : vec) pq.push(num); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } Modern C++11 Solution(lambda) Before C++20 we need to pass lambda function as argument to set constructor. int main(){ auto comp = [](int a, int b){ return a \u0026lt; b; } vector\u0026lt;int\u0026gt; vec = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int, decltype(comp)\u0026gt; pq(comp); for (int num : vec) pq.push(num); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } Usual function Make comparator as usual boolean function bool comp(int a, int b){ return a \u0026lt; b; } int main(){ vector\u0026lt;int\u0026gt; vec = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int, decltype(\u0026amp;comp)\u0026gt; pq(comp); // priority_queue\u0026lt;int, vector\u0026lt;int, decltype(comp)*\u0026gt; pq(comp); // in C++20, constructor can be ignored the same as lambda function. for (int num : vec) pq.push(num); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } Old solution using struct/class with () operator struct cmp { bool operator() (int a, int b) const { return a \u0026lt; b; } }; int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, comp\u0026gt; pq(vec.begin(), vec.end()); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } Alternative solution: create struct/class from boolean function bool comp(int a, int b){ return a \u0026lt; b; } #include \u0026lt;type_traits\u0026gt; using Cmp = integral_constant\u0026lt;decltype(\u0026amp;comp), \u0026amp;comp\u0026gt;; int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int, decltype(\u0026amp;comp)\u0026gt; pq(comp); for (int num : vec) pq.push(num); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } ","permalink":"http://intervalrain.github.io/posts/c++/custom_comparator/","summary":"C++ Custom Comparator sort(iter, iter, comp) Lambda function int main(){ auto comp = [](int a, int b){ return a \u0026lt; b; } vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Usual boolean function bool comp(const int\u0026amp; a, const int\u0026amp; b){ return a \u0026lt; b; } int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Old solution using struct/class with () operator struct cmp { bool operator() (int a, int b) const { return a \u0026lt; b; } }; int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.","title":"[C++] Custom Comparator"},{"content":"pair 宣告 pair (data_type1, data_type2) Pair_name; 初始化 pair\u0026lt;int, int\u0026gt; p1; pair\u0026lt;int, char\u0026gt; p2(1, \u0026#39;a\u0026#39;); pair\u0026lt;int, int\u0026gt; p3(1, 10); pair\u0026lt;int, int\u0026gt; p4(p3); p2 = make_pair(1, \u0026#39;a\u0026#39;); 成員 .first .second 函式 1. make_pair(v1, v2); 2. operators(=, ==, !=, \u0026gt;=, \u0026lt;=) 3. pair1.swap(pair2); ","permalink":"http://intervalrain.github.io/posts/c++/stl_pair/","summary":"pair 宣告 pair (data_type1, data_type2) Pair_name; 初始化 pair\u0026lt;int, int\u0026gt; p1; pair\u0026lt;int, char\u0026gt; p2(1, \u0026#39;a\u0026#39;); pair\u0026lt;int, int\u0026gt; p3(1, 10); pair\u0026lt;int, int\u0026gt; p4(p3); p2 = make_pair(1, \u0026#39;a\u0026#39;); 成員 .first .second 函式 1. make_pair(v1, v2); 2. operators(=, ==, !=, \u0026gt;=, \u0026lt;=) 3. pair1.swap(pair2); ","title":"[C++] The C++ Standard Template Library(STL) - pair"},{"content":"HDLBits HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。 由教學的題型由淺入深，逐步建立起電路設計的技能。 每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。\nCatalog 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n1 Getting Started \\(\\text{assign one}\\) Build a circuit with no inputs and one output. The output should always drive 1 (or logic high). module top_module( output one); assign one = 1\u0026#39;b1; endmodule \\(\\text{assign zero}\\) Build a circuit with no inputs and one output that outputs a constant 0. module top_module( output zero ); assign zero = 1\u0026#39;b0; endmodule ","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits1/","summary":"HDLBits HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。 由教學的題型由淺入深，逐步建立起電路設計的技能。 每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。\nCatalog 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n1 Getting Started \\(\\text{assign one}\\) Build a circuit with no inputs and one output. The output should always drive 1 (or logic high). module top_module( output one); assign one = 1\u0026#39;b1; endmodule \\(\\text{assign zero}\\) Build a circuit with no inputs and one output that outputs a constant 0.","title":"[VHDL] HDLbits 1 - Getting Started"},{"content":"1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n2 Verilog Language 2.1 Basics wire Create a module with one input and ont output that behaves like a wire module top_module( input in, output out); assign out = in; endmodule multi-in-out Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: module top_module( input a,b,c, output w,x,y,z ); assign w = a; assign x = b; assign y = b; assign z = c; endmodule not gate Create a module that implements a NOT gate. module top_module( input in, output out ); assign out = ~in; endmodule and gate Create a module that implments an AND gate. module top_module( input a,b, output out ); assign out = a \u0026amp; b; endmodule nor gate Create a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog. module top_module( input a,b, output out ); assign out = ~(a|b); endmodule xnor gate Create a module that implements a XNOR gate. module top_module( input a, b, output out ); assign out = ~(a^b); endmodule wire declaration Implement following circuits. Create two intermediate wires to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire out, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs. module top_module( input a,b,c,d, output out, out_n ); wire w1, w2; assign w1 = a \u0026amp; b; assign w2 = c \u0026amp; d; assign out = w1 | w2; assign out_n = ~out; endmodule 7458 The 7458 is a chip with four AND gates and two OR gates. Create a module with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. module top_module( input p1a, p1b, p1c, p1d, p1e, p1f, output p1y, intput p2a, p2b, p2c, p2d, output p2y ); wire w1a, w1b; wire w2a, w2b; assign w1a = p1a \u0026amp; p1b \u0026amp; p1c; assign w1b = p1d \u0026amp; p1e \u0026amp; p1f; assign p1y = w1a | w1b; assign w2a = p2a \u0026amp; p2b; assign w2b = p2c \u0026amp; p2d; assign p2y = w2a | w2b; endmodule 2.2 Vectors vector Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect outputs o0 to the input vector\u0026rsquo;s position 0, o1 to position 1, etc.\nIn a diagram, a tick mark with a number next to it indicates the width of the vector (or \u0026ldquo;bus\u0026rdquo;), rather than drawing a separate line for each bit in the vector. module top_module ( input wire [2:0] vec, output wire [2:0] outv, output wire o2, output wire o1, output wire o0 ); assign outv = vec; assign o0 = vec[0]; assign o1 = vec[1]; assign o2 = vec[2]; endmodule vector select Build a combinational circuit that splits an input half-word (16 bits, [15:0]) into lower [7:0] and upper [15:8] bytes. module top_module ( input [15:0] in, output [7:0] out_hi, output [7:0] out_lo ); assign out_hi = in[15:8]; assign out_lo = in[7:0]; endmodule vector swap A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of the 4-byte word.\nAaaaaaaaBbbbbbbbCcccccccDddddddd =\u0026gt; DdddddddCcccccccBbbbbbbbAaaaaaaa\nThis operation is often used when the endianness of a piece of data needs to be swapped, for example between little-endian x86 systems and the big-endian formats used in many Internet protocols. module top_module ( input [31:0] in, output [31:0] out ); assign out[31:24] = in[ 7: 0]; assign out[23:16] = in[15: 8]; assign out[15: 8] = in[23:16]; assign out[ 7: 0] = in[31:24]; endmodule vector gates uild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half. module top_module ( input [2:0] a, input [2:0] b, output [2:0] out_or_bitwise, output out_or_logical, output [5:0] out_not ); assign out_or_bitwise = a | b; assign out_or_logical = a || b; assign out_not[2:0] = ~a; assign out_not[5:3] = ~b; endmodule gate-prefix vector Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: out_and: output of a 4-input AND gate. out_or: output of a 4-input OR gate. out_xor: outout of a 4-input XOR gate. module top_module ( input [3:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026amp; in; assign out_or = | in; assign out_xor = ^ in; endmodule vector concatenate Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for module top_module ( input [4:0] a, b, c, d, e, f, output [7:0] w, x, y, z ); assign {w, x, y, z} = {a, b, c, d, e, f, 2\u0026#39;b11}; endmodule vector reverse Given an 8-bit input vector [7:0], reverse its bit ordering. module top_module( input [7:0] in, output [7:0] out ); assign {out[0], out[1], out[2], out[3], out[4], out[5], out[6], out[7]} = in endmodule module top_module( input [7:0] in, output [7:0] out ); always @(*) begin for (int i=0; i\u0026lt;8; i++) out[i] = in[8-i-1]; end endmodule module top_module( input [7:0] in, output [7:0] out ); generate genvar i; for (i=0; i\u0026lt;8; i = i+1) begin: my_block_name assign out[i] = in[8-i-1]; end endgenerate endmodule vector replication Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself. module top_module ( input [7:0] in, output [31:0] out ); assign out = {{24{in[7]}}, in}; endmodule vector replication2 Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. module top_module ( input a, b, c, d, e, output [24:0] out ); assign out = ~{{5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}}} ^ {5{a,b,c,d,e}}; endmodule 2.3 Modules: Hierarchy By now, you\u0026rsquo;re familiar with a module, which is a circuit that interacts with its outside through input and output ports. Larger, more complex circuits are built by composing bigger modules out of smaller modules and other pieces (such as assign statements and always blocks) connected together. This forms a hierarchy, as modules can contain instances of other modules.\nThe figure below shows a very simple circuit with a sub-module. In this exercise, create one instance of module mod_a, then connect the module\u0026rsquo;s three pins (in1, in2, and out) to your top-level module\u0026rsquo;s three ports (wires a, b, and out). The module mod_a is provided for you — you must instantiate it.\nWhen connecting modules, only the ports on the module are important. You do not need to know the code inside the module. The code for module mod_a looks like this:\nmodule mod_a ( input in1, input in2, output out ); // Module body endmodule The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written inside another module\u0026rsquo;s body (Code for different modules are not nested).\nYou may connect signals to the module by port name or port position. For extra practice, try both methods.\nConnecting Signals to Module Ports\nThere are two commonly-used methods to connect a wire to a port: by position or by name.\nBy position\nThe syntax to connect wires to ports by position should be familiar, as it uses a C-like syntax. When instantiating a module, ports are connected left to right according to the module\u0026rsquo;s declaration. For example:\nmod_a instance1 ( wa, wb, wc );\nThis instantiates a module of type mod_a and gives it an instance name of \u0026ldquo;instance1\u0026rdquo;, then connects signal wa (outside the new module) to the first port (in1) of the new module, wb to the second port (in2), and wc to the third port (out). One drawback of this syntax is that if the module\u0026rsquo;s port list changes, all instantiations of the module will also need to be found and changed to match the new module.\nBy name\nConnecting signals to a module\u0026rsquo;s ports by name allows wires to remain correctly connected even if the port list changes. This syntax is more verbose, however.\nmod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );\nThe above line instantiates a module of type mod_a named \u0026ldquo;instance2\u0026rdquo;, then connects signal wa (outside the module) to the port named in1, wb to the port named in2, and wc to the port named out. Notice how the ordering of ports is irrelevant here because the connection will be made to the correct name, regardless of its position in the sub-module\u0026rsquo;s port list. Also notice the period immediately preceding the port name in this syntax.\nmodule module top_module ( input a, input b, output out ); mod_a u_mod_a ( .in1 (a), .in2 (b), .out (out) ); endmodule module_pos This problem is similar to the previous one (module). You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. You must connect the 6 ports by position to your top-level module\u0026rsquo;s ports out1, out2, a, b, c, and d, in that order. You are given the following module: module top_module ( input a, b, c, d, output out1, out2 ); mod_a u_mod_a(out1, out2, a, b, c, d); endmodule module_name This problem is similar to module. You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. You must connect the 6 ports by name to your top-level module\u0026rsquo;s ports:You are given the following module: module top_module ( input a, input b, input c, input d, output out1, output out2 ); mod_a u_mod_a( .out1 (out1), .out2 (out2), .in1 (a), .in2 (b), .in3 (c), .in4 (d) ); endmodule module_shift You are given a module my_dff with two inputs and one output (that implements a D flip-flop). Instantiate three of them, then chain them together to make a shift register of length 3. The clk port needs to be connected to all instances. Note that to make the internal connections, you will need to declare some wires. Be careful about naming your wires and module instances: the names must be unique.\nThe module provided to you is: module my_dff ( input clk, input d, output q ); module top_module ( input clk, input d, output q ); wire q1; wire q2; my_dff(clk, d, q1); my_dff(clk, q1, q2); my_dff(clk, q2, q); endmodule module_shift8 You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: The value at the input d, after the first, after the second, or after the third D flip-flop. (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.) The module provided to you is: module my_dff8 ( input clk, input [7:0] d, output [7:0] q );\nThe multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside. module top_module ( input clk, input [7:0] d, input [1:0] sel, output [7:0] q ); wire [7:0] q1; wire [7:0] q2; wire [7:0] q3; my_dff8 (clk, d, q1); my_dff8 (clk, q1, q2); my_dff8 (clk, q2, q3); // multiplexer: mux9to1v always@(*) begin case(sel) 2\u0026#39;d0: q = d; 2\u0026#39;d1: q = q1; 2\u0026#39;d2: q = q2; 2\u0026#39;d3: q = q3; endcase end endmodule module_Half Adder You are given a module add16 that performs a 16-bit addition. Instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result, after receiving the carry-out from the first adder. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored), but the internal modules need to in order to function correctly. (In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).\nConnect the modules together as shown in the diagram below. The provided module add16 has the following declaration: module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout ); module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire [15:0] sum1; wire [15:0] sum2; wire cout1; wire cout2; add16 (a[15:0], b[15:0], 1\u0026#39;b0, sum1, cout1); add16 (a[31:16], b[31:16], cout1, sum2, cout2); assign sum = {sum2, sum1}; endmodule module_Full Adder You are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).\nConnect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nWithin each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. You must write the full adder module that has the following declaration:\nmodule add1 ( input a, input b, input cin, output sum, output cout );\nRecall that a full adder computes the sum and carry-out of a+b+cin.\nIn summary, there are three modules in this design: top_module — Your top-level module that contains two of\u0026hellip; add16, provided — A 16-bit adder module that is composed of 16 of\u0026hellip; add1 — A 1-bit full adder module. module top_module ( input [31:0] a, input [31:0] b, output [31:0] sum ); wire [15:0] sum1; wire [15:0] sum2; wire cout1; wire cout2; add16 (a[15:0], b[15:0], 1\u0026#39;b0, sum1, cout1); add16 (a[31:16], b[31:16], cout1, sum2, cout2); assign sum = {sum2, sum1}; endmodule module add1 ( input a, input b, input cin, output sum, output cout ); assign sum = a ^ b ^ cin; assign cout = (a\u0026amp;b)|(b\u0026amp;cin)|(cin\u0026amp;a); // assign {cout, sum} = a + b + cin; endmodule module_Carry Select Adder One drawback of the ripple carry adder is that the delay for an adder to compute the carry out (from the carry-in, in the worst case) is fairly slow, and the second-stage adder cannot begin computing its carry-out until the first-stage adder has finished. This makes the adder slow. One improvement is a carry-select adder, shown below. The first-stage adder is the same as before, but we duplicate the second-stage adder, one assuming carry-in=0 and one assuming carry-in=1, then using a fast 2-to-1 multiplexer to select which result happened to be correct.\nYou are provided with the same module add16 as the previous exercise, which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. You must instantiate three of these to build the carry-select adder, using your own 16-bit 2-to-1 multiplexer.\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nConnect the modules together as shown in the diagram below. The provided module add16 has the following declaration: module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire sel; wire [15:0] wire0, wire1; add16 (a[15: 0], b[15: 0], 1\u0026#39;b0, sum[15:0], sel); add16 (a[31:16], b[31:16], 1\u0026#39;b0, wire0, ); add16 (a[31:16], b[31:16], 1\u0026#39;b1, wire1, ); // selector always@(*) begin case(sel) 1\u0026#39;b0: sum[31:16] = wire0; 1\u0026#39;b1: sum[31:16] = wire1; endcase end // ternary operator // assign sum[31:16] = sel ? wire1 : wire0; endmodule module_Adder-Subtractor An adder-subtractor can be built from an adder by optionally negating one of the inputs, which is equivalent to inverting the input then adding 1. The net result is a circuit that can do two operations: (a + b + 0) and (a + ~b + 1). Build the adder-subtractor below. You are provided with a 16-bit adder module, which you need to instantiate twice:\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nUse a 32-bit wide XOR gate to invert the b input whenever sub is 1. (This can also be viewed as b[31:0] XORed with sub replicated 32 times. See replication operator.). Also connect the sub input to the carry-in of the adder. module top_module( input [31:0] a, input [31:0] b, input sub, output [31:0] sum ); wire cout; wire [31:0] bin; assign bin = {32{sub}} ^ b; add16 (a[15: 0], bin[15: 0], sub, sum[15: 0], cout); add16 (a[31:16], bin[31:16], cout, sum[31:16], ); endmodule 2.4 Procedures Alwaysblock For synthesizing hardware, two types of always blocks are relevant: Combinational: always @(*) Clocked: always @(posedge clk) Combinational always blocks are equivalent to assign statements, thus there is always a way to express a combinational circuit both ways. The choice between which to use is mainly an issue of which syntax is more convenient. The syntax for code inside a procedural block is different from code that is outside. Procedural blocks have a richer set of statements (e.g., if-then, case), cannot contain continuous assignments*, but also introduces many new non-intuitive ways of making errors. (*Procedural continuous assignments do exist, but are somewhat different from continuous assignments, and are not synthesizable.) For combinational always blocks, always use a sensitivity list of (*). Explicitly listing out the signals is error-prone (if you miss one), and is ignored for hardware synthesis. If you explicitly specify the sensitivity list and miss a signal, the synthesized hardware will still behave as though (*) was specified, but the simulation will not and not match the hardware\u0026rsquo;s behaviour. (In SystemVerilog, use always_comb.) A note on wire vs. reg: The left-hand-side of an assign statement must be a net type (e.g., wire), while the left-hand-side of a procedural assignment (in an always block) must be a variable type (e.g., reg). These types (wire vs. reg) have nothing to do with what hardware is synthesized, and is just syntax left over from Verilog\u0026rsquo;s use as a hardware simulation language. Build an AND gate using both an assign statement and a combinational always block. module top_module( input a, input b, output wire out_assign, output reg out_alwaysblock ); assign out_assign = a \u0026amp; b; always @(*) begin out_alwaysblock = a \u0026amp; b; end endmodule Clocked Clocked always blocks create a blob of combinational logic just like combinational always blocks, but also creates a set of flip-flops (or \u0026ldquo;registers\u0026rdquo;) at the output of the blob of combinational logic. Instead of the outputs of the blob of logic being visible immediately, the outputs are visible only immediately after the next (posedge clk). Blocking vs. Non-Backing Assignment\nThere are three types of assignments in Verilog:\nContinuous assignments (assign x = y;): Can only be used when not inside a procedure (\u0026ldquo;always block\u0026rdquo;). Procedural blocking assignment (x = y;): Can only be used inside a procedure. Procedural non-blocking assignment (x \u0026lt;= y;): Can only be used inside a procedure. In a combinational always block, use blocking assignments. In a clocked always block, used non-blocking assignments. A full understanding of why is not particularly usedful for hardware design and requires a good understanding of how Verilog simulators keep track of events. Not following this rule results in extremely hard to find errors that are both non-deterministic and differ between simulation and synthesized hardware.\nBuild an XOR gate three ways, using an assignment, a combinational always block, and a clocked always block. Note that the clocked always block precedures a different circuit from the other two: There is a flip-flop so the output is delayed. module top_module( input clk, input a, input b, output wire out_assign, output reg out_always_comb, output reg out_always_ff ); assign out_assign = a ^ b; always @(*) begin out_always_comb = a ^ b; end always @(posedge clk) begin out_always_ff \u0026lt;= a ^ b; end endmodule If statement An if statement usually creates a 2-to-1 multiplexer, selecting one input if the condition is true, and the other input if the condition is false. always @(*) begin if (condition) begin out = x; end else begin out = y; end end This is equivalent to using a continuous assignment with a conditional operator:\nassign out = (condition) ? x : y;\nHowever, the procedural if statement provides a new way to make mistakes. The circuit is combinational only if out is always assigned a value.\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement. \\(\\begin{array}{|c|c|c|}\\hline \\text{sel\\_b1}\u0026amp;\\text{sel\\_b2}\u0026amp;\\text{out\\_assign, out\\_always} \\\\\\hline 0\u0026amp;0\u0026amp;a\\\\\\hline 0\u0026amp;1\u0026amp;a\\\\\\hline 1\u0026amp;0\u0026amp;a\\\\\\hline 1\u0026amp;1\u0026amp;b\\\\\\hline \\end{array\nmodule top_module( input a, input b, input sel_b1, input sel_b2, output wire out_assign, output reg out_always ); assign out_assign = sel_b1 \u0026amp; sel_b2 ? b : a; always @(*) begin if (sel_b1 \u0026amp; sel_b2) begin out_always = b; end else begin out_always = a; end end // always @(*) begin // case ({sel_b1, sel_b2}) //\t2\u0026#39;d0:begin //\tout_always = a; // end // 2\u0026#39;d1:begin //\tout_always = a; // end // 2\u0026#39;d2:begin //\tout_always = a; // end // 2\u0026#39;d3:begin //\tout_always = b; // end // endcase // end endmodule If statement latches A common source of errors: How to avoid making latches\nWhen designing circuits, you must think first in terms of circuits:\nI want this logic gate I want a combinational blob of logic that has these inputs and produces these outputs I want a combinational blob of logic followed by a set of flip-flops What you must not do is write the code first, then hope it generates a proper circuit.\nIf (cpu_overheated) then shut_off_computer = 1; If (~arrived) then keep_driving = ~gas_tank_empty; Syntactically-correct code does not necessarily result in a reasonable circuit (combinational logic + flip-flops). The usual reason is: \u0026ldquo;What happens in the cases other than those you specified?\u0026rdquo;. Verilog\u0026rsquo;s answer is: Keep the outputs unchanged.\nThis behaviour of \u0026ldquo;keep outputs unchanged\u0026rdquo; means the current state needs to be remembered, and thus produces a latch. Combinational logic (e.g., logic gates) cannot remember any state. Watch out for Warning (10240): \u0026hellip; inferring latch(es)\u0026quot; messages. Unless the latch was intentional, it almost always indicates a bug. Combinational circuits must have a value assigned to all outputs under all conditions. This usually means you always need else clauses or a default value assigned to the outputs.\nDemonstration\nThe following code contains incorrect behaviour that creates a latch. Fix the bugs so that you will shut off the computer only if it\u0026rsquo;s really overheated, and stop driving if you\u0026rsquo;ve arrived at your destination or you need to refuel. always @(*) begin if (cpu_overheated) shut_off_computer = 1; end always @(*) begin if (~arrived) keep_driving = ~gas_tank_empty; end module top_module ( input cpu_overheated, output reg shut_off_computer, input arrived, input gas_tank_empty, output reg keep_driving ); // always @(*) begin if (cpu_overheated) shut_off_computer = 1; else shut_off_computer = 0; end always @(*) begin if (~arrived) keep_driving = ~gas_tank_empty; else keep_driving = 0; end endmodule Case statement Case statements in Verilog are nearly equivalent to a sequence of if-elseif-else that compares one expression to a list of others. Its syntax and functionality differs from the switch statement in C. always @(*) begin // This is a combinational circuit case (in) 1\u0026#39;b1: begin out = 1\u0026#39;b1; // begin-end if \u0026gt;1 statement end 1\u0026#39;b0: out = 1\u0026#39;b0; default: out = 1\u0026#39;bx; endcase end The case statement begins with case and each \u0026ldquo;case item\u0026rdquo; ends with a colon. There is no \u0026ldquo;switch\u0026rdquo;. Each case item can execute exactly one statement. This makes the \u0026ldquo;break\u0026rdquo; used in C unnecessary. But this means that if + you need more than one statement, you must use begin ... end.\nDuplicate (and partially overlapping) case items are permitted. The first one that matches is used. C does not allow duplicate case items.\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide. Be careful of inferring latches.\n// synthesis verilog_input_version verilog_2001 module top_module ( input [2:0] sel, input [3:0] data0, input [3:0] data1, input [3:0] data2, input [3:0] data3, input [3:0] data4, input [3:0] data5, output reg [3:0] out ); always @(*) begin case(sel) 0: out = data0; 1: out = data1; 2: out = data2; 3: out = data3; 4: out = data4; 5: out = data5; default: out = 0; endcase end endmodule Priority encoder A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3\u0026rsquo;d4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations. module top_module ( input [3:0] in, output reg [1:0] pos ); always @(*) begin case (in) 4\u0026#39;h0: pos = 2\u0026#39;h0; //0000 4\u0026#39;h1: pos = 2\u0026#39;h0; //0001 4\u0026#39;h2: pos = 2\u0026#39;h1; //0010 4\u0026#39;h3: pos = 2\u0026#39;h0; //0011 4\u0026#39;h4: pos = 2\u0026#39;h2; //0100 4\u0026#39;h5: pos = 2\u0026#39;h0; //0101 4\u0026#39;h6: pos = 2\u0026#39;h1; //0110 4\u0026#39;h7: pos = 2\u0026#39;h0; //0111 4\u0026#39;h8: pos = 2\u0026#39;h3; //1000 4\u0026#39;h9: pos = 2\u0026#39;h0; //1001 4\u0026#39;ha: pos = 2\u0026#39;h1; //1010 4\u0026#39;hb: pos = 2\u0026#39;h0; //1011 4\u0026#39;hc: pos = 2\u0026#39;h2; //1100 4\u0026#39;hd: pos = 2\u0026#39;h0; //1101 4\u0026#39;he: pos = 2\u0026#39;h1; //1110 4\u0026#39;hf: pos = 2\u0026#39;h0; //1111 default: pos = 2\u0026#39;b0; endcase end endmodule Priority encoder with casez Build previous problem with casez. If the case items in the case statement supported con\u0026rsquo;t care bits. This is what casez is for: It treats bits that have the value z as don\u0026rsquo;t care in the comparison. A case statement behaves as though each item is checked sequentially (in reality, a big combinational logic function). Notice how there are certain inputs (e.g., 4\u0026rsquo;b1111) that will match more than one case item. The first match is chosen (so 4\u0026rsquo;b1111 matches the first item, out = 0, but not any of the later ones). There is also a similar casex that treats both x and z as don\u0026rsquo;t-care. I don\u0026rsquo;t see much purpose to using it over casez. The digit ? is a synonym for z. so 2\u0026rsquo;bz0 is the same as 2\u0026rsquo;b?0 It may be less error-prone to explicitly specify the priority behaviour rather than rely on the ordering of the case items. For example, the following will still behave the same way if some of the case items were reordered, because any bit pattern can only match at most one case item: module top_module ( input [7:0] in, output reg [2:0] pos ); always @(*) begin casez(in) 8\u0026#39;bzzzzzzz1: pos = 3\u0026#39;d0; 8\u0026#39;bzzzzzz10: pos = 3\u0026#39;d1; 8\u0026#39;bzzzzz100: pos = 3\u0026#39;d2; 8\u0026#39;bzzzz1000: pos = 3\u0026#39;d3; 8\u0026#39;bzzz10000: pos = 3\u0026#39;d4; 8\u0026#39;bzz100000: pos = 3\u0026#39;d5; 8\u0026#39;bz1000000: pos = 3\u0026#39;d6; 8\u0026#39;b10000000: pos = 3\u0026#39;d7; default: pos = 2\u0026#39;d0; endcase end endmodule Avoiding latches Suppose you\u0026rsquo;re building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n\\(\\begin{array}{|c|c|}\\hline \\text{Scancode [15:0]}\u0026amp;\\text{Arrow key}\\\\\\hline \\text{16\u0026rsquo;he06b}\u0026amp;\\text{left arrow}\\\\\\hline \\text{16\u0026rsquo;he072}\u0026amp;\\text{down arrow}\\\\\\hline \\text{16\u0026rsquo;he074}\u0026amp;\\text{right arrow}\\\\\\hline \\text{16\u0026rsquo;he075}\u0026amp;\\text{up arrow}\\\\\\hline \\text{Anything else}\u0026amp;\\text{none}\\\\\\hline \\end{array Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output. To avoid creating latches, all outputs must be assigned a value in all possible conditions. Simply having a default case is not enough. You must assign a value to all four outputs in all four cases and the default case. This can involve a lot of unnecessary typing. One easy way around this is to assign a \u0026ldquo;default value\u0026rdquo; to the outputs before the case statement: always @(*) begin up = 1\u0026#39;b0; down = 1\u0026#39;b0; left = 1\u0026#39;b0; right = 1\u0026#39;b0; case (scancode) ... // Set to 1 as necessary. endcase end This style of code ensures the outputs are assigned a value (of 0) in all possible cases unless the case statement overrides the assignment. This also means that a default: case item becomes unnecessary. Reminder: The logic synthesizer generates a combinational circuit that behaves equivalently to what the code describes.Hardware does not \u0026ldquo;execute\u0026rdquo; the lines of code in sequence. module top_module ( input [15:0] scancode, output reg left, output reg down, output reg right, output reg up ); always @(*) begin left = 0; down = 0; right = 0; up = 0; case(scancode) 16\u0026#39;he06b: left = 1; 16\u0026#39;he072: down = 1; 16\u0026#39;he074: right = 1; 16\u0026#39;he075: up = 1; endcase end endmodule 2.5 More Verilog Features Conditional ternary operator Verilog has a ternary conditional operator ( ? : ) much like C: (condition ? if_true : if_false) Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a \u0026lt; b). Use the conditional operator to make two-way min circuits, then compose a few of them to create a 4-way min circuit. You\u0026rsquo;ll probably want some wire vectors for the intermediate results. module top_module ( input [7:0] a, b, c, d, output [7:0] min);// wire [7:0] wire1; wire [7:0] wire2; assign wire1 = a \u0026gt; b ? b : a; assign wire2 = c \u0026gt; d ? d : c; assign min = wire1 \u0026gt; wire2 ? wire2 : wire1; endmodule Reduction operators Some syntactic sugar for reduction: \u0026amp; a[3:0] // AND: a[3] \u0026amp; a[2] \u0026amp; a[1] \u0026amp; a[0]. Equivalent to (a[3:0] == 4\u0026#39;hf) | b[3:0] // OR: b[3] | b[2] | b[1] | b[0]. Equivalent to (b[3:0] != 4\u0026#39;h0) ^ c[2:0] // XOR: c[2] ^ c[1] ^ c[0] Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \u0026ldquo;even\u0026rdquo; parity, where the parity bit is just the XOR of all 8 data bits. module top_module ( input [7:0] in, output parity); assign parity = ^ in; endmodule Reduction: Even wider gates Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: out_and: output of a 100-input AND gate. out_or: output of a 100-input OR gate. out_xor: output of a 100-input XOR gate. module top_module( input [99:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026amp; in; assign out_or = | in; assign out_xor = ^ in; endmodule Combinational for-loop: Vector reversal Given a 100-bit input vector [99:0], reverse its bit ordering. module top_module( input [99:0] in, output [99:0] out ); always @(*) begin for (int i = 0; i \u0026lt; 100; i++) begin out[i] = in[99 - i]; end end endmodule Combinational for-loop: 255-bit population count A \u0026ldquo;population count\u0026rdquo; circuit counts the number of \u0026lsquo;1\u0026rsquo;s in an input vector. Build a population count circuit for a 255-bit input vector. module top_module( input [254:0] in, output [7:0] out ); always @(*) begin out = 0; for (int i = 0; i \u0026lt; 255; i++) begin out += in[i]; end end endmodule Generate for-loop: 100-bit binary adder Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see. module top_module( input [99:0] a, b, input cin, output [99:0] cout, output [99:0] sum ); always @(*) begin {cout[0], sum[0]} = a[0] + b[0] + cin; for (int i = 1; i \u0026lt; 100; i++) begin {cout[i], sum[i]} = a[i] + b[i] + cout[i-1]; end end endmodule Generate for-loop: 100-digit BCD adder You are provided with a BCD one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out. module bcd_fadd ( input [3:0] a, input [3:0] b, input cin, output cout, output [3:0] sum ); Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) and a carry-in to produce a 100-digit sum and carry out. module top_module( input [399:0] a, b, input cin, output cout, output [399:0] sum ); wire[99:0] carryin; generate genvar i; bcd_fadd(a[3:0], b[3:0], cin, carryin[0], sum[3:0]); for (i = 4; i \u0026lt; 400; i += 4) begin:adder bcd_fadd(a[i+3:i], b[i+3:i], carryin[i/4-1], carryin[i/4], sum[i+3:i]); end assign cout = carryin[99]; endgenerate endmodule ","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits2/","summary":"1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n2 Verilog Language 2.1 Basics wire Create a module with one input and ont output that behaves like a wire module top_module( input in, output out); assign out = in; endmodule multi-in-out Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: module top_module( input a,b,c, output w,x,y,z ); assign w = a; assign x = b; assign y = b; assign z = c; endmodule not gate Create a module that implements a NOT gate.","title":"[VHDL] HDLbits 2 - Verilog Language"},{"content":"1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n3 Circuits 3.1 Combinational Logic 3.1.1 Basic Gates Wire module top_module ( input in, output out); assign out = in; endmodule GND module top_module ( output out); assign out = 1\u0026#39;b0; endmodule NOR module top_module ( input in1, input in2, output out); assign out = ~(in1|in2); endmodule Another Gate module top_module ( input in1, input in2, output out); assign out = in1 \u0026amp; (~in2); endmodule Two gates module top_module ( input in1, input in2, input in3, output out); wire w1; assign w1 = ~(in1^in2); assign out = w1^in3; endmodule More logic gates module top_module( input a, b, output out_and, output out_or, output out_xor, output out_nand, output out_nor, output out_xnor, output out_anotb ); assign out_and = a \u0026amp; b; assign out_or = a | b; assign out_xor = a ^ b; assign out_nand = ~(a \u0026amp; b); assign out_nor = ~(a | b); assign out_xnor = ~(a ^ b); assign out_anotb = a \u0026amp; (~b); // and(out_and, a, b); // or(out_or, a, b); // xor(out_xor, a, b); // nand(out_nand, a, b); // nor(out_nor, a, b); // xnor(out_xnor, a, b); // and(out_anotb, a , ~b); endmodule 7420 chip module top_module ( input p1a, p1b, p1c, p1d, output p1y, input p2a, p2b, p2c, p2d, output p2y ); assign p1y = ~(p1a \u0026amp; p1b \u0026amp; p1c \u0026amp; p1d); assign p2y = ~(p2a \u0026amp; p2b \u0026amp; p2c \u0026amp; p2d); endmodule\\ Truth tables \\(\\begin{array}{|c|ccc|c|}\\hline \\text{Row}\u0026amp;\u0026amp;\\text{Inputs}\u0026amp;\u0026amp;\\text{Outputs}\\\\\\hline \\text{number}\u0026amp;\\text{x3}\u0026amp;\\text{x2}\u0026amp;\\text{x1}\u0026amp;\\text{f}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\\\hline 2\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 3\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline 4\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 5\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 6\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\hline 7\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array module top_module( input x3, input x2, input x1, output f ); assign f = ((~x3)\u0026amp;x2)|(x3\u0026amp;x1); endmodule Two-bit equality Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0. module top_module ( input [1:0] A, input [1:0] B, output z ); assign z = (A == B); endmodule Simple circuit A module top_module (input x, input y, output z); assign z = (x^y) \u0026amp;x; endmodule Simple circuit B module top_module ( input x, input y, output z ); assign z = (x==y); // assign z = ~(x ^ y); endmodule Combine circuits A and B module top_module (input x, input y, output z); wire o1, o2, o3, o4; A ia1(x,y,o1); B ib1(x,y,o2); A ia2(x,y,o3); B ib2(x,y,o4); assign z = (o1|o2)^(o3\u0026amp;o4); endmodule module A( input x, y, output z); assign z = (x ^ y) \u0026amp; x; endmodule module B( input x, y, output z); assign z = x ~^ y; endmodule Ringer Suppose you are designing a circuit to control a cellphone\u0026rsquo;s ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates. Design hint: When designing circuits, one often has to think of the problem \u0026ldquo;backwards\u0026rdquo;, starting from the outputs then working backwards towards the inputs. This is often the opposite of how one would think about a (sequential, imperative) programming problem, where one would look at the inputs first then decide on an action (or output). For sequential programs, one would often think \u0026ldquo;If (inputs are ___ ) then (output should be ___ )\u0026rdquo;. On the other hand, hardware designers often think \u0026ldquo;The (output should be ___ ) when (inputs are ___ )\u0026rdquo;. The above problem description is written in an imperative form suitable for software programming (if ring then do this), so you must convert it to a more declarative form suitable for hardware implementation (assign ringer = ___). Being able to think in, and translate between, both styles is one of the most important skills needed for hardware design. module top_module ( input ring, input vibrate_mode, output ringer, // Make sound output motor // Vibrate ); assign ringer = ring \u0026amp; (~vibrate_mode); assign motor = ring \u0026amp; (vibrate_mode); endmodule Thermostat A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates. 畫出真值表\n\\(\\begin{array}{|cccc|ccc|}\\hline \\text{mode}\u0026amp;\\text{too\\_cold}\u0026amp;\\text{too\\_hot}\u0026amp;\\text{fan on}\u0026amp;\\text{heater}\u0026amp;\\text{aircon}\u0026amp;\\text{fan}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline \\end{array}\\) module top_module ( input too_cold, input too_hot, input mode, input fan_on, output heater, output aircon, output fan); assign heater = mode \u0026amp; too_cold; assign aircon = (~mode) \u0026amp; too_hot; assign fan = heater|aircon|fan_on; endmodule 3-bit population count A \u0026ldquo;population count\u0026rdquo; circuit counts the number of \u0026lsquo;1\u0026rsquo;s in an input vector. Build a population count circuit for a 3-bit input vector. module top_module( input [2:0] in, output [1:0] out ); always @(*) begin out = 0; for (int i = 0; i \u0026lt;= 2; i++) begin out += in[i]; end end endmodule 此解會產生鎖存器，不建議使用。 Gates and vectors You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are \u0026lsquo;1\u0026rsquo;. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don\u0026rsquo;t need to know out_both[3]. out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are \u0026lsquo;1\u0026rsquo;. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don\u0026rsquo;t need to know out_any[0]. out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]\u0026rsquo;s neighbour to the left is in[0]. module top_module( input [3:0] in, output [2:0] out_both, output [3:1] out_any, output [3:0] out_different ); assign out_both[2:0] = in[2:0] \u0026amp; in[3:1]; assign out_any[3:1] = in[3:1] | in[2:0]; assign out_different[3:0] = in[3:0] ^ {in[0], in[3:1]}; // always @(*) begin // out_different[3] = (in[3] != in[0]); // for (int i = 0; i \u0026lt;= 2; i++) begin // out_both[i] = in[i] \u0026amp; in[i+1]; // out_any[i+1] = in[i+1] | in[i]; // out_different[i] = (in[i] != in[i+1]); // end // end endmodule Even longer vectors You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are \u0026lsquo;1\u0026rsquo;. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don\u0026rsquo;t need to know out_both[99]. out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are \u0026lsquo;1\u0026rsquo;. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don\u0026rsquo;t need to know out_any[0]. out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]\u0026rsquo;s neighbour to the left is in[0]. module top_module( input [99:0] in, output [98:0] out_both, output [99:1] out_any, output [99:0] out_different ); assign out_both[98:0] = in[98:0] \u0026amp; in[99:1]; assign out_any[99:1] = in[99:1] | in[98:0]; assign out_different[99:0] = in[99:0] ^ {in[0], in[99:1]}; endmodule 3.1.2 Multiplexers 2-to-1 multiplexer Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b. module top_module( input a, b, sel, output out ); assign out = sel ? b : a; endmodule 2-to-1 bus multiplexer Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b. module top_module( input [99:0] a, b, input sel, output [99:0] out ); assign out = sel ? b : a; endmodule 9-to-1 multiplexer Create a 16-bit 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to \u0026lsquo;1\u0026rsquo;. module top_module( input [15:0] a, b, c, d, e, f, g, h, i, input [3:0] sel, output [15:0] out ); always @(*) begin case(sel) 4\u0026#39;d0: out = a; 4\u0026#39;d1: out = b; 4\u0026#39;d2: out = c; 4\u0026#39;d3: out = d; 4\u0026#39;d4: out = e; 4\u0026#39;d5: out = f; 4\u0026#39;d6: out = g; 4\u0026#39;d7: out = h; 4\u0026#39;d8: out = i; default: out = \u0026#39;1; // special literal syntax with all bits set to 1 endcase end endmodule 256-to-1 multiplexer Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should be select in[0], sel1 selectes bits in[1], sel=2 selects bits in[2], etc. module top_module( input [255:0] in, input [7:0] sel, output out ); assign out = in[sel]; endmodule 256-to-1 4-bit multiplexer Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0],sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc. module top_module( input [1023:0] in, input [7:0] sel, output [3:0] out ); assign out = in[sel*4+:4]; // special syntax // assign out = in[sel*4+3-:4]; // assign out = {in[sel*4+3],in[sel*4+2],in[sel*4+1],in[sel*4+0]}; endmodule 3.1.3 Arithmetic Circuits Half adder Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out. module top_module( input a, b, output cout, sum ); assign {cout, sum} = a + b; endmodule Full adder Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and a carry-out. module top_module( input a, b, cin, output cout, sum ); assign {cout, sum} = a + b + cin; endmodule 3-bit binary adder Now that you know how to build a full adder, make 3 instances of it to create a 3-bit binary ripple-carry adder. The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last full adder, and is the carry-out you usually see. module top_module( input [2:0] a, b, input cin, output [2:0] cout, output [2:0] sum ); fulladder f1(a[0], b[0], cin, cout[0], sum[0]); fulladder f2(a[1], b[1], cout[0], cout[1], sum[1]); fulladder f3(a[2], b[2], cout[1], cout[2], sum[2]); endmodule module fulladder( input a, b, cin, output cout, sum); assign {cout, sum} = a + b + cin; endmodule Adder Implement the following circuit: module top_module ( input [3:0] x, input [3:0] y, output [4:0] sum); // assign sum = x + y; wire [2:0] cout; FA f1(x[0], y[0], 0, cout[0], sum[0]); FA f2(x[1], y[1], cout[0], cout[1], sum[1]); FA f3(x[2], y[2], cout[1], cout[2], sum[2]); FA f4(x[3], y[3], cout[2], sum[4], sum[3]); endmodule module FA ( input a, b, cin, output cout, sum); assign {cout, sum} = a + b + cin; endmodule Signed addition overflow Assume that you have two 8-bit 2\u0026rsquo;s complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred. module top_module ( input [7:0] a, input [7:0] b, output [7:0] s, output overflow ); assign s = a + b; assign overflow = (a[7] == b[7] \u0026amp;\u0026amp; a[7] != s[7]) ? 1 : 0; endmodule 100-bit binary adder Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. module top_module( input [99:0] a, b, input cin, output cout, output [99:0] sum); assign {cout, sum} = cin + a + b; endmodule 4-digit BCD adder You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out. module bcd_fadd ( input [3:0] a, input [3:0] b, input cin, output cout, output [3:0] sum ); Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.\nmodule top_module ( input [15:0] a, b, input cin, output cout, output [15:0] sum ); wire [2:0] wl; bcd_fadd u0 (a[ 3: 0], b[ 3: 0], cin, wl[0], sum[ 3: 0]); bcd_fadd u1 (a[ 7: 4], b[ 7: 4], wl[0], wl[1], sum[ 7: 4]); bcd_fadd u2 (a[11: 8], b[11: 8], wl[1], wl[2], sum[11: 8]); bcd_fadd u3 (a[15:12], b[15:12], wl[2], cout, sum[15:12]); endmodule 3.1.4 Karnaugh Map to Circuit Kmap1 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, output out ); assign out = a | b | c; endmodule Kmap2 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); // a\u0026#39;d\u0026#39; + b\u0026#39;c\u0026#39; + acd + a\u0026#39;bc wire w1, w2, w3, w4; assign w1 = (~a)\u0026amp;(~d); assign w2 = (~b)\u0026amp;(~c); assign w3 = a\u0026amp;c\u0026amp;d; assign w4 = (~a)\u0026amp;b\u0026amp;c; assign out = w1|w2|w3|w4; endmodule Kmap3 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); // a + b\u0026#39;c assign out = a | (~b\u0026amp;c); endmodule Kmap4 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); always @(*) begin if (a == b \u0026amp;\u0026amp; c != d) out = 1; else if (a != b \u0026amp;\u0026amp; c == d) out = 1; else out = 0; end endmodule Minimum SOP and POS A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form. module top_module ( input a, input b, input c, input d, output out_sop, output out_pos ); // f = d3 + m7 + d11 + m15 + m2 // f = cd + a\u0026#39;b\u0026#39;c assign out_sop = (c \u0026amp; d) | (~a \u0026amp; ~b \u0026amp; c); // f\u0026#39; = m0 + m1 + m4 + m5 + m6 + d8 + m9 + m10 + d11 + d12 + m13 + m14 // f\u0026#39; = c\u0026#39; + ab\u0026#39; + bd\u0026#39; // f = (c)(a\u0026#39;+b)(b\u0026#39;+d) assign out_pos = c \u0026amp; (~a | b) \u0026amp; (~b | d); endmodule Karnaugh map Consider the function f shown in the Karnaugh map below. Implement this function. d is don\u0026rsquo;t-care, which means you may choose to output whatever value is convenient. module top_module ( input [4:1] x, output f ); // x[2]x[4] + x[1]\u0026#39;x[3] assign f = (x[2] \u0026amp; x[4]) | (~x[1] \u0026amp; x[3]); endmodule Karnaugh map Consider the function f shown in the Karnaugh map below. Implement this function. (The original exam question asked for simplified SOP and POS forms of the function.) module top_module ( input [4:1] x, output f ); // x[2]\u0026#39;x[4]\u0026#39; + x[1]\u0026#39;x[3] + x[2]x[3]x[4] assign f = (~x[2] \u0026amp; ~x[4]) | (~x[1] \u0026amp; x[3]) | (x[2] \u0026amp; x[3] \u0026amp; x[4]); endmodule K-map implemented with a multiplexer For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below. You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map. (The requirement to use only 2-to-1 multiplexers exists because the original exam question also wanted to test logic function simplification using K-maps and how to synthesize logic functions using only multiplexers. If you wish to treat this as purely a Verilog exercise, you may ignore this constraint and write the module any way you wish.) module top_module ( input c, input d, output [3:0] mux_in ); assign mux_in[0] = c|d; // 0111 assign mux_in[1] = 1\u0026#39;b0; // 0000 assign mux_in[2] = ~d; // 1001 assign mux_in[3] = c\u0026amp;d; // 0010 endmodule 3.2 Sequential Logic 3.2.1 Latches and Flip-Flops D flip-flop A D flip-flop is a circuit that stores a bit and is updated periodically, at the (usually) positive edge of a clock signal. D flip-flops are created by the logic synthesizer when a clocked always block is used (See alwaysblock2). A D + flip-flop is the simplest form of \u0026ldquo;blob of combinational logic followed by a flip-flop\u0026rdquo; where the combinational logic portion is just a wire. Create a single D flip-flop. module top_module ( input clk, // Clocks are used in sequential circuits input d, output reg q ); always @(posedge clk) begin q \u0026lt;= d; end endmodule D flip-flops Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input [7:0] d, output [7:0] q ); always @(posedge clk) begin q \u0026lt;= d; end endmodule DFF with reset Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input reset, // Synchronous reset input [7:0] d, output [7:0] q ); always @(posedge clk) begin if (reset) begin q \u0026lt;= 8\u0026#39;b0; end else begin q \u0026lt;= d; end end endmodule DFF with reset value Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk. module top_module ( input clk, input reset, input [7:0] d, output [7:0] q ); always @(negedge clk) begin if (reset) begin q \u0026lt;= 8\u0026#39;h34; end else begin q \u0026lt;= d; end end endmodule DFF with asynchronous reset Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input areset, // active high asynchronous reset input [7:0] d, output [7:0] q ); always @(posedge clk or posedge areset) if (areset) q \u0026lt;= 0; else q \u0026lt;= d; endmodule In Verilog, the sensity list looks strange. The FF\u0026rsquo;s reset is sensitive to the level of areset, so why does using \u0026ldquo;posedge areset\u0026rdquo; work? To see why it works, consider the truth table for all events that change the input signals, assuming clk and areset do not swith at precisely the same time.\n\\(\\begin{array}{|c|c|c|l|}\\hline \\text{clk}\u0026amp;\\text{areset}\u0026amp;\\text{output}\u0026amp;\\text{comment}\\\\\\hline \\text{x}\u0026amp;\\text{0}\\rightarrow\\text{1}\u0026amp;\\text{q}\\leftarrow{0;}\u0026amp;\\text{because areset = 1}\\\\\\hline \\text{x}\u0026amp;\\text{1}\\rightarrow\\text{0}\u0026amp;\\text{no change}\u0026amp;\\text{always block not triggered}\\\\\\hline \\text{0}\\rightarrow\\text{1}\u0026amp;\\text{0}\u0026amp;\\text{q}\\leftarrow{d;}\u0026amp;\\text{not resetting}\\\\\\hline \\text{0}\\rightarrow\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{q}\\leftarrow{0;}\u0026amp;\\text{still resetting, q was 0 before too}\\\\\\hline \\text{1}\\rightarrow\\text{0}\u0026amp;\\text{x}\u0026amp;\\text{no change}\u0026amp;\\text{always block not triggered}\\\\\\hline \\end{array}\\) DFF with byte enable Create 16 D flip-flops. It\u0026rsquo;s sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input resetn, input [1:0] byteena, input [15:0] d, output [15:0] q ); always @(posedge clk) begin if (resetn == 1\u0026#39;b0) begin q \u0026lt;= 16\u0026#39;d0; end else begin case(byteena) 0: q \u0026lt;= q; 1: q \u0026lt;= {q[15:8], d[7:0]}; 2: q \u0026lt;= {d[15:8], q[7:0]}; 3: q \u0026lt;= d; endcase end end endmodule D Latch Implement the following circuit: Note that this is a latch, so a Quartus warning about hvaing inferred a latch is expected. 對於組合邏輯，if 若沒有補全 else，case 條件不完全，可能會產生 latch。但是如果中間的信號有初值，就不會產生 latch。所以要盡量避免 latch 的產生，避免對時序的危害很大。 module top_module ( input d, input ena, output q); always @(*) begin if (ena == 1\u0026#39;b1) q = d; end endmodule DFFAR Implement the following circuit: module top_module ( input clk, input d, input ar, // asynchronous reset output q); always@(posedge clk or posedge ar) begin if (ar == 1) q \u0026lt;= 0; else q \u0026lt;= d; end endmodule DFFR Implement the following circuit: module top_module ( input clk, input d, input r, // synchronous reset output q); always@(posedge clk) begin if (r == 1) begin q \u0026lt;= 0; end else begin q \u0026lt;= d; end end endmodule DFF+gate Implement the following circuit: module top_module ( input clk, input in, output reg out); always@(posedge clk) begin out \u0026lt;= out ^ in; end endmodule 注意 output 需為 reg 型別。 Mux and DFF Consider the sequential circuit below: Assume that you want to implement hierarchical Verilog code for this circuit, using three instantiations of a submodule that has a flip-flop and multiplexer in it. Write a Verilog module (containing one flip-flop and multiplexer) named top_module for this submodule. module top_module ( input clk, input L, input r_in, input q_in, output reg Q); always@(posedge clk) begin if (L) Q \u0026lt;= r_in; else Q \u0026lt;= q_in; end endmodule Mux and DFF DFF+gate Mux and DFF Mux and DFF DFFs and gates Create circuit from truth table Detect an edge Detect both edges Edge capture register Dual-edge triggered flip-flop 3.2.2 Counters 3.2.3 Shift Registers 3.2.4 More Circuits 3.2.5 Finite State Machines 3.3 Building Larger Circuits ","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits3/","summary":"1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n3 Circuits 3.1 Combinational Logic 3.1.1 Basic Gates Wire module top_module ( input in, output out); assign out = in; endmodule GND module top_module ( output out); assign out = 1\u0026#39;b0; endmodule NOR module top_module ( input in1, input in2, output out); assign out = ~(in1|in2); endmodule Another Gate module top_module ( input in1, input in2, output out); assign out = in1 \u0026amp; (~in2); endmodule Two gates module top_module ( input in1, input in2, input in3, output out); wire w1; assign w1 = ~(in1^in2); assign out = w1^in3; endmodule More logic gates module top_module( input a, b, output out_and, output out_or, output out_xor, output out_nand, output out_nor, output out_xnor, output out_anotb ); assign out_and = a \u0026amp; b; assign out_or = a | b; assign out_xor = a ^ b; assign out_nand = ~(a \u0026amp; b); assign out_nor = ~(a | b); assign out_xnor = ~(a ^ b); assign out_anotb = a \u0026amp; (~b); // and(out_and, a, b); // or(out_or, a, b); // xor(out_xor, a, b); // nand(out_nand, a, b); // nor(out_nor, a, b); // xnor(out_xnor, a, b); // and(out_anotb, a , ~b); endmodule 7420 chip module top_module ( input p1a, p1b, p1c, p1d, output p1y, input p2a, p2b, p2c, p2d, output p2y ); assign p1y = ~(p1a \u0026amp; p1b \u0026amp; p1c \u0026amp; p1d); assign p2y = ~(p2a \u0026amp; p2b \u0026amp; p2c \u0026amp; p2d); endmodule\\ Truth tables \\(\\begin{array}{|c|ccc|c|}\\hline \\text{Row}\u0026amp;\u0026amp;\\text{Inputs}\u0026amp;\u0026amp;\\text{Outputs}\\\\\\hline \\text{number}\u0026amp;\\text{x3}\u0026amp;\\text{x2}\u0026amp;\\text{x1}\u0026amp;\\text{f}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\\\hline 2\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 3\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline 4\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 5\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 6\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\hline 7\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array module top_module( input x3, input x2, input x1, output f ); assign f = ((~x3)\u0026amp;x2)|(x3\u0026amp;x1); endmodule Two-bit equality Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z.","title":"[VHDL] HDLbits 3 - Circuits"},{"content":"4 Verification - Reading Simulations 4.1 Finding bugs in code 4.2 Build a circuit from a simulation waveform 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits4/","summary":"4 Verification - Reading Simulations 4.1 Finding bugs in code 4.2 Build a circuit from a simulation waveform 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450","title":"[VHDL] HDLbits 4 - Verification: Reading Simulations"},{"content":"5 Verification - Writing Testbenches 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits5/","summary":"5 Verification - Writing Testbenches 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450","title":"[VHDL] HDLbits 5 - Verification: Writing Testbenches"},{"content":"6 CS450 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits6/","summary":"6 CS450 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450","title":"[VHDL] HDLbits 6 - CS450"},{"content":"TCAD 模擬收斂問題 收斂問題 Sentaurus Device 有非常多種可模擬大電場下之飽和遷移率的模型，而這主要是設定有效電場的模型。其中，最自然的選擇就是 Eparallel driving model。這種模型取總電場平行於電流方向上的分量。不過這通常會導致嚴重的收斂問題。主要是因為電場跟電流有著極為密切的關係，除此之外，以 MOSFET 通道為例，通常垂直與平行通道方向之電場數量級差很多，因為演算之數值誤差會「混合」這兩個分量，所以這種 Eparallel 模型會使得每個節點上的 driving force變化許多，進而改變電流方向，又接著改變電場分量，所以會造成極為不穩定的情況。\n其中一個折衷的辦法，就是只考慮平行於 silicon-oxide 界面上的電場，可以使用 HighFieldSaturation(EparallelToInterface) 指令來啟動這模型。只要大部分的電流都平行於界面，那基本上這就是個很好的模型。然而，目前最新科技通常會使得 source/drain 的電流以「向外散開，向內吸入」的方式進入與離開。例如說目前的 ultrashalow source and drain extensions。電流散開之後，電流就不再平行於界面，而這模型可能會帶來將近 5-15 % 的誤差。因此，如果你知道電流的方向，那麼你也可以設定用來計算平行電場分量之方向向量，而不再只是單純地與最鄰近的界面平行的方向。例如說，如果你覺得電流主要是沿著 x 軸在流動，那麼可以在 Math section 設定 EparallelToInterface (Direction = (1 0 0))。\n最常用的 driving force 是 quasi-Fermi potential 的梯度模型。通常這跟平行電場模型是一樣的，但它的演算法比較穩定。可以用 HighFieldSaturation(GradQuasiFermi) 選項來啟動它。不過，即便如此，還是可能會造成收斂問題。這是因為通常 quasi-Fermi potential 的梯度都非常的陡峭，變化得太過劇烈或是非常的不平滑，而這往往切得比較不好的網格所造成的。\n但在有些時候，即便網格切得很好，還是沒辦法收斂。有時是因為低載子濃度的區域的濃度相對誤差都滿高的，而這會進一步導致 quasi-Fermi potential 的誤差變得滿大的。因為這些區域通常對總電流的貢獻並不是很顯著，所以算得太準反而會讓模擬跑得更慢。不過，你確實需要確認一下這些低密度是不是導致發散。\n除此之外，也可藉由設定 RefDens_eGradQuasiFermi_EparallelToInterface 與 RefDens_hGradQuasiFermi_EparallelToInterface 來使用「內插 GradQuasiFermi 與 Eparallel」的 driving force 模型。該參數定義了 gradual transition 發生的局域載子濃度。例如說，如果設定為 1e12，那麼當載子濃度高於 1e12，就使用 GradQuasiFermi model，反之則使用 Eparallel model。通常 1e12 並不會影響到總電流，但仍能改善收斂問題。有時甚至需要用到 1e14 ～ 1e16 以獲得更好的收斂，但要留意不同設定所得到的電流是否一致，以確定 Eparallel driving force 帶來的誤差仍可接受。\n另一種內插法是 QausiGradFermi 與 電場本身，可使用 RefDens_eGradQuasiFermi_ElectricField 與 RefDens_eGradQuasiFermi_ElectricField 參數來設定。\n還有一種方法改善收斂，就是在低濃度的地方逐漸忽略 driving force。可以藉由 RefDens_eGradQuasiFermi_Zero (for electrons) and RefDens_hGradQuasiFermi_Zero (for holes) 設定，將它們設定為正值即可。例如說，如果設定為 1e10，那麼在 1e10 濃度以下的地方就不會用到 driving force。\n還有一個在物理上可行的做法，就是使用 hydrodynamic transport model。這時 sdevice 會計算局域載子溫度，接著並用來計算 driving force。可以藉由 HighFieldSaturation(CarrierTempDrive) 來開啟它。有時會因為有比較好的收斂而改善通常 HT model 算太慢的現象。總之，如果你在使用 GradQuasiFermi 時遇到了收斂問題。那麼你可以：\n確保通道的網格足夠細緻與均勻 考慮改成 EparallelToInterface 如果 terminal currents 誤差實在很大，那麼可考慮將 RefDens_e/hGradQuasiFermi_ElectricField 設定為 1e12 或者更高。 設定 RefDens_e/hGradQuasiFermi_Zero 到 1e10 或者更高以忽略在低於該濃度時的 driving force 計算 最後可以考慮改用 hydrodynamic transport model。 常見模擬參數之意義 HighFieldSaturation(GradQuasiFermi) RefDens_hGradQuasiFermi_Zero：低於其值則忽略 damp 有效電場 RefDens_eGradQuasiFermi_EparallelToInterface：高於其值則使用 GradQuasiFermi，低於則 EparallelToInterface。 RefDens_eGradQuasiFermi_ElectricField：高於其值則使用 GradQuasiFermi，低於則 Eparallel External resistor method 這方法很有用，但是非常慢。\n簡單來說，只是在元件上串聯一個電阻。\n但因為我們設定 \\(R=V_b/I_b\\)，所以在 InnerVoltage 到達 \\(V_b\\) 時，OuterVoltage 會是兩倍的崩潰電壓。而在那之前，因為電流實在是很小，所以外接電阻分配到的分壓並沒有追到元件分壓，使得大部分分壓都會正常地落在元件上。設定方法為，先在其中一個電極設定電阻，如下所示。\nElectrode { { Name= \u0026#34;substrate\u0026#34; Voltage= 0.0 } #if \u0026#34;@BVmethod@\u0026#34; == \u0026#34;resistor\u0026#34; { Name= \u0026#34;anode\u0026#34; Voltage= 0.0 Resistor= @R@} #else { Name= \u0026#34;anode\u0026#34; Voltage= 0.0 } #endif } 設定好之後其實就大功告成了。不過此時因為你只能夠控制某電極的電位，而在其中一個電極電位被設定為 Voltage=0.0 的情況下，這相當於設定兩電極（anode與substrate）之間的電壓，即「元件與電阻」的總跨壓。因此，倘若元件開始崩潰，電流開始爆增，那麼「元件與電阻」的總跨壓將會變得非常大。因此如果將後續的模擬目標電壓設定為-50V 或甚至是 -100V，那因為元件分到的跨壓一定比較小，所以很可能沒達到目標。因此這時需要將最後的目標電壓設定得高一點，通常我都設定-500到-1000。有時為了更加準確而會設定為-2000。\nTrap 設定(sdevice) Another available species is the fixed charge, which is a trap fully occupied by either electrons or holes. Therefore, its charge stays constant throughout the entire simulation and does not depend on electrical bias conditions. Electron–hole recombination through such a trap is not allowed. This type of trap uses the FixedCharge keyword for a trap specification.\nRecombination \u0026amp; Generation rate 基本上它們都遵守 SRH recombination rate:\n$$ R_{SRH}=\\frac{np-n_i^2}{\\tau_{p0}(n+n_1)+\\tau_{n_0}(p+p_1)} $$ 但是沒辦法在 sdevice 用 SRHRecombination( Integrate( Semiconductor ) ) 觀察到這些特地、額外設定的 trap 造成的 SHR recombination rate，反而必須使用：\nCurrentPlot { eGapStatesRecombination( Integrate( Semiconductor ) ) eGapStatesRecombination( Integrate( Region=\u0026#34;Absorption\u0026#34; ) ) eGapStatesRecombination( Integrate( Region=\u0026#34;Multiplication\u0026#34; ) ) hGapStatesRecombination( Integrate( Semiconductor ) ) hGapStatesRecombination( Integrate( Region=\u0026#34;Absorption\u0026#34; ) ) hGapStatesRecombination( Integrate( Region=\u0026#34;Multiplication\u0026#34; ) ) } 才能夠看見這些 trap 的貢獻。\nTrap-assisted tunneling 這些 Trap 預設並沒有 trap-assisted tunneling 效果。換言之，即便之前設定了 Physics{Recombination(SRH(ElectricField(Lifetime=Hurkx)))}，也不會讓 trap 有此效應。這需要額外設定：\nPhysics(Region=\u0026#34;Absorption\u0026#34;){ Traps(eNeutral Level fromMidBandGap EnergyMid=@Eti@ Conc=1e15 eXsection=@eXsec@ hXsection=@hXsec@ SpatialShape=Gaussian SpaceMid=(@PosX@, 1.5) SpaceSig=(@Lx@, 1e3) Tunneling(Hurkx) ) } 上面的Tunneling(Hurkx)就是 trap-assisted tunneling 效應。\nLifetime 雖然 lifetime 滿足底下公式：\n$$ \\tau_{n,p}=\\frac{1}{\\sigma_{n,p}v_{n,p}N_t} $$\n但是沒辦法直接使用eLifetime與hLifetime觀察，需要手動將上述數據相乘。\n","permalink":"http://intervalrain.github.io/posts/device/simulationconvergece/","summary":"TCAD 模擬收斂問題 收斂問題 Sentaurus Device 有非常多種可模擬大電場下之飽和遷移率的模型，而這主要是設定有效電場的模型。其中，最自然的選擇就是 Eparallel driving model。這種模型取總電場平行於電流方向上的分量。不過這通常會導致嚴重的收斂問題。主要是因為電場跟電流有著極為密切的關係，除此之外，以 MOSFET 通道為例，通常垂直與平行通道方向之電場數量級差很多，因為演算之數值誤差會「混合」這兩個分量，所以這種 Eparallel 模型會使得每個節點上的 driving force變化許多，進而改變電流方向，又接著改變電場分量，所以會造成極為不穩定的情況。\n其中一個折衷的辦法，就是只考慮平行於 silicon-oxide 界面上的電場，可以使用 HighFieldSaturation(EparallelToInterface) 指令來啟動這模型。只要大部分的電流都平行於界面，那基本上這就是個很好的模型。然而，目前最新科技通常會使得 source/drain 的電流以「向外散開，向內吸入」的方式進入與離開。例如說目前的 ultrashalow source and drain extensions。電流散開之後，電流就不再平行於界面，而這模型可能會帶來將近 5-15 % 的誤差。因此，如果你知道電流的方向，那麼你也可以設定用來計算平行電場分量之方向向量，而不再只是單純地與最鄰近的界面平行的方向。例如說，如果你覺得電流主要是沿著 x 軸在流動，那麼可以在 Math section 設定 EparallelToInterface (Direction = (1 0 0))。\n最常用的 driving force 是 quasi-Fermi potential 的梯度模型。通常這跟平行電場模型是一樣的，但它的演算法比較穩定。可以用 HighFieldSaturation(GradQuasiFermi) 選項來啟動它。不過，即便如此，還是可能會造成收斂問題。這是因為通常 quasi-Fermi potential 的梯度都非常的陡峭，變化得太過劇烈或是非常的不平滑，而這往往切得比較不好的網格所造成的。\n但在有些時候，即便網格切得很好，還是沒辦法收斂。有時是因為低載子濃度的區域的濃度相對誤差都滿高的，而這會進一步導致 quasi-Fermi potential 的誤差變得滿大的。因為這些區域通常對總電流的貢獻並不是很顯著，所以算得太準反而會讓模擬跑得更慢。不過，你確實需要確認一下這些低密度是不是導致發散。\n除此之外，也可藉由設定 RefDens_eGradQuasiFermi_EparallelToInterface 與 RefDens_hGradQuasiFermi_EparallelToInterface 來使用「內插 GradQuasiFermi 與 Eparallel」的 driving force 模型。該參數定義了 gradual transition 發生的局域載子濃度。例如說，如果設定為 1e12，那麼當載子濃度高於 1e12，就使用 GradQuasiFermi model，反之則使用 Eparallel model。通常 1e12 並不會影響到總電流，但仍能改善收斂問題。有時甚至需要用到 1e14 ～ 1e16 以獲得更好的收斂，但要留意不同設定所得到的電流是否一致，以確定 Eparallel driving force 帶來的誤差仍可接受。","title":"[TCAD] 模擬收斂問題"},{"content":"1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \\( \\boxed{\\text{Full Adder}} \\begin{cases} \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{OR}} \\end{cases}\\\\ \\text{設計目標}\\qquad\\qquad\\text{子模組}\\qquad\\text{元件} \\) 1.3 Verilog 語法詞彙 由一連串的標記(token)所組成 識別字(identifiers) 關鍵字(keywords) 字串(strings) 註解(comments) 空白(whitespace) 數值(numbers) 1.3.1 識別字(identifiers) 描述電路行為所使用的自訂物件 不違反命名規則，工程師自行定義的物件名稱 命名規則 字母、數字、底線_或是錢字號$所組合而成。 開頭只能使用字母或底線。 識別字是有大小寫之分的。 舉例 Shift_reg_b (Valid) _bus123 (Valid) $error_condition (Invalid) NT$899 (Valid) 3_bit_data (Invalid) 1.3.2 關鍵字(keywords) 描述電路語法所保留的一組特殊名稱的標記 定義語言的結構來描述電路 輸入(input)、輸出(output) 資料型態、電路行為 所有關鍵字都必須使用小寫表示 不可當作識別字使用 常見關鍵字 \\(\\begin{array}{|l|l|l|l|l|l|}\\hline \\text{always}\u0026amp;\\text{and}\u0026amp;\\text{assign}\u0026amp;\\text{begin}\u0026amp;\\text{buf}\u0026amp;\\text{bufif0}\\\\\\hline \\text{bufif1}\u0026amp;\\text{case}\u0026amp;\\text{casex}\u0026amp;\\text{casez}\u0026amp;\\text{cmos}\u0026amp;\\text{default}\\\\\\hline \\text{defparam}\u0026amp;\\text{else}\u0026amp;\\text{end}\u0026amp;\\text{endcase}\u0026amp;\\text{endfunction}\u0026amp;\\text{endmodule}\\\\\\hline \\text{endtask}\u0026amp;\\text{event}\u0026amp;\\text{for}\u0026amp;\\text{forever}\u0026amp;\\text{fork}\u0026amp;\\text{function}\\\\\\hline \\text{highz0}\u0026amp;\\text{highz1}\u0026amp;\\text{if}\u0026amp;\\text{initial}\u0026amp;\\text{inout}\u0026amp;\\text{input}\\\\\\hline \\text{integer}\u0026amp;\\text{join}\u0026amp;\\text{module}\u0026amp;\\text{nand}\u0026amp;\\text{negedge}\u0026amp;\\text{nmos}\\\\\\hline \\text{nor}\u0026amp;\\text{not}\u0026amp;\\text{notif0}\u0026amp;\\text{notif1}\u0026amp;\\text{or}\u0026amp;\\text{output}\\\\\\hline \\text{parameter}\u0026amp;\\text{pmos}\u0026amp;\\text{posedge}\u0026amp;\\text{pull0}\u0026amp;\\text{pull1}\u0026amp;\\text{pulldown}\\\\\\hline \\text{pullup}\u0026amp;\\text{rcmos}\u0026amp;\\text{real}\u0026amp;\\text{realtime}\u0026amp;\\text{reg}\u0026amp;\\text{repeat}\\\\\\hline \\text{rnmos}\u0026amp;\\text{rpmos}\u0026amp;\\text{rtran}\u0026amp;\\text{rtranif0}\u0026amp;\\text{rtranif1}\u0026amp;\\text{strong0}\\\\\\hline \\text{string1}\u0026amp;\\text{supply0}\u0026amp;\\text{supply1}\u0026amp;\\text{task}\u0026amp;\\text{time}\u0026amp;\\text{tran}\\\\\\hline \\text{tranif0}\u0026amp;\\text{tranif1}\u0026amp;\\text{tri}\u0026amp;\\text{tri0}\u0026amp;\\text{tri1}\u0026amp;\\text{triand}\\\\\\hline \\text{trior}\u0026amp;\\text{trireg}\u0026amp;\\text{wait}\u0026amp;\\text{wand}\u0026amp;\\text{weak0}\u0026amp;\\text{weak1}\\\\\\hline \\text{while}\u0026amp;\\text{wire}\u0026amp;\\text{wor}\u0026amp;\\text{xnor}\u0026amp;\\text{xor}\\\\\\hline \\end{array}\\) 1.3.3 字串(strings) 一連串字元(character)組成的單一個體 可含有字母、數字、及一些特殊字元 字串的所有字元必須在同一行上，並在雙引號之間 1.3.4 註解(comments) 程式碼中加入說明文字 可讀性(readability) 文件化(documentation) 版權宣告(license declaration) 以//開頭的單行註解(one-line comment) 以/*為開頭，並以*/為結尾的多行註解(multiple-line comment) 多行註解不支援巢狀結構 1.3.5 空白(whitespace) 區隔不同物件 空格(blank spaces，\\b) 欄位(tabs，\\t) 換行(newlines，\\n) 除字串內空白，註解與空白在編譯與合成時會被忽略 1.3.6 數值(numbers) Verilog 有兩種數值表示法 固定長度(\u0008sized): 定義位元寬度 \u0026lt;size\u0026gt;'\u0026lt;bsase format\u0026gt;\u0026lt;number\u0026gt; \u0026lt;size\u0026gt;：十進位來表示此數的位元數(bits) \u0026lt;base format\u0026gt;：定義進制 'H|'h：十六進制 'D|'d：十進制 'O|'p：八進制 'B|'b：二進制 \u0026lt;number\u0026gt;：用\u0026lt;base format\u0026gt;來表示數值 若為負號，將-放在\u0026lt;size\u0026gt;前面 舉例： 18'h47CB：18 bits 的十六進位數 47CB 13'h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB 12'd1023：12 bits 的十進位數 1023 9'o723：9 bits 的八進位數 723 5'b11101：5bits 的二進位數 11101 5'b1xx01：含有 unknown values 的表示法 不定長度(unsized): 未定義位元寬度 \u0026lsquo;\u0026lt;base format\u0026gt;\u0026lt;number 不使用\u0026lt;size\u0026gt;規定位元長度 使用 HDL 編譯器內定的長度(32bit的寬度) 沒有寫明\u0026lt;base format\u0026gt;，則內定為十進制 舉例： 'h47CB：32 bits 的十六進位數 47CB 1023：32 bits 的十進位數 1023 'o723：32 bits 的八進位數 723 'b11101：32 bits 的二進位數 11101 Verilog 有四種數值位準(value level) \\(\\begin{array}{|c|l|}\\hline \\text{數值位準}\u0026amp;\\text{實際電路狀態}\\\\\\hline \\text{0}\u0026amp;\\text{邏輯0，假(false)，接地}\\\\\\hline \\text{1}\u0026amp;\\text{邏輯1，真(true)，接壓電源}\\\\\\hline \\text{x}\u0026amp;\\text{不確定值(unknown value)}\\\\\\hline \\text{z}\u0026amp;\\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\\\\hline \\end{array} \\) 1.4 Verilog 資料物件與型態 資料物件(data objects) 描述行為過程中所使用的訊號載具 一個物件經過處理再傳到另一個物件 資料型態(data type) 定義資料物件的類型 接線、暫存器、參數等 1.4.1 接線(Nets) 接線(nets)是連接實體元件的連接線 要被驅動才能改變其內部的值 最主要的關鍵字是 wire 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 z(高阻抗、浮接) 宣告方式 wire w; // 宣告一條接線，命名為\u0008w，內定預設值為z wire x = 1\u0026#39;b0; // 宣告一條接線，命名為x，並指定x為邏輯0 wire a, b, c // 宣告三條接線，命名為a, b, c 1.4.2 暫存器(Registers) 抽象的資料儲存物件(有別於實體暫存器 D flip-flop) 保留一個數值直到下一次指定新值為止 觀念類似 C 語言中的變數 主要的關鍵字是 reg 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 x(未知) \\(\\begin{array}{|l|l|}\\hline \\text{reg}\u0026amp;\\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\\\\hline \\text{integer}\u0026amp;\\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\\\ \u0026amp;\\text{算術運算產生2補數結果(2\u0026rsquo;s complement results))}\\\\\\hline \\text{real}\u0026amp;\\text{雙倍精確度之有號浮點數}\\\\ \u0026amp;\\text{(signed floating-point variable with double precision)}\\\\\\hline \\text{time}\u0026amp;\\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\\\\hline \\end{array}\\) 設計電路請以reg為主，其他類型合成器可能不支援。 宣告方式 reg a; // 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x reg x, y; // 宣告 2 個宣存器，命名為 x, y integer count; // 宣告 1 個整數為 count，值可以為正負 real fraction; // 宣告 1 個浮點數為 fraction，值含小數點 1.4.3 純量與向量(scalar and vector) 純量(scalar) 一個位元的物件 向量(vector) 多個位元的物件 接線(ex. wire) 與 reg 內定一位元 [大數字:小數字]、[小數字:大數字]→[MSB:LSB] 宣告方式 wire a; // 宣告 1 個 1-bits 接線 wire [4:0] x; // 宣告 1 個 5-bits 接線 reg b; // 宣告 1 個 1-bits 暫存器 reg [0:7] y; // 宣告 1 個 8-bits 暫存器 reg [31:0] z; // 宣告 1 個 32-bits 暫存器 1.4.4 陣列(Array) 多個暫存器、接線的聚合體 索引值(index)定義聚合體中的個別物件 支援多維度的陣列 記憶體(memory)、暫存器檔案(register file) 陣列中暫存器、接線的個數 [大數字:小數字]、[小數字:大數字] 宣告方式 // mem_block 是一個包含 128 個暫存器的陣列， // 每個暫存器皆為 32 位元寬 reg [31:0] mem_block [127:0]; // mem_2D 是一個 2 維 4x64 的暫存器陣列， // 每個暫存器皆為 8 位元寬 reg [7:0] mem_2D [3:0][63:0]; 1.4.5 參數(parameter) 定義編譯合成電路時的常數 每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路 重複使用 關鍵字 parameter 宣告方式 parameter width = 4; wire [width-1:0] a, b; // 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動 reg [width-1:0] y; // 暫存器 y 的位元寬度，會隨著參數值的改變而變動 1.5 模組(Module)、埠(Port) 1.5.1 模組(Module) 一個電路區塊、可以由其他模組組成 連接模組時 考慮模組的輸入與輸出介面 不需要考慮模組內部的詳細電路 電路設計時 只修改模組內部電路 不會改變電路外部及周遭的模組 模組內部的電路描述可包含 訊號資料型態宣告 引用其他模組(邏輯閘) assign 資料處理模型之描述 always 行為模型之描述 函數(function) 與 任務(task) 除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為 模組宣告 以關鍵字 module 為開頭，在其後加一個識別用的模組名稱(module name) 再來是輸入與輸出埠列(module terminal list)和埠列宣告，接著是模組內部關於電路的描述 以關鍵字 endmodule 做為模組結尾 支援階層`式的設計概念 module module_name(terminal_list) port_declaration(...) param_declaration(optional) data_type_declaration(wire, reg) other_module(logic_gate) assign data_flow_model always behavior_model function, task endmodule 1.5.2 埠(port) 終端點、模組與外界溝通的介面接點(門) 一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通 若模組與外界不需要溝通，則埠列也就不存在(封閉系統) 測試環境(test bench) 埠的宣告 埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。 埠的宣告型態內定為接線(net)的 wire，若需要將訊號儲存起來則埠號型態須宣告成暫存器 reg。 輸入埠和雙向埠只能是接線(net)，不可宣告成暫存器。 輸出埠可以宣告成接線(net)或暫存器。 module full_adder(a, b, carry, sum); // 埠列 input [3:0] a, b; // 輸入埠(4位元向量) input carry // 輸入埠(1位元純量) output [4:0] sum; // 輸出埠(5位元向量) reg [4:0] sum; // 因輸出sum需儲存資料，故宣告成暫存器 ... endmodule 1.6 邏輯閘層次模型 利用關鍵字即可引用基本的邏輯閘元件 基本的邏輯閘關鍵字 and nand or nor not xor xnor 1.6.1 多個輸入邏輯閘(Multiple-Input Gates) and、nand、or、nor、xor、xnor 具有多個純量(scalar)的輸入，但是只有一個純量的輸出 多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面 輸出必須透過接線(wire)連接，輸入無規定 多個輸入邏輯閘的別名可以加或是不加 使用方法 gate_type instance(out, in_1, in_2, in_3, ..., in_n); gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n), inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n), inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n), ... inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn); \\(\\begin{array}{ccc} \\underbrace{\\text{a, b, c, d}}_{\\text{輸入}} \\rightarrow \\boxed{\\text{Multiple-Input Gate}} \\rightarrow \\underbrace{\\text{e}} _{\\text{輸出}} \\end{array} \\) \\(\\text{and\\quad a1(} \\underbrace{\\text{e}}_{\\text{輸出}} \\text{, } \\underbrace{\\text{a, b, c, d}} _{\\text{輸入}} \\text{);} \\) 1.6.2 多個輸出邏輯閘(Multiple-Output Gates) not、buf\n具有一個或是多個純量(scalar)的輸出，但是只有一個純量的輸入\n多個輸出邏輯閘的輸出是放在埠列(port list)的前面位置，而輸入則是放在列後面位置\n輸出必須透過接線(wire)連接，輸入無規定 多個輸出邏輯閘的別名可以加或是不加\n使用方法\ngate_type instance(out_1, out_2, out_3, ..., out_n, in); gate_type inst_1(out1_1, out1_2, out1_3, ..., out1_n, in1), inst_2(out2_1, out2_2, out2_3, ..., out2_n, in2), inst_3(out3_1, out3_2, out3_3, ..., out3_n, in3), ... inst_m(out_m1, out_m2, out_m3, ..., out_mn, in_m); \\(\\begin{array}{ccc} \\underbrace{\\text{d}}_{\\text{輸入}} \\rightarrow \\boxed{\\text{Multiple-Output Gate}} \\rightarrow \\underbrace{\\text{a, b, c}} _{\\text{輸出}} \\end{array} \\)\n\\(\\text{not\\quad n1(} \\underbrace{\\text{a, b, c}}_{\\text{輸出}} \\text{, } \\underbrace{\\text{d}} _{\\text{輸入}} \\text{);} \\)\n邏輯閘層次模型範例\nmodule and_or_gate(in1, in2, in3, in4, out; input in1, in2, in3, in4; output out; wire w1, w2; and a1(w1, in1, in2); and a2(w2, in3, in4); or o1(out, w1, w2); endmodule ","permalink":"http://intervalrain.github.io/posts/verilog/intro/","summary":"1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \\( \\boxed{\\text{Full Adder}} \\begin{cases} \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{OR}} \\end{cases}\\\\ \\text{設計目標}\\qquad\\qquad\\text{子模組}\\qquad\\text{元件} \\) 1.","title":"[VHDL] Verilog Hardware Description Language"},{"content":"前言 MVC MVC 是一種軟體架構模式。 模型 (Model) 視圖 (View) 控制器 (Controller) 目的是實現一種動態且有彈性的程式設計，使後續對程式設計的維護與擴充都變得更容易，另一方面也能使程式的某一部分被重複使用而提升設計效率。 SSH SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Struts Spring Hibernate SSM SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Spring-MVC Spring MyBatis SSH v.s. SSM Spring-MVC v.s. Struts Struts 和 Spring-MVC 都負責取轉發，但兩者針對 request 的請求上區別很大， Struts 是針對一個 Action class 來進行 request，即一個 Action 對應一個 request，屬於類攔截，請求的數據類共享。 Spring-MVC 則是針對 method 級別的 request，即一個 method 對應一個 request，屬於方法攔截，請求的數據方法不共享。 Spring-MVC 的配置文件相對較少，容易上手，方便開發。 Spring-MVC 的入口是 Servlet 級別的而 Struts 的級別是 Filter 級別的。 Hibernate v.s. MyBatis Hibernate 是一種 O/R 關係型，即完成資料庫和持久化類別之間的映射；而 MyBatis 是針對的 SQL-Mapping。猶如 Hibernate 是對資料庫封裝完成後，調用相對應的語句(HQL)來控制資料庫；而 MyBatis 是用原生的資料庫語法。 基於以上原因，Hibernate 的優化較 MyBatis 難，MyBatis 不需要額外學習新的語法，入門較快。 對於更高級的 Queuy，MyBatis 需要編寫 SQL 語句與 ResultMap。而 Hibernate 有因應的映射機制，無需關心 SQL 的生成與結果映射，可以專注於開發流程。 Hibernate 的資料庫移植性很好，MyBatis 的資料庫移植性不好，不同的資料庫需要寫不同的 SQL。 Spring Spring、Spring MVC、Spring Boot Spring 是一種框架，包含一系列的 IoC 容器的設計和依賴注入(DI) 及 整合AOP功能。 Spring MVC 是一種以 Spring 為核心的框架。 Spring Boot 是一種以 Spring 為核心的框架，同時又能簡化配置(configuration)。 Spring 的核心基礎 DI DI = 依賴注入 Dependency Injection 一種 coding style，為了未來在維護上能更加的靈活，概念類似： // 1 System.out.println(\u0026#34;This is Spring\u0026#34;); // 2 String str = \u0026#34;This is Spring\u0026#34;; System.out.println(str); IoC IoC = 控制反轉 Inversion of Control 將產生物件這件事交給IoC去做。簡單來說，IoC是一個xml檔，也可以是一個class(Bean class)。 IoC做的事情就是設定其他class(Bean class)的名稱，以及 Constructor 會用到的參數或物件。 public class User{ Family family = new Family(\u0026#34;Jason\u0026#34;, \u0026#34;Jocelyn\u0026#34;, \u0026#34;Mark\u0026#34;, \u0026#34;Eva\u0026#34;); public void showAll(){ family.showFamily(); } } public class Family{ String dad; String mom; String son; String dau; public Family(String dad, String mom, String son, String dau){ this.dad = dad; this.mom = mom; this.son = son; this.dau = dau; } public void showFamily(){ System.out.println(dad + \u0026#34; \u0026#34; + mom + \u0026#34; \u0026#34; + son + \u0026#34; \u0026#34; + dau); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;family\u0026#34; class=\u0026#34;Family\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dad\u0026#34; value=\u0026#34;Jason\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;mom\u0026#34; value=\u0026#34;Jocelyn\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;son\u0026#34; value=\u0026#34;Mike\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;dau\u0026#34; value=\u0026#34;Eva\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;allFamily\u0026#34; value=\u0026#34;family\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 實例 DI + IoC Dinner public class Diner{ Food food; public void getDinner(){ food.getFood(); } } xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;pork\u0026#34; class=\u0026#34;Pork\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;chicken\u0026#34; class=\u0026#34;Chicken\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;food\u0026#34; class=\u0026#34;Food\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;food\u0026#34; value=\u0026#34;chicken\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; classes public interface Food{ public void getFood(); } public class Chicken implements Food{ @override public void getFood(){ System.out.println(\u0026#34;Eat chicken\u0026#34;); } } public class Pork implements Food{ @override public void getFood(){ System.out.println(\u0026#34;Eat pork\u0026#34;); } } Spring Boot 由 Pivotal 團隊在 2013 年開始研發、2014年4月發布第一個版本。 是基於 Spring4.0 所設計的一種新型框架，繼承的 Spring 框架原有的優秀特性，還通過簡化配置來進一步簡化了 Spring 應用的整個搭建和開發過程。 通過集成大量的框架使得依賴包的版本衝突與引用的不穩定性得到很好的解決。 官方說明: Spring Boot makes it easy to create stand-alone, production-grade Spring baesd Applications that you can \u0026ldquo;just run\u0026rdquo;. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.\nString Boot 預設了各種合理的默認配置包括放棄了 XML，Spring Boot Web 應用程式使用了一個嵌入式 Tomcat 容器，可以自定義 Spring Boot 應用程式等。 簡而言之，Spring Boot 提供一組工具，可以快速構建且容易配置的 Spring 應用程式。同時不需要在重新定義基本的配置，從而成為可以達到快速開發的效果。 特色 創建獨立的 Spring 應用程式 嵌入式 Tomcat、Jetty; Undertow(不用部署 WAR 包) 提出自主的 starter 來簡化配置 隨時自動地配置 Spring 及相關的第三方庫 提供已隨時就緒的功能如 Metrics，程式的健檢及外部化配置 不會生成任何代碼及無任何 XML 配置的前設要求 ","permalink":"http://intervalrain.github.io/posts/java/java_mvc/","summary":"前言 MVC MVC 是一種軟體架構模式。 模型 (Model) 視圖 (View) 控制器 (Controller) 目的是實現一種動態且有彈性的程式設計，使後續對程式設計的維護與擴充都變得更容易，另一方面也能使程式的某一部分被重複使用而提升設計效率。 SSH SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Struts Spring Hibernate SSM SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Spring-MVC Spring MyBatis SSH v.s. SSM Spring-MVC v.s. Struts Struts 和 Spring-MVC 都負責取轉發，但兩者針對 request 的請求上區別很大， Struts 是針對一個 Action class 來進行 request，即一個 Action 對應一個 request，屬於類攔截，請求的數據類共享。 Spring-MVC 則是針對 method 級別的 request，即一個 method 對應一個 request，屬於方法攔截，請求的數據方法不共享。 Spring-MVC 的配置文件相對較少，容易上手，方便開發。 Spring-MVC 的入口是 Servlet 級別的而 Struts 的級別是 Filter 級別的。 Hibernate v.s. MyBatis Hibernate 是一種 O/R 關係型，即完成資料庫和持久化類別之間的映射；而 MyBatis 是針對的 SQL-Mapping。猶如 Hibernate 是對資料庫封裝完成後，調用相對應的語句(HQL)來控制資料庫；而 MyBatis 是用原生的資料庫語法。 基於以上原因，Hibernate 的優化較 MyBatis 難，MyBatis 不需要額外學習新的語法，入門較快。 對於更高級的 Queuy，MyBatis 需要編寫 SQL 語句與 ResultMap。而 Hibernate 有因應的映射機制，無需關心 SQL 的生成與結果映射，可以專注於開發流程。 Hibernate 的資料庫移植性很好，MyBatis 的資料庫移植性不好，不同的資料庫需要寫不同的 SQL。 Spring Spring、Spring MVC、Spring Boot Spring 是一種框架，包含一系列的 IoC 容器的設計和依賴注入(DI) 及 整合AOP功能。 Spring MVC 是一種以 Spring 為核心的框架。 Spring Boot 是一種以 Spring 為核心的框架，同時又能簡化配置(configuration)。 Spring 的核心基礎 DI DI = 依賴注入 Dependency Injection 一種 coding style，為了未來在維護上能更加的靈活，概念類似： // 1 System.","title":"[Java] 淺談 Java MVC"},{"content":"Microservices Definition Separate business logic functions. Instead of one big problem, several smaller applications. Communicative via well defined APIs - usually HTTP In demand Advantages and Disavantages Advantages Language independent Fast iterations Small teams Fault Isolation Pair well with containers Scalable Big plus Disavantages Complex networking Overhead Databases Servers Docker is an open platform for developers and sysadmins to build, ship, and run distributed applications, whether on laptops, data center VMs, or the cloud. Definition Containers are a way to package software in a format that can run isolated on a shared operating system. Unlike VMs, containers do not bundle a full operating system - only libraries and setting required to make the software work are needed. This makes for efficientm, lightweight, self-contained systems and guarantees that software will always run the same, regardless of where it\u0026rsquo;s deployed. Docker vs VM VM = App + Bins/Libs + guest OS Container = App + Bins/Libs + Docker Dockerfile Describes the build process for an image Can be run to automatically create an image Contains all the commands necessary to build the image and run your application. Kubernetes Components Node Kubelet Communicates with master Run Pods Pod Runs 1+ containers Exists on a node Service Handles requests Usually a load balancer Deployment Defines desired state - kubernetes handles the rest ","permalink":"http://intervalrain.github.io/posts/it/microservices_docker_kubernetes/","summary":"Microservices Definition Separate business logic functions. Instead of one big problem, several smaller applications. Communicative via well defined APIs - usually HTTP In demand Advantages and Disavantages Advantages Language independent Fast iterations Small teams Fault Isolation Pair well with containers Scalable Big plus Disavantages Complex networking Overhead Databases Servers Docker is an open platform for developers and sysadmins to build, ship, and run distributed applications, whether on laptops, data center VMs, or the cloud.","title":"[IT] Introduction to Microservices, Docker and Kubernetes"},{"content":"map 宣告 map \u0026lt;int, int\u0026gt; mp; // key和value都是整數 方法 mp[key] = value; 加入新的key-value pair mp.count(key); 檢查 key 是否存在 map 中 mp.erase(key); 刪除 key mp.clear(); 清空 map 中的所有元素： value = mp[key] 利用 key 取值 mp.empty() 判斷是否為空的map map 的遍歷 遍歷整個map時，利用iterator操作： 取key：it-\u0026gt;first 或 *(it).first 取value：it-\u0026gt;second 或 *(it).second for (auto it = mp.begin(); it != mp.end(); ++it){ cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (auto it = mp.begin(); it != mp.end(); ++it){ cout \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"http://intervalrain.github.io/posts/c++/stl_map/","summary":"map 宣告 map \u0026lt;int, int\u0026gt; mp; // key和value都是整數 方法 mp[key] = value; 加入新的key-value pair mp.count(key); 檢查 key 是否存在 map 中 mp.erase(key); 刪除 key mp.clear(); 清空 map 中的所有元素： value = mp[key] 利用 key 取值 mp.empty() 判斷是否為空的map map 的遍歷 遍歷整個map時，利用iterator操作： 取key：it-\u0026gt;first 或 *(it).first 取value：it-\u0026gt;second 或 *(it).second for (auto it = mp.begin(); it != mp.end(); ++it){ cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (auto it = mp.begin(); it !","title":"[C++] The C++ Standard Template Library(STL) - map"},{"content":"rand() 函數 在 C/C++ 中可以使用 rand() 這個函數，產生最簡單的亂數： 需引用 \u0026lt;stdlib.h\u0026gt; 函式庫 在呼叫 rand() 前需要先使用srand()設定初始的亂數種子，增加「亂度」。(實際上產生的亂數是有規則的，以示例為例，是以時間做為種子，故是有可能被預測的) 其產生的亂數是一個介於 0 到 RAND_MAX(INT_MAX)的整數。 C 與 C++ 幾乎一樣，只差在表頭檔的使用。 C-style #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main(){ srand(time(NULL)); // random seed int x = rand(); printf(\u0026#34;x = %d\\n\u0026#34;, x); return 0; } Cpp-style #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); int x = rand(); cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;x is between 0 and \u0026#34; \u0026lt;\u0026lt; RAND_MAX \u0026lt;\u0026lt; endl; return 0; } 亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。 上例中使用的亂數種子是時間，因為時間每分每秒都在變化，所以每次產生的亂數都會不同，如果是用於數值模擬的話， 固定亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。若是做數值模擬的話，通常會讓模擬結果具有可重復性(repeatability)，方便除錯與驗證，這種狀況就可以將亂數種子固定不變，以確保每次的結果都相同。 [0, 1) 浮點數亂數 [0, 1) 代表 0 \u0026lt;= x \u0026lt; 1 若要產生 0 到 1 之間的浮點數亂數，可以這樣寫： #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); double x = (double)rand()/(RAND_MAX + 1.0); cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } [a, b)特定範圍浮點數亂數 [a, b) 表 a \u0026lt;= x \u0026lt; b #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); double x = (double)rand()/(RAND_MAX + 1.0); cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } [a, b)特定範圍整數亂數 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); int a = 1; // min int b = 100; // max int x = rand() % (b - a + 1) + a; cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } 上面這種使用餘數運算（%）的方式只是比較方便的寫法，事實上使用餘數運算所產生的整數亂數在理論上不是標準的均勻分布。\n我們以一個簡單的例子來解釋，假設 RAND_MAX 的值為 10，而我們要產生介於 3 到 5 之間的整數亂數（亦即 min = 3、max = 5），以下是所有的可能性對照表：\n\\(\\def\\arraystretch{1.4}\\begin{array}{c|l|c} 轉換後的整數亂數\u0026amp;\\text{rand()}函數產生的亂數\u0026amp;出現機率\\\\\\hline 3\u0026amp;0,3,6,9\u0026amp;4/11\\\\\\hline 4\u0026amp;1,4,7,10\u0026amp;4/11\\\\\\hline 5\u0026amp;2,5,8\u0026amp;3/11 \\end{array}\\) rand() 函數所產生的每一個整數其出現的機率是均等的，但是經過於數運算的轉換之後，因為 RAND_MAX 通常不會被整除，所以轉換之後的整數亂數出現機率就存在有細微的偏差，以這個例子來說，3、4、5 三個數字出現的機率比是 4:4:3。\n另外有些人會先產生固定範圍的浮點數亂數，再將浮點數轉型為整數，例如產生 [3, 6) 的浮點數亂數，然後轉型為 [3, 5] 的整數亂數，其實這種方式跟餘數運算一樣會有每個整數出現機率不均等的問題，簡單來說就是現在有 11 個球要放進 3 個籃子裡，不管怎麼放，每個籃子的球都不可能一樣多。\n均勻分布亂數(uniform distribution) #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int randint(int n){ if ((n - 1) == RAND_MAX) return rand(); long end = RAND_MAX / n; assert (end \u0026gt; 0L); end *= n; int r; while ((r = rand()) \u0026gt;= end); return r % n; } int main(){ int x = randint(5); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } 使用 randint 函數產生特定範圍整數亂數： int x = randint(max - min + 1) + min; 這種作法就好像要把 11 個球要放進 3 個籃子裡，而最後多出來的 2 顆球就直接丟掉，確保每個籃子都一樣只有 3 顆，這樣大家的機率就可以相等了。\n這種使用截斷分布（truncated distribution）來校正機率的方式雖然在理論上是正確的，但是 rand 函數是使用 LCG（Linear Congruential Generator）來產生亂數的，他的優點只是快速、方便而已，但它本身所產生的亂數品質沒有非常好，再怎麼校正效果都有限，若需要高品質的亂數，請改用 C++11 標準的 函式庫。\n","permalink":"http://intervalrain.github.io/posts/c++/random/","summary":"rand() 函數 在 C/C++ 中可以使用 rand() 這個函數，產生最簡單的亂數： 需引用 \u0026lt;stdlib.h\u0026gt; 函式庫 在呼叫 rand() 前需要先使用srand()設定初始的亂數種子，增加「亂度」。(實際上產生的亂數是有規則的，以示例為例，是以時間做為種子，故是有可能被預測的) 其產生的亂數是一個介於 0 到 RAND_MAX(INT_MAX)的整數。 C 與 C++ 幾乎一樣，只差在表頭檔的使用。 C-style #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main(){ srand(time(NULL)); // random seed int x = rand(); printf(\u0026#34;x = %d\\n\u0026#34;, x); return 0; } Cpp-style #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); int x = rand(); cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;x is between 0 and \u0026#34; \u0026lt;\u0026lt; RAND_MAX \u0026lt;\u0026lt; endl; return 0; } 亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。 上例中使用的亂數種子是時間，因為時間每分每秒都在變化，所以每次產生的亂數都會不同，如果是用於數值模擬的話， 固定亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。若是做數值模擬的話，通常會讓模擬結果具有可重復性(repeatability)，方便除錯與驗證，這種狀況就可以將亂數種子固定不變，以確保每次的結果都相同。 [0, 1) 浮點數亂數 [0, 1) 代表 0 \u0026lt;= x \u0026lt; 1 若要產生 0 到 1 之間的浮點數亂數，可以這樣寫： #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); double x = (double)rand()/(RAND_MAX + 1.","title":"[C++] 如何產生 random 值"},{"content":"程式碼 static final int hash(Object key){ int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } h \u0026raquo; 16 的用途 h是key.hashCode()，h \u0026gt;\u0026gt;\u0026gt; 16代表的是取其高位的16位 key.hashCode() ^ (h \u0026raquo; 16) 這與 Java1.8 中 tab[(n-1) \u0026amp; hash] 的原理有關 static int indexFor(int h, int length){ return h \u0026amp; (length - 1); } 返回的值即為陣列的下標。 大多數情況下，capacity 都小於2^16，所以在此的 \u0026amp; 運算，只會對 h 的低16位進行 \u0026amp; 運算。 若將高位16位也加入計算，可以增加下標的發散度，避免衝突的次數。 而使用 XOR 的原因是，更較於 AND 或 OR 均勻，因為 AND 會使結果趨向於 0，OR 會使結果趨向於 1。 ","permalink":"http://intervalrain.github.io/posts/java/hashmap/hashcode/","summary":"程式碼 static final int hash(Object key){ int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } h \u0026raquo; 16 的用途 h是key.hashCode()，h \u0026gt;\u0026gt;\u0026gt; 16代表的是取其高位的16位 key.hashCode() ^ (h \u0026raquo; 16) 這與 Java1.8 中 tab[(n-1) \u0026amp; hash] 的原理有關 static int indexFor(int h, int length){ return h \u0026amp; (length - 1); } 返回的值即為陣列的下標。 大多數情況下，capacity 都小於2^16，所以在此的 \u0026amp; 運算，只會對 h 的低16位進行 \u0026amp; 運算。 若將高位16位也加入計算，可以增加下標的發散度，避免衝突的次數。 而使用 XOR 的原因是，更較於 AND 或 OR 均勻，因為 AND 會使結果趨向於 0，OR 會使結果趨向於 1。 ","title":"[Java] HashMap中的hashCode設計原理"},{"content":"C++ 易錯題目收集 1. bit-format expression #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ unsigned int x = -1; int y = ~0; if (x==y) cout \u0026lt;\u0026lt; \u0026#34;same\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;not same\u0026#34;; return 0; } 結果 same 解析 unsigned int x = -1 相當於11111111 y = ~0 也相當於11111111 2. 如何使 C(n,3) 正確且 n 的有效值最大? 結果 return n*(n-1)/2*(n-2)/3; 解析 n*(n-1)必為基偶相乘 n*(n-1)*(n-2)必為3的倍數 故此題的作法可避免因整數除法而造成的小數位消去 3. register在C++中的用法 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ register int i = 10; int *ptr = \u0026amp;i; cout \u0026lt;\u0026lt; *ptr; return 0; } 選項 Prints 10 on all compilers Prints 0 on all compilers May generate Compilation Error May generate Runtime Error 結果 May generate Compilation Error 解析 register關鍵字用來分配變數儲存於CPU的register，以達到快速存取。所以對其提取有可能造成編譯錯誤，因為指標指向的位址不在在RAM上。 在大部分的C++編譯器，不推薦使用register關鍵字，因為沒有任何意義，儘管他會被默認成auto關鍵字，使得C++編譯器可能可能適用。 4. 有趣的 for loop 問題 int fun(){ static int num = 16; return num--; } int main(){ for(fun(); fun(); fun()) cout \u0026lt;\u0026lt; fun(); return 0; } 結果 14 11 8 5 2 解析 main()中的 for-loop 可以寫成等效的 while-loop 如下 int main(){ int num = 16; num--; // num = 15 while (num-- != 0){ // 先判斷後遞減 15 !=0, num = 14 cout \u0026lt;\u0026lt; (num--) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 先印出後遞減印出 14, num = 13 num--; // 遞減後回到while, num = 12 } return 0; } static int num = 16 設定初值為 16，並遞減，故 num = 15 判斷 num 是否為真，後遞減。15 != 0，遞減使 num = 14，進入迴圈 印出 num = 14 後，遞減，num = 13 迴圈結束前作遞減，num = 12，重新回到 step2 5. const 與 volatile Pick the correct statemewnt for const and volatile keywords. 選項 const is the opposite of volatile and vice versa const and volatile can\u0026rsquo;t be used for struct and union const and volatile can\u0026rsquo;t be used for enum const and volatile can\u0026rsquo;t be used for typedef const and volatile are independent i.e. it\u0026rsquo;s possible that a variable is defined as both const and volatile 結果 const and volatile are independent i.e. it\u0026#39;s possible that a variable is defined as both const and volatile 解析 const 是確保變數不會變修改，使其值變成唯讀。 volatile 通常用在具有最佳化或多執行緒相關的變數或物件，volatile用來阻止編譯器因誤認某段程式碼無法被程式碼本身所改變，而造成的過度優化。volatile會使得每次存取這個變數或物件時，都會直接從變數位址中取得資料，避免可能使用暫存器中的值，在變數可能被其他程式更新的狀況下，產生錯誤的值。 6. operator priority int main(){ cout \u0026lt;\u0026lt; (1 \u0026lt;\u0026lt; 2 + 3 \u0026lt;\u0026lt; 4); return 0 } 結果 512 解析 +優先於\u0026lt;\u0026lt; 故此段敘述等效於 cout \u0026lt;\u0026lt; (1 \u0026lt;\u0026lt; (2 + 3) \u0026lt;\u0026lt; 4); cout \u0026lt;\u0026lt; (1 \u0026lt;\u0026lt; 5 \u0026lt;\u0026lt; 4); cout \u0026lt;\u0026lt; (32 \u0026lt;\u0026lt; 4); cout \u0026lt;\u0026lt; 512; 7. floating constant Suppose a C++ program has floating constant 1.414, what\u0026#39;s the best way to convert this as \u0026#34;float\u0026#34; data type? 選項 (float)1.414 float(1.414) 1.414f or 1.414F 1.414 itself of \u0026ldquo;float\u0026rdquo; data type i.e. nothing else required 結果 `1.414f` or `1.414F` 解析 floating constant 被預設為 double 資料型態，故利用f或F的suffix，即可將之轉為 float 資料型態。 8. array pointer int main(){ int arr[5]; // Assume base address of arr is 2000 and size of integer is 32 bit printf(%u %u, arr+1, \u0026amp;arr+1); return 0; } 結果 2004 2020 解析 array 的名稱會傳回第一個元素的地址(除了使用 sizeof)。 對 array 加 1 會加上 sizeof(type)。 \u0026amp;array 代表整個 array 的地址，加 1 回加上 sizeof(while array)。 9. initialize array int main(){ int a[][] = {{1,2},{3,4}}; int i, j; for (int i = 0; i \u0026lt; 2; i++){ for (int j = 0; j \u0026lt; 2; j++){ printf(\u0026#34;%d \u0026#34;, a[i][j]); } } return 0; } 結果 Compilation Error 解析 Array 在記憶體中是以row-major的型式儲存的。 儘管 array 是多維陣列，他都是被儲存成單一線性的區塊 下列 assign 的方式是合法的，(第一個可被省略) int a[] = {...}; int a[][10] = {{...}, ...}; int a[][5][10] = {{{...},...},...}; ","permalink":"http://intervalrain.github.io/posts/c++/question/","summary":"C++ 易錯題目收集 1. bit-format expression #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ unsigned int x = -1; int y = ~0; if (x==y) cout \u0026lt;\u0026lt; \u0026#34;same\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;not same\u0026#34;; return 0; } 結果 same 解析 unsigned int x = -1 相當於11111111 y = ~0 也相當於11111111 2. 如何使 C(n,3) 正確且 n 的有效值最大? 結果 return n*(n-1)/2*(n-2)/3; 解析 n*(n-1)必為基偶相乘 n*(n-1)*(n-2)必為3的倍數 故此題的作法可避免因整數除法而造成的小數位消去 3. register在C++中的用法 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ register int i = 10; int *ptr = \u0026amp;i; cout \u0026lt;\u0026lt; *ptr; return 0; } 選項 Prints 10 on all compilers Prints 0 on all compilers May generate Compilation Error May generate Runtime Error 結果 May generate Compilation Error 解析 register關鍵字用來分配變數儲存於CPU的register，以達到快速存取。所以對其提取有可能造成編譯錯誤，因為指標指向的位址不在在RAM上。 在大部分的C++編譯器，不推薦使用register關鍵字，因為沒有任何意義，儘管他會被默認成auto關鍵字，使得C++編譯器可能可能適用。 4.","title":"[C++]易錯題目收集"},{"content":"list, forward_list Lists 是序列式容器，但其記憶體的分配並非連續的。 跟 vector 相比，其遍歷的速度會較慢\\(O(n)\\，但一旦位置確定後，其插入(insert)或移除(delete)元素的速度很快\\(O(1)\\)。 一般來說，List 指的是雙向鏈結陣列(doubly linked list)。 而單向鏈結陣列則為 forward_list #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; void print(list\u0026lt;int\u0026gt; lst){ list\u0026lt;int\u0026gt;::iterator it; for (it = lst.begin(); it != lst.end(); ++it){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main(){ list\u0026lt;int\u0026gt; lst1, lst2; for (int i = 0; i \u0026lt; 10; ++i){ lst1.push_back(i); lst2.push_front(i); } cout \u0026lt;\u0026lt; \u0026#34;List1 is : \u0026#34;; print(lst1); cout \u0026lt;\u0026lt; \u0026#34;List2 is : \u0026#34;; print(lst2); cout \u0026lt;\u0026lt; \u0026#34;List1.front() : \u0026#34; \u0026lt;\u0026lt; lst1.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;List2.back() : \u0026#34; \u0026lt;\u0026lt; lst2.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;After List1.pop_front() : \u0026#34;; lst1.pop_front(); print(lst1); cout \u0026lt;\u0026lt; \u0026#34;After List2.pop_back() : \u0026#34;; lst2.pop_back(); print(lst2); cout \u0026lt;\u0026lt; \u0026#34;After List1.reverse() : \u0026#34;; lst1.reverse(); print(lst1); cout \u0026lt;\u0026lt; \u0026#34;After List2.sort() : \u0026#34;; lst2.sort(); print(lst2); return 0; } 函式(functions) 1. list.front() Returns the value of the first element in the list. 2. list.back() Returns the value of the last element in the list. 3. list.push_front(E val) Adds a new element val at the beginning of the list. 4. list.push_back(E val) Adds a new element val at the end of the list. 5. list.pop_front() Removes the first element of the list, and reduces size of the list by 1. Won\u0026rsquo;t return value. 6. list.pop_back() Removes the last element of the list, and reduces size of the list by 1. Won\u0026rsquo;t return value. 7. list.begin() Returns a iterator pointing to the first element of the list. 6. list.end() Returns a iterator pointing to the theoretical last element which follows the last element. 7. list.rbegin() Returns a reverse iterator which points to the last element of the list. 8. list.rend() Returns a reverse iterator which points to the position before the beginning of the list. 9. list.cbegin() Returns a constant random access iterator which points to the beginning of the list. 10. list.cend() Returns a constant random access iterator which points to the end of the list. 11. list.crbegin() Returns a constant reverse random access iterator which points to the beginning of the list. 12. list.crend() Returns a constant reverse random access iterator which points to the end of the list. 13. list.empty() Returns whether the list is empty or not. 14. list.insert(pos, n, val) pos: iterator, to point out the position to insert n: the numbers of val to insert (optional, default = 1) val: the insert elements Inserts new elements in the list before the element at a specified position. 15. list.erase(pos) pos: iterator, to point out the position to erase Removes a single element from the list. 16. list.erase(first, last) first: iterator, to point out the begining of the range. last: iterator, to point out the end of the range. Removes a range of elements from the list. 17. list.assign() 18. list.remove() 19. list.remove_if() 20. list.reverse() 21. list.size() 22. list.resize() 23. list.sort() 24. list.max_size() 25. list.unique() 26. list.emplace_front() 27. list.emplace_back() 28. list.clear() 29. list.swap() 30. list.splice() 31. list.merge() 32. list.emplace() 你可能會想繼續閱讀… 回到容器(Containers) vector deque arrays forward_list ","permalink":"http://intervalrain.github.io/posts/c++/stl_list/","summary":"list, forward_list Lists 是序列式容器，但其記憶體的分配並非連續的。 跟 vector 相比，其遍歷的速度會較慢\\(O(n)\\，但一旦位置確定後，其插入(insert)或移除(delete)元素的速度很快\\(O(1)\\)。 一般來說，List 指的是雙向鏈結陣列(doubly linked list)。 而單向鏈結陣列則為 forward_list #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; void print(list\u0026lt;int\u0026gt; lst){ list\u0026lt;int\u0026gt;::iterator it; for (it = lst.begin(); it != lst.end(); ++it){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main(){ list\u0026lt;int\u0026gt; lst1, lst2; for (int i = 0; i \u0026lt; 10; ++i){ lst1.push_back(i); lst2.push_front(i); } cout \u0026lt;\u0026lt; \u0026#34;List1 is : \u0026#34;; print(lst1); cout \u0026lt;\u0026lt; \u0026#34;List2 is : \u0026#34;; print(lst2); cout \u0026lt;\u0026lt; \u0026#34;List1.","title":"[C++] The C++ Standard Template Library(STL) - list, forward_list"},{"content":"vector Vectors 是一動態陣列，可以自動的調整其容器的容量。 Vector 的元素被儲存在連續的記憶體空間，所以可以使用迭代器(iterators)來進行存取。 在 vectors 中，元素是被插入在尾端的，插入尾端的時間取決於是否須進行容量的調整。 在 vectors 中，刪除尾端元素的時間複雜度則是固定的\\(O(1)\\)，因為不會發生容量調整。 在 vectors 的前端或中間插入元素或是清除元素，時間的複雜度都是\\(O(n)\\)。 迭代器(Iterators) 1. vec.begin() 回傳指向 vector 中第一個元素的迭代器 (vec[0]) 2. vec.end() 回傳指向 vector 中最後一個元素之後一個的迭代器 (vec[n+1]) 3. vec.rbegin() 回傳指向 vector 中最後一個元素的反向迭代器 (vec[n]) 4. vec.rend() 回傳指向 vector 中第一個元素之前一個的反向迭代器 (vec[-1]) 5. vec.cbegin() 回傳指向 vector 中第一個元素的常數迭代器 (vec[0]) 6. vec.cend() 回傳指向 vector 中最後一個元素之後一個的常數迭代器 (vec[n+1]) 7. vec.crbegin() 回傳指向 vector 中最後一個元素的反向常數迭代器 (vec[n]) 8. vec.crend() 回傳指向 vector 中第一個元素之前一個的反向常數迭代器 (vec[-1]) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int arr[] = {1,1,2,3,5,8,13,21,34,55}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // initialize with array cout \u0026lt;\u0026lt; \u0026#34;Output of begin() and end(): \u0026#34;; for (auto i = vec.begin(); i != vec.end(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\nOutput of rbegin() and rend(): \u0026#34;; for (auto i = vec.rbegin(); i != vec.rend(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\nOutput of cbegin() and cend(): \u0026#34;; for (auto i = vec.cbegin(); i != vec.cend(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\nOutput of crbegin() and crend(): \u0026#34;; for (auto i = vec.crbegin(); i != vec.crend(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 結果：\nOutput of begin() and end(): 1 1 2 3 5 8 13 21 34 55 Output of rbegin() and rend(): 55 34 21 13 8 5 3 2 1 1 Output of cbegin() and cend(): 1 1 2 3 5 8 13 21 34 55 Output of crbegin() and crend(): 55 34 21 13 8 5 3 2 1 1 容量(capacity) 1. vec.size() 回傳 vector 的元素數量 2. vec.max_size() 回傳 vector 可以持有的最大元素數量 3. vec.capacity() 回傳 vector 當前被分配到的儲存空間，以元素數目表示 4. vec.empty() 回傳容器是否沒有元素的 5. vec.shrink_to_fit() 將容器的容量縮減到剛好符合它的元素數量，並丟棄所有超出容量的元素 6. vec.resize(int n) 將容器的容量重新調整到 n 個元素的大小 7. vec.reserve(int n) 將容器的容量重新調整到至少可以容納 n 個元素的大小。 #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026#34;print.cc\u0026#34; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec; for (int i = 0; i \u0026lt;= 12; ++i) vec.push_back(i); cout \u0026lt;\u0026lt; \u0026#34;Max_size: \u0026#34; \u0026lt;\u0026lt; vec.max_size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Initial\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; print(vec); cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; vec.resize(8); cout \u0026lt;\u0026lt; \u0026#34;After resize(8)\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; print(vec); cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; vec.shrink_to_fit(); cout \u0026lt;\u0026lt; \u0026#34;After fitting\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; print(vec); cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; vec.reserve(20); cout \u0026lt;\u0026lt; \u0026#34;After reserve(20)\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; print(vec); cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;If the vector is empty: \u0026#34;; vec.empty() ? (cout \u0026lt;\u0026lt; \u0026#34;Empty\u0026#34;) : (cout \u0026lt;\u0026lt; \u0026#34;Not empty\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 結果：\nMax_size: 4611686018427387903 ================================== Initial Size: 13 Capacity: 16 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] ================================== After resize(8) Size: 8 Capacity: 16 [0, 1, 2, 3, 4, 5, 6, 7] ================================== After fitting Size: 8 Capacity: 8 [0, 1, 2, 3, 4, 5, 6, 7] ================================== After reserve(20) Size: 8 Capacity: 20 [0, 1, 2, 3, 4, 5, 6, 7] ================================== If the vector is empty: Not empty 存取元素(access elements) 1. vec[int n] 回傳 n 指標位置的值 2. at(int n) 回傳 n 指標位置的位 3. front() 回傳第一個元素的值 4. back() 回傳最後一個元素的值 5. data() 回傳一個直接的指標指向 vector 的記憶體位置 #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026#34;print.cc\u0026#34; using namespace std; int main(){ int arr[] = {0, 1, 2, 3, 4, 5, 6, 7}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); print(vec); cout \u0026lt;\u0026lt; \u0026#34;vec[2]: \u0026#34; \u0026lt;\u0026lt; vec[2] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;vec.at(4): \u0026#34; \u0026lt;\u0026lt; vec.at(4) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;vec.front(): \u0026#34; \u0026lt;\u0026lt; vec.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;vec.back(): \u0026#34; \u0026lt;\u0026lt; vec.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; int* pos = vec.data(); for (int* i = pos; i != pos + vec.size(); i++){ cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 結果\n[0, 1, 2, 3, 4, 5, 6, 7] vec[2]: 2 vec.at(4): 4 vec.front(): 0 vec.back(): 7 0 1 2 3 4 5 6 7 修改元素(modify elements) 1. assign(int n, E val) 指派新的值到 vector 中，並取代舊的值 2. push_back(E val) 將新的值加到 vector 的尾端 3. pop_back() 將 vector 的尾端的值取出並移除 4. insert(iterator it, E val) 在 vector 的指定位置加入新的值 5. erase(iterator it) 移除 vector 指定位置的移 6. v1.swap(v2) 交換兩個 vector 的值 7. vec.clear() 清除 vector 的所有值 #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026#34;print.cc\u0026#34; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec; cout \u0026lt;\u0026lt; \u0026#34;After assign(5, 10): \\n\u0026#34;; vec.assign(5, 10); print(vec); cout \u0026lt;\u0026lt; \u0026#34;After push_back(15): \\n\u0026#34;; vec.push_back(15); print(vec); int n = vec.size(); cout \u0026lt;\u0026lt; \u0026#34;The last element is: \u0026#34; \u0026lt;\u0026lt; vec.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;After pop_back(): \\n\u0026#34;; vec.pop_back(); print(vec); cout \u0026lt;\u0026lt; \u0026#34;After insert(vec.begin(), 5): \\n\u0026#34;; vec.insert(vec.begin(), 5); print(vec); cout \u0026lt;\u0026lt; \u0026#34;After erase(vec.begin()): \\n\u0026#34;; vec.erase(vec.begin()); print(vec); vec.clear(); cout \u0026lt;\u0026lt; \u0026#34;Vector size after clear(): \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; vector\u0026lt;int\u0026gt; v1, v2; v1.push_back(1); v1.push_back(2); v2.push_back(3); v2.push_back(4); cout \u0026lt;\u0026lt; \u0026#34;Vector 1: \u0026#34;; print(v1); cout \u0026lt;\u0026lt; \u0026#34;Vector 2: \u0026#34;; print(v2); // Swaps v1 and v2 v1.swap(v2); cout \u0026lt;\u0026lt; \u0026#34;After Swap \\nVector 1: \u0026#34;; print(v1); cout \u0026lt;\u0026lt; \u0026#34;Vector 2: \u0026#34;; print(v2); return 0; } 結果\nAfter assign(5, 10): [10, 10, 10, 10, 10] After push_back(15): [10, 10, 10, 10, 10, 15] The last element is: 15 After pop_back(): [10, 10, 10, 10, 10] After insert(vec.begin(), 5): [5, 10, 10, 10, 10, 10] After erase(vec.begin()): [10, 10, 10, 10, 10] Vector size after clear(): 0 Vector 1: [1, 2] Vector 2: [3, 4] After Swap Vector 1: [3, 4] Vector 2: [1, 2] 你可能會想繼續閱讀… 回到容器(Containers) list deque arrays forward_list ","permalink":"http://intervalrain.github.io/posts/c++/stl_vector/","summary":"vector Vectors 是一動態陣列，可以自動的調整其容器的容量。 Vector 的元素被儲存在連續的記憶體空間，所以可以使用迭代器(iterators)來進行存取。 在 vectors 中，元素是被插入在尾端的，插入尾端的時間取決於是否須進行容量的調整。 在 vectors 中，刪除尾端元素的時間複雜度則是固定的\\(O(1)\\)，因為不會發生容量調整。 在 vectors 的前端或中間插入元素或是清除元素，時間的複雜度都是\\(O(n)\\)。 迭代器(Iterators) 1. vec.begin() 回傳指向 vector 中第一個元素的迭代器 (vec[0]) 2. vec.end() 回傳指向 vector 中最後一個元素之後一個的迭代器 (vec[n+1]) 3. vec.rbegin() 回傳指向 vector 中最後一個元素的反向迭代器 (vec[n]) 4. vec.rend() 回傳指向 vector 中第一個元素之前一個的反向迭代器 (vec[-1]) 5. vec.cbegin() 回傳指向 vector 中第一個元素的常數迭代器 (vec[0]) 6. vec.cend() 回傳指向 vector 中最後一個元素之後一個的常數迭代器 (vec[n+1]) 7. vec.crbegin() 回傳指向 vector 中最後一個元素的反向常數迭代器 (vec[n]) 8. vec.crend() 回傳指向 vector 中第一個元素之前一個的反向常數迭代器 (vec[-1]) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int arr[] = {1,1,2,3,5,8,13,21,34,55}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // initialize with array cout \u0026lt;\u0026lt; \u0026#34;Output of begin() and end(): \u0026#34;; for (auto i = vec.","title":"[C++] The C++ Standard Template Library(STL) - vector"},{"content":"容器(Containers) 基礎容器 pair 序列式容器(Sequence Containers) 特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。 vector list, forward_list deque arrays 容器適配器(Container Adaptors) 用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。 queue priority_queue stack 關聯性容器(Associative Containers) 又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。 set multiset map multimap 無序關聯容器(Unordered Associative Containers(C++11)) 通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。 unordered_set unordered_multiset unordered_map unordered_mutlimap 你可能會想繼續閱讀… 演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library ","permalink":"http://intervalrain.github.io/posts/c++/stl_container/","summary":"容器(Containers) 基礎容器 pair 序列式容器(Sequence Containers) 特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。 vector list, forward_list deque arrays 容器適配器(Container Adaptors) 用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。 queue priority_queue stack 關聯性容器(Associative Containers) 又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。 set multiset map multimap 無序關聯容器(Unordered Associative Containers(C++11)) 通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。 unordered_set unordered_multiset unordered_map unordered_mutlimap 你可能會想繼續閱讀… 演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library ","title":"[C++] The C++ Standard Template Library(STL) - Container"},{"content":"前言 在做 WAT 量測後的資料處理時，IDAS 老舊的 VBA macro 執行時間實在過於久，且佔用大量的記憶體，於是就下了一個命題，想減少產生報表的時間。 想法 通常量測多片 wafer 的狀況下，不同 wafer 的排列順序是一致的，如果可以加入 Java 中 HashMap 的資料結構來處理 VBA 中 Lookup()，便可大幅減少 summary table 時，對 rawdata 做搜尋的時間。 令時間複雜度從\\(O(n)\\)進步到\\(O(1)\\)。 做法 產生 Dictionary 物件 由於 VBA 預設並沒有 Dictionary 的物，所以需要用 CreateObject(\u0026quot;Scritping.Dictionary\u0026quot;) 的程式碼，引入 Dictionary。 其 Dictionary 物件的 method 可參考 Microsoft 的文件：點此 在此先預先定義一個 function setDict() 可以對初始化 Dictionary。 接著宣告兩個 Dictionary 物件來存取 spec 和 data 工作頁的列數(\u0008row)。 Dim SpecDict As Object \u0026#39; Claim a dict to store spec rows in worksheet SPEC. Dim DataDict As Object \u0026#39; Claim a dict to store rawdata rows in worksheet Data. Set SpecDict = CreateObject(\u0026#34;Scripting.Dictionary\u0026#34;) Set DataDict = CreateObject(\u0026#34;Scripting.Dictionary\u0026#34;) Call setDict(\u0026#34;SPEC\u0026#34;, 3, SpecDict, Worksheets(\u0026#34;SPEC\u0026#34;).UsedRange, True) Call setDict(\u0026#34;Data\u0026#34;, 2, DataDict, Range(Worksheets(\u0026#34;Data\u0026#34;).Names(1)), True) 實作 setDict() 函數 利用 HashTable 的概念對不同的 parameter 列數先做一次記錄，因為只需一次迴圈，故時間複雜度是 \\(O(n)\\)，其中 n = SPEC 的列數 或是 量測的 parameter 數。 在此設計了五個 arguments，方便在未來如果還有使用到 Dictionary 的需求時，可以方便使用。 sheetName 字串，需要作儲存的工作頁(worksheet)。 Target 要儲存的列數(row)或欄數(column)。 Dict 要存放的 Dictionary 物件。 mRange 要做儲存的資料範圍，若表頭並是在第一列或第一欄時可指定。 若表頭是第一列或第一欄時，可直接代入 Worksheets(\u0026quot;工作頁名稱\u0026quot;).UsedRange byRows 看要儲存的對象是列(row)或是欄(column)，預設是以列來搜尋。 Public Function setDict(ByVal sheetName As String, ByVal Target As Integer, ByRef Dict As Object, ByVal mRange As Range, Optional ByVal byRows As Boolean = True) Dim nowSheet As Worksheet If Not IsExistSheet(sheetName) Then Exit Function Set nowSheet = Worksheets(sheetName) Dim i As Long Dim n As Long On Error Resume Next If byRows = True Then For i = 1 To mRange.Rows.Count If Not Trim(mRange.Cells(i, Target).Value) = \u0026#34;\u0026#34; Then Dict.Add mRange.Cells(i, Target).Value, i End If Next i Else For i = 1 To mRange.Columns.Count If Not Trim(mRange.Cells(Target, i).Value) = \u0026#34;\u0026#34; Then Dict.Add mRange.Cells(Target, i).Value, i End If Next i End If End Function 對 getSPECByPara() 做重製 將 parameter or SPEC 做 hashing 的處理後，可以用 Dictionary 物件來查值，時間複雜度為 \\(O(1)\\)。 在此不對原本的設計做更動，只做單純的 implement。 nowPara 要搜尋的 parameter 字串。 n 要搜尋的欄數(column)，specColumn是原作者預設的 enum，存放工作頁 SPEC 的每一欄的表頭。 \u0008sheetName 要搜尋的工作頁，預設為 SPECTEMP，是按完 initial，從 SPEC 工作頁複製出來的隱藏工作頁。 Public Function getSPECByPara(ByVal nowPara As String, ByVal n As specColumn, Optional sheetName As String = \u0026#34;SPECTEMP\u0026#34;) Dim reValue Dim nowRange As Range Dim TargetSheet As Worksheet If Left(nowPara, 1) = \u0026#34;\u0026#39;\u0026#34; Then nowPara = Mid(nowPara, 2) Set TargetSheet = Worksheets(sheetName) Set nowRange = TargetSheet.UsedRange On Error Resume Next reValue = TargetSheet.Cells(SpecDict(nowPara), n) If Not IsEmpty(reValue) Then If Trim(reValue) = \u0026#34;\u0026#34; Then Set reValue = Nothing End If getSPECByPara = reValue End Function 對 getRangeByPara() 做重製 將 parameter or SPEC 做 hashing 的處理後，可以用 Dictionary 物件來查值，時間複雜度為 \\(O(1)\\)。 Public Function getRangeByPara(nowWafer As String, nowPara As String, Optional dieNum As Integer = 0) Dim nowRow As Long Dim nowRange As Range Set nowRange = Worksheets(\u0026#34;Data\u0026#34;).Range(\u0026#34;wafer_\u0026#34; \u0026amp; nowWafer) Set getRangeByPara = Nothing If DataDict.Exists(nowPara) Then nowRow = DataDict(nowPara) Set getRangeByPara = nowRange.Range(N2L(4) \u0026amp; CStr(nowRow) \u0026amp; \u0026#34;:\u0026#34; \u0026amp; N2L(dieNum + 3) \u0026amp; CStr(nowRow)) End If End Function 解析 優點：較快的執行速度。經測試可以將 2~3 分鐘的執行時間縮短到 30 秒內。 缺點：若修改 rawdata，會發生錯誤。但若針對每一片 wafer 都做 setDict()的話，會浪費太多 memory。 ","permalink":"http://intervalrain.github.io/posts/vba/idas+_record/","summary":"前言 在做 WAT 量測後的資料處理時，IDAS 老舊的 VBA macro 執行時間實在過於久，且佔用大量的記憶體，於是就下了一個命題，想減少產生報表的時間。 想法 通常量測多片 wafer 的狀況下，不同 wafer 的排列順序是一致的，如果可以加入 Java 中 HashMap 的資料結構來處理 VBA 中 Lookup()，便可大幅減少 summary table 時，對 rawdata 做搜尋的時間。 令時間複雜度從\\(O(n)\\)進步到\\(O(1)\\)。 做法 產生 Dictionary 物件 由於 VBA 預設並沒有 Dictionary 的物，所以需要用 CreateObject(\u0026quot;Scritping.Dictionary\u0026quot;) 的程式碼，引入 Dictionary。 其 Dictionary 物件的 method 可參考 Microsoft 的文件：點此 在此先預先定義一個 function setDict() 可以對初始化 Dictionary。 接著宣告兩個 Dictionary 物件來存取 spec 和 data 工作頁的列數(\u0008row)。 Dim SpecDict As Object \u0026#39; Claim a dict to store spec rows in worksheet SPEC.","title":"[IDAS+] Optimize Summary Table Function"},{"content":"cout Functions 設定顯示小數點位數 setprecision(int n) and fixed #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main(){ double a = 5.43/2.653; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.04674 cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; fixed; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.047 return 0; } 顯示 Boolean 值 std::boolalpha #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ bool a = true; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; std::boolalpha; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // true return 0; } ","permalink":"http://intervalrain.github.io/posts/c++/cout/","summary":"cout Functions 設定顯示小數點位數 setprecision(int n) and fixed #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main(){ double a = 5.43/2.653; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.04674 cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; fixed; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.047 return 0; } 顯示 Boolean 值 std::boolalpha #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ bool a = true; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; std::boolalpha; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // true return 0; } ","title":"[C++] Cout functions"},{"content":"演算法(Algorithms) Non-Manupulating Algorithms 1. sort() sort(first_iterator, last_iterator) 對 vector 作排序 2. reverse() reverse(first_iterator, last_iterator) 反轉 vector 的排序 3. *max_element() *max_element(first_iterator, last_iterator) 找出 vector 的最大值 4. *min_element() *min_element(first_iterator, last_iterator)` 找出 vector 的最小值 5. accumulate accumulate(first_iterator, last_iterator, initial value of sum) 計算 vector 的總和 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; using namespace std; void print(vector\u0026lt;int\u0026gt;\u0026amp; vec){ for (vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it != vec.end(); it++){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main(){ int arr[] = {10, 20, 5, 23, 42, 15}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // print initial vector print(vec); // [10, 20, 5, 23, 42, 15] // sort sort(vec.begin(), vec.end()); // [5, 10, 15, 20, 23, 42] print(vec); // reverse reverse(vec.begin(), vec.end()); // [42, 23, 20, 15, 10, 5] print(vec); // max \u0026amp; min cout \u0026lt;\u0026lt; *max_element(vec.begin(), vec.end()) \u0026lt;\u0026lt; endl; // 42 cout \u0026lt;\u0026lt; *min_element(vec.begin(), vec.end()) \u0026lt;\u0026lt; endl; // 5 // accumulate cout \u0026lt;\u0026lt; accumulate(vec.begin(), vec.end(), 0) \u0026lt;\u0026lt; endl; // 115 return 0; } 6. count() count(first_iterator, last_iterator, x) 計算 vector 中 x 的數量 7. find() find(fist_iterator, last_iterator, x) 回傳 vector 中第一個符合的 iterator，若無則傳回 v.end()。 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int arr[] = {10, 20, 5, 23 ,42, 20, 15}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); cout \u0026lt;\u0026lt; count(vec.begin(), vec.end(), 20); // 2 find(vec.begin(), vec.end(),5) != vec.end() ? // Element found cout \u0026lt;\u0026lt; \u0026#34;\\nElement found\u0026#34;: cout \u0026lt;\u0026lt; \u0026#34;\\nElement not found\u0026#34;; return 0; } 8. binary_search() binary_search(first_iterator, last_iterator, x) 測試 x 是否存在已排序的 vector 中 9. lower_bound() lower_bound(first_iterator, last_iterator, x) 傳回指向不大於 x 的元素的 iterator 10. upper_bound() upper_bound(first_iterator, last_iterator, x) 傳回指向大於 x 的元素的 iterator #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ int arr[] = {5, 10, 15, 20, 20, 23, 42, 45}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); sort(vec.begin(), vec.end()); cout \u0026lt;\u0026lt; binary_search(vec.begin(), vec.end(), 20) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; (lower_bound(vec.begin(), vec.end(), 20) - vec.begin()) \u0026lt;\u0026lt; endl; // 3 cout \u0026lt;\u0026lt; (upper_bound(vec.begin(), vec.end(), 20) - vec.begin()) \u0026lt;\u0026lt; endl; // 5 return 0; } Manipulating Algorithms 1. vec.erase() arr.erase(position_to_be_deleted) 移除指定位置的元素 2. vec.erase(unique()) arr.erase(unique(arr.begin(), arr.end()), arr.end()) 移除已排序的 vector 中重複的元素 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ int arr[] = {5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // [5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20] vec.erase(vec.begin() + 1); // [5, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20] sort(vec.begin(), vec.end()); // [5, 15, 20, 20, 20, 20, 20, 20, 20, 23, 42, 45] vec.erase(unique(vec.begin(), vec.end()), vec.end()); // [5, 15, 20, 23, 42, 45] return 0; } 3. next_permutation() next_permutation(first_iterator, last_iterator) 對 vector 作動成下一個字典排序 4. prev_permutation() prev_permutation(first_iterator, last_iterator) 對 vector 作動成上一個字典排序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ int arr[] = {1,2,3,4,5,6,7}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // [1,2,3,4,5,6,7] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,5,7,6] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,5,7] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,7,5,6] prev_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5] return 0; } 5. distance() distance(first_iterator, last_iterator) #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;print.cc\u0026#34; using namespace std; int main(){ int arr[] = {5\u0008,10,15,20,20,23,42,45}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); cout \u0026lt;\u0026lt; distance(vec.begin(), max_element(vec.begin(), vec.end())) \u0026lt;\u0026lt; endl; // 7 // == max_element(vec.begin(), vec.end()) - vec.begin(); return 0; } Array algorithms 1. any_of() any_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否有任何元素滿足條件 2. all_of() all(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否有全部元素滿足條件 3 none_of() none_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否沒有元素滿足條件 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec1 {1,3,7,9,11,17,23}; all_of(vec1.begin(), vec1.end(), [](int x) { return (x \u0026amp; 1) == 1;}) ? cout \u0026lt;\u0026lt; \u0026#34;All odds\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;Not all odds\\n\u0026#34;; vector\u0026lt;int\u0026gt; vec2 {1,3,6,8,9,11,13}; any_of(vec2.begin(), vec2.end(), [](int x) { return (x \u0026amp; 1) == 0;}) ? cout \u0026lt;\u0026lt; \u0026#34;There are at least one even\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;There are no any even\\n\u0026#34;; none_of(vec1.begin(), vec1.end(), [](int x) { return (x \u0026amp; 1) == 0;}) ? cout \u0026lt;\u0026lt; \u0026#34;There are no any even\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;There are at least one even\\n\u0026#34;; return 0; } 4. copy_n() copy_n(source_array, array_size, target_array) 複製陣列 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ int arr[] = {1,2,3,4,5,6}; int arr2[6]; copy_n(arr, 6, arr2); for (int i : arr2){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 5. iota() iota(array_name, array_size, starting_number) 逐一增加並寫入指定大小的陣列 // C++ code to demonstrate working of iota() #include\u0026lt;iostream\u0026gt; #include\u0026lt;numeric\u0026gt; // for iota() using namespace std; int main(){ // Initializing array with 0 values int ar[6] = {0}; // Using iota() to assign values iota(ar, ar+6, 20); // Displaying the new array cout \u0026lt;\u0026lt; \u0026#34;The new array after assigning values is : \u0026#34;; for (int i=0; i\u0026lt;6 ; i++) cout \u0026lt;\u0026lt; ar[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } Partition operations C++ 在標準模板資料庫(STL)中有一個 class 可以來做 partition 的演算法。 Partition 就是用來將容器裡面的元素依指定的條件做分隔。 1. partition() partition(begin, end, conditon) 依照指定條件做分隔。 2. is_partition() is_partitioned(begin, end, condition 判斷元素是否依照條件分開。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec = {2,1,5,6,8,7}; is_partitioned(vec.begin(), vec.end(), [](int x){ return x % 2 == 0; }) ? cout \u0026lt;\u0026lt; \u0026#34;Vector is partitioned\u0026#34;: cout \u0026lt;\u0026lt; \u0026#34;Vector is not partitioned\u0026#34;; cout \u0026lt;\u0026lt; endl; partition(vec.begin(), vec.end(), [](int x){ return x % 2 == 0; }) ? cout \u0026lt;\u0026lt; \u0026#34;The partitioned vector is : \u0026#34;; for (int \u0026amp;x : vec) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 3. stable_partition() stable_partition(begin, end, condition) 依指定條件作分隔，同時保留元素的相對位置。 4. partition_point() partition_point(begin, end, condition) 返回指向分隔位置的迭代器，也就是在 [begin, end] 範圍內的第一個元素。 This function returns an iterator pointing to the partition point of container i.e. the first element in the partitioned range [beg,end) for which condition is not true. The container should already be partitioned for this function to work. // C++ code to demonstrate the working of // stable_partition() and partition_point() #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; // for partition algorithm #include\u0026lt;vector\u0026gt; // for vector using namespace std; int main() { // Initializing vector vector\u0026lt;int\u0026gt; vect = { 2, 1, 5, 6, 8, 7 }; // partitioning vector using stable_partition() // in sorted order stable_partition(vect.begin(), vect.end(), [](int x) { return x%2 == 0;\t}); // Displaying partitioned Vector cout \u0026lt;\u0026lt; \u0026#34;The partitioned vector is : \u0026#34;; for (int \u0026amp;x : vect) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // Declaring iterator vector\u0026lt;int\u0026gt;::iterator it1; // using partition_point() to get ending position of partition auto it = partition_point(vect.begin(), vect.end(), [](int x) { return x%2==0; }); // Displaying partitioned Vector cout \u0026lt;\u0026lt; \u0026#34;The vector elements returning true for condition are : \u0026#34;; for ( it1= vect.begin(); it1!=it; it1++) cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 5. partition_copy() partition_copy(begin, end, begin1, begin2, condition) This function copies the partitioned elements in the different containers mentioned in its arguments. It takes 5 arguments. Beginning and ending position of container, beginning position of new container where elements have to be copied (elements returning true for condition), beginning position of new container where other elements have to be copied (elements returning false for condition) and the condition. Resizing new containers is necessary for this function. // C++ code to demonstrate the working of // partition_copy() #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; // for partition algorithm #include\u0026lt;vector\u0026gt; // for vector using namespace std; int main() { // Initializing vector vector\u0026lt;int\u0026gt; vect = { 2, 1, 5, 6, 8, 7 }; // Declaring vector1 vector\u0026lt;int\u0026gt; vect1; // Declaring vector1 vector\u0026lt;int\u0026gt; vect2; // Resizing vectors to suitable size using count_if() and resize() int n = count_if (vect.begin(), vect.end(), [](int x) { return x%2==0; } ); vect1.resize(n); vect2.resize(vect.size()-n); // Using partition_copy() to copy partitions partition_copy(vect.begin(), vect.end(), vect1.begin(), vect2.begin(), [](int x) { return x%2==0; }); // Displaying partitioned Vector cout \u0026lt;\u0026lt; \u0026#34;The elements that return true for condition are : \u0026#34;; for (int \u0026amp;x : vect1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // Displaying partitioned Vector cout \u0026lt;\u0026lt; \u0026#34;The elements that return false for condition are : \u0026#34;; for (int \u0026amp;x : vect2) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } Numeric algorithms 1. apply() apply([](int x){return operation;}) 對陣列所有元素做運算 2. arr.sum() arr.sum() 計算陣列所有元素的總合 // C++ code to demonstrate the working of // apply() and sum() #include\u0026lt;iostream\u0026gt; #include\u0026lt;valarray\u0026gt; // for valarray functions using namespace std; int main() { // Initializing valarray valarray\u0026lt;int\u0026gt; varr = { 10, 2, 20, 1, 30 }; // Declaring new valarray valarray\u0026lt;int\u0026gt; varr1 ; // Using apply() to increment all elements by 5 varr1 = varr.apply([](int x){return x=x+5;}); // Displaying new elements value cout \u0026lt;\u0026lt; \u0026#34;The new valarray with manipulated values is : \u0026#34;; for (int \u0026amp;x: varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // Displaying sum of both old and new valarray cout \u0026lt;\u0026lt; \u0026#34;The sum of old valarray is : \u0026#34;; cout \u0026lt;\u0026lt; varr.sum() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;The sum of new valarray is : \u0026#34;; cout \u0026lt;\u0026lt; varr1.sum() \u0026lt;\u0026lt; endl; return 0; } 3. arr.min() arr.min() 傳回陣列中最小的元素 4. arr.max() arr.max() 傳回陣列中最大的元素 // C++ code to demonstrate the working of // max() and min() #include\u0026lt;iostream\u0026gt; #include\u0026lt;valarray\u0026gt; // for valarray functions using namespace std; int main() { // Initializing valarray valarray\u0026lt;int\u0026gt; varr = { 10, 2, 20, 1, 30 }; // Displaying largest element of valarray cout \u0026lt;\u0026lt; \u0026#34;The largest element of valarray is : \u0026#34;; cout \u0026lt;\u0026lt; varr.max() \u0026lt;\u0026lt; endl; // Displaying smallest element of valarray cout \u0026lt;\u0026lt; \u0026#34;The smallest element of valarray is : \u0026#34;; cout \u0026lt;\u0026lt; varr.min() \u0026lt;\u0026lt; endl; return 0; } 5. arr.shift() \u0008arr.shift(int n) 對陣列做 n 個位的移動，正為向右移，負為向左移，缺位補零。 6. cshift() arr.cshift(int n) 對陣列做 n 個位的移動，正為向右移，負為向左移，缺位使用循環補位。 // C++ code to demonstrate the working of // shift() and cshift() #include\u0026lt;iostream\u0026gt; #include\u0026lt;valarray\u0026gt; // for valarray functions using namespace std; int main() { // Initializing valarray valarray\u0026lt;int\u0026gt; varr = { 10, 2, 20, 1, 30 }; // Declaring new valarray valarray\u0026lt;int\u0026gt; varr1; // using shift() to shift elements to left // shifts valarray by 2 position varr1 = varr.shift(2); // Displaying elements of valarray after shifting cout \u0026lt;\u0026lt; \u0026#34;The new valarray after shifting is : \u0026#34;; for ( int\u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // using cshift() to circulary shift elements to right // rotates valarray by 3 position varr1 = varr.cshift(-3); // Displaying elements of valarray after circular shifting cout \u0026lt;\u0026lt; \u0026#34;The new valarray after circular shifting is : \u0026#34;; for ( int\u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 7. arr1.swap(arr2) arr1.swap(arr2) 陣列做交換 // C++ code to demonstrate the working of // swap() #include\u0026lt;iostream\u0026gt; #include\u0026lt;valarray\u0026gt; // for valarray functions using namespace std; int main(){ // Initializing 1st valarray valarray\u0026lt;int\u0026gt; varr1 = {1, 2, 3, 4}; // Initializing 2nd valarray valarray\u0026lt;int\u0026gt; varr2 = {2, 4, 6, 8}; // Displaying valarrays before swapping cout \u0026lt;\u0026lt; \u0026#34;The contents of 1st valarray \u0026#34; \u0026#34;before swapping are : \u0026#34;; for (int \u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;The contents of 2nd valarray \u0026#34; \u0026#34;before swapping are : \u0026#34;; for (int \u0026amp;x : varr2) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // Use of swap() to swap the valarrays varr1.swap(varr2); // Displaying valarrays after swapping cout \u0026lt;\u0026lt; \u0026#34;The contents of 1st valarray \u0026#34; \u0026#34;after swapping are : \u0026#34;; for (int \u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;The contents of 2nd valarray \u0026#34; \u0026#34;after swapping are : \u0026#34;; for (int \u0026amp;x : varr2) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0;\t} 你可能會想繼續閱讀… 容器(Containers) 函式(Functions) 迭代器(Iterators) Utility Library ","permalink":"http://intervalrain.github.io/posts/c++/stl_algo/","summary":"演算法(Algorithms) Non-Manupulating Algorithms 1. sort() sort(first_iterator, last_iterator) 對 vector 作排序 2. reverse() reverse(first_iterator, last_iterator) 反轉 vector 的排序 3. *max_element() *max_element(first_iterator, last_iterator) 找出 vector 的最大值 4. *min_element() *min_element(first_iterator, last_iterator)` 找出 vector 的最小值 5. accumulate accumulate(first_iterator, last_iterator, initial value of sum) 計算 vector 的總和 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; using namespace std; void print(vector\u0026lt;int\u0026gt;\u0026amp; vec){ for (vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it != vec.end(); it++){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main(){ int arr[] = {10, 20, 5, 23, 42, 15}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // print initial vector print(vec); // [10, 20, 5, 23, 42, 15] // sort sort(vec.","title":"[C++] The C++ Standard Template Library(STL) - Algorithm"},{"content":"STL \u0008標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。\nSTL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。\nSTL 的四大組成 演算法(Algorithms) 容器(Containers) 函式(Functions) 迭代器(Iterators) 補充 Utility Library ","permalink":"http://intervalrain.github.io/posts/c++/stl/","summary":"STL \u0008標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。\nSTL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。\nSTL 的四大組成 演算法(Algorithms) 容器(Containers) 函式(Functions) 迭代器(Iterators) 補充 Utility Library ","title":"[C++] The C++ Standard Template Library(STL)"},{"content":"vector 的介紹 vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include \u0026lt;vector\u0026gt; vector 的使用 建構式 constructor vector\u0026lt;int\u0026gt; v1; // 不進行初始化 vector\u0026lt;int\u0026gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector\u0026lt;int\u0026gt; v3(v2); // 利用vector初始化 vector\u0026lt;int\u0026gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector\u0026lt;int\u0026gt; v5(3, 0); // 含有3個0的vector 談一下特殊的二維vector，其實就是二維矩陣，寫法為 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vv(3, vector\u0026lt;int\u0026gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse 遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。 vector\u0026lt;int\u0026gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3}; // 1. iterator vector\u0026lt;int\u0026gt;::iterator it = v.begin(); while (it != v.end()){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; it++; } cout \u0026lt;\u0026lt; endl; // 2. for loop for (int e : v){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } // 3. [] for (size_t i = 0; i \u0026lt; v.size(); ++i){ cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } 資料的資刪查改 \\( \\def\\arraystrecth{1.4}\\begin{array}{|l|l|}\\hline \\text{methods}\u0026amp;\\text{description}\\\\\\hline\\hline \\text{push\\_back}\u0026amp;\\text{Add element at the end}\\\\\\hline \\text{pop\\_back}\u0026amp;\\text{Delete last element}\\\\\\hline \\text{insert}\u0026amp;\\text{Insert elements}\\\\\\hline \\text{erase}\u0026amp;\\text{Erase elements}\\\\\\hline \\end{array} \\)\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec; vec.push_back(0); [0] vec.push_back(1); [0,1] vec.push_back(3); [0,1,3] vec.push_back(4); [0,1,3,4] vec.pop_back(); [0,1,3] vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); vec.insert(it + 2, 2); // 在下標為1的位置，插入2 [0,1,2,3] vec.erase(it); [1,2,3] return 0; } resize 和 reserve int main(){ cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 0 cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 0 v.resize(30); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30 cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30 v.reservse(50); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30 cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 50 } vector 的實作 member variables template \u0026lt;class T\u0026gt; class myVector{ private: size_t _size; // 儲存現有 elements 的數目 size_t _capacity; // 此時陣列所有的最大容量 public: T* arr; // 儲存 elements 的陣列指標 }; 建構式 constructor public: // 無引數的初始化 myVector(){ this-\u0026gt;_size = 0; this-\u0026gt;_capacity = DEFAULT_CAPACITY; this-\u0026gt;arr = new int[this-\u0026gt;_capacity]; } // 指定容量的初始化 myVector(int capacity){ this-\u0026gt;_size = 0; this-\u0026gt;_capacity = capacity; this-\u0026gt;arr = new int[this-\u0026gt;capacity]; } // 以另一個 myVector 初始化 myVector(const myVector\u0026lt;T\u0026gt;\u0026amp; v): _size(v.size), _capacity(v._capacity) { this-\u0026gt;reserve(v.capacity); for (size_t i = 0; i \u0026lt; v._size; ++i){ this-\u0026gt;push_back(v[i]); } } // 填滿 n 個 val 的初始化 myVector(size_t n, T val): _size(n), _capacity(n) { this-\u0026gt;arr = new int[this-\u0026gt;_capacity]; for (size_t i = 0; i \u0026lt; n; ++i){ this-\u0026gt;arr[i] = val; } } 解構式 destructor public: ~myVector(){ // 將原有的陣列丟棄 delete[] this-\u0026gt;arr; } 運算子多載 operator overload public: // 令 myVector 可讀可寫 T\u0026amp; operator[](size_t i){ assert (i \u0026lt; this-\u0026gt;_size); return this-\u0026gt;arr[i]; } 函式 Methods public: // 回傳 vector 元素的數目 size_t size(){ return this-\u0026gt;_size; } // 回傳當前 vector 的容量 size_t capacity(){ return this-\u0026gt;_capacity; } // 回傳指向陣列的下標 0 位置 T* begin(){ return this-\u0026gt;arr; } // 回傳指向陣列的最末位 + 1 T* end(){ return this-\u0026gt;arr + this-\u0026gt;_size; } const T* begin() const{ return this-\u0026gt;arr; } const T* end() const{ return this-\u0026gt;arr + this-\u0026gt;_size; } // 回傳此 myVector 是否含有元素 bool isEmpty(){ return this-\u0026gt;_size == 0; } reserve 和 resize public: // force to resize with a n capacity void reserve(size_t n){ if (n \u0026gt; this-\u0026gt;_capacity){ T* tmp = new T[n]; if (arr != nullptr){ for (size_t i = 0; i \u0026lt; this-\u0026gt;_size; ++i){ tmp[i] = this-\u0026gt;arr[i]; } delete[] this-\u0026gt;arr; } this-\u0026gt;arr = tmp; _capacity = n; } } // expand the capacity while adding elements void resize(){ this-\u0026gt;_capacity *= 2; int* tmp = new int[this-\u0026gt;_capacity]; for (size_t i = 0; i \u0026lt; this-\u0026gt;_size; ++i){ tmp[i] = this-\u0026gt;arr[i]; } delete[] this-\u0026gt;arr; this-\u0026gt;arr = tmp; } 資料的增刪查改 public: // adding elements in the last of vector void push_back(T val){ if (this-\u0026gt;_capacity \u0026lt; this-\u0026gt;_size + 1) resize(); this-\u0026gt;arr[this-\u0026gt;_size] = val; this-\u0026gt;_size++; } // remove elements in the last of vector T pop_back(){ assert(!this-\u0026gt;isEmpty()); T tmp = *(this-\u0026gt;end()-1); this-\u0026gt;_size--; return tmp; } // insert element by the index. void insert(size_t i, T val){ assert (i \u0026lt;= this-\u0026gt;_size); if (this-\u0026gt;_size + 1 \u0026gt; this-\u0026gt;capacity()) resize(); int* ptr = this-\u0026gt;begin() + i; for (int* it = this-\u0026gt;end(); it != ptr; --it) *it = *(it - 1); *ptr = val; this-\u0026gt;_size++; } //erase element by the index T erase(size_t i){ assert(i \u0026lt; this-\u0026gt;_size); int* it = this-\u0026gt;begin() + i; T tmp = *it; for (; it != this-\u0026gt;end(); ++it){ *it = *(it + 1); } this-\u0026gt;_size--; return tmp; } Reference: 有解無憂 UJ5U.com\n","permalink":"http://intervalrain.github.io/posts/c++/vector/","summary":"vector 的介紹 vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include \u0026lt;vector\u0026gt; vector 的使用 建構式 constructor vector\u0026lt;int\u0026gt; v1; // 不進行初始化 vector\u0026lt;int\u0026gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector\u0026lt;int\u0026gt; v3(v2); // 利用vector初始化 vector\u0026lt;int\u0026gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector\u0026lt;int\u0026gt; v5(3, 0); // 含有3個0的vector 談一下特殊的二維vector，其實就是二維矩陣，寫法為 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vv(3, vector\u0026lt;int\u0026gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse 遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。 vector\u0026lt;int\u0026gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3}; // 1.","title":"[C++] STL: Vector 的使用與實作"},{"content":"TCAD 常用的三種程式語言 工具語言 用於操作 Sentaurus 工具的指令，例如： snmesh sdevice 預處理語言 Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro) 例如： #define __x__ 1 // 將所有 __x__ 字串取代成字串 1 TCL 公用語言，通常用來處理字串與數據。 範例 SPP 語言：@...@、#開頭的敘述都是 SPP 語言 #if \u0026#34;@tunneling@ == \u0026#34;Hurkx\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1_5\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E2\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif TCL 語言：set 與 puts 其中 @\u0026hellip;@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 .cmd 檔。 set A [expr -@BF_Thick@-@AB_Thick@-@GR_Thick@-@CH_Thick@-@ML_Thick@] puts \u0026#34;DOE: Xmin [format %.2f $A]\u0026#34; ","permalink":"http://intervalrain.github.io/posts/device/tcad/","summary":"TCAD 常用的三種程式語言 工具語言 用於操作 Sentaurus 工具的指令，例如： snmesh sdevice 預處理語言 Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro) 例如： #define __x__ 1 // 將所有 __x__ 字串取代成字串 1 TCL 公用語言，通常用來處理字串與數據。 範例 SPP 語言：@...@、#開頭的敘述都是 SPP 語言 #if \u0026#34;@tunneling@ == \u0026#34;Hurkx\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1_5\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E2\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif TCL 語言：set 與 puts 其中 @\u0026hellip;@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 .","title":"[TCAD] 工具語言"},{"content":"計算機的抽象化與科技 電腦的定義 一種可以進行計算的裝置，特指可編程(programmable) 且可執行高速的數學或邏輯的運算，或可收集、儲存、處理資料的電子器械。 一般用途 or 特別用途 可編程 or 不可編程 科學用 or 商務 機械械 or 電子式 or 電機 \u0026hellip; Instruction 與 data 分開儲存的結構稱為 哈佛架構Harvard Architecture\u0008 電腦的歷史 ENIAC (Electronic Numberical Integrator and Calculator) 1943 - 1946 at the University of Pennsylvania 約 25 公尺長、2.5 公尺高 由真空管製成: 耗能、易燒壞KJKKI 1900個加法/每秒 商業化、電晶體的發現 in 1947 使用電晶體的電腦 (IBM 14001, Big Blue) in 1959 IC(Integrated Circuit) in 1958 at 德儀 微處理器(Intel 4004) in 1971 Apple II in 1977 個人電腦(IBM PC) in 1981 IBM 開放式系統(open system)使得周邊設備大量的發展 Xerox PARC Alto: 具備滑鼠、以太網路、點陣圖、按鍵、菜單、WYSIWYG編輯器 區域網路 雷射列印 client / server 分散式計算 應用程式 VisiCalc for Applie II in 1979 超大型積體電路 VLSI(Very-Large-Scale Integration) RISC(Reduced Instruction Set Computer) 的出現，對應於 CISC(Complex Instruction Set Computer) RISC: MIPS CISC: Intel x86 processor Post PC Era: Embedded Computer 冰箱、手機、手錶… 電腦的發展 應用 行動電腦 手機 人類基因體計畫 世界網路 搜尋引擎 摩爾定律 Moore\u0026rsquo;s Law Line Width/Feature Size: 電晶體的 Source 與 Drain 的距離，約是 gate length。 電腦的分類 通用電腦 特性： 軟體相容性 產品生命週期短 更好的效能(more transistors)與人機介面 個人電腦 Personal Computers 一般用途、軟體多樣性 取決於成本與效能的權衡 伺服器電腦 Server Computers 基於網路的 高容量、效能、可靠度 範圍可小至伺服，大至建築 超級電腦 Supercomputers 高端的科學與工程計算 最高的效能，但小的市佔 特殊用途電腦 特性： 通常沒有浮點數、記憶體管理 會與各種功能的外部裝置(peripherals)協作 e.g. DSP 多元的 ISA、效能、外部裝置 較不需考量相容性(通常是 pre-determined program)，ISA更簡單、低功耗 更多元的結構、生命週期更長 高產低銷 (Large volume sale and low price) 趨勢：低成本、更多功 SoC(system-on-chip)、micro P core on ASIC 嵌入式電腦 Embedded Computers 隱身在系統中 嚴格的功耗、效能、成本考量 ","permalink":"http://intervalrain.github.io/posts/ca/lec1/","summary":"計算機的抽象化與科技 電腦的定義 一種可以進行計算的裝置，特指可編程(programmable) 且可執行高速的數學或邏輯的運算，或可收集、儲存、處理資料的電子器械。 一般用途 or 特別用途 可編程 or 不可編程 科學用 or 商務 機械械 or 電子式 or 電機 \u0026hellip; Instruction 與 data 分開儲存的結構稱為 哈佛架構Harvard Architecture\u0008 電腦的歷史 ENIAC (Electronic Numberical Integrator and Calculator) 1943 - 1946 at the University of Pennsylvania 約 25 公尺長、2.5 公尺高 由真空管製成: 耗能、易燒壞KJKKI 1900個加法/每秒 商業化、電晶體的發現 in 1947 使用電晶體的電腦 (IBM 14001, Big Blue) in 1959 IC(Integrated Circuit) in 1958 at 德儀 微處理器(Intel 4004) in 1971 Apple II in 1977 個人電腦(IBM PC) in 1981 IBM 開放式系統(open system)使得周邊設備大量的發展 Xerox PARC Alto: 具備滑鼠、以太網路、點陣圖、按鍵、菜單、WYSIWYG編輯器 區域網路 雷射列印 client / server 分散式計算 應用程式 VisiCalc for Applie II in 1979 超大型積體電路 VLSI(Very-Large-Scale Integration) RISC(Reduced Instruction Set Computer) 的出現，對應於 CISC(Complex Instruction Set Computer) RISC: MIPS CISC: Intel x86 processor Post PC Era: Embedded Computer 冰箱、手機、手錶… 電腦的發展 應用 行動電腦 手機 人類基因體計畫 世界網路 搜尋引擎 摩爾定律 Moore\u0026rsquo;s Law Line Width/Feature Size: 電晶體的 Source 與 Drain 的距離，約是 gate length。 電腦的分類 通用電腦 特性： 軟體相容性 產品生命週期短 更好的效能(more transistors)與人機介面 個人電腦 Personal Computers 一般用途、軟體多樣性 取決於成本與效能的權衡 伺服器電腦 Server Computers 基於網路的 高容量、效能、可靠度 範圍可小至伺服，大至建築 超級電腦 Supercomputers 高端的科學與工程計算 最高的效能，但小的市佔 特殊用途電腦 特性： 通常沒有浮點數、記憶體管理 會與各種功能的外部裝置(peripherals)協作 e.","title":"[CA] Lec 1 - Computer Abstraction and Technology"},{"content":"計算機結構簡介 二進制 從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。 現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。 電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機 計算機結構/組織 計算機結構 Computer Architecture 處理器(processor) Control Datapath 記憶體(memory) 裝置(Devices) Input: 鍵盤、滑鼠、磁碟 Output: 磁碟、顯示器、影印機 計算機組織 Computer Organization(架構) 功能元件的性能: registers, ALU, shifters Structure Dataflow Control logic Register Transfer Level(RTL) description 計算機結構 Computer Architecture = Instruction Set Architecture(ISA) + Machine Organization Software 與 Hardware 間的 interface。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。 選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置 指令集Instruction Set Architecture(ISA) 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) Instruction Set Instruction Formats 讀寫資料的模式與指令 例外狀況 e.g. Intel(CISC)、Arm(RISC) CISC: Complex Instruction Set Computer RISC: Reduced Instruction Set Computer [目錄] Chapter 1. Computer Abstractions and Technology Chapter 2. Instruction Set Architecture Chapter 3. Computer Arithmetic Chapter 4. Designing a Single-Cycle Processor Chapter 5. Pipelining Chapter 6. Memory Hierarchy ","permalink":"http://intervalrain.github.io/posts/ca/lec0/","summary":"計算機結構簡介 二進制 從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。 現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。 電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機 計算機結構/組織 計算機結構 Computer Architecture 處理器(processor) Control Datapath 記憶體(memory) 裝置(Devices) Input: 鍵盤、滑鼠、磁碟 Output: 磁碟、顯示器、影印機 計算機組織 Computer Organization(架構) 功能元件的性能: registers, ALU, shifters Structure Dataflow Control logic Register Transfer Level(RTL) description 計算機結構 Computer Architecture = Instruction Set Architecture(ISA) + Machine Organization Software 與 Hardware 間的 interface。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。 選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置 指令集Instruction Set Architecture(ISA) 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) Instruction Set Instruction Formats 讀寫資料的模式與指令 例外狀況 e.","title":"[CA] Lec 0 - Introduction to Computer Architecture"},{"content":"題目 題目描述 設計一個類似 stack 的資料結構，實行 push() 跟 pop() 的功能，其中 pop() 會丟出 stack 中出現最多次的元素。 FreqStack class 必須實現： FreqStack() 建構子必須初始化一個空的 FreqStack。 void push(int val) 將 val 推至 stack 的頂端。 int pop() 將 stack 中最頻繁出現的元素移除，並返回。 如果 stack 中最頻繁出現的元素出現平手的狀況，則返回平手的元素中最接近 stack 頂端的元素。 題目範例 輸入\n[\u0026ldquo;FreqStack\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n輸出\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n說明\nFreqStack freqStack = new FreqStack(); freqStack.push(5); // The stack is [5] freqStack.push(7); // The stack is [5,7] freqStack.push(5); // The stack is [5,7,5] freqStack.push(7); // The stack is [5,7,5,7] freqStack.push(4); // The stack is [5,7,5,7,4] freqStack.push(5); // The stack is [5,7,5,7,4,5] freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. freqStack.pop(); // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,4]. freqStack.pop(); // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]. 解題 想法 在解題時，我打算在 push 時動手腳，將 push 的元素直接 push 到對的位置後，執行 pop 的動作時，就只要將最頂端的元素取出即可。 FreqStack freqStack = new FreqStack(); freqStack.push(5); // [5] freqStack.push(7); // [5,7] freqStack.push(5); // [5,7,5] freqStack.push(7); // [5,7,5,7] freqStack.push(4); // [5,7,5,7,4] // 此時 4 因為並非最頻繁的元素，所以要將 4 往下推，即變成 [5,7,4,5,7] freqStack.push(5); // [5,7,4,5,7,5] freqStack.pop(); // return 5, [5,7,4,5,7] freqStack.pop(); // return 7, [5,7,4,5] freqStack.pop(); // return 5, [5,7,4] freqStack.pop(); // return 4, [5,7] 為了實現以上的想法，我試想將出現次數相同的元素放在同一個 stack，取出時則從頻率最高的 stack 開始取，即為： freqStack[0] = [5,7,4] // 檢查元素是否出現在 freqStack[0] 否則則往freqStack[1] 移動 freqStack[1] = [5,7] freqStack[2] = [5] // pop 的時候，從freqStack[2] 開始取，空了則將 freqStack[2] 移除 實作1: List of Stacks public class freqStack{ // Field List\u0026lt;Stack\u0026lt;Integer\u0026gt;\u0026gt; stacks; // Constructor public freqStack(){ stacks = new ArrayList\u0026lt;\u0026gt;(); } // Methods public void push(int val){ push(val, 0); } private void push(int val, int freq){ // 當 stacks[freq] 是空的時候，則新建一個 stack。 Stack\u0026lt;Integer\u0026gt; stack; if (freq \u0026gt;= stacks.size()){ stack = new Stack\u0026lt;\u0026gt;(); stacks.add(stack); } else { stack = stacks.get(freq); } // 當該 stacks[freq] 已經有該元素，則往下一個 stacks 找 if (stack.contains(val)){ push(val, freq + 1); } else { stack.push(val); } } public int pop(){ // 直接找到最高的 stack，然後把頂端的元素 pop 出。 Stack\u0026lt;Integer\u0026gt; stack = stacks.get(stacks.size() - 1); int top = stack.pop(); if (stack.isEmpty()){ stacks.remove(stacks.size() - 1); } return top; } } 然而，此時 push 的 \u0008complexity 與欲 push 的元素的出現次數 n 有關，元素出現 n 次，則需要往下找 n 個 stack，也就是 \\(O(n)\\)。 實作2: Use HashMap to record freqency 為了優化，我們可以加入一個 HashMap 來記錄出現的次數，再下次要 push 此元素時，只需要到 HashMap 中查詢出現的次數即可。 public class freqStack{ // Field List\u0026lt;Stack\u0026lt;Integer\u0026gt;\u0026gt; stacks; Map\u0026lt;Integer, Integer\u0026gt; map; // 用來記錄出現次數 // Constructor public freqStack(){ stacks = new ArrayList\u0026lt;\u0026gt;(); map = new HashMap(); } // Methods public void push(int val){ Stack\u0026lt;Integer\u0026gt; stack; // 還沒有此出現次數的元素出現，則新增此 stack if (stacks.size() \u0026lt; map.getOrDefault(val, 0) + 1){ stack = new Stack\u0026lt;\u0026gt;(); } else { // 取得此元素出現的次數，若沒出現過則取得 stacks[0] stack = stacks.get(map.getOrDefault(val, 0)); } stack.push(val); map.put(val, map.getOrDefault(val, 0) + 1); // 更新出現次數 } public int pop(){ // 直接找到最高的 stack，然後把頂端的元素 pop 出。 Stack\u0026lt;Integer\u0026gt; stack = stacks.get(stacks.size() - 1); int top = stack.pop(); map.put(val, map.get(val) - 1); // 更新出現次數 if (stack.isEmpty()){ stacks.remove(stacks.size() - 1); } return top; } } 程式碼 題解：請點此 測試檔：請點此 Reference: Leetcode: 895. Maximum Frequency Stack\n","permalink":"http://intervalrain.github.io/posts/algorithm/freqstack/","summary":"題目 題目描述 設計一個類似 stack 的資料結構，實行 push() 跟 pop() 的功能，其中 pop() 會丟出 stack 中出現最多次的元素。 FreqStack class 必須實現： FreqStack() 建構子必須初始化一個空的 FreqStack。 void push(int val) 將 val 推至 stack 的頂端。 int pop() 將 stack 中最頻繁出現的元素移除，並返回。 如果 stack 中最頻繁出現的元素出現平手的狀況，則返回平手的元素中最接近 stack 頂端的元素。 題目範例 輸入\n[\u0026ldquo;FreqStack\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n輸出\n[null, null, null, null, null, null, null, 5, 7, 5, 4]","title":"[Algorithm] Maximum Frequency Stack 最大頻率堆疊"},{"content":"1. 請說明 Final, Finally, Finalize 三者不同? Final: 一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。 Finally: 例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。 Finalize: 是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。 2. 請說明 String 字串中 == 與 .equals() 哪裡不同? ==:\n比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。 equals():\n是 String 覆寫後的 equals 方法，比較值。 補充：\nJava 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。 若使用 String s1 = \u0026quot;Hello World\u0026quot;; 來宣告，則會透過字串池。 若使用 String s2 = new String(\u0026quot;Hello World\u0026quot;) 來宣告，則字串會存在 Heap 中，與上者的址不同。 3. 使用 \u0026ldquo;abc\u0026rdquo;.equals(s) 比較好還是 s.equals(\u0026ldquo;abc\u0026rdquo;)? 等效。 前者不會出現 NullPointerException。 4. Arrays 與 ArrayList 的差異? Arrays 可包含原始(primitive)及物件(object)，ArrayList只允許物件。 Arrays 大小固定，ArrayList 可動態調整。 ArrayList 提供許多方法，如 removeAll、iterator等。 5. stack 與 heap 的區別? stack: 可被預測生命週期的變數或函數資訊都放在 stack，例如：區域變數(local variable)、物件或陣列的返回位址(function/method return address)等資訊。 heap: 動態配置的記憶體空間，放置被 new 出來的物件以及內含的成員變數。 6. Arrays 與 String 的大小 Arrays 有 length 這個屬性。 String 有 legnth() 這個方法。 7. throw 與 throws 的區別 throws: throws 關鍵字通常被應用在聲明方法時，放在方法的大括號前，用來拋出異常，多個異常可以使用逗號隔開。後續使用者要調用方法時必須要拋出異常或者使用 try-catch 語句處理異常。 throw: throw 關鍵字通常用在設計方法時，預先宣告可能會產生的例外，後續方法使用者需要使用 try-catch 處理例外，或者使用 throws 關鍵字再拋出例外。 補充： throw 用於方法內，throws 用於方法的聲明。 throw 用於方法內拋出異常，throws 用於方法聲明上拋出異常。 throw 後面只能有一個異常，throws 可以聲明多個異常。 8. int 和 Integer 何者會占用更多記憶體? Integer，Integer 是一個物件，會在 heap 中儲存，並儲存址的值到 stack 中，而 int 只會保存值在 stack 中。 9. 是否能將 int 強制轉型為 byte? 可以，可以使用 b = (byte) a 來進行強制轉換，但是超過範圍的部分會被丟棄。 10. 是否能保證 gc 的執行? 否，垃報回收機制程式設計師無法保證，但可以透過 System.gc() 呼叫。 11. abstract class 與 interface 的區別? abstract class 可以宣告抽象方法，提供子類別實作。 interface 的方法必定是抽象方法。 一個類別可以繼承多個介面，但只能繼承一個抽象類別。 12. List 與 Set 區別? List: 有順序性(索引值)。 可重複。 ArrayList 實作了 List 介面。 ArrayList: 插入、刪除速度 \\(O(n)\\)，走訪速度\\(O(1)\\)。 \u0008LinkedList: 插入、刪除速度 \\O(1)\\)，走訪速度\\(O(n)\\)。 Set 無順序性(配合 iterator) 不可重複，走訪速度\\(O(1)\\)。 HashSet 實作了 Set 介面。 HashSet: 無順序性，查找速度快。 LinkedHashSet: 有順序性 TreeSet: 有排序性(依字母) Map 1.有元素鍵值(Key-Value)，搜尋快 2.元素可重複，鍵值如果重複新加入值會覆蓋舊有值 3.HashMap: 查找速度慢，插入刪除速度快 4.TreeMap: 有排序性 ","permalink":"http://intervalrain.github.io/posts/java/interviewq/","summary":"1. 請說明 Final, Finally, Finalize 三者不同? Final: 一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。 Finally: 例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。 Finalize: 是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。 2. 請說明 String 字串中 == 與 .equals() 哪裡不同? ==:\n比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。 equals():\n是 String 覆寫後的 equals 方法，比較值。 補充：\nJava 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。 若使用 String s1 = \u0026quot;Hello World\u0026quot;; 來宣告，則會透過字串池。 若使用 String s2 = new String(\u0026quot;Hello World\u0026quot;) 來宣告，則字串會存在 Heap 中，與上者的址不同。 3.","title":"[Java] 面試常見問題"},{"content":"C 當我們要去評價程式碼的品質時，我們會考慮以下元素： 正確性(correctness): 程式碼是否有正確的解決我們的問題 設計(design): 程式碼的好壞決定於它的效率與可讀性 風格(style): 程式碼在視覺上是否有良好的format 我們的第一個 C 語言程式： #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello, world\\n\u0026#34;); } 整合開發環境、編譯器、介面 IDEs, compilers, interfaces 在執行程式前，我們必須將程式碼轉變成電腦可讀的 binary codes，也就是 0 與 1。 IDE(integrated development environments) 可以協助我們開發、編譯程式碼。如Visual Studio Code 我們撰寫的程式碼為開源碼(source code)，我們必須將他轉變成機器碼(machine code)，才能被電腦執行。 編譯器(compiler)是將一種語言轉變成另一種語言的程式，例如將開源碼編譯成機器碼。 在 IDE 中，我們可以在一個叫作 terminal 的視窗中輸入指令。 terminal 提供了 command-line interface(CLI) 當我們輸入 make hello，會產生一個叫作 hello 的檔案，我們可以透過輸入 ./hello 執行它。 . 代表當下的目錄，上面的指令代表我們要執行當下目錄中叫作 hello 的檔案。 hello 即是內含機器碼的檔案。 欲刪除檔案可以用 rm 指令。 輸入 ls 列出當下目錄所包含的檔案。 若源碼檔經過修過，則必須重新編譯，才能對執行檔進行修改。 函式、引數、傳回值、變數 Functions, Arguments, Return Values, Variables printf(\u0026#34;Hello, world\u0026#34;); 此處，介紹一個叫作 printf 的函數 f 代表 formatted 的字串。字串是多個字元(characters)組成的字詞，在 C 中，我們需要用雙引號(\u0026quot;\u0026quot;)來包住它。 括號 () 使我們可以輸入引數，也就是 printf 函數的 input。 最後，我們需要分號 ;，來宣告述句的結束。 其中，函式的一種產物叫作 side effect，也就是我們可以觀察到的變化，如螢幕印出字樣，或是發出聲響。 相比與 **side effects，我們也可以將函式的回傳值用於程式中，回傳值通被儲存於變數中。 string answer = get_string(\u0026#34;What\u0026#39;s your name? \u0026#34;); 此處，示範 CS50 IDE 中的一個函數。 這裡的 get_string為函式，而What's your name? 為引數。 然後，我們可以將回傳值存入到變數中，以上例，我們可利用賦值運算子(=)將右值(r_value)傳給左值(l_value)的answer。 最後，我們宣告變數的變數型別(type)。 如果我們嘗試將上述的變數改為其他變數型別，編譯器會顯示錯誤。 printf(\u0026#34;Hello, world\\n\u0026#34;); 我們此處為了換行，而使用了 escape sequence \\n。 ","permalink":"http://intervalrain.github.io/posts/cs50/lec1/","summary":"C 當我們要去評價程式碼的品質時，我們會考慮以下元素： 正確性(correctness): 程式碼是否有正確的解決我們的問題 設計(design): 程式碼的好壞決定於它的效率與可讀性 風格(style): 程式碼在視覺上是否有良好的format 我們的第一個 C 語言程式： #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello, world\\n\u0026#34;); } 整合開發環境、編譯器、介面 IDEs, compilers, interfaces 在執行程式前，我們必須將程式碼轉變成電腦可讀的 binary codes，也就是 0 與 1。 IDE(integrated development environments) 可以協助我們開發、編譯程式碼。如Visual Studio Code 我們撰寫的程式碼為開源碼(source code)，我們必須將他轉變成機器碼(machine code)，才能被電腦執行。 編譯器(compiler)是將一種語言轉變成另一種語言的程式，例如將開源碼編譯成機器碼。 在 IDE 中，我們可以在一個叫作 terminal 的視窗中輸入指令。 terminal 提供了 command-line interface(CLI) 當我們輸入 make hello，會產生一個叫作 hello 的檔案，我們可以透過輸入 ./hello 執行它。 . 代表當下的目錄，上面的指令代表我們要執行當下目錄中叫作 hello 的檔案。 hello 即是內含機器碼的檔案。 欲刪除檔案可以用 rm 指令。 輸入 ls 列出當下目錄所包含的檔案。 若源碼檔經過修過，則必須重新編譯，才能對執行檔進行修改。 函式、引數、傳回值、變數 Functions, Arguments, Return Values, Variables printf(\u0026#34;Hello, world\u0026#34;); 此處，介紹一個叫作 printf 的函數 f 代表 formatted 的字串。字串是多個字元(characters)組成的字詞，在 C 中，我們需要用雙引號(\u0026quot;\u0026quot;)來包住它。 括號 () 使我們可以輸入引數，也就是 printf 函數的 input。 最後，我們需要分號 ;，來宣告述句的結束。 其中，函式的一種產物叫作 side effect，也就是我們可以觀察到的變化，如螢幕印出字樣，或是發出聲響。 相比與 **side effects，我們也可以將函式的回傳值用於程式中，回傳值通被儲存於變數中。 string answer = get_string(\u0026#34;What\u0026#39;s your name?","title":"[CS50] Lec 1 - C"},{"content":"1. transient 的作用及使用方法 當一個物件繼承(implements)了 Serializable 介面，這個物件就可以被序列化，Java 的序列化模式為開發者提供了許多便利，開發者可以不必關心具體序列化的過程，只要繼承了 Serializable 介面，該類別(class)的所有屬性(property)和方法(method)都會自動序列化。 然而在實際開發過程中，有些屬性需要序列化，有些屬性則不需要。 用戶的私密訊息如密碼、銀行帳號等，通常不希望在網路操作時被傳輸。 此時，便可在這些對應的變數前加上 transient。 如此一來，這些私密訊息的生命週期只會存在於調用者的記憶體(memory)中，不會寫到磁碟(disk)裡。 注意讀取時，讀取數據的順序一定要和存放數據的順序保持一致。\n範例： import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; import java.io.Serializable; public class TransientExample { public static void main(String[] args){ User user = new User(); user.setUsername(\u0026#34;Rain\u0026#34;); user.setPassword(\u0026#34;12345678\u0026#34;); System.out.println(\u0026#34;Read before Serializable: \u0026#34;); System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername()); System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword()); try { ObjectOutput os = new ObjectOutputStream(new FileOutputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;)); os.writeObject(user); os.flush(); os.close(); } catch (FileNotFoundException e){ e.printStackTrace(); } catch (IOException e){ e.printStackTrace(); } try { ObjectInputStream is = new ObjectInputStream(new FileInputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;)); user = (User) is.readObject(); is.close(); System.out.println(\u0026#34;Read after Serializable: \u0026#34;); System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername()); System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword()); } catch (FileNotFoundException e){ e.printStackTrace(); } catch (IOException e){ e.printStackTrace(); } catch (ClassNotFoundException e){ e.printStackTrace(); } } } class User implements Serializable{ private static final long serialVersionID = 8294180014912103005L; private String username; private transient String password; public String getUsername(){ return username; } public void setUsername(String username){ this.username = username; } public String getPassword(){ return password; } public void setPassword(String password){ this.password = password; } } 輸出的結果是： Read before Serializable:\nUsername: Rain\nPassword: 12345678\nRead after Serializable:\nUsername: Rain\nPassword: null\n也就是說反序列化並沒有成功從文件獲取到訊息。 2. transient 的小結 一旦變數被 transient 修飾，變數將不再是物件持久化的一部分，該變敗內容將在序列化後無法再次訪問。 transient 關鍵字只能飾飾變數(variable)，不能修飾方法(method)和類別(class)。注意，區域變數是無法被 transient 修飾的。 被 transient 修飾的變數不能再被序列化，一個靜態變數不管是否被 transient 修飾，都不能被序列化。 其中，在上例中的 username 帶有 static 關鍵字，實際上是沒有被序列化的，也就是說我們在讀取之前改變 username 的值，讀取完並不會改變 username 的值，而是 JVM 中對應靜態變數的值。 3. 當遇上了 Externalizable 當被 transient 修飾的變數在存於一個繼承了 Externalizable 的介面，則代表沒有任何東西被自動序列化。 需要在 writeExternal方法中手工指定所要序列化的變數，這與是否被 transient 修飾無關。 ","permalink":"http://intervalrain.github.io/posts/java/transient/","summary":"1. transient 的作用及使用方法 當一個物件繼承(implements)了 Serializable 介面，這個物件就可以被序列化，Java 的序列化模式為開發者提供了許多便利，開發者可以不必關心具體序列化的過程，只要繼承了 Serializable 介面，該類別(class)的所有屬性(property)和方法(method)都會自動序列化。 然而在實際開發過程中，有些屬性需要序列化，有些屬性則不需要。 用戶的私密訊息如密碼、銀行帳號等，通常不希望在網路操作時被傳輸。 此時，便可在這些對應的變數前加上 transient。 如此一來，這些私密訊息的生命週期只會存在於調用者的記憶體(memory)中，不會寫到磁碟(disk)裡。 注意讀取時，讀取數據的順序一定要和存放數據的順序保持一致。\n範例： import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; import java.io.Serializable; public class TransientExample { public static void main(String[] args){ User user = new User(); user.setUsername(\u0026#34;Rain\u0026#34;); user.setPassword(\u0026#34;12345678\u0026#34;); System.out.println(\u0026#34;Read before Serializable: \u0026#34;); System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername()); System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword()); try { ObjectOutput os = new ObjectOutputStream(new FileOutputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;)); os.writeObject(user); os.flush(); os.","title":"[Java] transient 關鍵字"},{"content":"Mismatch 的重要性 Mismatch 就是當元件的結構設計相同，且尺寸相等，發生性質差異的一種行為。 當尺寸漸縮，變異(viriability)的程度會愈來愈大。 變異(viriability)變大會影響到類比邏輯應用的表現。 Variability/Fluctuation 變異度/誤差定義 元件的單體量測值到整體的 Stardard Target 或 Median 的差距。 可分為系統誤差與隨機誤差。 Systematic variability 系統誤差 (Global) 外質特性(extrinsic) 可以透過製程改良或控制來改善 W2W: 裝置穩定度 equipment stability Wafer level: 裝置均勻度 equipment uniformity、黃光穩定度 Litho. stability Die level: 黃光均勻度 Litho. uniformity、溫度均勻度 temp. non-uniformity pattern density like poly gate density might impact temperature uniformity Layout-Dependent: 光學偏移效應 Optical proximity effect、機械應力 Mechanical stress Random variability 隨機誤差 (Local/Mismatch) 本質特性(intrinsic) 較難被改善 沒有空間相關性 尺寸漸縮，比例可能被放大 微擾動: 參雜 dopant, LER, \u0026hellip; random dopant fluctuation(RDF): dopant diffuse randomly gate dieletric roughness line edge roughness(LER) grain irregularity 統計手法 常態分佈 大部分的元件特性都呈常態分布(normal distribution) 中央極限定理 Advanced Central Limit Therem: 相互獨立的隨機變數, 其均值以常態分佈為極限 Sum of normally distributed random variables: 常態分佈的線性組合依然是常態分布 可簡單透過 median 與 sigma 來描述一組數據, 並用來預測數據 常態分布的函數式為 \\(f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}}\\) 分析手法 透過刪減 outlier 使 rawdata 盡量接近常態分布 (刪除 3倍 sigma 以外的 outlier，重複 6 次) 通常 Full mapping 量測(66pts) 會有 0~2 點的 outliers 數學公式: A = B + C 且 B 與 C 為不相依的變數時 \\((\\sigma_A)^2=(\\sigma_B)^2+(\\sigma_C)^2\\) $$(\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2$$ Total: \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in wafer Global: \\((\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2\\) \\(\\text{Median(Vt1,Vt2,\u0026hellip;Vtn)}\\) \\(\\sigma(\\text{Med1,Med2,\u0026hellip;Medn})\\) Local: \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in die local = \\(\\sqrt{\\frac{\\sum\\sigma_i}{n}})\\) mismatch = \\(\\sigma(\\Delta\\text{Vt1},\\Delta\\text{Vt2},\u0026hellip;\\Delta\\text{Vtn})\\) Mismatch量測 量測 Full mapping data 將同個 die 裡面的 device pair(the same W \u0026amp; L) 計算差值 \\(\\Delta\\text{Vt}=Vt1-Vt2\\) \\(\\Delta\\text{Ion}=\\frac{2\\times(\\text{Ion}_1-\\text{Ion}_2)}{\\text{Ion}_1+\\text{Ion}_2}\\) Normalization 同一組 device pair 內，去除 outlier，使數據接近常態分佈 因為 mismatch 受 sacle 影響，故須對 scale 做正常化 1/sqrt(WL)，Standard variation of mismatch is proportional to inverse of square root of area. Draw \\(\\Delta\\text{Vt}-\\frac{1}{\\sqrt{W/L}}\\)圖 斜率即為 Mismatch ","permalink":"http://intervalrain.github.io/posts/device/mismatch/","summary":"Mismatch 的重要性 Mismatch 就是當元件的結構設計相同，且尺寸相等，發生性質差異的一種行為。 當尺寸漸縮，變異(viriability)的程度會愈來愈大。 變異(viriability)變大會影響到類比邏輯應用的表現。 Variability/Fluctuation 變異度/誤差定義 元件的單體量測值到整體的 Stardard Target 或 Median 的差距。 可分為系統誤差與隨機誤差。 Systematic variability 系統誤差 (Global) 外質特性(extrinsic) 可以透過製程改良或控制來改善 W2W: 裝置穩定度 equipment stability Wafer level: 裝置均勻度 equipment uniformity、黃光穩定度 Litho. stability Die level: 黃光均勻度 Litho. uniformity、溫度均勻度 temp. non-uniformity pattern density like poly gate density might impact temperature uniformity Layout-Dependent: 光學偏移效應 Optical proximity effect、機械應力 Mechanical stress Random variability 隨機誤差 (Local/Mismatch) 本質特性(intrinsic) 較難被改善 沒有空間相關性 尺寸漸縮，比例可能被放大 微擾動: 參雜 dopant, LER, \u0026hellip; random dopant fluctuation(RDF): dopant diffuse randomly gate dieletric roughness line edge roughness(LER) grain irregularity 統計手法 常態分佈 大部分的元件特性都呈常態分布(normal distribution) 中央極限定理 Advanced Central Limit Therem: 相互獨立的隨機變數, 其均值以常態分佈為極限 Sum of normally distributed random variables: 常態分佈的線性組合依然是常態分布 可簡單透過 median 與 sigma 來描述一組數據, 並用來預測數據 常態分布的函數式為 \\(f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}}\\) 分析手法 透過刪減 outlier 使 rawdata 盡量接近常態分布 (刪除 3倍 sigma 以外的 outlier，重複 6 次) 通常 Full mapping 量測(66pts) 會有 0~2 點的 outliers 數學公式: A = B + C 且 B 與 C 為不相依的變數時 \\((\\sigma_A)^2=(\\sigma_B)^2+(\\sigma_C)^2\\) $$(\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2$$ Total: \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in wafer Global: \\((\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2\\) \\(\\text{Median(Vt1,Vt2,\u0026hellip;Vtn)}\\) \\(\\sigma(\\text{Med1,Med2,\u0026hellip;Medn})\\) Local: \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in die local = \\(\\sqrt{\\frac{\\sum\\sigma_i}{n}})\\) mismatch = \\(\\sigma(\\Delta\\text{Vt1},\\Delta\\text{Vt2},\u0026hellip;\\Delta\\text{Vtn})\\) Mismatch量測 量測 Full mapping data 將同個 die 裡面的 device pair(the same W \u0026amp; L) 計算差值 \\(\\Delta\\text{Vt}=Vt1-Vt2\\) \\(\\Delta\\text{Ion}=\\frac{2\\times(\\text{Ion}_1-\\text{Ion}_2)}{\\text{Ion}_1+\\text{Ion}_2}\\) Normalization 同一組 device pair 內，去除 outlier，使數據接近常態分佈 因為 mismatch 受 sacle 影響，故須對 scale 做正常化 1/sqrt(WL)，Standard variation of mismatch is proportional to inverse of square root of area.","title":"[Device] Mismatch Introduction"},{"content":"如何初始化 vector 事先準備 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; 1. 利用 push_back() 函式 vector\u0026lt;int\u0026gt; A; A.push_back(1); A.push_back(2); A.push_back(3); // A = [1,2,3] 2. 利用重載建構子(overloaded constructor) int size = 5; int fill = 2; vector\u0026lt;int\u0026gt; B(size, fill); // B = [2,2,2,2,2] 3. 將 array 傳給 vector 的建構子(-std=c++11) vector\u0026lt;int\u0026gt; C{1, 2, 3, 4, 5}; // C = [1,2,3,4,5] 4. 利用既有的 array int array[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; D(array, array+4); // D = [1,2,3,4] 5. 利用既有的 vector vector\u0026lt;int\u0026gt; E(C.begin()+1, C.end()-3); // E = [2] 6. 利用 fill 函式 vector\u0026lt;int\u0026gt; F(6); fill(F.begin(), F.end(), 3); // F = [3,3,3,3,3,3] Reference\n","permalink":"http://intervalrain.github.io/posts/c++/newvector/","summary":"如何初始化 vector 事先準備 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; 1. 利用 push_back() 函式 vector\u0026lt;int\u0026gt; A; A.push_back(1); A.push_back(2); A.push_back(3); // A = [1,2,3] 2. 利用重載建構子(overloaded constructor) int size = 5; int fill = 2; vector\u0026lt;int\u0026gt; B(size, fill); // B = [2,2,2,2,2] 3. 將 array 傳給 vector 的建構子(-std=c++11) vector\u0026lt;int\u0026gt; C{1, 2, 3, 4, 5}; // C = [1,2,3,4,5] 4. 利用既有的 array int array[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; D(array, array+4); // D = [1,2,3,4] 5.","title":"[C++] How to Initialize vector in C++"},{"content":"Integer.bitCount 的函式解析 要計算整數以二進制的方式表示時，所有 bit 位為 1 的總和。 雛形 從低位開始，檢查是否為 1。 public static int bitCount(int i){ int count = 0; while (i \u0026gt; 0) { if ((i \u0026amp; 1) == 1) // 如果最低位為 1，count就加 1 count++; i \u0026gt;\u0026gt;= 1; // 向右推進 1 位，等同於 num /= 2; } return count; } 時間複雜度為 \\(O(n)\\)，\\(n\\) 為整數的位數(bit 數)。 優化 利用(i - 1) \u0026amp; i 可以消除最低位數的 1 的性質來計算。 public static bitCount(int i){ int count = 0; while (i \u0026gt; 0){ i = i \u0026amp; (i - 1); // 0b0101_1100 - 1 = 0b0101_1011, 且 0b0101_1100 \u0026amp; 0b0101_1011 = 0b0101_1000; count++; } return count; } 時間複雜度為 \\(O(n))\\)，\\(n\\) 為位數為 1 的個數。 利用 int 的特性再優化 \u0008因為 int 的最大正整數為 2^31，故我們可以兩兩錯位相加來求和 private static int bitCount(int i){ i = (i \u0026amp; 0x55555555) + ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); // 0b0101_0101_0101_0101_0101_0101_0101_0101 i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); // 0b0011_0011_0011_0011_0011_0011_0011_0011 i = (i \u0026amp; 0x0f0f0f0f) + ((i \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); // 0b0000_1111_0000_1111_0000_1111_0000_1111 i = (i \u0026amp; 0x00ff00ff) + ((i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); // 0b0000_0000_1111_1111_0000_0000_1111_1111 i = (i \u0026amp; 0x0000ffff) + ((i \u0026gt;\u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff); // 0b0000_0000_0000_0000_1111_1111_1111_1111 return i; } 時間複雜度為 \\(O(1))\\)。 Source Code(final) public static int bitCount(int i) { // HD, Figure 5-2 i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f; i = i + (i \u0026gt;\u0026gt;\u0026gt; 8); i = i + (i \u0026gt;\u0026gt;\u0026gt; 16); return i \u0026amp; 0x3f; } 一、三、四、五步不進行消位，在最後再利用 i \u0026amp; 0x3f 消去不必要的位數 ","permalink":"http://intervalrain.github.io/posts/java/bitcount/","summary":"Integer.bitCount 的函式解析 要計算整數以二進制的方式表示時，所有 bit 位為 1 的總和。 雛形 從低位開始，檢查是否為 1。 public static int bitCount(int i){ int count = 0; while (i \u0026gt; 0) { if ((i \u0026amp; 1) == 1) // 如果最低位為 1，count就加 1 count++; i \u0026gt;\u0026gt;= 1; // 向右推進 1 位，等同於 num /= 2; } return count; } 時間複雜度為 \\(O(n)\\)，\\(n\\) 為整數的位數(bit 數)。 優化 利用(i - 1) \u0026amp; i 可以消除最低位數的 1 的性質來計算。 public static bitCount(int i){ int count = 0; while (i \u0026gt; 0){ i = i \u0026amp; (i - 1); // 0b0101_1100 - 1 = 0b0101_1011, 且 0b0101_1100 \u0026amp; 0b0101_1011 = 0b0101_1000; count++; } return count; } 時間複雜度為 \\(O(n))\\)，\\(n\\) 為位數為 1 的個數。 利用 int 的特性再優化 \u0008因為 int 的最大正整數為 2^31，故我們可以兩兩錯位相加來求和 private static int bitCount(int i){ i = (i \u0026amp; 0x55555555) + ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); // 0b0101_0101_0101_0101_0101_0101_0101_0101 i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); // 0b0011_0011_0011_0011_0011_0011_0011_0011 i = (i \u0026amp; 0x0f0f0f0f) + ((i \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); // 0b0000_1111_0000_1111_0000_1111_0000_1111 i = (i \u0026amp; 0x00ff00ff) + ((i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); // 0b0000_0000_1111_1111_0000_0000_1111_1111 i = (i \u0026amp; 0x0000ffff) + ((i \u0026gt;\u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff); // 0b0000_0000_0000_0000_1111_1111_1111_1111 return i; } 時間複雜度為 \\(O(1))\\)。 Source Code(final) public static int bitCount(int i) { // HD, Figure 5-2 i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f; i = i + (i \u0026gt;\u0026gt;\u0026gt; 8); i = i + (i \u0026gt;\u0026gt;\u0026gt; 16); return i \u0026amp; 0x3f; } 一、三、四、五步不進行消位，在最後再利用 i \u0026amp; 0x3f 消去不必要的位數 ","title":"[Java] Integer.bitCount 解析"},{"content":"一、OS 簡介 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：\n資源分配者 監控使用者程式的執行，以防止不正常的運作造成對系統的危害。 一個標準 PC 的作業系統應該提供以下功能： 行程管理 (processing management) 記憶體管理 (memory management) 檔案系統 (file system) 網路通訊 (networking) 安全機制 (security) 使用者介面 (user integerface) 驅動程式 (device drivers) OS 系統依大小來區分： 大型電腦：IBM OS/360 個人電腦：Windows、Linux、BSD、Mac OS X 嵌入式：VxWorks、eCos、Sysbian OS、Palm OS 依品牌來區分： 類 Unix 家族：包含 System V、BSD 與 Linux。 微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。 蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統 Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。 二、常見的系統類型 Multiprogramming System 系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel)) Multiprogramming Degree：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 Thrashing 現象) 當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。 [方法1] 降低 Multiprogramming Degree [方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 [方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。 分時系統 Time Sharing System Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。 常見配置： 行程排程採用 RR 排程(Round-robin scheduling) 記憶體空間所有使用者分享 使用虛擬記憶體技術 I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。 分散式系統 Distributed System 須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：\nClient-Server System Peer-to-peer 舉例：志願計算，使用志願者電腦的閒置計算力，透過網際網路進行資料傳輸(如 Folding@home 蛋白質摺疊研究計畫)\n分散式系統的好處：\n資源共享 (Resource sharing) 加快計算速度 (Speed up) 可靠性 (Reliability)：指不容易因為一台電腦 shut down 而全部崩潰 通訊需求 (Coummunication Need) 補充：勿將 Multiprocessor 與分散式系統混為一談\nSymmetric Multiprocessing (SMP)：對稱式多元處理，每一個處理器具有相同的功能，可靠度高，強調負載平衡。 Asymmetric Multiprocessing (ASMP)：非對稱式多元處理，Master/Slave 架構。 即時系統 Real Time System 定義嚴謹的固定時間限制，電腦在處理工作時必須在這個定義的時間內完成，否則工作就算失效。 硬性即時系統(Hard Real Time Sydstem)：對於完成工作的時間有極嚴格的限制。若 Prcess 未能於規定的時間內完成，則 Process 即屬失效。(意義同即時系統之定義) 工廠自動化系統、軍事系統、核能安控等。 Application Program 設計上非常重要。 Data 及 Program 皆存在 ROM 或 RAM 中。 不使用虛擬記憶體，因為 Page Fault 的處理時間過長。 減少 os 的干預以降低 Dispatch Latency。 軟性即時系統(Soft Real Time System)：保證高優先權的 Process 必須先於所有低優先權的 Process 完成。 Multimedia System、Virtual Reality等。(影音多媒體的緩衝時間) CPU 的 Scheduling 應能支援 Priority Scheduling 且不能提供類似 Aging 技術。 可和分時系統、virtual memory 共存。 叢集系統 Clustered System 叢集系統共享儲存裝置，集合許多 CPU 並且經由 LAN 連線緊密地連結以完成工作。 叢集系統主要是利用多台獨立的電腦系統或是工作站來共同完成大型數值的平行計算。 Batch 較好的耐用度、安全性 常用於大量數據分析 常用於醫院、金融業 計算機一次只執行一件事 使用者與計算機的執行沒有互動性 CPU 時常處在閒置的狀態(因為 I/O speed 遠小於 CPU speed) OS 處理完一件事後，才將控制權交給下一個工作 Multi-programming 讓 I/O 與計算的工作可以同時進行，減少 CPU 閒置的時間。\nSpooling(Simultaneous Peripheral Operation On-Line)。\n但仍是一次執行一件事。 OS 的工作包含：\n記憶體管控。 系統必須分配記憶體給不同的程式 CPU 排程。 系統必須決定哪些程式要執行 I/O 系統。 系統提供 I/O 的排程與裝置的分配 Time-sharing System 使用者與系統間具有互動性\nCPU 頻繁的切換不同的工作，所以會有很多時間點可以接收 I/O。 使用者可以及時看到結果。 使用者感受像是同時進行的，但其實是很快速的切換在不同的工作之間。 OS 的工作包含：\nVirtual memory，從硬碟中借儲存空間出來，當作 memory 來使用。 檔案系統和硬碟管理。 同步化(Synchronization) 和 死鎖(deadlock)。 \\( \\def\\arraystretch{1.5}\\begin{array}{|c|c|c|c|}\\hline \u0026amp;\\text{Batch}\u0026amp;\\text{Multi-programming}\u0026amp;\\text{Time-sharing}\\\\\\hline \\text{系統模型}\u0026amp;\\text{單一使用者、單一作業}\u0026amp;\\text{單一使用者、多作業排程}\u0026amp;\\text{多使用者、作業平行處理}\\\\\\hline \\text{目的}\u0026amp;\\text{簡單}\u0026amp;\\text{增加資源利用效率(機本)}\u0026amp;\\text{提升反應速度(人本)}\\\\\\hline \\text{特徵}\u0026amp;\\text{N.A.}\u0026amp;\\text{CPU 排程、記憶體管理、I/O系統}\u0026amp;\\text{檔案系統、虛擬記憶體、同步化、死鎖}\\\\\\hline \\end{array} \\)\n電腦系統結構 桌面系統(Desktop Systems)：單處理器(single processor) PC(personal computer) GUI I/O devices: 鍵盤、滑書、螢幕、印表機… 多元的 OS Window, MacOS, Unix, Linux 缺乏檔案與作業系統的保護 木馬、病毒 平行系統(Parallel Systems)：多處理器(multiprocessor/tightly couplde system) 多核、或多 CPU。 通常共享記憶體 優點： Throughput: 提升計算能力 Economical: 很多裝置可以共用、節省成本 Reliability: 當其中一個 CPU 壞掉時，不會使得電腦完全無法操作。 分類： 對稱式多處理器系統 Symmetric multiprocessor system(SMP) 作業系統控制的每個處理器都扮演相同角色 大多 CPU 屬於這種 需要額外處理 synchronization 非對稱式多處理器系統Asymmetric multiprocessor system 每個處理器被指派處理不同的特殊工作 一個主要的 master CPU 與多個 slave CPUs 常見於極大的系統 多核處理器 Multi-Core Processor 在單一的 CPU 有多核 On-chip communication 比 between-chip communication 還快 One chip with multiple core 比 multiple single-core chips 還節能 Many-Core Processor Nvidia General-Purpose GPU 圖形處理器 Single Instruction Multiple Data 處理矩陣更快 Intel Xeon Phi TILE64 記憶體存取結構(Memory Access Architecture) 統一記憶體存取架構 Uniform memory access(UMA) 非統一記憶體存取架構 Non-uniform memory access(NUMA) 分散式系統(Distributed Systems)： ","permalink":"http://intervalrain.github.io/posts/os/lec1/","summary":"一、OS 簡介 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：\n資源分配者 監控使用者程式的執行，以防止不正常的運作造成對系統的危害。 一個標準 PC 的作業系統應該提供以下功能： 行程管理 (processing management) 記憶體管理 (memory management) 檔案系統 (file system) 網路通訊 (networking) 安全機制 (security) 使用者介面 (user integerface) 驅動程式 (device drivers) OS 系統依大小來區分： 大型電腦：IBM OS/360 個人電腦：Windows、Linux、BSD、Mac OS X 嵌入式：VxWorks、eCos、Sysbian OS、Palm OS 依品牌來區分： 類 Unix 家族：包含 System V、BSD 與 Linux。 微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。 蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統 Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。 二、常見的系統類型 Multiprogramming System 系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel)) Multiprogramming Degree：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 Thrashing 現象) 當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。 [方法1] 降低 Multiprogramming Degree [方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 [方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。 分時系統 Time Sharing System Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。 常見配置： 行程排程採用 RR 排程(Round-robin scheduling) 記憶體空間所有使用者分享 使用虛擬記憶體技術 I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。 分散式系統 Distributed System 須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：","title":"[OS] Lec 1 - Introduction"},{"content":"HashMap.comparableClassFor(Object x) 的函式解讀 原文敘述\nReturns x\u0026rsquo;s Class if it is of the form \u0026ldquo;class C implements Comparable\u0026rdquo;, else null.\n我的翻譯 當x的類別為Comparable的實作時，返回x的類別；否則返回 null。\n藉由這個函式實例的解讀，可以了解一下類別、泛型的相關概念。 Source Code static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) { if (x instanceof Comparable) { Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) { for (Type t : ts) { if ((t instanceof ParameterizedType) \u0026amp;\u0026amp; ((p = (ParameterizedType) t).getRawType() == Comparable.class) \u0026amp;\u0026amp; (as = p.getActualTypeArguments()) != null \u0026amp;\u0026amp; as.length == 1 \u0026amp;\u0026amp; as[0] == c) // type arg is c return c; } } } return null; } instanceof insanceof 可理解成某類別的實作，無論是執行期時的類別，或是父類別，或是它實現的介面，或父類別實現的介面…，總之只要在繼承鏈上有這個類別就可以了。 getClass() 與instanceof相對應的是getClass()函式，無論該物件如果轉型，getClass()都會返回它執行時期的類別，可以簡單理解成實際類別\u0008，換言之也就是我們 new 出來物件時使用的類別。 有一種例外情形是匿名物件，當匿名物件調用getClass()時，返回的是依賴它的物件在執行期的類別，並以1,2,3\u0026hellip;的index區分。 getGenericInterfaces() getGenericInterfaces()方法返回的是該物件在執行期時直接實作的介面。必然是該類別自己實作的介面，繼承的則不可。 getGenericSuperclass()和getSuperclass() 這兩個函式雖然沒有出現在 comparableClassFor(Object x)中，但也順帶一提。\ngetSuperclass()返回的是直接父類的類別，不包括泛型參數。 \u0008getGenericSuperclass()返回的是包括泛型參數在內的直接父類別。 注意如果父類別聲明了泛型，但子類別繼承時沒有為父類別實作該泛型，這時候也是沒有泛型參數的 ParameterizedType ParameterizedType 是 Type 介面的子介面，表示參數化的類別，亦即實作了泛型參數的類型。 注意如果直接用 bean 物件 instanceof ParameterizedType，结果都是 false。 Class 物件只能是 instanceof ParameterizedType，否則編譯會報錯。 只有用 Type 物件 instanceof ParameterizedType 才能得到想要的比較结果。可以這麼理解：一個 Bean 類別不會是 ParameterizedType，只有代表這個Bean類的類型（Type）才可能是ParameterizedType。 實現泛型參數，可以是給泛型傳入了一個真實的類別，或者傳入另一個新聲明的泛型參數，只聲明泛型而不實作，則 instanceof ParameterizedType 為 false。 getRawType() getRawType()方法返回聲明了這個類別的類或介面，也就是去掉了泛型参数部分的類別物件。 getActualTypeArguments() 與getRawType()相對應，getActualTypeArguments()以數組的形式返回泛型參數列表。 當傳入的是真實類別時，印出來的是全類名 當傳入的是另一個聲明的泛型參數時滿印出來的是代表該泛型參數的符號。 getOwnerType() ParameterizedType介面還有一個getOwnerType()函式，如果該類別是一个內部類別/介面，返回它的外部類別/介面。如果該類型不是內部類型不是内部類別/介面，返回null。 comparableClassFor(Object x) 總結 static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) { if (x instanceof Comparable) { // 判斷是否實作了 Comparable 介面 Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p; if ((c = x.getClass()) == String.class) // 如果是String類別，直接返回String.class return c; if ((ts = c.getGenericInterfaces()) != null) { // 檢查是否有直接實現的介面 for (Type t : ts) { // 遍歷介面 if ((t instanceof ParameterizedType) \u0026amp;\u0026amp; // 當介面實現了泛型 ((p = (ParameterizedType) t).getRawType() == // 取得介面不帶參數時的類別對象 Comparable.class) \u0026amp;\u0026amp; // 且為 Comparable (as = p.getActualTypeArguments()) != null \u0026amp;\u0026amp; // 取得該介面的泛型參數 as.length == 1 \u0026amp;\u0026amp; as[0] == c) // type arg is c // 只帶有一種泛型且是實作類別為其本身 return c; // 返回該類別 } } } return null; // 皆否則回傳 null } ","permalink":"http://intervalrain.github.io/posts/java/hashmap/hashmap/","summary":"HashMap.comparableClassFor(Object x) 的函式解讀 原文敘述\nReturns x\u0026rsquo;s Class if it is of the form \u0026ldquo;class C implements Comparable\u0026rdquo;, else null.\n我的翻譯 當x的類別為Comparable的實作時，返回x的類別；否則返回 null。\n藉由這個函式實例的解讀，可以了解一下類別、泛型的相關概念。 Source Code static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) { if (x instanceof Comparable) { Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) { for (Type t : ts) { if ((t instanceof ParameterizedType) \u0026amp;\u0026amp; ((p = (ParameterizedType) t).","title":"[Java] Java 的中 HashMap.comparableClassFor(Object x) 的函式解讀"},{"content":"什麼是 Computer Science(CS)? CS 意在解決問題，更精準地說，是將問題 (input) 轉換成答案 (output) 的過程。 在計算機的世界，為了表達 inputs 和 outputs，我們必須將資訊標準化來儲存與操作它們，因為計算機只讀得懂 0 與 1 (開路/通路)。 如何表達數字? 在人類的世界，人們使用十進制(Decimal)。 在計算機的世界，用的是二進制(Binary)，也就是 0 與 1。 \\(1+1=10\\) \\((1,2,3,4,5,6,7,\u0026hellip;)_{10}=(001,010,011,100,101,110,111,\u0026hellip;)_2\\) 每個二進制的位元(digit)稱為 bit。 在現代計算機結構中，是由數以億計的電晶體(transistors)所組成的。 電晶體是一種具有開關(switch)性質的邏輯元件。 大部分的計算機一次用 8 個 bits，或稱 1 bytes，來表達數字。 \\(8 \\text{bits}=1 \\text{bytes}\\) 如何表達文字? 要表達文字，只需將不同的字元定義到對應的數字即可。 ASCII，American Standard Code for Information Interchange，即是一種基於拉丁字母的編碼系統，可應用顯示現代英語。 A-\u0026gt;65, B-\u0026gt;66, \u0026hellip;etc a-\u0026gt;97, b-\u0026gt;98, \u0026hellip;etc H-\u0026gt;72, I-\u0026gt;73, !-\u0026gt;33, so HI!=72, 73, 33 在不同語言，有不同的字符，就必須定義新的編碼系統，來容納更多的字符。 如 Unicode。 如 emojo 顏文字也是一種字符。 如何表達顏色? 同理，可以把不同的數字定義給不同的顏色，其中最常見的就是 RGB 系統。 由紅綠藍色塊所組成。 紅、綠、藍又個別以 8 bits 儲存的 256 種不同層度的顏色強度表示。 一共由 24 bits 來表達，超過1百萬種顏色。 那圖案、影片、音樂呢? 圖案是由數以萬計的色塊(dots)所組成，在螢幕顯示器上我們稱作畫素(pixels)。 影片則是由連續的圖案經由連續播放所建構而成的。 音樂同樣可以用 bits 來表達，其中 MIDI 是一種用數字來表達音符的形式。 All are composed by 0 and 1 in the computer world.\n演算法 (Algorithms) 我們現在可以表達 inputs 和 outputs 了，接下來要開始解決問題。 演算法就是將 inputs 經過一連串系統性、且有邏輯的指令(instructions)轉化成 outpus 的過程。 試想我們要從電話簿中查朋友的電話，電話簿是按照名字排序的。 我們可以從第一頁往後找到最後一頁，只有名字與電話是存在的，我們就會在電話簿中找到，所以這個方法是無誤的。 我們也可以兩頁兩頁找，但我們有可能因此錯失我們要查的號碼。 我們也可以一次翻到當前電話簿的一半，利用電話簿的排序規則，決定往左半邊找或右半邊找，並且持續這個步驟直到找到。 將上述的演算法效率視覺化如下： 從上圖可見，當我們處理的樣本數很大時(電話簿頁數很多)，那麼我們用方法1解決問題的時間(找到號碼的時間)就會大的很多。而利用方法3解決問題的時間則會呈對數成長。 因此，好的演算法設計，會大大的影響計算機的操作效率。 Pseudocode 我們可以用英文(或人類語言)來表達我們的演算法，這種寫作方式叫作 Pseudocode。 Pick up phone book Open to middle of phone book Look at page If person is on page Call person Else if person is earlier in book Open to middle of left half to book Go back to line 3 Else if person is later in book Open to middle of right half to book Go back to line 3 Else Quit 其中像Pick up、Open to、Look at、Quit這些動作，在計算機中我們稱作函式(functions)。 其中分枝的部分If、Else，稱作條件(conditions)。 而我們需要決定的判斷式如person is on page、person is earlier than book、person is later in book稱為布林邏輯值(Boolean expressions)，也就是Yes or No，是或否。 最後，不斷地重覆Go back to line 3的動作，稱作迴圈(loops)。 接下來我們會繼續遇到各種玩意： function 引數 arguments, 傳回值 return values conditionals Boolean expressions loops variables 和 David 的第一個程式：將 \u0026ldquo;hello, world\u0026rdquo; 印到螢幕上。 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello, world\\n\u0026#34;); } Scratch 試試看到 Scratch(https://scratch.mit.edu/) 這套圖像化軟體語言操作看看吧！ Reference: https://cs50.harvard.edu/college/2021/fall/notes/0/\n","permalink":"http://intervalrain.github.io/posts/cs50/lec0/","summary":"什麼是 Computer Science(CS)? CS 意在解決問題，更精準地說，是將問題 (input) 轉換成答案 (output) 的過程。 在計算機的世界，為了表達 inputs 和 outputs，我們必須將資訊標準化來儲存與操作它們，因為計算機只讀得懂 0 與 1 (開路/通路)。 如何表達數字? 在人類的世界，人們使用十進制(Decimal)。 在計算機的世界，用的是二進制(Binary)，也就是 0 與 1。 \\(1+1=10\\) \\((1,2,3,4,5,6,7,\u0026hellip;)_{10}=(001,010,011,100,101,110,111,\u0026hellip;)_2\\) 每個二進制的位元(digit)稱為 bit。 在現代計算機結構中，是由數以億計的電晶體(transistors)所組成的。 電晶體是一種具有開關(switch)性質的邏輯元件。 大部分的計算機一次用 8 個 bits，或稱 1 bytes，來表達數字。 \\(8 \\text{bits}=1 \\text{bytes}\\) 如何表達文字? 要表達文字，只需將不同的字元定義到對應的數字即可。 ASCII，American Standard Code for Information Interchange，即是一種基於拉丁字母的編碼系統，可應用顯示現代英語。 A-\u0026gt;65, B-\u0026gt;66, \u0026hellip;etc a-\u0026gt;97, b-\u0026gt;98, \u0026hellip;etc H-\u0026gt;72, I-\u0026gt;73, !-\u0026gt;33, so HI!=72, 73, 33 在不同語言，有不同的字符，就必須定義新的編碼系統，來容納更多的字符。 如 Unicode。 如 emojo 顏文字也是一種字符。 如何表達顏色? 同理，可以把不同的數字定義給不同的顏色，其中最常見的就是 RGB 系統。 由紅綠藍色塊所組成。 紅、綠、藍又個別以 8 bits 儲存的 256 種不同層度的顏色強度表示。 一共由 24 bits 來表達，超過1百萬種顏色。 那圖案、影片、音樂呢?","title":"[CS50] Lec 0 - Introduction to Computer Science"},{"content":"0. 前言 以往寫筆記通常是使用 Notion，簡單的 Markdown 語法搭配支援 LaTex，使得在撰寫學習筆記時，可以達到快速且美觀的呈現。 雖說 GitHub Pages 支援了 Markdown 的語法，但卻不支援 LaTex，這使得想將筆記從 Notion 移轉到 GitHub Pages，成為一個小缺點。 而此處介紹的是在網頁上顯示較為輕便的 KaTex。 1. 解決方法 利用 KaTex，在靜態頁面掛載 JavaScript 程式碼。 其在官網的描述是： Beautilful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works.\nStep 1. 創建一個可常駐的靜態頁面 在 \\layouts\\partials\\ 下創建一個叫作 math.html 的頁面。 注意是 global 的 layouts 文件夾中不是 hugo themes 中的文件夾 開啟頁面之後，在 \u0026lt;head\u0026gt; 與 \u0026lt;/head\u0026gt; 之間加入下一步驟內的 JavaScript 程式碼。 Step 2. 將 JavaScript 程式碼貼入 math.html \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 上面的程式碼是將 KaTex 的渲染程式碼寫到 math.html 中。 Step 3. 將 Hugo theme 中的 header.html 複製出來 同樣將 header.html 複製到 global 下的 \\layout\\partials，並貼入 {{- /* Head custom content area start */ -}} {{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} {{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} {{- /* Head custom content area end */ -}} 上面的程式碼的功能將 math.html 嵌進 header.html 中，並以 config.yml 中的 .param.math 指令來控制。 Step 4. 開始撰寫 KaTex 一開始先將標頭的定義區將 math: true，即可開啟該頁面的 KaTex 渲染功能。 在 \\\\( 符號與 \\\\) 符號間進行 inline equation 插入。 或在 $ $ 符號與 $ $ 間進行 block equation 的插入。 LaTex 的語法可以參考https://www.cs.pu.edu.tw/~wckuo/doc/latex123/node11.html 參考來源：\nhttps://bend1031.github.io/ https://teddygood.github.io/posts/blog/katex/ ","permalink":"http://intervalrain.github.io/posts/ghpage/latexrendering/","summary":"0. 前言 以往寫筆記通常是使用 Notion，簡單的 Markdown 語法搭配支援 LaTex，使得在撰寫學習筆記時，可以達到快速且美觀的呈現。 雖說 GitHub Pages 支援了 Markdown 的語法，但卻不支援 LaTex，這使得想將筆記從 Notion 移轉到 GitHub Pages，成為一個小缺點。 而此處介紹的是在網頁上顯示較為輕便的 KaTex。 1. 解決方法 利用 KaTex，在靜態頁面掛載 JavaScript 程式碼。 其在官網的描述是： Beautilful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works.\nStep 1. 創建一個可常駐的靜態頁面 在 \\layouts\\partials\\ 下創建一個叫作 math.html 的頁面。 注意是 global 的 layouts 文件夾中不是 hugo themes 中的文件夾 開啟頁面之後，在 \u0026lt;head\u0026gt; 與 \u0026lt;/head\u0026gt; 之間加入下一步驟內的 JavaScript 程式碼。 Step 2.","title":"[ghpage] 在 GitHub Pages 中渲染 KaTex 公式"},{"content":"前言 2022/3/3 更新\n此篇為筆者以工作經驗為背景寫下的筆記，如有錯誤煩請指教。點此聯絡我。 Ring Oscillator 環形振盪器(RO) 簡介 在 IC 電路設計中，除了 metal routing 會造成訊號的延遲，邏輯閘從高電位轉換到低電位、或從低電位轉換到高電位(switch)，也會造成相對應的 Gate Delay，然而 Gate Delay 非常小，很難以測量，故 RO 是一個便於測量 Gate Delay 的電路設計。 在 IC 電路設計中，除了考慮速度，還會考慮功耗，而邏輯閘開關所造成的動態功耗(dynamic power consumption)佔比非常大，故 Ring Oscillator 也可以用來計算閘開關的功耗。 1. Time Delay 為了方便測量 Time Delay，RO 是一種用奇數 n 個 inverter(NOT Gate) 串接成的電路。透過在輸入端振盪產生方波，經過奇數個 inverter 之後，在輸出端產生反向的方波訊號，其時間差為經過 n 個 inverter 的 time delay。利用 time delay 會透過串接 inverter 累加(或稱propagation)的性質，故可以算出單個閘極的 gate delay(\\(T_p\\), propagation time) \\(t_{HtoL}\\sim t_{LtoH}=t_p=\\Delta T/2n\\) [註] 圖為一個由3個反向器組成的環形振盪器，其輸出頻率為 \\(\\frac{1}{6}t_p\\)(Gate Delay)。 由偶數個 inverter 組成的環形電路無法構成環形振盪器，因為其輸入與輸出相同。然而這種配置可以被用作記憶體的基本單元，它是建構靜態隨機存取記憶體 SRAM (static random access memory)的基本組成。 環形振盪器通常全部由 inverter 所組成，較能抵抗環境影響。事實上也可以用 non-inverter 與 inverter 混合組成，前提是 inverter 的總數要是奇數。其振蕩器的週期等於兩倍的閘延遲(Gate delay)， 為了增加振盪頻率，通常有兩種方法 減少環形電路中的 inverter 數量。 提升電壓，但同時會有較大的電流與功耗。 2. Power consumption 分為 Dynamic Power Consumption 與 Static Power Consumption。 \\(P_{total}=a\\times f\\times(\\frac{1}{2}CV_{DD}^2+V_{DD}I_{SC})+V_{DD}I_{off}+V_{DD}I_{Diode}+V_{DD}I_{Gate}\\) a 為 activity，每個 clock cycle 的平均開關切換數目。 故在電路設計上減少開關的次數也能有效降低功耗。 f 為頻率，代表一秒內可以完成幾次開關(switch)。 Dynamic Power(Switching Power) 為現今 CMOS 振盪器的主要功耗來源。 Dynamic Power 為 RO 在固定方波頻率為 \\(f\\) 時的平均功率(一組方波歷時為 \\(1/f\\))。 每一次開或關(switch)所耗的能為 \\(\\frac{1}{2}CV^2\\) 推導： \\(C=\\frac{Q}{V}\\) \\(I=\\frac{dQ}{dt}=C\\frac{dV}{dt}\\) \\(W=IV=\\int_{0}^{t}CV\\frac{dV}{dt}=\\frac{1}{2}CV^2\\) 故功耗為\\(P_{dynamic}=I_{active}V=CV^2\\) 如何降低功耗? 降低 Activity Clock Gating: 避免不必要的 flip-flop 避免 transition downstream logic 加入 enable 來控制邏輯複雜度 Data Gating: 利用 gating off inputs 來避免不必要的 toggling Bus Encodings Freeze \u0026ldquo;Don\u0026rsquo;t cares\u0026rdquo; Remove Glitches 降低\\(C_{Load}\\) 降低\\(f\\) 降低\\(V_{DD}\\) 平行結構 可降低相同 Throughput 時的功耗 Trade off performance Short-Circuit current 當 NMOS 與 PMOS 同時在切換開關時發生(NMOS尚未完全關閉，但PMOS已經部分啟動或是兩者相反)。 Kept to \u0026lt; 10% of capacitor charging current by making edges fast Static Power 因為 subthreshold leakage，MOS並未完全關閉所造成的漏電流致使的功耗。 在小尺寸(\u0026lt;180nm)元件中，因為 short channel effect 的加劇，此功耗的比例會加劇，甚至達 10~40%。 Diode Leakage Drain 端與 Source 端的 Diode junction 產生的 junction leakage。 通常很小可忽略。 Gate Leakage 因為電子穿隧穿過閘極氧化層(gate oxide)造成的漏電，通常在極薄的閘極氧化層發生，可忽略。 Reference reference1_Eletrical Engineering and Computer Science by MIT\n","permalink":"http://intervalrain.github.io/posts/device/ringoscillator/","summary":"前言 2022/3/3 更新\n此篇為筆者以工作經驗為背景寫下的筆記，如有錯誤煩請指教。點此聯絡我。 Ring Oscillator 環形振盪器(RO) 簡介 在 IC 電路設計中，除了 metal routing 會造成訊號的延遲，邏輯閘從高電位轉換到低電位、或從低電位轉換到高電位(switch)，也會造成相對應的 Gate Delay，然而 Gate Delay 非常小，很難以測量，故 RO 是一個便於測量 Gate Delay 的電路設計。 在 IC 電路設計中，除了考慮速度，還會考慮功耗，而邏輯閘開關所造成的動態功耗(dynamic power consumption)佔比非常大，故 Ring Oscillator 也可以用來計算閘開關的功耗。 1. Time Delay 為了方便測量 Time Delay，RO 是一種用奇數 n 個 inverter(NOT Gate) 串接成的電路。透過在輸入端振盪產生方波，經過奇數個 inverter 之後，在輸出端產生反向的方波訊號，其時間差為經過 n 個 inverter 的 time delay。利用 time delay 會透過串接 inverter 累加(或稱propagation)的性質，故可以算出單個閘極的 gate delay(\\(T_p\\), propagation time) \\(t_{HtoL}\\sim t_{LtoH}=t_p=\\Delta T/2n\\) [註] 圖為一個由3個反向器組成的環形振盪器，其輸出頻率為 \\(\\frac{1}{6}t_p\\)(Gate Delay)。 由偶數個 inverter 組成的環形電路無法構成環形振盪器，因為其輸入與輸出相同。然而這種配置可以被用作記憶體的基本單元，它是建構靜態隨機存取記憶體 SRAM (static random access memory)的基本組成。 環形振盪器通常全部由 inverter 所組成，較能抵抗環境影響。事實上也可以用 non-inverter 與 inverter 混合組成，前提是 inverter 的總數要是奇數。其振蕩器的週期等於兩倍的閘延遲(Gate delay)， 為了增加振盪頻率，通常有兩種方法 減少環形電路中的 inverter 數量。 提升電壓，但同時會有較大的電流與功耗。 2.","title":"[Device] Ring Oscillator 環形振盪器"},{"content":"List of Generics equality Case In leetcode no. 39 Combination Sum gives\nGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nIt is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be use mutiple times. 7 is a candidate, and 7 = 7. These are the only two combinations.\nList Equality Consider the following case:\nList\u0026lt;Integer\u0026gt; a = Arrays.asList(1,2,3,4); List\u0026lt;Integer\u0026gt; b = Arrays.asList(4,3,2,1); List\u0026lt;Integer\u0026gt; c = Arrays.asList(4,4,3,2,1); If we apply containsAll methods to test List equality in any order, it might work. But it might not test size of List, so it might go wrong when there is repeated items.\nSystem.out.println(b.containsAll(a)) // true System.out.println(c.containsAll(a)) // true How about applying equals methods after sorting the List?\n// apply sort to all to-be-check items. Collections.sort(a); Collections.sort(b); Collections.sort(c); System.out.println(a.equals(b)); // true System.out.println(a.equals(c)); // false Luckily, List can easily to test elements equality rathan than strict equality of the same object.\nSo, We can see if we want to test List Equality in any order, we can just simply sort List, and apply a.equals(b).\nList of List Equality But in case leetcode no. 39 Combination Sum, list of list of Integer in any order is considered acceptable answer. How do we test list of list of Integer equality?\nclass Solution{ public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target){..} @Test public void test(){ Solution sol = new Solution(); expected = List.of(List.of(2,2,3), List.of(7)) // [[2,2,3],[7]] actual = sol.combinationSum(new int[]{2,3,6,7} Collections.sort(expected); // fail Collections.sort(actual); // fail assertEquals(expected, acutal) } } The code will fail, and the description shows below.\nThe method sort(List) in the type Collections is not applicable for the arguments (List\u0026lt;List\u0026gt;)Java(67108979)\nThus, we have to turns List of Integers in the List into some other type like String, by using toString(). So, we can do like this:\npublic boolean equalsAnyOrder(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; expected, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; actual){ // First we have to check size of list equaltiy if (expected == null \u0026amp;\u0026amp; actual == null) return false; if ((expected == null \u0026amp;\u0026amp; actual != null) || (expected != null \u0026amp;\u0026amp; actual == null) || expected.size() != actual.size()) return false; // Create List of string to turn List of Integer into strings. List\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; d = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; expected.size(); i++){ c.add(expected.get(i).toString()); d.add(actual.get(i).toString()); } // Sort List of strings Collections.sort(c); Collections.sort(d); // Apply simple list equaltiy (We have known List.equals() just test equality of elements in order.) return c.equals(d); } More materials Leetcode no.39 Solution Test List of List Equality Implementation Test cases for no.39 by Junit ","permalink":"http://intervalrain.github.io/posts/java/listequal/","summary":"List of Generics equality Case In leetcode no. 39 Combination Sum gives\nGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.","title":"[Java] List of list of something equality"},{"content":"Rain Hu / intervalrain / 陣雨 Music, coding, and life.\n陣雨 / 音樂使人快樂，也使人憂傷，如同陣雨。\nRain Hu / 寫程式充實生命，在生命的道路上，盲目的前行。\nintervalrain / 人生不過是一場電影或是一首歌，踟躕不如笑一個，然後繼續。\nAbout me 八年級，青年期的最後一個梯次。\n曾經有過音樂夢，當過吉他老師，組過樂團，當過鼓手，也曾在西餐廳駐唱表演。\n沒有隱疾，只有顯疾。人生周折而困頓，為了現實還是選擇當工程師賣肝。\n喜歡寫程式處理繁瑣重覆的事，然後拿空出來的時間作白日夢。\n喜歡唱歌、彈吉他、聽歌、看書，寫憤世嫉俗的歌，解Leetcode，吃。\n喜歡的食物有壽司、拉麵、鹹蛋苦瓜、菜脯蛋、魚香茄子、香菇雞湯。\n最喜歡的甜點有肉桂捲、可麗露、檸檬塔、藍莓塔、草莓蛋糕。\n最喜歡的水果是削好的蘋果跟切好的火龍果跟奇異果，芒果冰上面的芒果，還有所有莓果類，最近多了無籽葡萄，不能吃楊桃。\nCoffeholic，淺焙，上班日喜歡日曬，假日喜歡水洗，加班的話就蜜處理吧。\n討厭毛、討厭草、討厭昆蟲、討厭KMT、除了自己以外的機掰人。\n如果明天就要死亡的話，我會跟家人一起。\nMore about me Job Resume Music Streetvoice Youtube Coding Leetcode Algorithm Contact Email Facebook Instagram Twitter LinkedIn ","permalink":"http://intervalrain.github.io/posts/aboutme/","summary":"Rain Hu / intervalrain / 陣雨 Music, coding, and life.\n陣雨 / 音樂使人快樂，也使人憂傷，如同陣雨。\nRain Hu / 寫程式充實生命，在生命的道路上，盲目的前行。\nintervalrain / 人生不過是一場電影或是一首歌，踟躕不如笑一個，然後繼續。\nAbout me 八年級，青年期的最後一個梯次。\n曾經有過音樂夢，當過吉他老師，組過樂團，當過鼓手，也曾在西餐廳駐唱表演。\n沒有隱疾，只有顯疾。人生周折而困頓，為了現實還是選擇當工程師賣肝。\n喜歡寫程式處理繁瑣重覆的事，然後拿空出來的時間作白日夢。\n喜歡唱歌、彈吉他、聽歌、看書，寫憤世嫉俗的歌，解Leetcode，吃。\n喜歡的食物有壽司、拉麵、鹹蛋苦瓜、菜脯蛋、魚香茄子、香菇雞湯。\n最喜歡的甜點有肉桂捲、可麗露、檸檬塔、藍莓塔、草莓蛋糕。\n最喜歡的水果是削好的蘋果跟切好的火龍果跟奇異果，芒果冰上面的芒果，還有所有莓果類，最近多了無籽葡萄，不能吃楊桃。\nCoffeholic，淺焙，上班日喜歡日曬，假日喜歡水洗，加班的話就蜜處理吧。\n討厭毛、討厭草、討厭昆蟲、討厭KMT、除了自己以外的機掰人。\n如果明天就要死亡的話，我會跟家人一起。\nMore about me Job Resume Music Streetvoice Youtube Coding Leetcode Algorithm Contact Email Facebook Instagram Twitter LinkedIn ","title":"About me"},{"content":"How to say hello to the world?\nJava class Hello{ public static void main(String[] args){ System.out.println(\u0026#34;Hello World!\u0026#34;); } } C #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } C++ #include \u0026lt;iostream\u0026gt; int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ###C#\nnamespace HelloWorld{ class Hello{ static void Main(String[] args){ System.Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } } Python print(\u0026#34;Hello World!\u0026#34;) Ruby puts \u0026#39;Hello World!\u0026#39; TCL Language puts \u0026#34;Hello World!\u0026#34; JavaScript console.log(\u0026#34;Hello World!\u0026#34;); TypeScript console.log \u0026#39;Hello World!\u0026#39; Perl print \u0026#34;Hello World!\u0026#34;; R cat(\u0026#39;Hello World!\u0026#39;); Swift println(\u0026#39;Hello World!\u0026#39;); Kotlin fun main(args: Array\u0026lt;String\u0026gt;){ println(\u0026#34;Hello World!\u0026#34;) } Go println(\u0026#39;Hello World!\u0026#39;); PHP echo \u0026#34;Hello World!\u0026#34;; VBA msgbox \u0026#34;Hello World\u0026#34; Assembly Language global _main extern _printf section .text _main: push message call _printf add esp, 4 message: db \u0026#39;Hello World!\u0026#39;, 11, 0 Me Hello the fucking world ","permalink":"http://intervalrain.github.io/posts/helloworld/","summary":"How to say hello to the world?\nJava class Hello{ public static void main(String[] args){ System.out.println(\u0026#34;Hello World!\u0026#34;); } } C #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } C++ #include \u0026lt;iostream\u0026gt; int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ###C#\nnamespace HelloWorld{ class Hello{ static void Main(String[] args){ System.Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } } Python print(\u0026#34;Hello World!\u0026#34;) Ruby puts \u0026#39;Hello World!\u0026#39; TCL Language puts \u0026#34;Hello World!\u0026#34; JavaScript console.","title":"Hello World"},{"content":"數位系統與開關電路 在現實世界中，資訊是以類比(Analog)的方式傳遞的，換言之，資訊是連續的 在電腦世界中，資訊是以數位(Digital)的方式傳遞的，也就是開與關或是0或1。 A/D \u0026lt;-\u0026gt; DSP(digital signal processor) \u0026lt;-\u0026gt; D/A Switching Circuit 可分為三個層級： System: 模組Modules、算術運算單元 ALU(Arithmetic logic unit)、記憶體 Memory Logic：邏輯閘(gates) Circuit：電晶體(transistors) 經由 switching network 的設計，可將輸入轉成合乎 spec 的輸出。其中 switching network 的種類包含： Combinational network 輸出是輸入的函數，且表達當下的值。 Sequential network 輸出是輸入的函數，可以表達當下的值或是過去的值。 具有記憶體的行為 Switches 由電晶體來實現 transistor level, gate level, module level\u0026hellip; 數字系統與轉換 在現實世界中，最普遍使用的數字系統為十進制(Decimal) 然而在電腦世界中，因為只有代表開與關的 0 與 1，故使用的數字系統是以二進制(Binary)為基礎。 \\(N=(a_2a_1a_0)_R=a_2\\times R^2+a_1\\times R^1+a_0\\times R^0\\) 負數 N 正數表示 -N 正數加負號 1的補數 2的補數 +0 0000 -0 1000 1111 N/A +1 0001 -1 1001 1110 1111 +2 0010 -2 1010 1101 1110 +3 0011 -3 1011 1100 1101 +4 0100 -4 1100 1011 1100 +5 0101 -5 1101 1010 1011 +6 0110 -6 1110 1001 1010 +7 0111 -7 1111 1000 1001 +8 N/A -8 N/A N/A 1000 二進制算數 當兩數相加或兩數相減時，超過可用bits數時會發生overflow， 例如-3+-4=-4是OK的 但-5+-6=-11會產生溢位 二進制的表達方式 Binary codes Decimal Digit 8421 Code(BCD) 6311 Code Excess-3 Code 2-out-of-5 Code Gray Code 0 0000 0000 0011 00011 0000 1 0001 0001 0100 00101 0001 2 0010 0011 0101 00110 0011 3 0011 0100 0110 01001 0010 4 0100 0101 0111 01010 0110 5 0101 0111 1000 01100 1110 6 0110 1000 1001 10001 1010 7 0111 1001 1010 10010 1011 8 1000 1011 1011 10100 1001 9 1001 1100 1100 11000 1000 Weighted Codes 8421 Code 與 6311 都是 Weighted Code，代表每4個bit，各自代表的數字， 例：1011 for 8421 = 8 + 0 + 2 + 1 = 11 例：1011 for 6311 = 6 + 0 + 1 + 1 = 8 Excess-3 Codes Excess-3 是以 8421 Code 為基礎下，額外加 3。 使得 i 與 10-i 互為 1 的補數， 0 與 9 為補數。(0011 與 1100) 1 與 8 為補數。(0100 與 1011) 2 與 7 為補數。(0101 與 1010) 3 與 6 為補數。(0110 與 1001) 4 與 5 為補數。(0111 與 1000) Gray Codes 兩相鄰的數只會相差一個 bit 又名 Reflected Binary Codes(RBC)、Unit distance code、Minimum error code 可以減少 switching operation 如何轉換 Gray Code? 參考Leetcode no.89 ASCII table ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec1/","summary":"數位系統與開關電路 在現實世界中，資訊是以類比(Analog)的方式傳遞的，換言之，資訊是連續的 在電腦世界中，資訊是以數位(Digital)的方式傳遞的，也就是開與關或是0或1。 A/D \u0026lt;-\u0026gt; DSP(digital signal processor) \u0026lt;-\u0026gt; D/A Switching Circuit 可分為三個層級： System: 模組Modules、算術運算單元 ALU(Arithmetic logic unit)、記憶體 Memory Logic：邏輯閘(gates) Circuit：電晶體(transistors) 經由 switching network 的設計，可將輸入轉成合乎 spec 的輸出。其中 switching network 的種類包含： Combinational network 輸出是輸入的函數，且表達當下的值。 Sequential network 輸出是輸入的函數，可以表達當下的值或是過去的值。 具有記憶體的行為 Switches 由電晶體來實現 transistor level, gate level, module level\u0026hellip; 數字系統與轉換 在現實世界中，最普遍使用的數字系統為十進制(Decimal) 然而在電腦世界中，因為只有代表開與關的 0 與 1，故使用的數字系統是以二進制(Binary)為基礎。 \\(N=(a_2a_1a_0)_R=a_2\\times R^2+a_1\\times R^1+a_0\\times R^0\\) 負數 N 正數表示 -N 正數加負號 1的補數 2的補數 +0 0000 -0 1000 1111 N/A +1 0001 -1 1001 1110 1111 +2 0010 -2 1010 1101 1110 +3 0011 -3 1011 1100 1101 +4 0100 -4 1100 1011 1100 +5 0101 -5 1101 1010 1011 +6 0110 -6 1110 1001 1010 +7 0111 -7 1111 1000 1001 +8 N/A -8 N/A N/A 1000 二進制算數 當兩數相加或兩數相減時，超過可用bits數時會發生overflow， 例如-3+-4=-4是OK的 但-5+-6=-11會產生溢位 二進制的表達方式 Binary codes Decimal Digit 8421 Code(BCD) 6311 Code Excess-3 Code 2-out-of-5 Code Gray Code 0 0000 0000 0011 00011 0000 1 0001 0001 0100 00101 0001 2 0010 0011 0101 00110 0011 3 0011 0100 0110 01001 0010 4 0100 0101 0111 01010 0110 5 0101 0111 1000 01100 1110 6 0110 1000 1001 10001 1010 7 0111 1001 1010 10010 1011 8 1000 1011 1011 10100 1001 9 1001 1100 1100 11000 1000 Weighted Codes 8421 Code 與 6311 都是 Weighted Code，代表每4個bit，各自代表的數字， 例：1011 for 8421 = 8 + 0 + 2 + 1 = 11 例：1011 for 6311 = 6 + 0 + 1 + 1 = 8 Excess-3 Codes Excess-3 是以 8421 Code 為基礎下，額外加 3。 使得 i 與 10-i 互為 1 的補數， 0 與 9 為補數。(0011 與 1100) 1 與 8 為補數。(0100 與 1011) 2 與 7 為補數。(0101 與 1010) 3 與 6 為補數。(0110 與 1001) 4 與 5 為補數。(0111 與 1000) Gray Codes 兩相鄰的數只會相差一個 bit 又名 Reflected Binary Codes(RBC)、Unit distance code、Minimum error code 可以減少 switching operation 如何轉換 Gray Code?","title":"[Logic Design] Lec 1 - 數字系統與轉換"},{"content":"基本邏輯運算 Logic Gates Not Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|}\\hline \\text{X}\u0026amp;\\overline{\\text{X}}\\text{or}\\text{X\u0026rsquo;}\\\\\\hline 0\u0026amp;1\\\\\\hline 1\u0026amp;0\\\\\\hline \\end{array} \\) And Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\cdot\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) Or Gates Symbol Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X+Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) 布林表達式與真值表(Boolean Expression and Truth Table) Boolean expression 用 ' 代表 NOT 用 + 代表 OR 用 . 代表 AND 將輸入用上面的運算子表示成算式，如：\\((A+C)(B\u0026rsquo;+C)\\) Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{ccc|cccccc} A\u0026amp;B\u0026amp;C\u0026amp;B\u0026rsquo;\u0026amp;AB\u0026rsquo;\u0026amp;AB\u0026rsquo;+C\u0026amp;A+C\u0026amp;B\u0026rsquo;+C\u0026amp;(A+C)(B\u0026rsquo;+C)\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} \\) 基本運算定理 NOT gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x\u0026rsquo;)\u0026rsquo;\u0026amp;=\u0026amp;x \\end{array} } \\)\nAND gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x+0\u0026amp;=\u0026amp;x\\\\ x+1\u0026amp;=\u0026amp;1\\\\ x+x\u0026amp;=\u0026amp;x\\\\ x+x\u0026rsquo;\u0026amp;=\u0026amp;1 \\end{array} } \\)\nOR gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\cdot 0\u0026amp;=\u0026amp;0\\\\ x\\cdot 1\u0026amp;=\u0026amp;x\\\\ x\\cdot x\u0026amp;=\u0026amp;x\\\\ x\\cdot x\u0026rsquo;\u0026amp;=\u0026amp;0 \\end{array} } \\)\n進階運算定理 交換律 Commutative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} xy\u0026amp;=\u0026amp;yx\\\\ x+y\u0026amp;=\u0026amp;y+x \\end{array} } \\)\n結合律 Associative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (xy)z\u0026amp;=\u0026amp;x(yz)\\\\ (x+y)+z\u0026amp;=\u0026amp;x+(y+z) \\end{array} } \\)\n分配律 Distributive Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026amp;=\u0026amp;xy+xz\\\\ x+yz\u0026amp;=\u0026amp;(x+y)(x+z) \\end{array} } \\)\nMultiplying out and factoring Sum of Product(SOP) form 將算式化整成各個輸入端先 AND 後再 OR 例： \\(ABC+AB\u0026rsquo;C+AB\u0026rsquo;C\u0026rsquo;\\) Product of Sum(POS) form 將算式化整成各個輸入端先 OR 後再 AND 例： \\((A+B+C)(A+B\u0026rsquo;+C)(A+B\u0026rsquo;+C\u0026rsquo;)\\) Multiplying out： 將算式化簡成 SOP form 善用\\(\\boxed{(A+B)(A+C)=A+BC}\\) 範例：\n\\((A+BC)(A+D+E)\\)\n\\(=(A+x)(A+y)\\)\n\\(=A+xy\\)\n\\(=A+BC(D+E)\\)\n\\(=A+BCD+BCE\\) Factoring： 將算式化簡成 POS form 善用\\(\\boxed{A+BC=(A+B)(A+C)}\\) 範例：\n\\(AB\u0026rsquo;+C\u0026rsquo;D\\)\n\\(=(AB\u0026rsquo;+C\u0026rsquo;)(AB\u0026rsquo;+D)\\)\n\\(=(A+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;)(A+D)(B\u0026rsquo;+D))\\) 2-level realization 利用 Multiplying out 與 Factoring 可以將電路簡化成 2-level circuit 因為減少了 Delay propagation 可以減少 Total Time Delay DeMorgan\u0026rsquo;s Laws and Duality DeMorgan\u0026rsquo;s Laws 方法： \\(AND\\leftrightarrow OR\\) \\(A\\leftrightarrow A\u0026rsquo;\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x+y+z+\u0026hellip;)\u0026rsquo;\u0026amp;=\u0026amp;x\u0026rsquo; y\u0026rsquo; z\u0026rsquo;\u0026hellip;\\\\ (xyz\u0026hellip;)\u0026rsquo;\u0026amp;=\u0026amp;x\u0026rsquo;+y\u0026rsquo;+z\u0026rsquo;\u0026hellip; \\end{array} } \\) Truth Table 證明\n\\( \\def\\arraystretch{1.5}\\begin{array}{ccc|ccc|c|c|c} x\u0026amp;y\u0026amp;z\u0026amp;x\u0026rsquo;\u0026amp;y\u0026rsquo;\u0026amp;z\u0026rsquo;\u0026amp;x+y+z\u0026amp;(x+y+z)\u0026rsquo;\u0026amp;x\u0026rsquo; y\u0026rsquo; z\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ \\end{array} \\) 範例\n\\([(A\u0026rsquo; B+C\u0026rsquo;)(D\u0026rsquo;+EF\u0026rsquo;)+GH+W]\u0026rsquo;\\)\n\\(=[(A+B\u0026rsquo;)C+D(E\u0026rsquo;+F)] (G\u0026rsquo;+H\u0026rsquo;)W\u0026rsquo;\\) Duality 方法\n\\(AND\\leftrightarrow OR\\) \\(0\\leftrightarrow 1\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{cccccccccc} [f(\u0026amp;x_1,\u0026amp;x_2,\u0026amp;\u0026hellip;,\u0026amp;x_n,\u0026amp;0,\u0026amp;1,\u0026amp;+,\u0026amp;\\cdot\u0026amp;)]^D\\\\ =f(\u0026amp;x_1,\u0026amp;x_2,\u0026amp;\u0026hellip;,\u0026amp;x_n,\u0026amp;1,\u0026amp;0,\u0026amp;\\cdot,\u0026amp;+\u0026amp;) \\end{array} } \\) 性質\n\\(\\boxed{F=G\\rightarrow F^D=G^D}\\) 範例\n\\((x+y\u0026rsquo;)y=xy\\rightarrow x\\cdot y\u0026rsquo;+y=x+y\\)\n回顧分配律 Distributive Law，即為 Duality 的表現。\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026amp;=\u0026amp;xy+xz\\\\ x+yz\u0026amp;=\u0026amp;(x+y)(x+z) \\end{array} } \\)\nExclusive-OR and equivalence operations Exlusive-OR(XOR,\\(\\oplus\\)) Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\oplus\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;0\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\oplus 0\u0026amp;=\u0026amp;x\\\\ x\\oplus 1\u0026amp;=\u0026amp;x\u0026rsquo;\\\\ x\\oplus x\u0026amp;=\u0026amp;0\\\\ x\\oplus x\u0026rsquo;\u0026amp;=\u0026amp;1\\\\ x\\oplus y\u0026amp;=\u0026amp;y\\oplus x\\\\ (x\\oplus y)\\oplus z\u0026amp;=\u0026amp;x\\oplus (y\\oplus z)\\\\ x(y\\oplus z)\u0026amp;=\u0026amp;xy\\oplus xz\\\\ x\\oplus y\u0026amp;=\u0026amp;xy+x\u0026rsquo; y' \\end{array} } \\) Equivalence(\\(\\equiv\\)) Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\equiv{Y}\\\\\\hline 0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\equiv 0\u0026amp;=\u0026amp;x\u0026rsquo;\\\\ x\\equiv 1\u0026amp;=\u0026amp;x\\\\ x\\equiv x\u0026amp;=\u0026amp;1\\\\ x\\equiv x\u0026rsquo;\u0026amp;=\u0026amp;0\\\\ x\\equiv y\u0026amp;=\u0026amp;y\\equiv x\\\\ (x\\equiv y)\\equiv z\u0026amp;=\u0026amp;x\\equiv (y\\equiv z)\\\\ x(y\\equiv z)\u0026amp;=\u0026amp;xy\\equiv xz\\\\ x\\equiv y\u0026amp;=\u0026amp;xy\u0026rsquo;+x\u0026rsquo; y \\end{array} } \\) 連鎖律 The consensus thorem 公式： \\(\\boxed{xy+x\u0026rsquo; z+yz=xy+x\u0026rsquo; z}\\) \\(\\boxed{(x+y)(x\u0026rsquo;+z)(y+z)=(x+y)(x\u0026rsquo;+z)}\\) 證明：\n\\(xy+x\u0026rsquo; z+yz\\)\n\\(=xy+x\u0026rsquo; z + (x+x\u0026rsquo;)yz\\)\n\\(=xy+xyz+x\u0026rsquo; z+x\u0026rsquo; yz\\)\n\\(=xy(1+z)+x\u0026rsquo; z(1+y)\\)\n\\(=xy+x\u0026rsquo; z\\) 簡化布林表達式的流程 利用 \\(\\boxed{xy+xy\u0026rsquo;=x(y+y\u0026rsquo;)=x}\\)(AND性質) 利用 \\(\\boxed{x+xy+\u0026hellip;=x(1+y+\u0026hellip;)=x}\\)(OR性質) 利用 \\(\\boxed{xy+x\u0026rsquo; z+yz=xy+x\u0026rsquo;z }\\)(連鎖律) 利用 \\(\\boxed{x+x\u0026rsquo;y=x(y+y\u0026rsquo;)+x\u0026rsquo;y=xy+xy\u0026rsquo;+x\u0026rsquo; y=x+y}\\) 必要時加入 redundant terms Lec3會使用圖表法，較不容易出錯。 如何證明布林表達式的正確性? 建構 Truth Table 簡化 LHS 和 RHS ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec2/","summary":"基本邏輯運算 Logic Gates Not Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|}\\hline \\text{X}\u0026amp;\\overline{\\text{X}}\\text{or}\\text{X\u0026rsquo;}\\\\\\hline 0\u0026amp;1\\\\\\hline 1\u0026amp;0\\\\\\hline \\end{array} \\) And Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\cdot\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) Or Gates Symbol Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X+Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) 布林表達式與真值表(Boolean Expression and Truth Table) Boolean expression 用 ' 代表 NOT 用 + 代表 OR 用 . 代表 AND 將輸入用上面的運算子表示成算式，如：\\((A+C)(B\u0026rsquo;+C)\\) Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{ccc|cccccc} A\u0026amp;B\u0026amp;C\u0026amp;B\u0026rsquo;\u0026amp;AB\u0026rsquo;\u0026amp;AB\u0026rsquo;+C\u0026amp;A+C\u0026amp;B\u0026rsquo;+C\u0026amp;(A+C)(B\u0026rsquo;+C)\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} \\) 基本運算定理 NOT gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.","title":"[Logic Design] Lec 2 - 布林代數"},{"content":"布林表達式的轉換 將文字敘述轉換成布林表達式： \\( \\def\\arraystrecth{1.5}\\begin{array}{l} \\underbrace{\\text{The alarm will ring}}_ {Z} \\text{ iff } \\underbrace{\\text{the power of alarm is on}} _{A} \\text{ and } \\underbrace{\\text{the door is not closed}} _{B\u0026rsquo;} \\\\ \\text{ or } \\underbrace{\\text{it is after 6 p.m.}} _{C} \\text{ and } \\underbrace{\\text{the window is not closed}} _{D\u0026rsquo;} \\end{array} \\)\n\\(Z=AB\u0026rsquo;+CD\u0026rsquo;\\) 由真值表開始建構邏輯電路 Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|c|c} A\u0026amp;B\u0026amp;C\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array} } \\) 利用 1\u0026rsquo;s 的函數\n\\(f=A\u0026rsquo; BC+AB\u0026rsquo; C\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo;+ABC\\)\n\\(=A\u0026rsquo; BC+AB\u0026rsquo;+AB\\)\n\\(=A\u0026rsquo; BC+A\\)\n\\(=A+BC\\) 利用 0\u0026rsquo;s 的函數\n\\(f=(A+B+C)(A+B+C\u0026rsquo;)(A+B\u0026rsquo;+C)\\)\n\\(=(A+B)(A+B\u0026rsquo;+C)\\)\n\\(=A+B(B\u0026rsquo;+C)\\)\n\\(=A+BC\\) Minterm 與 maxterm 展開 以 \\(F=A\u0026rsquo; BC+A\\) 為範例 \\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{c|ccc|c|c|cc} \\text{Row No.}\u0026amp;A\u0026amp;B\u0026amp;C\u0026amp;\\text{Minterns}\u0026amp;\\text{Maxterms}\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;\\text{A\u0026rsquo;B\u0026rsquo;C\u0026rsquo;}=\\text{m}_0\u0026amp;\\text{A+B+C}=\\text{M}_0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;\\text{A\u0026rsquo;B\u0026rsquo;C}=\\text{m}_1\u0026amp;\\text{A+B+C\u0026rsquo;}=\\text{M}_1\u0026amp;0\u0026amp;1\\\\ 2\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;\\text{A\u0026rsquo;BC\u0026rsquo;}=\\text{m}_2\u0026amp;\\text{A+B\u0026rsquo;+C}=\\text{M}_2\u0026amp;0\u0026amp;1\\\\ 3\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;\\text{A\u0026rsquo;BC}=\\text{m}_3\u0026amp;\\text{A+B\u0026rsquo;+C\u0026rsquo;}=\\text{M}_3\u0026amp;1\u0026amp;0\\\\ 4\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;\\text{AB\u0026rsquo;C\u0026rsquo;}=\\text{m}_4\u0026amp;\\text{A\u0026rsquo;+B+C}=\\text{M}_4\u0026amp;1\u0026amp;0\\\\ 5\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;\\text{AB\u0026rsquo;C}=\\text{m}_5\u0026amp;\\text{A\u0026rsquo;+B+C\u0026rsquo;}=\\text{M}_5\u0026amp;1\u0026amp;0\\\\ 6\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;\\text{ABC\u0026rsquo;}=\\text{m}_6\u0026amp;\\text{A\u0026rsquo;+B\u0026rsquo;+C}=\\text{M}_6\u0026amp;1\u0026amp;0\\\\ 7\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\text{ABC}=\\text{m}_7\u0026amp;\\text{A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;}=\\text{M}_7\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\)\n\\(m_i\u0026rsquo;=M_i\\)\n\\(\\text{f=A\u0026rsquo;BC+A=1}\\)\n\\(\\text{=A\u0026rsquo;BC+AB\u0026rsquo;C\u0026rsquo;+AB\u0026rsquo;C+ABC\u0026rsquo;+ABC}\\)\n\\(=m_3+m_4+m_5+m_6+m_7\\)\n\\(=\\sum m(3,4,5,6,7)\\)\n\\(\\text{f=(A+B+C)(A+B+C\u0026rsquo;)(A+B\u0026rsquo;+C)=0}\\)\n\\(=M_0M_1M_2\\)\n\\(=\\prod M(0,1,2)\\)\nMaxterm 與 minterm 的轉換\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{rcl} g\u0026amp;=\u0026amp;\\sum m(2,3,4,6,7)\\\\ \u0026amp;=\u0026amp;\\prod M(0,1,5)\\\\ g\u0026rsquo;\u0026amp;=\u0026amp;\\sum m(0,1,5)\\\\ g\u0026amp;=\u0026amp;[\\sum m(0,1,5)]\u0026rsquo;\\\\ \u0026amp;=\u0026amp;\\prod m\u0026rsquo;(0,1,5)\\\\ \u0026amp;=\u0026amp;\\prod M(0,1,5) \\end{array} } \\)\n性質：\n\\(\\boxed{\\text{m}_i\\text{m}_j=0\\text{ if i}\\neq j}\\) 未完整定義的函式(Don\u0026rsquo;t Care) Truth table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{lll|l} A\u0026amp;B\u0026amp;C\u0026amp;F\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;X\\leftarrow \\text{Don\u0026rsquo;t care}\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;X\\leftarrow \\text{Don\u0026rsquo;t care}\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\) 表達式： \\(F=\\sum m(0,3,7)+\\sum d(1,6)=\\prod M(2,4,5)\\cdot \\prod(1,6)\\) Binary adders and subtracters Half Adder 半加器 \\(X,Y_{\\text{in}}\\rightarrow{\\boxed{\\text{Half Adder}}\\rightarrow \\text{Sum}}\\) Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{cc|c} X\u0026amp;Y\u0026amp;Sum\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\) 表達式： \\(\\text{Sum}=X\u0026rsquo; Y+XY\u0026rsquo;\\) Full Adder 全加器 \\(X,Y,C_{\\text{in}}\\rightarrow{\\boxed{\\text{Full Adder}}\\rightarrow C_{out}, \\text{Sum}}\\) Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|cc} X\u0026amp;Y\u0026amp;C_{\\text{in}}\u0026amp;C_{\\text{out}}\u0026amp;\\text{Sum}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\) 表達式： \\(\\text{Sum}=X\\oplus Y\\oplus C_{\\text{in}}\\) \\(C_\\text{out}=YC_{\\text{in}}+XC_{\\text{in}}+XY\\) 邏輯電路 4-Bit Parallel Adder (Ripple Carry Adder 漣波加法器) 四個平行串接的全加器 (Full Adder) Binary Subtracter using Full Adders 用全加器來實現減法器 Full Subtracter \\(x_i,y_i,b_i\\rightarrow\\boxed{\\text{Full Subtracter}}\\rightarrow b_{i+1},d_i\\)\nTruth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|cc} x_i\u0026amp;y_i\u0026amp;b_i\u0026amp;b_{i+1}\u0026amp;d_i\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\)\n示意\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{c|cc} \u0026amp;\\text{Column i Before Borrow}\u0026amp;\\text{Column i After Borrow}\\\\\\hline x_i\u0026amp;0\u0026amp;10\u0026amp;\\\\ -b_i\u0026amp;-1\u0026amp;-1\\\\ -y_i\u0026amp;-1\u0026amp;-1\\\\\\hline d_i\u0026amp;\u0026amp;0(b_{i+1}=1)\\\\ \\end{array} } \\)\nParallel Subtracter Speeding up integer additions Ripple Carry Adder 一般的漣波進位加法器 設計簡單、規律 有較大的 Time Delay 一個 Full Adder 為\\(C_\\text{out}=YC_{\\text{in}}+XC_{\\text{in}}+XY\\) 也就是先 AND 再 OR，兩個 gate delay 故 n-bit adder 的 time delay 是 2n Carry Lockahead Adder(CLA) \\(\\text{Sum}=A\\oplus B\\oplus C_{in}\\) \\(C_{out}=AB+(A+B)C_{in}\\) \\(C_{i+1}=A_iB_i+(A_i+B_i)C_i\\) \\(C_{i+1}=g_i+p_iC_i\\) \\(g_i=A_iB_i\\) generate function \\(p_i=A_i+B_i\\) propagate function \\(C_2=g_1+p_1C_1\\) \\(C_2=g_1+p_1p_0g_0+p_1p_0C_0\\) \\(C_n=g_{n-1}+p_{n-1}g_{n-2}+p_{n-1}p_{n-2}g_{n-3}+\u0026hellip;+p_{n-1}p_{n-2}\u0026hellip;p_1g_0+p_{n-1}p_{n-2}\u0026hellip;p_0C_0\\) 換句話說，\\(C_n\\)可以藉由 \\(C_0\\)運算出來，以 4-bit 為例，可以從漣波的 8 次降到 5 次的 Gate delay。 Carry Select Adder 將兩個加法作平行處理 預先假設 carry-in 的值，待前一級的 carry-in 算出後再用 selector 選擇正確的 carry-in，減去收到前級 carry-in 再開始運算的時間。 Binary multiplication 用邏輯閘模擬一般十進制進位法的乘法 示意\n\\( \\def\\arraystretch{1}\\begin{array}{rcccc} \\text{Multiplicand}\u0026amp;\u0026amp;\u0026amp;B_1\u0026amp;B_0\\\\ \\text{Multiplier}\u0026amp;\u0026amp;\u0026amp;A_1\u0026amp;A_0\\\\\\hline \\text{Partial products}\u0026amp;\u0026amp;\u0026amp;A_0B_1\u0026amp;A_0B_0\\\\ \\text{shift one bit left}\u0026amp;\u0026amp;A_1B_1\u0026amp;A_1B_0\\\\ \\text{Sum of partial products}\u0026amp;C1\u0026amp;C2\u0026amp;C3\u0026amp;C4\\\\ \\end{array} \\) ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec3/","summary":"布林表達式的轉換 將文字敘述轉換成布林表達式： \\( \\def\\arraystrecth{1.5}\\begin{array}{l} \\underbrace{\\text{The alarm will ring}}_ {Z} \\text{ iff } \\underbrace{\\text{the power of alarm is on}} _{A} \\text{ and } \\underbrace{\\text{the door is not closed}} _{B\u0026rsquo;} \\\\ \\text{ or } \\underbrace{\\text{it is after 6 p.m.}} _{C} \\text{ and } \\underbrace{\\text{the window is not closed}} _{D\u0026rsquo;} \\end{array} \\)\n\\(Z=AB\u0026rsquo;+CD\u0026rsquo;\\) 由真值表開始建構邏輯電路 Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|c|c} A\u0026amp;B\u0026amp;C\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array} } \\) 利用 1\u0026rsquo;s 的函數","title":"[Logic Design] Lec 3 - Minterm 與 Maxterm 展開"},{"content":"布林邏輯式的簡化 卡諾圖(Karnaugh Maps, K-maps)是一種簡單、快速的簡化布林邏輯的方法。 SOP 將布林邏輯化簡成最簡SOP(Minimum Sum of products) \\(F=A\u0026rsquo; B\u0026rsquo; C\u0026rsquo;+A\u0026rsquo; B\u0026rsquo; C+A\u0026rsquo; BC\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo; +ABC\\) \\(F=A\u0026rsquo; B\u0026rsquo;+B\u0026rsquo; C+BC\u0026rsquo;+AB\\) \\(F=A\u0026rsquo; B\u0026rsquo;+BC\u0026rsquo;+AC\\) POS 將布林邏輯化簡成最簡POS(Minimum Product of Sums) \\(F=(A+B\u0026rsquo;+C+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D)(A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;+D)(A+B+C\u0026rsquo;+D)(A\u0026rsquo;+B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;+D)(B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D)(A+B\u0026rsquo;+C\u0026rsquo;)(C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(C\u0026rsquo;+D)\\) 2或3個變數的卡諾圖 簡化2個變數的布林邏輯式 \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B\\) 布林代數： \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B=A\u0026rsquo;(B\u0026rsquo;+B)=A\u0026rsquo;\\) 卡諾圖： \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow B\\rightarrow A\u0026amp;0\u0026amp;1\u0026amp;\\\\\\hline 0\u0026amp;\\text{A=0,B=0}\u0026amp;\\text{A=1,B=0}\\\\\\hline 1\u0026amp;\\text{A=0,B=1}\u0026amp;\\text{A=1,B=1}\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\rightarrow A' \\) 簡化3個變數的布林邏輯式 \\(F=\\sum m(2,3,6)=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;\\) 布林代數： \\(F=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;=A\u0026rsquo; B+BC\u0026rsquo;\\) 卡諾圖：*注意相鄰以grey code排列 \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow BC\\rightarrow A\u0026amp;0\u0026amp;1\u0026amp;\\\\\\hline 00\u0026amp;m_0(000)\u0026amp;m_4(100)\\\\\\hline 01\u0026amp;m_1(001)\u0026amp;m_5(101)\\\\\\hline 11\u0026amp;m_3(011)\u0026amp;m_7(111)\\\\\\hline 10\u0026amp;m_2(010)\u0026amp;m_6(110)\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;0\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;0\u0026amp;0\\\\\\hline B C \u0026amp;1\u0026amp;0\\\\\\hline B C\u0026rsquo; \u0026amp;1\u0026amp;1\\\\ \\end{array} } \\rightarrow A\u0026rsquo; B+BC' \\) 相鄰(Adjacency)的定義 最上面可以與最下面相接，視為相鄰 最左邊可以與最右邊相接，視為相鄰 \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;0\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;0\u0026amp;0\\\\\\hline B C \u0026amp;1\u0026amp;1\\\\\\hline B C\u0026rsquo; \u0026amp;0\u0026amp;0\\\\ \\end{array} } \\rightarrow BC \\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;0\u0026amp;0\\\\\\hline B C \u0026amp;0\u0026amp;0\\\\\\hline B C\u0026rsquo; \u0026amp;1\u0026amp;0\\\\ \\end{array} } \\rightarrow A\u0026rsquo; C' \\) 組合的規則 以組合相鄰且以2為倍數為規則 組合的元素愈多愈好 可以重複選(cover) 等效最簡式 \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;1\u0026amp;1\\\\\\hline B C \u0026amp;0\u0026amp;1\\\\\\hline B C\u0026rsquo; \u0026amp;1\u0026amp;1\\\\ \\end{array}} \\rightarrow F=A\u0026rsquo; B\u0026rsquo;+BC\u0026rsquo;+AC=A\u0026rsquo; C\u0026rsquo;+B\u0026rsquo;C+AB \\) 4個變數的卡諾圖 \\(F=ACD+A\u0026rsquo; B+D\u0026rsquo;\\) 以卡諾圖表示 \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;A\u0026rsquo; B\u0026rsquo;\u0026amp;A\u0026rsquo; B\u0026amp;AB\u0026amp;AB\u0026rsquo;\\\\\\hline C\u0026rsquo; D\u0026rsquo;\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline C\u0026rsquo; D \u0026amp; \u0026amp;1\u0026amp; \u0026amp; \\\\\\hline C D \u0026amp; \u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline C D\u0026rsquo; \u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array}} \\quad \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;m_0\u0026amp;m_4\u0026amp;m_{12}\u0026amp;m_8\\\\\\hline 01\u0026amp;m_1\u0026amp;m_5\u0026amp;m_{13}\u0026amp;m_9\\\\\\hline 11\u0026amp;m_3\u0026amp;m_7\u0026amp;m_{15}\u0026amp;m_{11}\\\\\\hline 10\u0026amp;m_2\u0026amp;m_6\u0026amp;m_{14}\u0026amp;m_{10}\\\\ \\end{array}} \\) 以 min-term expression 方式解題 解 \\(F(a,b,c,d)=\\sum m(1,3,4,5,10,12,13)\\) \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp; \u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; \u0026amp;1\\\\ \\end{array}} \\rightarrow F=bc\u0026rsquo;+a\u0026rsquo; b\u0026rsquo; d+ab\u0026rsquo; c\u0026rsquo;d \\) 考慮 Don\u0026rsquo;t care 的情況 解 \\(F(a,b,c,d)=\\sum m(1,3,5,7,9)+\\sum d(6,12,13)\\) \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;X\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;X\u0026amp;1\\\\\\hline 11\u0026amp;1\u0026amp;1\u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp;X\u0026amp; \u0026amp; \\\\ \\end{array}} \\rightarrow F=a\u0026rsquo;d+c\u0026rsquo;d \\) 以 max-term expression 方式解題 解 \\(F(a,b,c,d)=\\sum m(0,2,3,4,8,10,11,15)=\\prod M(1,5,6,7,9,12,13,14)\\) \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;0\u0026amp; \\\\\\hline 01\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 11\u0026amp; \u0026amp;0\u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp;0\u0026amp;0\u0026amp; \\\\ \\end{array}} \\)\n\\(\\rightarrow F\u0026rsquo;=c\u0026rsquo; d+a\u0026rsquo; bc+abd\u0026rsquo;\\)\n\\(\\rightarrow F=(c+d)(a+b\u0026rsquo;+c\u0026rsquo;)(a\u0026rsquo;+b\u0026rsquo;+d)\\) 基本質函項(essential prime implicants) 名詞定義 蘊函項(Implicant) 任何可以被組合的單一或群元素(意指為 \\(F\\)的子集。) 質函項(Prime Implicant) 已不能再被組合更多的函項。(意指最大的、框選最多的子集) 基本質函項(Essential Prime Implicant) 一個帶有只能被單一質函項框選到的元素的質函項 \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;1\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline 10\u0026amp; \u0026amp;1\u0026amp; \u0026amp; \\\\ \\end{array}} \\) 蘊函項：\\(A\u0026rsquo; C\u0026rsquo; D, ABC\u0026rsquo;, ACD, A\u0026rsquo; BC, BD, m_1, m_5, m_6, m_7\u0026hellip;. \\) 質函項：\\(A\u0026rsquo; C\u0026rsquo; D, ABC\u0026rsquo;, ACD, A\u0026rsquo; BC, BD \\) 基本質函項：\\(A\u0026rsquo; C\u0026rsquo; D,ABC\u0026rsquo;,A\u0026rsquo; BC, ACD\\) 簡化原則 因為有可能存在多個等效的最簡式，所以： 盡可能將式子展開成質函項(Prime implicants)。 用盡可能最少的質函項來表式布林函式。 例題 \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp; \u0026amp;1\u0026amp;1\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp;1\u0026amp;1\\\\ \\end{array}} \\rightarrow F=A\u0026rsquo; B\u0026rsquo; D+BC\u0026rsquo;+AC \\) 5個變數的卡諾圖 表示法1 表示法2 ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec4/","summary":"布林邏輯式的簡化 卡諾圖(Karnaugh Maps, K-maps)是一種簡單、快速的簡化布林邏輯的方法。 SOP 將布林邏輯化簡成最簡SOP(Minimum Sum of products) \\(F=A\u0026rsquo; B\u0026rsquo; C\u0026rsquo;+A\u0026rsquo; B\u0026rsquo; C+A\u0026rsquo; BC\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo; +ABC\\) \\(F=A\u0026rsquo; B\u0026rsquo;+B\u0026rsquo; C+BC\u0026rsquo;+AB\\) \\(F=A\u0026rsquo; B\u0026rsquo;+BC\u0026rsquo;+AC\\) POS 將布林邏輯化簡成最簡POS(Minimum Product of Sums) \\(F=(A+B\u0026rsquo;+C+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D)(A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;+D)(A+B+C\u0026rsquo;+D)(A\u0026rsquo;+B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;+D)(B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D)(A+B\u0026rsquo;+C\u0026rsquo;)(C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(C\u0026rsquo;+D)\\) 2或3個變數的卡諾圖 簡化2個變數的布林邏輯式 \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B\\) 布林代數： \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B=A\u0026rsquo;(B\u0026rsquo;+B)=A\u0026rsquo;\\) 卡諾圖： \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow B\\rightarrow A\u0026amp;0\u0026amp;1\u0026amp;\\\\\\hline 0\u0026amp;\\text{A=0,B=0}\u0026amp;\\text{A=1,B=0}\\\\\\hline 1\u0026amp;\\text{A=0,B=1}\u0026amp;\\text{A=1,B=1}\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\rightarrow A' \\) 簡化3個變數的布林邏輯式 \\(F=\\sum m(2,3,6)=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;\\) 布林代數： \\(F=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;=A\u0026rsquo; B+BC\u0026rsquo;\\) 卡諾圖：*注意相鄰以grey code排列 \\( \\boxed{ \\def\\arraystretch{1.","title":"[Logic Design] Lec 4 - 卡諾圖 Karnaugh Maps"},{"content":"概要 當變數愈來愈多時，很難依靠人眼判斷，所以必須計設系統化的簡化過程讓電腦運行。 系統化的簡化過程 輸入：minterm expansion 輸出：minimum SOP 步驟： 找出所有質函項，並試著將和項消除到不能再消，利用\\(XY+XY\u0026rsquo;=X\\) \u0008利用質函項圖找出最小解 範例：\\(F(a,b,c)=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; + ab\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; c+ abc\\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo;\u0026amp;1\u0026amp;\u0026amp;\u0026amp;1\\\\\\hline c\u0026amp;\u0026amp;\u0026amp;1\u0026amp;1 \\end{array} } \\) 所有蘊函項：\\(a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c, abc, ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 質函項：\\(ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 基本質函項：\\(b\u0026rsquo; c\u0026rsquo;, ac\\) Min SOP：\\(F(a,b,c)=b\u0026rsquo; c\u0026rsquo;+ac\\) 決定質函項(prime implicants) 找出所有質函項 將每個 minterm 以二進制表示。 統計每個項的1的數量作為 index 並分群。 將分完群的 minterm 以 index 排列。 從 index 最小開始，往 index + 1 的群，尋找可以用\\(XY+XY\u0026rsquo;=X\\)簡化的組合 檢查所有的項都合併成組合，留下來的項即為質函項。 重複步驟 4 到 步驟 5 直到沒有函項可以合併。\n被打勾表示不是質函項(prime implicants) 範例：\\(f(a,b,c,d)=\\sum m(0,1,2,5,6,7,8,9,10,14)\\) \\(f(a,b,c,d)=P1+P2+P3+P4+P5+P6\\) \\(f(a,b,c,d)=a\u0026rsquo; c\u0026rsquo; d+a\u0026rsquo; bd+a\u0026rsquo; bc+cd\u0026rsquo;+b\u0026rsquo; d\u0026rsquo;+b\u0026rsquo; c\u0026rsquo;\\) \\(\\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|cc} \u0026amp;\\text{Column I}\\\\\\hline m_0\u0026amp;0000\u0026amp;\\checkmark\\\\\\hline m_1\u0026amp;0001\u0026amp;\\checkmark\\\\ m_2\u0026amp;0010\u0026amp;\\checkmark\\\\ m_8\u0026amp;1000\u0026amp;\\checkmark\\\\\\hline m_5\u0026amp;0101\u0026amp;\\checkmark\\\\ m_6\u0026amp;0110\u0026amp;\\checkmark\\\\ m_9\u0026amp;1001\u0026amp;\\checkmark\\\\ m_{10}\u0026amp;1010\u0026amp;\\checkmark\\\\\\hline m_7\u0026amp;0111\u0026amp;\\checkmark\\\\ m_{14}\u0026amp;1110\u0026amp;\\checkmark \\end{array} }\\) \\(\\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|cc} \u0026amp;\\text{Column II}\\\\\\hline m_0,m_1\u0026amp;000.\u0026amp;\\checkmark\\\\ m_0,m_2\u0026amp;00.0\u0026amp;\\checkmark\\\\ m_0,m_8\u0026amp;.000\u0026amp;\\checkmark\\\\\\hline m_1,m_5\u0026amp;0.01\u0026amp;\\text{P1}\\\\ m_1,m_9\u0026amp;.001\u0026amp;\\checkmark\\\\ m_2,m_6\u0026amp;0.10\u0026amp;\\checkmark\\\\ m_2,m_{10}\u0026amp;.010\u0026amp;\\checkmark\\\\ m_8,m_9\u0026amp;100.\u0026amp;\\checkmark\\\\ m_8,m_{10}\u0026amp;10.0\u0026amp;\\checkmark\\\\\\hline m_5,m_7\u0026amp;01.1\u0026amp;\\text{P2}\\\\ m_6,m_7\u0026amp;011.\u0026amp;\\text{P3}\\\\ m_6,m_{14}\u0026amp;.110\u0026amp;\\checkmark\\\\ m_{10},m_{14}\u0026amp;1.10\u0026amp;\\checkmark \\end{array} }\\) \\(\\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|cc} \u0026amp;\\text{Column III}\\\\\\hline m_0,m_1,m_8,m_9\u0026amp;.00.\u0026amp;\\text{P4}\\\\ m_0,m_2,m_8,m_{10}\u0026amp;.0.0\u0026amp;\\text{P5}\\\\ \\sout{m_0,m_8,m_1,m_9}\u0026amp;\\sout{.00.}\\\\ \\sout{m_0,m_8,m_2,m_{10}}\u0026amp;\\sout{.0.0}\\\\\\hline m_2,m_6,m_{10},m_{14}\u0026amp;..10\u0026amp;\\text{P6}\\\\ \\sout{m_2,m_{10},m_6,m_{14}}\u0026amp;\\sout{..10}\\\\ \\end{array} } \\) 質函項圖(表) 範例 \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{r|l|c|cccccccccc} \u0026amp; \u0026amp; \u0026amp;0\u0026amp;1\u0026amp;2\u0026amp;5\u0026amp;6\u0026amp;7\u0026amp;8\u0026amp;9\u0026amp;10\u0026amp;14\\\\\\hline 0, 1, 8, 9\u0026amp;b\u0026rsquo; c\u0026rsquo; \u0026amp;P6\u0026amp;\\checkmark\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\oplus\\\\ 0, 2, 8,10\u0026amp;b\u0026rsquo; d\u0026rsquo; \u0026amp;P5\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ 2, 6,10,14\u0026amp;c d\u0026rsquo; \u0026amp;P4\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\oplus\\\\ 1, 5\u0026amp;a\u0026rsquo; c\u0026rsquo; d\u0026amp;P1\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ 5, 7\u0026amp;a\u0026rsquo; bd \u0026amp;P2\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ 6, 7\u0026amp;a\u0026rsquo; bc \u0026amp;P3\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ \\end{array} } \\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{r|l|c|cccccccccc} \u0026amp;\u0026amp;\u0026amp;5\u0026amp;7\\\\\\hline 1,5\u0026amp;a\u0026rsquo; c\u0026rsquo;d\u0026amp;P1\u0026amp;\\checkmark\\\\ 5,7\u0026amp;a\u0026rsquo; bd \u0026amp;P2\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ 6,7\u0026amp;a\u0026rsquo; bc \u0026amp;P3\u0026amp;\u0026amp;\\checkmark\\\\ \\end{array} } \\) 優先選 \\(\\oplus\\)的質函項(只出現過一次，代表是基本質函項)，如範例\\(P6與P4\\)。 刪除選出的質函項後化簡成更簡化的質函項圖。 選可以同時照顧到最多函項的質函項。 \\(\\rightarrow f(a,b,c)=P2+P4+P6=a\u0026rsquo; bd+cd\u0026rsquo;+b\u0026rsquo; c\u0026rsquo;\\) (若沒有基本質函項時，有可以有多個最佳解) Petrick\u0026rsquo;s method 用來解出質函項圖的所有 min SOP 解。 在使用 Petrick 法前，需將所有基本質函項與其函蓋的 minterms 從表上劃掉。 範例：\\(F=\\sum m(0,1,2,5,6,7)\\)\n\\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{r|l|c|cccccc} P1\u0026amp;0,1\u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ P2\u0026amp;0,2\u0026amp;a\u0026rsquo; c\u0026rsquo;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P3\u0026amp;1,5\u0026amp;b\u0026rsquo; c \u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P4\u0026amp;2,6\u0026amp;b c\u0026rsquo;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P5\u0026amp;5,7\u0026amp;a c \u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P6\u0026amp;6,7\u0026amp;a b \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ \\end{array} } \\) \\(\\def\\arraystretch{1.4}\\begin{array}{l} 0\\rightarrow P1+P2\\\\ 1\\rightarrow P1+P3\\\\ 2\\rightarrow P2+P4\\\\ 5\\rightarrow P3+P5\\\\ 6\\rightarrow P4+P6\\\\ 7\\rightarrow P5+P6\\\\ \\end{array}\\) \\(P=(P1+P2)(P1+P3)(P2+P4)(P3+P5)(P4+P6)(P5+P6)=1\\) \\(P=(P1+P2P3)(P4+P2P6)(P5+P3P6)\\) \\(P=P1P4P5+P1P2P5P6+P2P3P4P5+P2P3P5P6+P1P3P4P6+P1P2P3P6+P2P3P4P6+P2P3P6\\) 刪掉含有\\(P2P3P6\\)的和項 \\(P=P1P4P5+P1P2P5P6+P2P3P4P5+P1P3P4P6+P2P3P6\\) \\(\\text{min Sol:}\\) \\(F=P1+P4+P5=a\u0026rsquo; b\u0026rsquo;+bc\u0026rsquo;+ac\\) \\(F=P2+P3+P6=a\u0026rsquo; c\u0026rsquo;+b\u0026rsquo; c+ab\\) 考慮 Don\u0026rsquo;t Care 的情形 稍微修改一下 Quine-McClusky 方法 找出所有質函項：將DC視為minterms 建構出質函項表：DC不必列在表頭 範例：\\(F(A,B,C,D)=\\sum m(2,3,7,9,11,13)+\\sum d(1,10,15)\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{rrl} 1\u0026amp;0001\u0026amp;\\checkmark\\\\ 2\u0026amp;0010\u0026amp;\\checkmark\\\\\\hline 3\u0026amp;0011\u0026amp;\\checkmark\\\\ 9\u0026amp;1001\u0026amp;\\checkmark\\\\ 10\u0026amp;1010\u0026amp;\\checkmark\\\\\\hline 7\u0026amp;0111\u0026amp;\\checkmark\\\\ 11\u0026amp;1011\u0026amp;\\checkmark\\\\ 13\u0026amp;1101\u0026amp;\\checkmark\\\\\\hline 15\u0026amp;1111\u0026amp;\\checkmark \\end{array}}\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{rrl} 1,3\u0026amp;00.1\u0026amp;\\checkmark\\\\ 1,9\u0026amp;.001\u0026amp;\\checkmark\\\\ 2,3\u0026amp;001.\u0026amp;\\checkmark\\\\ 2,10\u0026amp;.01.\u0026amp;\\checkmark\\\\\\hline 3,7\u0026amp;0.11\u0026amp;\\checkmark\\\\ 3,11\u0026amp;.011\u0026amp;\\checkmark\\\\ 9,11\u0026amp;10.1\u0026amp;\\checkmark\\\\ 9,13\u0026amp;1.01\u0026amp;\\checkmark\\\\ 10,11\u0026amp;101.\u0026amp;\\checkmark\\\\\\hline 7,15\u0026amp;.111\u0026amp;\\checkmark\\\\ 11,15\u0026amp;1.11\u0026amp;\\checkmark\\\\ 13,15\u0026amp;11.1\u0026amp;\\checkmark\\\\ \\end{array}}\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{rrl} 1,3,9,11\u0026amp;.0.1\\\\ 2,3,10,11,\u0026amp;.01.\\\\ 3,7,11,15\u0026amp;..11\\\\ 9,11,13,15\u0026amp;1..1\\\\ \\end{array}}\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{r|cccccc} \u0026amp;2\u0026amp;3\u0026amp;7\u0026amp;9\u0026amp;11\u0026amp;13\\\\\\hline 1,3,9,11\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ *2,3,10,11\u0026amp;\\oplus\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\\checkmark\\\\ *3,7,11,15\u0026amp;\u0026amp;\\checkmark\u0026amp;\\oplus\u0026amp;\u0026amp;\\checkmark\\\\ *9,11,13,15\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\u0026amp;\\oplus\\\\ \\end{array}}\\) \\(F=B\u0026rsquo; C+CD+AD\\) 其中 1 被當作 0，10、15當作1。 ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec5/","summary":"概要 當變數愈來愈多時，很難依靠人眼判斷，所以必須計設系統化的簡化過程讓電腦運行。 系統化的簡化過程 輸入：minterm expansion 輸出：minimum SOP 步驟： 找出所有質函項，並試著將和項消除到不能再消，利用\\(XY+XY\u0026rsquo;=X\\) \u0008利用質函項圖找出最小解 範例：\\(F(a,b,c)=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; + ab\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; c+ abc\\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo;\u0026amp;1\u0026amp;\u0026amp;\u0026amp;1\\\\\\hline c\u0026amp;\u0026amp;\u0026amp;1\u0026amp;1 \\end{array} } \\) 所有蘊函項：\\(a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c, abc, ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 質函項：\\(ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 基本質函項：\\(b\u0026rsquo; c\u0026rsquo;, ac\\) Min SOP：\\(F(a,b,c)=b\u0026rsquo; c\u0026rsquo;+ac\\) 決定質函項(prime implicants) 找出所有質函項 將每個 minterm 以二進制表示。 統計每個項的1的數量作為 index 並分群。 將分完群的 minterm 以 index 排列。 從 index 最小開始，往 index + 1 的群，尋找可以用\\(XY+XY\u0026rsquo;=X\\)簡化的組合 檢查所有的項都合併成組合，留下來的項即為質函項。 重複步驟 4 到 步驟 5 直到沒有函項可以合併。","title":"[Logic Design] Lec 5 - Quine-McClusky Method"},{"content":"Multi-level gate circuits 如何決定 level 數： Gate input number \u0026amp; Delay determine level Factoring to accomplish different level AND-OR: 2-level SOP OR-AND: 2-level POS OR-AND-OR: 3-level circuit of AND and OR → no particular ordering 4 level gates: \\(\\text{Z=(AB+C)(FG+D+E)+H}\\) 3 level gates: (case fan out) \\(\\text{AB(D+E)+C(D+E)+ABFG+CFG+H}\\) Factoring 可變成 4-level \\(\\text{(AB+C)(D+E+FG)+H}\\) level \u0026amp; gate \u0026amp; gate inputs 的關係會隨之變化，可根據電路設計的需求改變 範例： \\( \\begin{array}{llll} f(a,b,c,d)=\\sum(1,5,6,10,13,14)\\\\ f=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]\u0026amp;\\text{4 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;)\u0026amp;\\text{3 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=c\u0026rsquo; d(a\u0026rsquo;+b)+cd\u0026rsquo;(a+b)\u0026amp;\\text{3 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{12 gate inputs} \\end{array} \\) \\( \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;m_0\u0026amp;m_4\u0026amp;m_{12}\u0026amp;m_{8}\\\\\\hline 01\u0026amp;m_1\u0026amp;m_5\u0026amp;m_{13}\u0026amp;m_{9}\\\\\\hline 11\u0026amp;m_3\u0026amp;m_7\u0026amp;m_{15}\u0026amp;m_{11}\\\\\\hline 10\u0026amp;m_2\u0026amp;m_6\u0026amp;m_{14}\u0026amp;m_{10} \\end{array}}\\rightarrow \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline 11\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 10\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\) \\(\\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo; d\u0026rsquo;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline c\u0026rsquo; d\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline cd\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline cd\u0026rsquo;\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\\\ =a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;=(a\u0026rsquo;+b)c\u0026rsquo; d+(a+b)cd\u0026rsquo;\\\\ =(c\u0026rsquo; d\u0026rsquo;+ab\u0026rsquo; c\u0026rsquo;+cd+a\u0026rsquo; b\u0026rsquo; c)\u0026rsquo;=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\\\\ =[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;) \\) NAND and NOR gates NAND 符號 真值表\n\\(\\boxed{\\begin{array}{cc|cc} A\u0026amp;B\u0026amp;AB\u0026amp;\\overline{AB}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array}} \\) 布林表達式：\n\\(F=(ABC)\u0026rsquo;=A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;\\) NOR 符號 真值表\n\\(\\boxed{\\begin{array}{cc|cc} A\u0026amp;B\u0026amp;AB\u0026amp;\\overline{AB}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array}} \\) 布林表達式： \\(F=(A+B+C)\u0026rsquo;=A\u0026rsquo; B\u0026rsquo; C\u0026rsquo;\\) Functionally Complete Sets of Gates 定義：當所有的布林式皆可以被這組邏輯閘組合而成，則這組邏輯閘為 Functionally Complete \\(\\lbrace{\\text{AND, OR, NOT}}\\rbrace\\) \\(\\lbrace{\\text{AND, NOT}}\\rbrace\\rightarrow \\text{OR}=X+Y=(X\u0026rsquo; Y\u0026rsquo;)\u0026rsquo;\\) \\(\\lbrace{\\text{OR, NOT}}\\rbrace\\rightarrow \\text{AND}=XY=(X\u0026rsquo;+Y\u0026rsquo;)\u0026rsquo;\\) \\(\\lbrace{\\text{NAND}}\\rbrace\\) \\(\\lbrace{\\text{NOR}}\\rbrace\\) \\(\\lbrace{\\text{3-input Minority Gate}}\\rbrace\\) Majority Gate and Minority Gate 真值表\n\\(\\boxed{\\begin{array}{ccc|cc} A\u0026amp;B\u0026amp;C\u0026amp;F_M\u0026amp;F_m\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array}}\\) \\(\\text{(0, B, C)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{NAND}=\\text{(BC)\u0026rsquo;=\\text{B\u0026rsquo;+C\u0026rsquo;}}\\) \\(\\text{(1, B, C)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{NOR}=\\text{(B+C)\u0026rsquo;=\\text{B\u0026rsquo;C\u0026rsquo;}}\\) \\(\\text{(A, A, A)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{NOT}=\\text{A\u0026rsquo;}\\) \\(\\text{(0, B\u0026rsquo;, C\u0026rsquo;)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{AND}=\\text{BC}\\) \\(\\text{(1, B\u0026rsquo;, C\u0026rsquo;)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{OR}=\\text{B+C}\\) 2-level NAND and NOR gates DeMorgon\u0026rsquo;s Law 等效邏輯閘： \\((A+B)\u0026rsquo;=A\u0026rsquo; B\u0026rsquo;\\) \\((AB)\u0026rsquo;=A\u0026rsquo;+B\u0026rsquo;\\) \\(A+B=(A\u0026rsquo; B\u0026rsquo;)\u0026rsquo;\\) \\(AB=(A\u0026rsquo;+B\u0026rsquo;)\u0026rsquo;\\) \\(\\text{Ex1: AND/OR}\\rightarrow\\text{NAND/NAND}\\) \\(\\text{Ex2: AND/OR}\\rightarrow\\text{NOR/NOR}\\) Multi-level NAND and NOR circuits Multi-level NAND and NOR circuits \\(\\text{to NAND gate}\\)\n\\(\\text{to NOR gate}\\) Multi-output circuit realization 實際一個多工器(multiplexer)內的電路實現，可以用 fan out 的方式達到最佳化。 整體最佳不一定代表個別都為最佳。 實作1: \\(F_1(A,B,C,D)=\\sum m(11,12,13,14,15) =AB+ACD \\\\ F_2(A,B,C,D)=\\sum m(3,7,11,12,13,15)=ABC\u0026rsquo;+CD\\\\ F_3(A,B,C,D)=\\sum m(3,7,12,13,14,15)=A\u0026rsquo; CD+AB\\\\ \\) \\( \\begin{array}{|c|c|c|c|c|}\\hline F_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; 1\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline F_2\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 11\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; 1\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline F_3\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;1 \u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp;1 \u0026amp; \\\\\\hline 11\u0026amp; 1\u0026amp;1 \u0026amp;1 \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; \u0026amp;1 \u0026amp; \\\\\\hline \\end{array} \\) \\(\\text{9 Gates, 21 Gate inputs}\\rightarrow\\text{7 Gates, 18 Gate inputs}\\) \\(\\text{Share AB(fan out)}\\) \\(\\text{A\u0026rsquo;CD+ACD=CD}\\) \\(F_1(A,B,C,D)=AB+ACD \\\\ F_2(A,B,C,D)=ABC\u0026rsquo;+ACD+A\u0026rsquo; CD\\\\ F_3(A,B,C,D)=A\u0026rsquo; CD+AB\\\\ \\lbrace{AB,A\u0026rsquo; CD,ACD,ABC\u0026rsquo;}\\rbrace \\) 實作2: \\(f_1=\\sum m(2,3,5,7,8,9,10,11,13,15)=bd+b\u0026rsquo; c+ab\u0026rsquo;\\\\ f_2=\\sum m(2,3,5,6,7,10,11,14,15)=a\u0026rsquo; bd+c\\\\ f_3=\\sum m(6,7,8,9,13,14,15)=bc+ab\u0026rsquo; c\u0026rsquo;+abd\\\\ \\rightarrow\\text{10 Gates, 25 Gate inputs} \\) \\( \\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp;1 \\\\\\hline 01\u0026amp; \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline 11\u0026amp;1 \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline 10\u0026amp;1 \u0026amp; \u0026amp; \u0026amp;1 \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_2\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 01\u0026amp; \u0026amp;1 \u0026amp; \u0026amp; \\\\\\hline 11\u0026amp;1 \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline 10\u0026amp;1 \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_3\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp;1 \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp;1 \u0026amp;1 \\\\\\hline 11\u0026amp; \u0026amp;1 \u0026amp;1 \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp;1 \u0026amp;1 \u0026amp; \\\\\\hline \\end{array} \\) \\( \\text{(1) } b\u0026rsquo; c+bc = c\\\\ \\text{(2) } a\u0026rsquo; bd+abd = bd\\\\ \\text{用}\\lbrace{b\u0026rsquo; c, bc, a\u0026rsquo;bd, abd, ab\u0026rsquo; c\u0026rsquo;}\\rbrace\\text{組合上例} \\) \\( f_1=b\u0026rsquo; c+(abd+a\u0026rsquo; bd)+ab\u0026rsquo; c\u0026rsquo;\\\\ f_2=(b\u0026rsquo; c+ bc)+a\u0026rsquo; bd\\\\ f_3=bc+abd+ab\u0026rsquo; c\u0026rsquo;\\\\ \\lbrace {b\u0026rsquo; c,bc,abd,a\u0026rsquo; bd,ab\u0026rsquo; c\u0026rsquo;}\\rbrace\\\\ \\rightarrow\\text{8 Gates, 23 Gate inputs} \\) 實作3: \\( f_1=\\sum m(1,5,9,13,15)=c\u0026rsquo; d+abd\\\\ f_2=\\sum m(4,6,12,14,15)=bd\u0026rsquo;+abc\\\\ \\rightarrow\\text{6 Gates, 14 Gate inputs} \\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 01\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; 1\\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_2\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline \\end{array}\\) 使上面兩式共用 \\(abcd\\) \\( f_1=c\u0026rsquo; d+abcd\\\\ f_2=bd\u0026rsquo;+abcd\\\\ \\rightarrow\\text{5 Gates, 12 Gate inputs} \\) 實作4: \\( f_1=\\sum m(0,3,4,5,6,14)=a\u0026rsquo; c\u0026rsquo; d\u0026rsquo;+a\u0026rsquo; bc\u0026rsquo;+a\u0026rsquo; cd\u0026rsquo;+bcd\u0026rsquo;\\\\ f_2=\\sum m(0,1,4,6,8,10)=a\u0026rsquo; c\u0026rsquo; d\u0026rsquo;+bc\u0026rsquo; d\u0026rsquo;+a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;+bcd\u0026rsquo;\\\\ \\rightarrow\\text{8 Gates, 26 Gate inputs} \\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; \u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; 1\u0026amp; \u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; 1\u0026amp; \u0026amp; \u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline \\end{array} \\) 不 combine 各自做最佳化 \\( f_1=a\u0026rsquo; d\u0026rsquo;+a\u0026rsquo; bc\u0026rsquo;+bcd\u0026rsquo;\\\\ f_2=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;+bd\u0026rsquo;\\\\ \\rightarrow\\text{7 Gates, 18 Gate Inputs} \\) 多輸出電路的基本質函項 參考實作3，若基本質函項可通過多工器中其他的輸入共用的話，則對多輸出電路而言並非基本質函項(Essential prime terms)。 參考實作4，\\(a\u0026rsquo; d\u0026rsquo;(m_2),a\u0026rsquo; bc\u0026rsquo;(m_5), a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;(m_1), bd\u0026rsquo;(m_{12})\\)皆為基本質函項。 一般而言，不會為了共享而把基本質函項拆開。 和項共用(Shared by sum terms) 真值表\n\\(\\begin{array}{|cccc|cccc:c|}\\hline a\u0026amp;b\u0026amp;c\u0026amp;d\u0026amp;w\u0026amp;x\u0026amp;y\u0026amp;z\u0026amp;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;2\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;3\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;4\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;5\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;6\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;7\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;8\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;9\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline \\end{array}\\) k-map\n\\(\\begin{array}{|c|c|c|c|c||}\\hline w\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; X\u0026amp; 1\\\\\\hline 01\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; 1\\\\\\hline 11\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline \\end{array} \\begin{array}{|c|c|c|c|c||}\\hline x\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; \\\\\\hline 01\u0026amp; 1\u0026amp; \u0026amp; X\u0026amp; 1\\\\\\hline 11\u0026amp; 1\u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; 1\u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline \\end{array} \\begin{array}{|c|c|c|c|c||}\\hline y\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; 1\\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; X\u0026amp; \\\\\\hline 11\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline \\end{array} \\begin{array}{|c|c|c|c|c|}\\hline z\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; 1\\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; X\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline \\end{array}\\) \\(w=a+bc+bd=a+b(c+d)\\\\ x=bc\u0026rsquo; d\u0026rsquo;+b\u0026rsquo; d+b\u0026rsquo; c=bc\u0026rsquo; d\u0026rsquo;+b\u0026rsquo;(c+d)\\\\ y=c\u0026rsquo; d\u0026rsquo;+cd\\\\ z=d' \\) Sum terms 也可以 share Multi-output circuits 也可以只用 \\(\\text{NAND/NOR}\\) 表示 Multi-Output NAND/NOR circuits 範例 \\(\\text{to NAND}\\) \\(\\text{to NOR}\\) ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec6/","summary":"Multi-level gate circuits 如何決定 level 數： Gate input number \u0026amp; Delay determine level Factoring to accomplish different level AND-OR: 2-level SOP OR-AND: 2-level POS OR-AND-OR: 3-level circuit of AND and OR → no particular ordering 4 level gates: \\(\\text{Z=(AB+C)(FG+D+E)+H}\\) 3 level gates: (case fan out) \\(\\text{AB(D+E)+C(D+E)+ABFG+CFG+H}\\) Factoring 可變成 4-level \\(\\text{(AB+C)(D+E+FG)+H}\\) level \u0026amp; gate \u0026amp; gate inputs 的關係會隨之變化，可根據電路設計的需求改變 範例： \\( \\begin{array}{llll} f(a,b,c,d)=\\sum(1,5,6,10,13,14)\\\\ f=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]\u0026amp;\\text{4 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;)\u0026amp;\\text{3 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=c\u0026rsquo; d(a\u0026rsquo;+b)+cd\u0026rsquo;(a+b)\u0026amp;\\text{3 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{12 gate inputs} \\end{array} \\) \\( \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;m_0\u0026amp;m_4\u0026amp;m_{12}\u0026amp;m_{8}\\\\\\hline 01\u0026amp;m_1\u0026amp;m_5\u0026amp;m_{13}\u0026amp;m_{9}\\\\\\hline 11\u0026amp;m_3\u0026amp;m_7\u0026amp;m_{15}\u0026amp;m_{11}\\\\\\hline 10\u0026amp;m_2\u0026amp;m_6\u0026amp;m_{14}\u0026amp;m_{10} \\end{array}}\\rightarrow \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline 11\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 10\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\) \\(\\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo; d\u0026rsquo;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline c\u0026rsquo; d\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline cd\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline cd\u0026rsquo;\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\\\ =a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;=(a\u0026rsquo;+b)c\u0026rsquo; d+(a+b)cd\u0026rsquo;\\\\ =(c\u0026rsquo; d\u0026rsquo;+ab\u0026rsquo; c\u0026rsquo;+cd+a\u0026rsquo; b\u0026rsquo; c)\u0026rsquo;=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\\\\ =[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;) \\) NAND and NOR gates NAND 符號 真值表","title":"[Logic Design] Lec 6 - Multi-Level Gate Circuits / NAND and NOR Gates"},{"content":"Review 組合電路設計 建構真值表將輸出表示成輸入的函式 \\(\\text{Inputs}\\rightarrow\\boxed{\\text{MUX}}\\rightarrow\\text{Outputs}\\) 用 K-map, Q-M method 等方法得到簡化的布林表達式 多層、多輸出的電路(Multi-level \u0026amp; Multi-outputs) Mininum SOP 起點 Minimum two-level \\(\\text{AND-OR, NAND-NAND, OR-NAND, NOR-OR}\\) Minimum POS 起點 Minimum two-level \\(\\text{OR-AND, NOR-NOR, AND-NOR, NAND-AND}\\) 限制 fan-in 數的電路設計 Ex1 \\(\\text{用 3 pin 的 NOR Gate 實現}f(a,b,c,d)=\\sum m(0,3,4,5,8,9,10,14,15)\\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 01\u0026amp; 0\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 11\u0026amp; 1\u0026amp; 0\u0026amp; 1\u0026amp; 0\\\\\\hline 10\u0026amp; 0\u0026amp; 0\u0026amp; 1\u0026amp; 1\\\\\\hline \\end{array}\\) 從 POS 開始 \\(f\u0026rsquo;=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; d+ab\u0026rsquo; cd+abc\u0026rsquo; + a\u0026rsquo; bc+a\u0026rsquo; cd\u0026rsquo;\\\\ \\quad=b\u0026rsquo; d(a\u0026rsquo; c\u0026rsquo;+ac)+a\u0026rsquo; c(b+d\u0026rsquo;)+abc\u0026rsquo;\\) Ex2 Multiple-Output \\(\\text{用 2 pin 的 NAND 與 NOT 實現}\\) \\(f_1=\\sum m(0,2,3,4,5)=b\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; +a\u0026rsquo; b\\\\ f_2=\\sum m(0,2,3,4,7)=b\u0026rsquo; c\u0026rsquo;+bc+a\u0026rsquo; b\\\\ f_3=\\sum m(1,2,6,7)=a\u0026rsquo; b\u0026rsquo; c+ab+bc\u0026rsquo;\\) \\(\\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp;1\\\\\\hline 11\u0026amp;1\u0026amp; \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp;1 \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp; \u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp;1\\\\\\hline 10\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) \\(f_1=b\u0026rsquo;(a+c\u0026rsquo;)+a\u0026rsquo; b\\\\ f_2=(b\u0026rsquo;+c)(b+c\u0026rsquo;)+b\u0026rsquo; c\u0026rsquo;\\\\ f_3=b(a+c\u0026rsquo;)+a\u0026rsquo; b\u0026rsquo; c\\) 閘延遲與時序圖 邏輯閘必然存在延遲，固然小，但存在。 組合電路 延遲亦可能來自電線，電線愈長則延遲可能愈久。 Control value \\(\\text{AND gate}\\) 的 control value 是 \\(0\\) \\(\\text{OR gate}\\) 的 control value 是 \\(1\\) \\(\\text{AND=2ns}\\\\ \\text{NOR=3ns}\\) 若 X 訊號相反時， Z 要到 5ns 訊號才有意義。 組合邏輯中的 Hazards Hazard 是在切換輸入時，因閘延遲而產生的錯誤訊號。 種類 若相鄰兩個 1 不來自同一個邏輯閘(在 K-map 上沒有被框在一起)則會存在 hazard。 \\((A,B,C)=(1,0,1)\\rightarrow (1,1,1)\\) \u0008可將相鄰的所有蘊函項框在一起，避免「一個bit切換」的 hazard 發生。 邏輯電路的模擬與測試 對模擬邏輯電路來說 有明確的電路元素與連線 決定輸入 觀察輸出 輸入值 有四種，分別為： 0 (low) 1 (high) X (unknown) Z (don\u0026rsquo;t care, High impedence) \\(\\text{AND } \\\u0026amp; \\text{ OR } \\text{function for 4-value simulation}\\) \\(\\begin{array}{c|cccc} \\text{AND}\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;Z\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\\\\ X\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\\\\ Z\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\\\\ \\end{array} \\qquad \\begin{array}{c|cccc} \\text{OR}\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;Z\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ X\u0026amp;X\u0026amp;1\u0026amp;X\u0026amp;X\\\\ Z\u0026amp;X\u0026amp;1\u0026amp;X\u0026amp;X\\\\ \\end{array} \\) 驗證(verification)與測試(testing) 邏輯電路的輸出錯誤，可以由下面兩種方式偵錯： 驗證(Verification) 錯誤的電路設計 邏輯閘接線錯誤 輸入訊號錯誤 測試(Testing) 邏輯閘缺陷 金屬接線缺陷 已知 \\(A=B=C=D=1時，F=0\\) ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec7/","summary":"Review 組合電路設計 建構真值表將輸出表示成輸入的函式 \\(\\text{Inputs}\\rightarrow\\boxed{\\text{MUX}}\\rightarrow\\text{Outputs}\\) 用 K-map, Q-M method 等方法得到簡化的布林表達式 多層、多輸出的電路(Multi-level \u0026amp; Multi-outputs) Mininum SOP 起點 Minimum two-level \\(\\text{AND-OR, NAND-NAND, OR-NAND, NOR-OR}\\) Minimum POS 起點 Minimum two-level \\(\\text{OR-AND, NOR-NOR, AND-NOR, NAND-AND}\\) 限制 fan-in 數的電路設計 Ex1 \\(\\text{用 3 pin 的 NOR Gate 實現}f(a,b,c,d)=\\sum m(0,3,4,5,8,9,10,14,15)\\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 01\u0026amp; 0\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 11\u0026amp; 1\u0026amp; 0\u0026amp; 1\u0026amp; 0\\\\\\hline 10\u0026amp; 0\u0026amp; 0\u0026amp; 1\u0026amp; 1\\\\\\hline \\end{array}\\) 從 POS 開始 \\(f\u0026rsquo;=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; d+ab\u0026rsquo; cd+abc\u0026rsquo; + a\u0026rsquo; bc+a\u0026rsquo; cd\u0026rsquo;\\\\ \\quad=b\u0026rsquo; d(a\u0026rsquo; c\u0026rsquo;+ac)+a\u0026rsquo; c(b+d\u0026rsquo;)+abc\u0026rsquo;\\) Ex2 Multiple-Output \\(\\text{用 2 pin 的 NAND 與 NOT 實現}\\) \\(f_1=\\sum m(0,2,3,4,5)=b\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; +a\u0026rsquo; b\\\\ f_2=\\sum m(0,2,3,4,7)=b\u0026rsquo; c\u0026rsquo;+bc+a\u0026rsquo; b\\\\ f_3=\\sum m(1,2,6,7)=a\u0026rsquo; b\u0026rsquo; c+ab+bc\u0026rsquo;\\) \\(\\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp;1\\\\\\hline 11\u0026amp;1\u0026amp; \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp;1 \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp; \u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp;1\\\\\\hline 10\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) \\(f_1=b\u0026rsquo;(a+c\u0026rsquo;)+a\u0026rsquo; b\\\\ f_2=(b\u0026rsquo;+c)(b+c\u0026rsquo;)+b\u0026rsquo; c\u0026rsquo;\\\\ f_3=b(a+c\u0026rsquo;)+a\u0026rsquo; b\u0026rsquo; c\\) 閘延遲與時序圖 邏輯閘必然存在延遲，固然小，但存在。 組合電路 延遲亦可能來自電線，電線愈長則延遲可能愈久。 Control value \\(\\text{AND gate}\\) 的 control value 是 \\(0\\) \\(\\text{OR gate}\\) 的 control value 是 \\(1\\) \\(\\text{AND=2ns}\\\\ \\text{NOR=3ns}\\) 若 X 訊號相反時， Z 要到 5ns 訊號才有意義。 組合邏輯中的 Hazards Hazard 是在切換輸入時，因閘延遲而產生的錯誤訊號。 種類 若相鄰兩個 1 不來自同一個邏輯閘(在 K-map 上沒有被框在一起)則會存在 hazard。 \\((A,B,C)=(1,0,1)\\rightarrow (1,1,1)\\) \u0008可將相鄰的所有蘊函項框在一起，避免「一個bit切換」的 hazard 發生。 邏輯電路的模擬與測試 對模擬邏輯電路來說 有明確的電路元素與連線 決定輸入 觀察輸出 輸入值 有四種，分別為： 0 (low) 1 (high) X (unknown) Z (don\u0026rsquo;t care, High impedence) \\(\\text{AND } \\\u0026amp; \\text{ OR } \\text{function for 4-value simulation}\\) \\(\\begin{array}{c|cccc} \\text{AND}\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;Z\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\\\\ X\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\\\\ Z\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\\\\ \\end{array} \\qquad \\begin{array}{c|cccc} \\text{OR}\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;Z\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ X\u0026amp;X\u0026amp;1\u0026amp;X\u0026amp;X\\\\ Z\u0026amp;X\u0026amp;1\u0026amp;X\u0026amp;X\\\\ \\end{array} \\) 驗證(verification)與測試(testing) 邏輯電路的輸出錯誤，可以由下面兩種方式偵錯： 驗證(Verification) 錯誤的電路設計 邏輯閘接線錯誤 輸入訊號錯誤 測試(Testing) 邏輯閘缺陷 金屬接線缺陷 已知 \\(A=B=C=D=1時，F=0\\) ","title":"[Logic Design] Lec 7 - 組合電路設計與模擬"},{"content":"多工器(Multiplexer, MUX) 一個 \\(2^n\\text{ to }1\\) 多工器，需要有 n 個控制項(選項器) \\(\\begin{array}{c|c|l} \\text{MUX}\u0026amp;\\text{sel}\u0026amp;\\text{Output}\\\\\\hline \\text{2 to 1}\u0026amp;1\u0026amp;A\u0026rsquo; I_0+AI_1\\\\\\hline \\text{4 to 1}\u0026amp;2\u0026amp;A\u0026rsquo; B\u0026rsquo; I_0+A\u0026rsquo; BI_1+AB\u0026rsquo; I_2+ABI_3\\\\\\hline \\text{8 to 1}\u0026amp;3\u0026amp;A\u0026rsquo; B\u0026rsquo; C\u0026rsquo; I_0+A\u0026rsquo; B\u0026rsquo; CI_1+\u0026hellip;\\\\\\hline 2^n\\text{ to 1}\u0026amp;n\u0026amp;\\sum_{k=0}^{2^n-1}m_kI_k \\end{array}\\) quad multiplexer 多了一個致能(enable, en)來控制多工器 用 4-1 多工器實現三個變數函式 代數展開\n\\(\\begin{array}{rl} F(A,B,C)\u0026amp;=A\u0026rsquo; B\u0026rsquo;+AC\\\\ \u0026amp;=A\u0026rsquo; B\u0026rsquo;(C+C\u0026rsquo;)+A(B+B\u0026rsquo;)C\\\\ \u0026amp;=A\u0026rsquo; B\u0026rsquo;\\cdot1+A\u0026rsquo; B\\cdot0+AB\u0026rsquo; C+ABC \\end{array}\\) 真值表法\n\\(\\begin{array}{|cccc:cc|}\\hline \u0026amp;A\u0026amp;B\u0026amp;C\u0026amp;F\\\\\\hline \u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ I_0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline \u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ I_1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\hline \u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ I_2\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;C\\\\\\hline \u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ I_3\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;C\\\\\\hline \\end{array}\\) Verilog 4-to-1 MUX implements 3-var function test bench 三態緩衝器(Three state buffer) 緩衝器(Buffers)的用途: 用來增加閘輸出的趨動力(driving force) 因為閘並聯而造成電容增加(fan out)，電容增加充電變慢，使電路變慢 總體而言，可用來調節電路的速度。 三態緩衝器: Three-state buffer 或 tri-state buffer 真值表\n\\(\\begin{array}{|cc|c|}\\hline B\u0026amp;A\u0026amp;C\\\\\\hline 0\u0026amp;0\u0026amp;Z\\\\\\hline 0\u0026amp;1\u0026amp;Z\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array}\\) 利用 tri-state buffer 實現 2-to-1 MUX tri-state buffer 並聯 真值表\n\\(\\begin{array}{|c|c|c|c|c|}\\hline \u0026amp;X\u0026amp;0\u0026amp;1\u0026amp;Z\\\\\\hline X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\\\\\\hline 0\u0026amp;X\u0026amp;0\u0026amp;X\u0026amp;0\\\\\\hline 1\u0026amp;X\u0026amp;X\u0026amp;1\u0026amp;1\\\\\\hline Z\u0026amp;X\u0026amp;0\u0026amp;1\u0026amp;Z\\\\\\hline \\end{array}\\) 應用 Bus 匯流排 Chip I/O 解碼器(Decoder) \\(n 個 \\text{input} 可以對應到 2^n 個 \\text{output}\\) 事實上，n 個 input 在編碼器前成生各種 minterm 的組合，後面面編碼器就是將 minterm \\(OR\\) 起來。 7442 編碼器，數字 1 到 9 產生對應位置的輸出為 0。 這樣的設計可以使雜訊的干擾變輕。 配合 \\(\\text{NAND Gate}\\)，其實就跟前面的編碼器一樣，是產生 minterm 再 \\(OR\\) 起來的過程。 \\(F_1=m_1+m_2+m_4 \\qquad F_2=m_4+m_7+m_9\\) 編碼器(Encoder) Priority Encoder 8-to-3 編碼，將輸入將對應的數字編到 abc 中。 若 input 端有兩個以上為 1，則輸出數字較高的數(MSB)。 d 的作用，用來表示輸入是否含有 1，否則為 0。 唯讀記憶體(Read only memories, ROMs) 唯讀記憶體就是一個編寫好的編碼器，輸入就像是位址(address)。 General Form \\(\\text{n inputs}\\rightarrow 2^n 個 \\text{words} \\rightarrow \\text{m outputs}\\) 可以把 ROM 看成 decoder 加上 memory array 用二極體形成 \\(OR\\) 的效果，一般也會將二極體極化成黑點。 二極體在這邊使電流為單向流動，一般二極體的壓降為 0.7V。 整個矩陣稱為 OR-plane。 word line 用於控制儲存單元與 bit line 的連通 bit line 用於讀寫儲存單元。(此處只有讀) ROM 的變形 PROM (prgrammable ROM): 使用光罩定義金屬線 OTP (one time program ROM): 利用 fuse 熔斷機制，一次性 EPROM(Erasable Programmable ROM) EEPROM(Electrically Erasable Programmable ROM) 可程式化邏輯元件(programmable logic devices) 現場可程式化邏輯閘陣列(Field programmable gate arrays, FPGAs) ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec8/","summary":"多工器(Multiplexer, MUX) 一個 \\(2^n\\text{ to }1\\) 多工器，需要有 n 個控制項(選項器) \\(\\begin{array}{c|c|l} \\text{MUX}\u0026amp;\\text{sel}\u0026amp;\\text{Output}\\\\\\hline \\text{2 to 1}\u0026amp;1\u0026amp;A\u0026rsquo; I_0+AI_1\\\\\\hline \\text{4 to 1}\u0026amp;2\u0026amp;A\u0026rsquo; B\u0026rsquo; I_0+A\u0026rsquo; BI_1+AB\u0026rsquo; I_2+ABI_3\\\\\\hline \\text{8 to 1}\u0026amp;3\u0026amp;A\u0026rsquo; B\u0026rsquo; C\u0026rsquo; I_0+A\u0026rsquo; B\u0026rsquo; CI_1+\u0026hellip;\\\\\\hline 2^n\\text{ to 1}\u0026amp;n\u0026amp;\\sum_{k=0}^{2^n-1}m_kI_k \\end{array}\\) quad multiplexer 多了一個致能(enable, en)來控制多工器 用 4-1 多工器實現三個變數函式 代數展開\n\\(\\begin{array}{rl} F(A,B,C)\u0026amp;=A\u0026rsquo; B\u0026rsquo;+AC\\\\ \u0026amp;=A\u0026rsquo; B\u0026rsquo;(C+C\u0026rsquo;)+A(B+B\u0026rsquo;)C\\\\ \u0026amp;=A\u0026rsquo; B\u0026rsquo;\\cdot1+A\u0026rsquo; B\\cdot0+AB\u0026rsquo; C+ABC \\end{array}\\) 真值表法\n\\(\\begin{array}{|cccc:cc|}\\hline \u0026amp;A\u0026amp;B\u0026amp;C\u0026amp;F\\\\\\hline \u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ I_0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline \u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ I_1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\hline \u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ I_2\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;C\\\\\\hline \u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ I_3\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;C\\\\\\hline \\end{array}\\) Verilog 4-to-1 MUX implements 3-var function test bench 三態緩衝器(Three state buffer) 緩衝器(Buffers)的用途: 用來增加閘輸出的趨動力(driving force) 因為閘並聯而造成電容增加(fan out)，電容增加充電變慢，使電路變慢 總體而言，可用來調節電路的速度。 三態緩衝器: Three-state buffer 或 tri-state buffer 真值表","title":"[Logic Design] Lec 8 - 多工器、編碼器、可程式化邏輯元件"},{"content":"Coding Interview University John Washam:\nI originally created this as a short to-do list of study topics for becoming a software engineer, but it grew to the large list you see today. After going through this study plan, I got hired as a Software Development Engineer at Amazon! You probably won\u0026rsquo;t have to study as much as I did. Anyway, everything you need is here.\nI studied about 8-12 hours a day, for several months. This is my story: Why I studied full-time for 8 months for a Google interview\nPlease Note: You won\u0026rsquo;t need to study as much as I did. I wasted a lot of time on things I didn\u0026rsquo;t need to know. More info about that below. I\u0026rsquo;ll help you get there without wasting your precious time.\nThe items listed here will prepare you well for a technical interview at just about any software company, including the giants: Amazon, Facebook, Google, and Microsoft.\nBest of luck to you!\nWhat is it? This is my multi-month study plan for becoming a software engineer for a large company.\nRequired:\nA little experience with coding (variables, loops, methods/functions, etc) Patience Time Note this is a study plan for software engineering, not web development. Large software companies like Google, Amazon, Facebook and Microsoft view software engineering as different from web development. For example, Amazon has Frontend Engineers (FEE) and Software Development Engineers (SDE). These are 2 separate roles and the interviews for them will not be the same, as each has its own competencies. These companies require computer science knowledge for software development/engineering roles.\nTable of Contents The Study Plan What is it? Why use it? How to use it Don\u0026rsquo;t feel you aren\u0026rsquo;t smart enough A Note About Video Resources Choose a Programming Language Books for Data Structures and Algorithms Interview Prep Books Don\u0026rsquo;t Make My Mistakes What you Won\u0026rsquo;t See Covered The Daily Plan Coding Question Practice Coding Problems Topics of Study Algorithmic complexity / Big-O / Asymptotic analysis Data Structures Arrays Linked Lists Stack Queue Hash table More Knowledge Binary search Bitwise operations Trees Trees - Notes \u0026amp; Background Binary search trees: BSTs Heap / Priority Queue / Binary Heap balanced search trees (general concept, not details) traversals: preorder, inorder, postorder, BFS, DFS Sorting selection insertion heapsort quicksort merge sort Graphs directed undirected adjacency matrix adjacency list traversals: BFS, DFS Even More Knowledge Recursion Dynamic Programming Design Patterns Combinatorics (n choose k) \u0026amp; Probability NP, NP-Complete and Approximation Algorithms How computers process a program Caches Processes and Threads Testing String searching \u0026amp; manipulations Tries Floating Point Numbers Unicode Endianness Networking Final Review Getting the Job Update Your Resume Find a Job Interview Process \u0026amp; General Interview Prep Be thinking of for when the interview comes Have questions for the interviewer Once You\u0026rsquo;ve Got The Job \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- Everything below this point is optional \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\nOptional Extra Topics \u0026amp; Resources Additional Books System Design, Scalability, Data Handling (if you have 4+ years experience) Additional Learning Compilers Emacs and vi(m) Unix command line tools Information theory Parity \u0026amp; Hamming Code Entropy Cryptography Compression Computer Security Garbage collection Parallel Programming Messaging, Serialization, and Queueing Systems A* Fast Fourier Transform Bloom Filter HyperLogLog Locality-Sensitive Hashing van Emde Boas Trees Augmented Data Structures Balanced search trees AVL trees Splay trees Red/black trees 2-3 search trees 2-3-4 Trees (aka 2-4 trees) N-ary (K-ary, M-ary) trees B-Trees k-D Trees Skip lists Network Flows Disjoint Sets \u0026amp; Union Find Math for Fast Processing Treap Linear Programming Geometry, Convex hull Discrete math Machine Learning Additional Detail on Some Subjects Video Series Computer Science Courses Papers Why use it? If you want to work as a software engineer for a large company, these are the things you have to know.\nIf you missed out on getting a degree in computer science, like I did, this will catch you up and save four years of your life.\nWhen I started this project, I didn\u0026rsquo;t know a stack from a heap, didn\u0026rsquo;t know Big-O anything, or anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it would have been terrible. Every data structure I had ever used was built into the language, and I didn\u0026rsquo;t know how they worked under the hood at all. I never had to manage memory unless a process I was running would give an \u0026ldquo;out of memory\u0026rdquo; error, and then I\u0026rsquo;d have to find a workaround. I used a few multidimensional arrays in my life and thousands of associative arrays, but I never created data structures from scratch.\nIt\u0026rsquo;s a long plan. It may take you months. If you are familiar with a lot of this already it will take you a lot less time.\nHow to use it Everything below is an outline, and you should tackle the items in order from top to bottom.\nI\u0026rsquo;m using GitHub\u0026rsquo;s special markdown flavor, including tasks lists to track progress.\nCreate a new branch so you can check items like this, just put an x in the brackets: [x]\nFork a branch and follow the commands below Fork the GitHub repo https://github.com/jwasham/coding-interview-university by clicking on the Fork button.\nClone to your local repo:\ngit clone git@github.com:\u0026lt;your_github_username\u0026gt;/coding-interview-university.git git checkout -b progress git remote add jwasham https://github.com/jwasham/coding-interview-university git fetch --all Mark all boxes with X after you completed your changes:\ngit add . git commit -m \u0026quot;Marked x\u0026quot; git rebase jwasham/main git push --set-upstream origin progress git push --force More about GitHub-flavored markdown\nDon\u0026rsquo;t feel you aren\u0026rsquo;t smart enough Successful software engineers are smart, but many have an insecurity that they aren\u0026rsquo;t smart enough. The myth of the Genius Programmer It\u0026rsquo;s Dangerous to Go Alone: Battling the Invisible Monsters in Tech A Note About Video Resources Some videos are available only by enrolling in a Coursera or EdX class. These are called MOOCs. Sometimes the classes are not in session so you have to wait a couple of months, so you have no access.\nIt would be great to replace the online course resources with free and always-available public sources, such as YouTube videos (preferably university lectures), so that you people can study these anytime, not just when a specific online course is in session.\nChoose a Programming Language You\u0026rsquo;ll need to choose a programming language for the coding interviews you do, but you\u0026rsquo;ll also need to find a language that you can use to study computer science concepts.\nPreferably the language would be the same, so that you only need to be proficient in one.\nFor this Study Plan When I did the study plan, I used 2 languages for most of it: C and Python\nC: Very low level. Allows you to deal with pointers and memory allocation/deallocation, so you feel the data structures and algorithms in your bones. In higher level languages like Python or Java, these are hidden from you. In day to day work, that\u0026rsquo;s terrific, but when you\u0026rsquo;re learning how these low-level data structures are built, it\u0026rsquo;s great to feel close to the metal. C is everywhere. You\u0026rsquo;ll see examples in books, lectures, videos, everywhere while you\u0026rsquo;re studying. The C Programming Language, Vol 2 This is a short book, but it will give you a great handle on the C language and if you practice it a little you\u0026rsquo;ll quickly get proficient. Understanding C helps you understand how programs and memory work. You don\u0026rsquo;t need to go super deep in the book (or even finish it). Just get to where you\u0026rsquo;re comfortable reading and writing in C. Answers to questions in the book Python: Modern and very expressive, I learned it because it\u0026rsquo;s just super useful and also allows me to write less code in an interview. This is my preference. You do what you like, of course.\nYou may not need it, but here are some sites for learning a new language:\nExercism Codewars Codility HackerEarth Sphere Online Judge (spoj) Codechef Codeforces For your Coding Interview You can use a language you are comfortable in to do the coding part of the interview, but for large companies, these are solid choices:\nC++ Java Python You could also use these, but read around first. There may be caveats:\nJavaScript Ruby Here is an article I wrote about choosing a language for the interview: Pick One Language for the Coding Interview. This is the original article my post was based on: http://blog.codingforinterviews.com/best-programming-language-jobs/\nYou need to be very comfortable in the language and be knowledgeable.\nRead more about choices:\nChoose the Right Language for Your Coding Interview See language-specific resources here\nBooks for Data Structures and Algorithms This book will form your foundation for computer science.\nJust choose one, in a language that you will be comfortable with. You\u0026rsquo;ll be doing a lot of reading and coding.\nC Algorithms in C, Parts 1-5 (Bundle), 3rd Edition Fundamentals, Data Structures, Sorting, Searching, and Graph Algorithms Python Data Structures and Algorithms in Python by Goodrich, Tamassia, Goldwasser I loved this book. It covered everything and more. Pythonic code my glowing book report: https://startupnextdoor.com/book-report-data-structures-and-algorithms-in-python/ Java Your choice:\nGoodrich, Tamassia, Goldwasser Data Structures and Algorithms in Java Sedgewick and Wayne: Algorithms Free Coursera course that covers the book (taught by the authors!): Algorithms I Algorithms II C++ Your choice:\nGoodrich, Tamassia, and Mount Data Structures and Algorithms in C++, 2nd Edition Sedgewick and Wayne Algorithms in C++, Parts 1-4: Fundamentals, Data Structure, Sorting, Searching Algorithms in C++ Part 5: Graph Algorithms Interview Prep Books You don\u0026rsquo;t need to buy a bunch of these. Honestly \u0026ldquo;Cracking the Coding Interview\u0026rdquo; is probably enough, but I bought more to give myself more practice. But I always do too much.\nI bought both of these. They gave me plenty of practice.\nProgramming Interviews Exposed: Coding Your Way Through the Interview, 4th Edition Answers in C++ and Java This is a good warm-up for Cracking the Coding Interview Not too difficult. Most problems may be easier than what you\u0026rsquo;ll see in an interview (from what I\u0026rsquo;ve read) Cracking the Coding Interview, 6th Edition answers in Java If you have tons of extra time: Choose one:\nElements of Programming Interviews (C++ version) Elements of Programming Interviews in Python Elements of Programming Interviews (Java version) - Companion Project - Method Stub and Test Cases for Every Problem in the Book Don\u0026rsquo;t Make My Mistakes This list grew over many months, and yes, it got out of hand.\nHere are some mistakes I made so you\u0026rsquo;ll have a better experience. And you\u0026rsquo;ll save months of time.\n1. You Won\u0026rsquo;t Remember it All I watched hours of videos and took copious notes, and months later there was much I didn\u0026rsquo;t remember. I spent 3 days going through my notes and making flashcards, so I could review. I didn\u0026rsquo;t need all of that knowledge.\nPlease, read so you won\u0026rsquo;t make my mistakes:\nRetaining Computer Science Knowledge.\n2. Use Flashcards To solve the problem, I made a little flashcards site where I could add flashcards of 2 types: general and code. Each card has different formatting. I made a mobile-first website, so I could review on my phone or tablet, wherever I am.\nMake your own for free:\nFlashcards site repo I DON\u0026rsquo;T RECOMMEND using my flashcards. There are too many and many of them are trivia that you don\u0026rsquo;t need.\nBut if you don\u0026rsquo;t want to listen to me, here you go:\nMy flash cards database (1200 cards): My flash cards database (extreme - 1800 cards): Keep in mind I went overboard and have cards covering everything from assembly language and Python trivia to machine learning and statistics. It\u0026rsquo;s way too much for what\u0026rsquo;s required.\nNote on flashcards: The first time you recognize you know the answer, don\u0026rsquo;t mark it as known. You have to see the same card and answer it several times correctly before you really know it. Repetition will put that knowledge deeper in your brain.\nAn alternative to using my flashcard site is Anki, which has been recommended to me numerous times. It uses a repetition system to help you remember. It\u0026rsquo;s user-friendly, available on all platforms and has a cloud sync system. It costs $25 on iOS but is free on other platforms.\nMy flashcard database in Anki format: https://ankiweb.net/shared/info/25173560 (thanks @xiewenya).\nSome students have mentioned formatting issues with white space that can be fixed by doing the following: open deck, edit card, click cards, select the \u0026ldquo;styling\u0026rdquo; radio button, add the member \u0026ldquo;white-space: pre;\u0026rdquo; to the card class.\n3. Do Coding Interview Questions While You\u0026rsquo;re Learning THIS IS VERY IMPORTANT.\nStart doing coding interview questions while you\u0026rsquo;re learning data structures and algorithms.\nYou need to apply what you\u0026rsquo;re learning to solving problems, or you\u0026rsquo;ll forget. I made this mistake.\nOnce you\u0026rsquo;ve learned a topic, and feel somewhat comfortable with it, for example, linked lists:\nOpen one of the coding interview books (or coding problem websites, listed below) Do 2 or 3 questions regarding linked lists. Move on to the next learning topic. Later, go back and do another 2 or 3 linked list problems. Do this with each new topic you learn. Keep doing problems while you\u0026rsquo;re learning all this stuff, not after.\nYou\u0026rsquo;re not being hired for knowledge, but how you apply the knowledge.\nThere are many resources for this, listed below. Keep going.\n4. Focus There are a lot of distractions that can take up valuable time. Focus and concentration are hard. Turn on some music without lyrics and you\u0026rsquo;ll be able to focus pretty well.\nWhat you won\u0026rsquo;t see covered These are prevalent technologies but not part of this study plan:\nSQL Javascript HTML, CSS, and other front-end technologies The Daily Plan This course goes over a lot of subjects. Each will probably take you a few days, or maybe even a week or more. It depends on your schedule.\nEach day, take the next subject in the list, watch some videos about that subject, and then write an implementation of that data structure or algorithm in the language you chose for this course.\nYou can see my code here:\nC C++ Python You don\u0026rsquo;t need to memorize every algorithm. You just need to be able to understand it enough to be able to write your own implementation.\nCoding Question Practice Why is this here? I'm not ready to interview. Then go back and read this.\nWhy you need to practice doing programming problems:\nProblem recognition, and where the right data structures and algorithms fit in Gathering requirements for the problem Talking your way through the problem like you will in the interview Coding on a whiteboard or paper, not a computer Coming up with time and space complexity for your solutions (see Big-O below) Testing your solutions There is a great intro for methodical, communicative problem solving in an interview. You\u0026rsquo;ll get this from the programming interview books, too, but I found this outstanding: Algorithm design canvas\nWrite code on a whiteboard or paper, not a computer. Test with some sample inputs. Then type it and test it out on a computer.\nIf you don\u0026rsquo;t have a whiteboard at home, pick up a large drawing pad from an art store. You can sit on the couch and practice. This is my \u0026ldquo;sofa whiteboard\u0026rdquo;. I added the pen in the photo just for scale. If you use a pen, you\u0026rsquo;ll wish you could erase. Gets messy quick. I use a pencil and eraser.\nCoding question practice is not about memorizing answers to programming problems.\nCoding Problems Don\u0026rsquo;t forget your key coding interview books here.\nSolving Problems:\nHow to Find a Solution How to Dissect a Topcoder Problem Statement Coding Interview Question Videos:\nIDeserve (88 videos) Tushar Roy (5 playlists) Super for walkthroughs of problem solutions Nick White - LeetCode Solutions (187 Videos) Good explanations of solution and the code You can watch several in a short time FisherCoder - LeetCode Solutions Challenge sites:\nLeetCode My favorite coding problem site. It\u0026rsquo;s worth the subscription money for the 1-2 months you\u0026rsquo;ll likely be preparing. See Nick White and FisherCoder Videos above for code walk-throughs. HackerRank TopCoder Geeks for Geeks InterviewBit Project Euler Let\u0026rsquo;s Get Started Alright, enough talk, let\u0026rsquo;s learn!\nBut don\u0026rsquo;t forget to do coding problems from above while you learn!\nAlgorithmic complexity / Big-O / Asymptotic analysis Nothing to implement here, you\u0026rsquo;re just watching videos and taking notes! Yay! There are a lot of videos here. Just watch enough until you understand it. You can always come back and review. Don\u0026rsquo;t worry if you don\u0026rsquo;t understand all the math behind it. You just need to understand how to express the complexity of an algorithm in terms of Big-O. Harvard CS50 - Asymptotic Notation (video) Big O Notations (general quick tutorial) (video) Big O Notation (and Omega and Theta) - best mathematical explanation (video) Skiena: video slides UC Berkeley Big O (video) Amortized Analysis (video) TopCoder (includes recurrence relations and master theorem): Computational Complexity: Section 1 Computational Complexity: Section 2 Cheat sheet Well, that\u0026rsquo;s about enough of that.\nWhen you go through \u0026ldquo;Cracking the Coding Interview\u0026rdquo;, there is a chapter on this, and at the end there is a quiz to see if you can identify the runtime complexity of different algorithms. It\u0026rsquo;s a super review and test.\nData Structures Arrays About Arrays: Arrays (video) UC Berkeley CS61B - Linear and Multi-Dim Arrays (video) (Start watching from 15m 32s) Dynamic Arrays (video) Jagged Arrays (video) Implement a vector (mutable array with automatic resizing): Practice coding using arrays and pointers, and pointer math to jump to an index instead of using indexing. New raw data array with allocated memory can allocate int array under the hood, just not use its features start with 16, or if starting number is greater, use power of 2 - 16, 32, 64, 128 size() - number of items capacity() - number of items it can hold is_empty() at(index) - returns item at given index, blows up if index out of bounds push(item) insert(index, item) - inserts item at index, shifts that index\u0026rsquo;s value and trailing elements to the right prepend(item) - can use insert above at index 0 pop() - remove from end, return value delete(index) - delete item at index, shifting all trailing elements left remove(item) - looks for value and removes index holding it (even if in multiple places) find(item) - looks for value and returns first index with that value, -1 if not found resize(new_capacity) // private function when you reach capacity, resize to double the size when popping an item, if size is 1/4 of capacity, resize to half Time O(1) to add/remove at end (amortized for allocations for more space), index, or update O(n) to insert/remove elsewhere Space contiguous in memory, so proximity helps performance space needed = (array capacity, which is \u0026gt;= n) * size of item, but even if 2n, still O(n) Linked Lists Description: Singly Linked Lists (video) CS 61B - Linked Lists 1 (video) CS 61B - Linked Lists 2 (video) C Code (video) - not the whole video, just portions about Node struct and memory allocation Linked List vs Arrays: Core Linked Lists Vs Arrays (video) In The Real World Linked Lists Vs Arrays (video) why you should avoid linked lists (video) Gotcha: you need pointer to pointer knowledge: (for when you pass a pointer to a function that may change the address where that pointer points) This page is just to get a grasp on ptr to ptr. I don\u0026rsquo;t recommend this list traversal style. Readability and maintainability suffer due to cleverness. Pointers to Pointers Implement (I did with tail pointer \u0026amp; without): size() - returns number of data elements in list empty() - bool returns true if empty value_at(index) - returns the value of the nth item (starting at 0 for first) push_front(value) - adds an item to the front of the list pop_front() - remove front item and return its value push_back(value) - adds an item at the end pop_back() - removes end item and returns its value front() - get value of front item back() - get value of end item insert(index, value) - insert value at index, so current item at that index is pointed to by new item at index erase(index) - removes node at given index value_n_from_end(n) - returns the value of the node at nth position from the end of the list reverse() - reverses the list remove_value(value) - removes the first item in the list with this value Doubly-linked List Description (video) No need to implement Stack Stacks (video) Will not implement. Implementing with array is trivial Queue Queue (video) Circular buffer/FIFO Implement using linked-list, with tail pointer: enqueue(value) - adds value at position at tail dequeue() - returns value and removes least recently added element (front) empty() Implement using fixed-sized array: enqueue(value) - adds item at end of available storage dequeue() - returns value and removes least recently added element empty() full() Cost: a bad implementation using linked list where you enqueue at head and dequeue at tail would be O(n) because you\u0026rsquo;d need the next to last element, causing a full traversal each dequeue enqueue: O(1) (amortized, linked list and array [probing]) dequeue: O(1) (linked list and array) empty: O(1) (linked list and array) Hash table Videos:\nHashing with Chaining (video) Table Doubling, Karp-Rabin (video) Open Addressing, Cryptographic Hashing (video) PyCon 2010: The Mighty Dictionary (video) PyCon 2017: The Dictionary Even Mightier (video) (Advanced) Randomization: Universal \u0026amp; Perfect Hashing (video) (Advanced) Perfect hashing (video) Online Courses:\nCore Hash Tables (video) Data Structures (video) Phone Book Problem (video) distributed hash tables: Instant Uploads And Storage Optimization In Dropbox (video) Distributed Hash Tables (video) Implement with array using linear probing\nhash(k, m) - m is size of hash table add(key, value) - if key already exists, update value exists(key) get(key) remove(key) More Knowledge Binary search Binary Search (video) Binary Search (video) detail Implement: binary search (on sorted array of integers) binary search using recursion Bitwise operations Bits cheat sheet - you should know many of the powers of 2 from (2^1 to 2^16 and 2^32) Get a really good understanding of manipulating bits with: \u0026amp;, |, ^, ~, \u0026raquo;, \u0026laquo; words Good intro: Bit Manipulation (video) C Programming Tutorial 2-10: Bitwise Operators (video) Bit Manipulation Bitwise Operation Bithacks The Bit Twiddler The Bit Twiddler Interactive Bit Hacks (video) Practice Operations 2s and 1s complement Binary: Plusses \u0026amp; Minuses (Why We Use Two\u0026rsquo;s Complement) (video) 1s Complement 2s Complement Count set bits 4 ways to count bits in a byte (video) Count Bits How To Count The Number Of Set Bits In a 32 Bit Integer Swap values: Swap Absolute value: Absolute Integer Trees Trees - Notes \u0026amp; Background Series: Trees (video) basic tree construction traversal manipulation algorithms BFS(breadth-first search) and DFS(depth-first search) (video) BFS notes: level order (BFS, using queue) time complexity: O(n) space complexity: best: O(1), worst: O(n/2)=O(n) DFS notes: time complexity: O(n) space complexity: best: O(log n) - avg. height of tree worst: O(n) inorder (DFS: left, self, right) postorder (DFS: left, right, self) preorder (DFS: self, left, right) Binary search trees: BSTs Binary Search Tree Review (video) Introduction (video) MIT (video) C/C++: Binary search tree - Implementation in C/C++ (video) BST implementation - memory allocation in stack and heap (video) Find min and max element in a binary search tree (video) Find height of a binary tree (video) Binary tree traversal - breadth-first and depth-first strategies (video) Binary tree: Level Order Traversal (video) Binary tree traversal: Preorder, Inorder, Postorder (video) Check if a binary tree is binary search tree or not (video) Delete a node from Binary Search Tree (video) Inorder Successor in a binary search tree (video) Implement: insert // insert value into tree get_node_count // get count of values stored print_values // prints the values in the tree, from min to max delete_tree is_in_tree // returns true if given value exists in the tree get_height // returns the height in nodes (single node\u0026rsquo;s height is 1) get_min // returns the minimum value stored in the tree get_max // returns the maximum value stored in the tree is_binary_search_tree delete_value get_successor // returns next-highest value in tree after given value, -1 if none Heap / Priority Queue / Binary Heap visualized as a tree, but is usually linear in storage (array, linked list) Heap Introduction (video) Naive Implementations (video) Binary Trees (video) Tree Height Remark (video) Basic Operations (video) Complete Binary Trees (video) Pseudocode (video) Heap Sort - jumps to start (video) Heap Sort (video) Building a heap (video) MIT: Heaps and Heap Sort (video) CS 61B Lecture 24: Priority Queues (video) Linear Time BuildHeap (max-heap) Implement a max-heap: insert sift_up - needed for insert get_max - returns the max item, without removing it get_size() - return number of elements stored is_empty() - returns true if heap contains no elements extract_max - returns the max item, removing it sift_down - needed for extract_max remove(x) - removes item at index x heapify - create a heap from an array of elements, needed for heap_sort heap_sort() - take an unsorted array and turn it into a sorted array in-place using a max heap or min heap Sorting Notes:\nImplement sorts \u0026amp; know best case/worst case, average complexity of each: no bubble sort - it\u0026rsquo;s terrible - O(n^2), except when n \u0026lt;= 16 Stability in sorting algorithms (\u0026ldquo;Is Quicksort stable?\u0026rdquo;) Sorting Algorithm Stability Stability In Sorting Algorithms Stability In Sorting Algorithms Sorting Algorithms - Stability Which algorithms can be used on linked lists? Which on arrays? Which on both? I wouldn\u0026rsquo;t recommend sorting a linked list, but merge sort is doable. Merge Sort For Linked List For heapsort, see Heap data structure above. Heap sort is great, but not stable\nSedgewick - Mergesort (5 videos)\n1. Mergesort 2. Bottom up Mergesort 3. Sorting Complexity 4. Comparators 5. Stability Sedgewick - Quicksort (4 videos)\n1. Quicksort 2. Selection 3. Duplicate Keys 4. System Sorts UC Berkeley:\nCS 61B Lecture 29: Sorting I (video) CS 61B Lecture 30: Sorting II (video) CS 61B Lecture 32: Sorting III (video) CS 61B Lecture 33: Sorting V (video) Bubble Sort (video)\nAnalyzing Bubble Sort (video)\nInsertion Sort, Merge Sort (video)\nInsertion Sort (video)\nMerge Sort (video)\nQuicksort (video)\nSelection Sort (video)\nMerge sort code:\nUsing output array (C) Using output array (Python) In-place (C++) Quick sort code:\nImplementation (C) Implementation (C) Implementation (Python) Implement:\nMergesort: O(n log n) average and worst case Quicksort O(n log n) average case Selection sort and insertion sort are both O(n^2) average and worst case For heapsort, see Heap data structure above Not required, but I recommended them:\nSedgewick - Radix Sorts (6 videos) 1. Strings in Java 2. Key Indexed Counting 3. Least Significant Digit First String Radix Sort 4. Most Significant Digit First String Radix Sort 5. 3 Way Radix Quicksort 6. Suffix Arrays Radix Sort Radix Sort (video) Radix Sort, Counting Sort (linear time given constraints) (video) Randomization: Matrix Multiply, Quicksort, Freivalds\u0026rsquo; algorithm (video) Sorting in Linear Time (video) As a summary, here is a visual representation of 15 sorting algorithms. If you need more detail on this subject, see \u0026ldquo;Sorting\u0026rdquo; section in Additional Detail on Some Subjects\nGraphs Graphs can be used to represent many problems in computer science, so this section is long, like trees and sorting were.\nNotes:\nThere are 4 basic ways to represent a graph in memory: objects and pointers adjacency matrix adjacency list adjacency map Familiarize yourself with each representation and its pros \u0026amp; cons BFS and DFS - know their computational complexity, their trade offs, and how to implement them in real code When asked a question, look for a graph-based solution first, then move on if none MIT(videos):\nBreadth-First Search Depth-First Search Skiena Lectures - great intro:\nCSE373 2012 - Lecture 11 - Graph Data Structures (video) CSE373 2012 - Lecture 12 - Breadth-First Search (video) CSE373 2012 - Lecture 13 - Graph Algorithms (video) CSE373 2012 - Lecture 14 - Graph Algorithms (con\u0026rsquo;t) (video) CSE373 2012 - Lecture 15 - Graph Algorithms (con\u0026rsquo;t 2) (video) CSE373 2012 - Lecture 16 - Graph Algorithms (con\u0026rsquo;t 3) (video) Graphs (review and more):\n6.006 Single-Source Shortest Paths Problem (video) 6.006 Dijkstra (video) 6.006 Bellman-Ford (video) 6.006 Speeding Up Dijkstra (video) Aduni: Graph Algorithms I - Topological Sorting, Minimum Spanning Trees, Prim\u0026rsquo;s Algorithm - Lecture 6 (video) Aduni: Graph Algorithms II - DFS, BFS, Kruskal\u0026rsquo;s Algorithm, Union Find Data Structure - Lecture 7 (video) Aduni: Graph Algorithms III: Shortest Path - Lecture 8 (video) Aduni: Graph Alg. IV: Intro to geometric algorithms - Lecture 9 (video) CS 61B 2014 (starting at 58:09) (video) CS 61B 2014: Weighted graphs (video) Greedy Algorithms: Minimum Spanning Tree (video) Strongly Connected Components Kosaraju\u0026rsquo;s Algorithm Graph Algorithm (video) Full Coursera Course:\nAlgorithms on Graphs (video) I\u0026rsquo;ll implement:\nDFS with adjacency list (recursive) DFS with adjacency list (iterative with stack) DFS with adjacency matrix (recursive) DFS with adjacency matrix (iterative with stack) BFS with adjacency list BFS with adjacency matrix single-source shortest path (Dijkstra) minimum spanning tree DFS-based algorithms (see Aduni videos above): check for cycle (needed for topological sort, since we\u0026rsquo;ll check for cycle before starting) topological sort count connected components in a graph list strongly connected components check for bipartite graph Even More Knowledge Recursion Stanford lectures on recursion \u0026amp; backtracking: Lecture 8 | Programming Abstractions (video) Lecture 9 | Programming Abstractions (video) Lecture 10 | Programming Abstractions (video) Lecture 11 | Programming Abstractions (video) When it is appropriate to use it? How is tail recursion better than not? What Is Tail Recursion Why Is It So Bad? Tail Recursion (video) Dynamic Programming You probably won\u0026rsquo;t see any dynamic programming problems in your interview, but it\u0026rsquo;s worth being able to recognize a problem as being a candidate for dynamic programming. This subject can be pretty difficult, as each DP soluble problem must be defined as a recursion relation, and coming up with it can be tricky. I suggest looking at many examples of DP problems until you have a solid understanding of the pattern involved. Videos: the Skiena videos can be hard to follow since he sometimes uses the whiteboard, which is too small to see Skiena: CSE373 2012 - Lecture 19 - Introduction to Dynamic Programming (video) Skiena: CSE373 2012 - Lecture 20 - Edit Distance (video) Skiena: CSE373 2012 - Lecture 21 - Dynamic Programming Examples (video) Skiena: CSE373 2012 - Lecture 22 - Applications of Dynamic Programming (video) Simonson: Dynamic Programming 0 (starts at 59:18) (video) Simonson: Dynamic Programming I - Lecture 11 (video) Simonson: Dynamic programming II - Lecture 12 (video) List of individual DP problems (each is short): Dynamic Programming (video) Yale Lecture notes: Dynamic Programming Coursera: The RNA secondary structure problem (video) A dynamic programming algorithm (video) Illustrating the DP algorithm (video) Running time of the DP algorithm (video) DP vs. recursive implementation (video) Global pairwise sequence alignment (video) Local pairwise sequence alignment (video) Design patterns Quick UML review (video) Learn these patterns: strategy singleton adapter prototype decorator visitor factory, abstract factory facade observer proxy delegate command state memento iterator composite flyweight Series of videos (27 videos) Book: Head First Design Patterns I know the canonical book is \u0026ldquo;Design Patterns: Elements of Reusable Object-Oriented Software\u0026rdquo;, but Head First is great for beginners to OO. Handy reference: 101 Design Patterns \u0026amp; Tips for Developers Combinatorics (n choose k) \u0026amp; Probability Math Skills: How to find Factorial, Permutation and Combination (Choose) (video) Make School: Probability (video) Make School: More Probability and Markov Chains (video) Khan Academy: Course layout: Basic Theoretical Probability Just the videos - 41 (each are simple and each are short): Probability Explained (video) NP, NP-Complete and Approximation Algorithms Know about the most famous classes of NP-complete problems, such as traveling salesman and the knapsack problem, and be able to recognize them when an interviewer asks you them in disguise. Know what NP-complete means. Computational Complexity (video) Simonson: Greedy Algs. II \u0026amp; Intro to NP Completeness (video) NP Completeness II \u0026amp; Reductions (video) NP Completeness III (Video) NP Completeness IV (video) Skiena: CSE373 2012 - Lecture 23 - Introduction to NP-Completeness (video) CSE373 2012 - Lecture 24 - NP-Completeness Proofs (video) CSE373 2012 - Lecture 25 - NP-Completeness Challenge (video) Complexity: P, NP, NP-completeness, Reductions (video) Complexity: Approximation Algorithms (video) Complexity: Fixed-Parameter Algorithms (video) Peter Norvig discusses near-optimal solutions to traveling salesman problem: Jupyter Notebook Pages 1048 - 1140 in CLRS if you have it. How computers process a program How CPU executes a program (video) How computers calculate - ALU (video) Registers and RAM (video) The Central Processing Unit (CPU) (video) Instructions and Programs (video) Caches LRU cache: The Magic of LRU Cache (100 Days of Google Dev) (video) Implementing LRU (video) LeetCode - 146 LRU Cache (C++) (video) CPU cache: MIT 6.004 L15: The Memory Hierarchy (video) MIT 6.004 L16: Cache Issues (video) Processes and Threads Computer Science 162 - Operating Systems (25 videos): for processes and threads see videos 1-11 Operating Systems and System Programming (video) What Is The Difference Between A Process And A Thread? Covers: Processes, Threads, Concurrency issues Difference between processes and threads Processes Threads Locks Mutexes Semaphores Monitors How they work? Deadlock Livelock CPU activity, interrupts, context switching Modern concurrency constructs with multicore processors Paging, segmentation and virtual memory (video) Interrupts (video) Process resource needs (memory: code, static storage, stack, heap, and also file descriptors, i/o) Thread resource needs (shares above (minus stack) with other threads in the same process but each has its own pc, stack counter, registers, and stack) Forking is really copy on write (read-only) until the new process writes to memory, then it does a full copy. Context switching How context switching is initiated by the operating system and underlying hardware? threads in C++ (series - 10 videos) CS 377 Spring \u0026lsquo;14: Operating Systems from University of Massachusetts concurrency in Python (videos): Short series on threads Python Threads Understanding the Python GIL (2010) reference David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015 Keynote David Beazley - Topics of Interest (Python Asyncio) Mutex in Python Testing To cover: how unit testing works what are mock objects what is integration testing what is dependency injection Agile Software Testing with James Bach (video) Open Lecture by James Bach on Software Testing (video) Steve Freeman - Test-Driven Development (that’s not what we meant) (video) slides Dependency injection: video Tao Of Testing How to write tests String searching \u0026amp; manipulations Sedgewick - Suffix Arrays (video) Sedgewick - Substring Search (videos) 1. Introduction to Substring Search 2. Brute-Force Substring Search 3. Knuth-Morris Pratt 4. Boyer-Moore 5. Rabin-Karp Search pattern in text (video) If you need more detail on this subject, see \u0026ldquo;String Matching\u0026rdquo; section in Additional Detail on Some Subjects.\nTries Note there are different kinds of tries. Some have prefixes, some don\u0026rsquo;t, and some use string instead of bits to track the path I read through code, but will not implement Sedgewick - Tries (3 videos) 1. R Way Tries 2. Ternary Search Tries 3. Character Based Operations Notes on Data Structures and Programming Techniques Short course videos: Introduction To Tries (video) Performance Of Tries (video) Implementing A Trie (video) The Trie: A Neglected Data Structure TopCoder - Using Tries Stanford Lecture (real world use case) (video) MIT, Advanced Data Structures, Strings (can get pretty obscure about halfway through) (video) Floating Point Numbers simple 8-bit: Representation of Floating Point Numbers - 1 (video - there is an error in calculations - see video description) 32 bit: IEEE754 32-bit floating point binary (video) Unicode The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text Endianness Big And Little Endian Big Endian Vs Little Endian (video) Big And Little Endian Inside/Out (video) Very technical talk for kernel devs. Don\u0026rsquo;t worry if most is over your head. The first half is enough. Networking if you have networking experience or want to be a reliability engineer or operations engineer, expect questions Otherwise, this is just good to know Khan Academy UDP and TCP: Comparison of Transport Protocols (video) TCP/IP and the OSI Model Explained! (video) Packet Transmission across the Internet. Networking \u0026amp; TCP/IP tutorial. (video) HTTP (video) SSL and HTTPS (video) SSL/TLS (video) HTTP 2.0 (video) Video Series (21 videos) (video) Subnetting Demystified - Part 5 CIDR Notation (video) Sockets: Java - Sockets - Introduction (video) Socket Programming (video) Final Review This section will have shorter videos that you can watch pretty quickly to review most of the important concepts. It's nice if you want a refresher often. Series of 2-3 minutes short subject videos (23 videos) Videos Series of 2-5 minutes short subject videos - Michael Sambol (18 videos): Videos Sedgewick Videos - Algorithms I Sedgewick Videos - Algorithms II Update Your Resume See Resume prep information in the books: \u0026ldquo;Cracking The Coding Interview\u0026rdquo; and \u0026ldquo;Programming Interviews Exposed\u0026rdquo; I don\u0026rsquo;t know how important this is (you can do your own research) but here is an article on making your resume ATS Compliant: How to Create or Check if your Resume is ATS Compliant \u0026ldquo;This Is What A GOOD Resume Should Look Like\u0026rdquo; by Gayle McDowell (author of Cracking the Coding Interview), Note by the author: \u0026ldquo;This is for a US-focused resume. CVs for India and other countries have different expectations, although many of the points will be the same.\u0026rdquo; Find a Job Sites for Finding Jobs Interview Process \u0026amp; General Interview Prep How to Pass the Engineering Interview in 2021 Demystifying Tech Recruiting How to Get a Job at the Big 4: How to Get a Job at the Big 4 - Amazon, Facebook, Google \u0026amp; Microsoft (video) How to Get a Job at the Big 4.1 (Follow-up video) Cracking The Coding Interview Set 1: Gayle L McDowell - Cracking The Coding Interview (video) Cracking the Coding Interview with Author Gayle Laakmann McDowell (video) Cracking the Facebook Coding Interview: The Approach Problem Walkthrough Prep Courses: Software Engineer Interview Unleashed (paid course): Learn how to make yourself ready for software engineer interviews from a former Google interviewer. Python for Data Structures, Algorithms, and Interviews (paid course): A Python centric interview prep course which covers data structures, algorithms, mock interviews and much more. Intro to Data Structures and Algorithms using Python (Udacity free course): A free Python centric data structures and algorithms course. Data Structures and Algorithms Nanodegree! (Udacity paid Nanodegree): Get hands-on practice with over 100 data structures and algorithm exercises and guidance from a dedicated mentor to help prepare you for interviews and on-the-job scenarios. Grokking the Behavioral Interview (Educative free course): Many times, it’s not your technical competency that holds you back from landing your dream job, it’s how you perform on the behavioral interview. Mock Interviews:\nGainlo.co: Mock interviewers from big companies - I used this and it helped me relax for the phone screen and on-site interview Pramp: Mock interviews from/with peers - peer-to-peer model of practice interviews interviewing.io: Practice mock interview with senior engineers - anonymous algorithmic/systems design interviews with senior engineers from FAANG anonymously Be thinking of for when the interview comes Think of about 20 interview questions you\u0026rsquo;ll get, along with the lines of the items below. Have at least one answer for each. Have a story, not just data, about something you accomplished.\nWhy do you want this job?\nWhat\u0026rsquo;s a tough problem you\u0026rsquo;ve solved?\nBiggest challenges faced?\nBest/worst designs seen?\nIdeas for improving an existing product\nHow do you work best, as an individual and as part of a team?\nWhich of your skills or experiences would be assets in the role and why?\nWhat did you most enjoy at [job x / project y]?\nWhat was the biggest challenge you faced at [job x / project y]?\nWhat was the hardest bug you faced at [job x / project y]?\nWhat did you learn at [job x / project y]?\nWhat would you have done better at [job x / project y]?\nIf you find it hard to come up with good answers of these types of interview questions, here are some ideas:\nGeneral Interview Questions and their Answers Have questions for the interviewer Some of mine (I already may know the answers, but want their opinion or team perspective):\nHow large is your team? What does your dev cycle look like? Do you do waterfall/sprints/agile? Are rushes to deadlines common? Or is there flexibility? How are decisions made in your team? How many meetings do you have per week? Do you feel your work environment helps you concentrate? What are you working on? What do you like about it? What is the work life like? How is the work/life balance? Once You\u0026rsquo;ve Got The Job Congratulations!\nKeep learning.\nYou\u0026rsquo;re never really done.\n***************************************************************************************************** ***************************************************************************************************** Everything below this point is optional. It is NOT needed for an entry-level interview. However, by studying these, you'll get greater exposure to more CS concepts, and will be better prepared for any software engineering job. You'll be a much more well-rounded software engineer. ***************************************************************************************************** ***************************************************************************************************** Additional Books These are here so you can dive into a topic you find interesting. The Unix Programming Environment An oldie but a goodie The Linux Command Line: A Complete Introduction A modern option TCP/IP Illustrated Series Head First Design Patterns A gentle introduction to design patterns Design Patterns: Elements of Reusable Object-Oriente​d Software AKA the \u0026ldquo;Gang Of Four\u0026rdquo; book, or GOF The canonical design patterns book Algorithm Design Manual (Skiena) As a review and problem recognition The algorithm catalog portion is well beyond the scope of difficulty you\u0026rsquo;ll get in an interview This book has 2 parts: Class textbook on data structures and algorithms Pros: Is a good review as any algorithms textbook would be Nice stories from his experiences solving problems in industry and academia Code examples in C Cons: Can be as dense or impenetrable as CLRS, and in some cases, CLRS may be a better alternative for some subjects Chapters 7, 8, 9 can be painful to try to follow, as some items are not explained well or require more brain than I have Don\u0026rsquo;t get me wrong: I like Skiena, his teaching style, and mannerisms, but I may not be Stony Brook material Algorithm catalog: This is the real reason you buy this book. This book is better as an algorithm reference, and not something you read cover to cover. Can rent it on Kindle Answers: Solutions Solutions Errata Write Great Code: Volume 1: Understanding the Machine The book was published in 2004, and is somewhat outdated, but it\u0026rsquo;s a terrific resource for understanding a computer in brief The author invented HLA, so take mentions and examples in HLA with a grain of salt. Not widely used, but decent examples of what assembly looks like These chapters are worth the read to give you a nice foundation: Chapter 2 - Numeric Representation Chapter 3 - Binary Arithmetic and Bit Operations Chapter 4 - Floating-Point Representation Chapter 5 - Character Representation Chapter 6 - Memory Organization and Access Chapter 7 - Composite Data Types and Memory Objects Chapter 9 - CPU Architecture Chapter 10 - Instruction Set Architecture Chapter 11 - Memory Architecture and Organization Introduction to Algorithms Important: Reading this book will only have limited value. This book is a great review of algorithms and data structures, but won\u0026rsquo;t teach you how to write good code. You have to be able to code a decent solution efficiently AKA CLR, sometimes CLRS, because Stein was late to the game Computer Architecture, Sixth Edition: A Quantitative Approach For a richer, more up-to-date (2017), but longer treatment System Design, Scalability, Data Handling You can expect system design questions if you have 4+ years of experience.\nScalability and System Design are very large topics with many topics and resources, since there is a lot to consider when designing a software/hardware system that can scale. Expect to spend quite a bit of time on this Considerations: Scalability Distill large data sets to single values Transform one data set to another Handling obscenely large amounts of data System design features sets interfaces class hierarchies designing a system under certain constraints simplicity and robustness tradeoffs performance analysis and optimization START HERE: The System Design Primer System Design from HiredInTech How Do I Prepare To Answer Design Questions In A Technical Interview? 8 Things You Need to Know Before a System Design Interview Database Normalization - 1NF, 2NF, 3NF and 4NF (video) System Design Interview - There are a lot of resources in this one. Look through the articles and examples. I put some of them below How to ace a systems design interview Numbers Everyone Should Know How long does it take to make a context switch? Transactions Across Datacenters (video) A plain English introduction to CAP Theorem MIT 6.824: Distributed Systems, Spring 2020 (20 videos) Consensus Algorithms: Paxos - Paxos Agreement - Computerphile (video) Raft - An Introduction to the Raft Distributed Consensus Algorithm (video) Easy-to-read paper Infographic Consistent Hashing NoSQL Patterns Scalability: You don\u0026rsquo;t need all of these. Just pick a few that interest you. Great overview (video) Short series: Clones Database Cache Asynchronism Scalable Web Architecture and Distributed Systems Fallacies of Distributed Computing Explained Jeff Dean - Building Software Systems At Google and Lessons Learned (video) Introduction to Architecting Systems for Scale Scaling mobile games to a global audience using App Engine and Cloud Datastore (video) How Google Does Planet-Scale Engineering for Planet-Scale Infra (video) The Importance of Algorithms Sharding Engineering for the Long Game - Astrid Atkinson Keynote(video) 7 Years Of YouTube Scalability Lessons In 30 Minutes video How PayPal Scaled To Billions Of Transactions Daily Using Just 8VMs How to Remove Duplicates in Large Datasets A look inside Etsy\u0026rsquo;s scale and engineering culture with Jon Cowie (video) What Led Amazon to its Own Microservices Architecture To Compress Or Not To Compress, That Was Uber\u0026rsquo;s Question When Should Approximate Query Processing Be Used? Google\u0026rsquo;s Transition From Single Datacenter, To Failover, To A Native Multihomed Architecture The Image Optimization Technology That Serves Millions Of Requests Per Day A Patreon Architecture Short Tinder: How Does One Of The Largest Recommendation Engines Decide Who You\u0026rsquo;ll See Next? Design Of A Modern Cache Live Video Streaming At Facebook Scale A Beginner\u0026rsquo;s Guide To Scaling To 11 Million+ Users On Amazon\u0026rsquo;s AWS A 360 Degree View Of The Entire Netflix Stack Latency Is Everywhere And It Costs You Sales - How To Crush It What Powers Instagram: Hundreds of Instances, Dozens of Technologies Salesforce Architecture - How They Handle 1.3 Billion Transactions A Day ESPN\u0026rsquo;s Architecture At Scale - Operating At 100,000 Duh Nuh Nuhs Per Second See \u0026ldquo;Messaging, Serialization, and Queueing Systems\u0026rdquo; way below for info on some of the technologies that can glue services together Twitter: O\u0026rsquo;Reilly MySQL CE 2011: Jeremy Cole, \u0026ldquo;Big and Small Data at @Twitter\u0026rdquo; (video) Timelines at Scale For even more, see \u0026ldquo;Mining Massive Datasets\u0026rdquo; video series in the Video Series section Practicing the system design process: Here are some ideas to try working through on paper, each with some documentation on how it was handled in the real world: review: The System Design Primer System Design from HiredInTech cheat sheet flow: Understand the problem and scope: Define the use cases, with interviewer\u0026rsquo;s help Suggest additional features Remove items that interviewer deems out of scope Assume high availability is required, add as a use case Think about constraints: Ask how many requests per month Ask how many requests per second (they may volunteer it or make you do the math) Estimate reads vs. writes percentage Keep 80/20 rule in mind when estimating How much data written per second Total storage required over 5 years How much data read per second Abstract design: Layers (service, data, caching) Infrastructure: load balancing, messaging Rough overview of any key algorithm that drives the service Consider bottlenecks and determine solutions Exercises: Design a random unique ID generation system Design a key-value database Design a picture sharing system Design a recommendation system Design a URL-shortener system: copied from above Design a cache system Additional Learning I added them to help you become a well-rounded software engineer, and to be aware of certain technologies and algorithms, so you'll have a bigger toolbox. Compilers How a Compiler Works in ~1 minute (video) Harvard CS50 - Compilers (video) C++ (video) Understanding Compiler Optimization (C++) (video) Emacs and vi(m) Familiarize yourself with a unix-based code editor vi(m): Editing With vim 01 - Installation, Setup, and The Modes (video) VIM Adventures set of 4 videos: The vi/vim editor - Lesson 1 The vi/vim editor - Lesson 2 The vi/vim editor - Lesson 3 The vi/vim editor - Lesson 4 Using Vi Instead of Emacs emacs: Basics Emacs Tutorial (video) set of 3 (videos): Emacs Tutorial (Beginners) -Part 1- File commands, cut/copy/paste, cursor commands Emacs Tutorial (Beginners) -Part 2- Buffer management, search, M-x grep and rgrep modes Emacs Tutorial (Beginners) -Part 3- Expressions, Statements, ~/.emacs file and packages Evil Mode: Or, How I Learned to Stop Worrying and Love Emacs (video) Writing C Programs With Emacs (maybe) Org Mode In Depth: Managing Structure (video) Unix command line tools I filled in the list below from good tools. bash cat grep sed awk curl or wget sort tr uniq strace tcpdump Information theory (videos) Khan Academy More about Markov processes: Core Markov Text Generation Core Implementing Markov Text Generation Project = Markov Text Generation Walk Through See more in MIT 6.050J Information and Entropy series below Parity \u0026amp; Hamming Code (videos) Intro Parity Hamming Code: Error detection Error correction Error Checking Entropy Also see videos below Make sure to watch information theory videos first Information Theory, Claude Shannon, Entropy, Redundancy, Data Compression \u0026amp; Bits (video) Cryptography Also see videos below Make sure to watch information theory videos first Khan Academy Series Cryptography: Hash Functions Cryptography: Encryption Compression Make sure to watch information theory videos first Computerphile (videos): Compression Entropy in Compression Upside Down Trees (Huffman Trees) EXTRA BITS/TRITS - Huffman Trees Elegant Compression in Text (The LZ 77 Method) Text Compression Meets Probabilities Compressor Head videos (optional) Google Developers Live: GZIP is not enough! Computer Security MIT (23 videos) Introduction, Threat Models Control Hijacking Attacks Buffer Overflow Exploits and Defenses Privilege Separation Capabilities Sandboxing Native Code Web Security Model Securing Web Applications Symbolic Execution Network Security Network Protocols Side-Channel Attacks Garbage collection GC in Python (video) Deep Dive Java: Garbage Collection is Good! Deep Dive Python: Garbage Collection in CPython (video) Parallel Programming Coursera (Scala) Efficient Python for High Performance Parallel Computing (video) Messaging, Serialization, and Queueing Systems Thrift Tutorial Protocol Buffers Tutorials gRPC gRPC 101 for Java Developers (video) Redis Tutorial Amazon SQS (queue) Amazon SNS (pub-sub) RabbitMQ Get Started Celery First Steps With Celery ZeroMQ Intro - Read The Manual ActiveMQ Kafka MessagePack Avro A* A Search Algorithm A* Pathfinding Tutorial (video) A* Pathfinding (E01: algorithm explanation) (video) Fast Fourier Transform An Interactive Guide To The Fourier Transform What is a Fourier transform? What is it used for? What is the Fourier Transform? (video) Divide \u0026amp; Conquer: FFT (video) Understanding The FFT Bloom Filter Given a Bloom filter with m bits and k hashing functions, both insertion and membership testing are O(k) Bloom Filters (video) Bloom Filters | Mining of Massive Datasets | Stanford University (video) Tutorial How To Write A Bloom Filter App HyperLogLog How To Count A Billion Distinct Objects Using Only 1.5KB Of Memory Locality-Sensitive Hashing Used to determine the similarity of documents The opposite of MD5 or SHA which are used to determine if 2 documents/strings are exactly the same Simhashing (hopefully) made simple van Emde Boas Trees Divide \u0026amp; Conquer: van Emde Boas Trees (video) MIT Lecture Notes Augmented Data Structures CS 61B Lecture 39: Augmenting Data Structures Balanced search trees Know at least one type of balanced binary tree (and know how it\u0026rsquo;s implemented):\n\u0026ldquo;Among balanced search trees, AVL and 2/3 trees are now passé, and red-black trees seem to be more popular. A particularly interesting self-organizing data structure is the splay tree, which uses rotations to move any accessed key to the root.\u0026rdquo; - Skiena\nOf these, I chose to implement a splay tree. From what I\u0026rsquo;ve read, you won\u0026rsquo;t implement a balanced search tree in your interview. But I wanted exposure to coding one up and let\u0026rsquo;s face it, splay trees are the bee\u0026rsquo;s knees. I did read a lot of red-black tree code\nSplay tree: insert, search, delete functions If you end up implementing red/black tree try just these: Search and insertion functions, skipping delete I want to learn more about B-Tree since it\u0026rsquo;s used so widely with very large data sets\nSelf-balancing binary search tree\nAVL trees\nIn practice: From what I can tell, these aren\u0026rsquo;t used much in practice, but I could see where they would be: The AVL tree is another structure supporting O(log n) search, insertion, and removal. It is more rigidly balanced than red–black trees, leading to slower insertion and removal but faster retrieval. This makes it attractive for data structures that may be built once and loaded without reconstruction, such as language dictionaries (or program dictionaries, such as the opcodes of an assembler or interpreter) MIT AVL Trees / AVL Sort (video) AVL Trees (video) AVL Tree Implementation (video) Split And Merge Splay trees\nIn practice: Splay trees are typically used in the implementation of caches, memory allocators, routers, garbage collectors, data compression, ropes (replacement of string used for long text strings), in Windows NT (in the virtual memory, networking and file system code) etc CS 61B: Splay Trees (video) MIT Lecture: Splay Trees: Gets very mathy, but watch the last 10 minutes for sure. Video Red/black trees\nThese are a translation of a 2-3 tree (see below). In practice: Red–black trees offer worst-case guarantees for insertion time, deletion time, and search time. Not only does this make them valuable in time-sensitive applications such as real-time applications, but it makes them valuable building blocks in other data structures which provide worst-case guarantees; for example, many data structures used in computational geometry can be based on red–black trees, and the Completely Fair Scheduler used in current Linux kernels uses red–black trees. In the version 8 of Java, the Collection HashMap has been modified such that instead of using a LinkedList to store identical elements with poor hashcodes, a Red-Black tree is used Aduni - Algorithms - Lecture 4 (link jumps to starting point) (video) Aduni - Algorithms - Lecture 5 (video) Red-Black Tree An Introduction To Binary Search And Red Black Tree 2-3 search trees\nIn practice: 2-3 trees have faster inserts at the expense of slower searches (since height is more compared to AVL trees). You would use 2-3 tree very rarely because its implementation involves different types of nodes. Instead, people use Red Black trees. 23-Tree Intuition and Definition (video) Binary View of 23-Tree 2-3 Trees (student recitation) (video) 2-3-4 Trees (aka 2-4 trees)\nIn practice: For every 2-4 tree, there are corresponding red–black trees with data elements in the same order. The insertion and deletion operations on 2-4 trees are also equivalent to color-flipping and rotations in red–black trees. This makes 2-4 trees an important tool for understanding the logic behind red–black trees, and this is why many introductory algorithm texts introduce 2-4 trees just before red–black trees, even though 2-4 trees are not often used in practice. CS 61B Lecture 26: Balanced Search Trees (video) Bottom Up 234-Trees (video) Top Down 234-Trees (video) N-ary (K-ary, M-ary) trees\nnote: the N or K is the branching factor (max branches) binary trees are a 2-ary tree, with branching factor = 2 2-3 trees are 3-ary K-Ary Tree B-Trees\nFun fact: it\u0026rsquo;s a mystery, but the B could stand for Boeing, Balanced, or Bayer (co-inventor). In Practice: B-Trees are widely used in databases. Most modern filesystems use B-trees (or Variants). In addition to its use in databases, the B-tree is also used in filesystems to allow quick random access to an arbitrary block in a particular file. The basic problem is turning the file block i address into a disk block (or perhaps to a cylinder-head-sector) address B-Tree B-Tree Datastructure Introduction to B-Trees (video) B-Tree Definition and Insertion (video) B-Tree Deletion (video) MIT 6.851 - Memory Hierarchy Models (video) - covers cache-oblivious B-Trees, very interesting data structures - the first 37 minutes are very technical, may be skipped (B is block size, cache line size) k-D Trees Great for finding number of points in a rectangle or higher dimension object A good fit for k-nearest neighbors Kd Trees (video) kNN K-d tree algorithm (video) Skip lists \u0026ldquo;These are somewhat of a cult data structure\u0026rdquo; - Skiena Randomization: Skip Lists (video) For animations and a little more detail Network Flows Ford-Fulkerson in 5 minutes — Step by step example (video) Ford-Fulkerson Algorithm (video) Network Flows (video) Disjoint Sets \u0026amp; Union Find UCB 61B - Disjoint Sets; Sorting \u0026amp; selection (video) Sedgewick Algorithms - Union-Find (6 videos) Math for Fast Processing Integer Arithmetic, Karatsuba Multiplication (video) The Chinese Remainder Theorem (used in cryptography) (video) Treap Combination of a binary search tree and a heap Treap Data Structures: Treaps explained (video) Applications in set operations Linear Programming (videos) Linear Programming Finding minimum cost Finding maximum value Solve Linear Equations with Python - Simplex Algorithm Geometry, Convex hull (videos) Graph Alg. IV: Intro to geometric algorithms - Lecture 9 Geometric Algorithms: Graham \u0026amp; Jarvis - Lecture 10 Divide \u0026amp; Conquer: Convex Hull, Median Finding Discrete math Computer Science 70, 001 - Spring 2015 - Discrete Mathematics and Probability Theory Discrete Mathematics by Shai Simonson (19 videos) Discrete Mathematics By IIT Ropar NPTEL Machine Learning Why ML? How Google Is Remaking Itself As A Machine Learning First Company Large-Scale Deep Learning for Intelligent Computer Systems (video) Deep Learning and Understandability versus Software Engineering and Verification by Peter Norvig Google\u0026rsquo;s Cloud Machine learning tools (video) Google Developers\u0026rsquo; Machine Learning Recipes (Scikit Learn \u0026amp; Tensorflow) (video) Tensorflow (video) Tensorflow Tutorials Practical Guide to implementing Neural Networks in Python (using Theano) Courses: Great starter course: Machine Learning - videos only - see videos 12-18 for a review of linear algebra (14 and 15 are duplicates) Neural Networks for Machine Learning Google\u0026rsquo;s Deep Learning Nanodegree Google/Kaggle Machine Learning Engineer Nanodegree Self-Driving Car Engineer Nanodegree Metis Online Course ($99 for 2 months) Resources: Books: Python Machine Learning Data Science from Scratch: First Principles with Python Introduction to Machine Learning with Python Machine Learning for Software Engineers Data School: http://www.dataschool.io/ Additional Detail on Some Subjects I added these to reinforce some ideas already presented above, but didn't want to include them above because it's just too much. It's easy to overdo it on a subject. You want to get hired in this century, right? SOLID\nBob Martin SOLID Principles of Object Oriented and Agile Design (video) S - Single Responsibility Principle | Single responsibility to each Object more flavor O - Open/Closed Principle | On production level Objects are ready for extension but not for modification more flavor L - Liskov Substitution Principle | Base Class and Derived class follow ‘IS A’ Principle more flavor I - Interface segregation principle | clients should not be forced to implement interfaces they don\u0026rsquo;t use Interface Segregation Principle in 5 minutes (video) more flavor D -Dependency Inversion principle | Reduce the dependency In composition of objects. Why Is The Dependency Inversion Principle And Why Is It Important more flavor Union-Find\nOverview Naive Implementation Trees Union By Rank Path Compression Analysis Options More Dynamic Programming (videos)\n6.006: Dynamic Programming I: Fibonacci, Shortest Paths 6.006: Dynamic Programming II: Text Justification, Blackjack 6.006: DP III: Parenthesization, Edit Distance, Knapsack 6.006: DP IV: Guitar Fingering, Tetris, Super Mario Bros. 6.046: Dynamic Programming \u0026amp; Advanced DP 6.046: Dynamic Programming: All-Pairs Shortest Paths 6.046: Dynamic Programming (student recitation) Advanced Graph Processing (videos)\nSynchronous Distributed Algorithms: Symmetry-Breaking. Shortest-Paths Spanning Trees Asynchronous Distributed Algorithms: Shortest-Paths Spanning Trees MIT Probability (mathy, and go slowly, which is good for mathy things) (videos):\nMIT 6.042J - Probability Introduction MIT 6.042J - Conditional Probability MIT 6.042J - Independence MIT 6.042J - Random Variables MIT 6.042J - Expectation I MIT 6.042J - Expectation II MIT 6.042J - Large Deviations MIT 6.042J - Random Walks Simonson: Approximation Algorithms (video)\nString Matching\nRabin-Karp (videos): Rabin Karps Algorithm Precomputing Optimization: Implementation and Analysis Table Doubling, Karp-Rabin Rolling Hashes, Amortized Analysis Knuth-Morris-Pratt (KMP): TThe Knuth-Morris-Pratt (KMP) String Matching Algorithm Boyer–Moore string search algorithm Boyer-Moore String Search Algorithm Advanced String Searching Boyer-Moore-Horspool Algorithms (video) Coursera: Algorithms on Strings starts off great, but by the time it gets past KMP it gets more complicated than it needs to be nice explanation of tries can be skipped Sorting\nStanford lectures on sorting: Lecture 15 | Programming Abstractions (video) Lecture 16 | Programming Abstractions (video) Shai Simonson, Aduni.org: Algorithms - Sorting - Lecture 2 (video) Algorithms - Sorting II - Lecture 3 (video) Steven Skiena lectures on sorting: lecture begins at 26:46 (video) lecture begins at 27:40 (video) lecture begins at 35:00 (video) lecture begins at 23:50 (video) Video Series Sit back and enjoy.\nList of individual Dynamic Programming problems (each is short)\nx86 Architecture, Assembly, Applications (11 videos)\nMIT 18.06 Linear Algebra, Spring 2005 (35 videos)\nExcellent - MIT Calculus Revisited: Single Variable Calculus\nCSE373 - Analysis of Algorithms (25 videos)\nSkiena lectures from Algorithm Design Manual UC Berkeley 61B (Spring 2014): Data Structures (25 videos)\nUC Berkeley 61B (Fall 2006): Data Structures (39 videos)\nUC Berkeley 61C: Machine Structures (26 videos)\nOOSE: Software Dev Using UML and Java (21 videos)\nUC Berkeley CS 152: Computer Architecture and Engineering (20 videos)\nMIT 6.004: Computation Structures (49 videos)\nCarnegie Mellon - Computer Architecture Lectures (39 videos)\nMIT 6.006: Intro to Algorithms (47 videos)\nMIT 6.033: Computer System Engineering (22 videos)\nMIT 6.034 Artificial Intelligence, Fall 2010 (30 videos)\nMIT 6.042J: Mathematics for Computer Science, Fall 2010 (25 videos)\nMIT 6.046: Design and Analysis of Algorithms (34 videos)\nMIT 6.050J: Information and Entropy, Spring 2008 (19 videos)\nMIT 6.824: Distributed Systems, Spring 2020 (20 videos)\nMIT 6.851: Advanced Data Structures (22 videos)\nMIT 6.854: Advanced Algorithms, Spring 2016 (24 videos)\nHarvard COMPSCI 224: Advanced Algorithms (25 videos)\nMIT 6.858 Computer Systems Security, Fall 2014\nStanford: Programming Paradigms (27 videos)\nIntroduction to Cryptography by Christof Paar\nCourse Website along with Slides and Problem Sets Mining Massive Datasets - Stanford University (94 videos)\nGraph Theory by Sarada Herke (67 videos)\nComputer Science Courses Directory of Online CS Courses Directory of CS Courses (many with online lectures) Algorithms implementation Multiple Algorithms implementation by Princeton University Papers Love classic papers? 1978: Communicating Sequential Processes implemented in Go 2003: The Google File System replaced by Colossus in 2012 2004: MapReduce: Simplified Data Processing on Large Clusters mostly replaced by Cloud Dataflow? 2006: Bigtable: A Distributed Storage System for Structured Data 2006: The Chubby Lock Service for Loosely-Coupled Distributed Systems 2007: Dynamo: Amazon’s Highly Available Key-value Store The Dynamo paper kicked off the NoSQL revolution 2007: What Every Programmer Should Know About Memory (very long, and the author encourages skipping of some sections) 2012: AddressSanitizer: A Fast Address Sanity Checker: paper video 2013: Spanner: Google’s Globally-Distributed Database: paper video 2014: Machine Learning: The High-Interest Credit Card of Technical Debt 2015: Continuous Pipelines at Google 2015: High-Availability at Massive Scale: Building Google’s Data Infrastructure for Ads 2015: TensorFlow: Large-Scale Machine Learning on Heterogeneous Distributed Systems 2015: How Developers Search for Code: A Case Study More papers: 1,000 papers LICENSE CC-BY-SA-4.0\n","permalink":"http://intervalrain.github.io/posts/washam/","summary":"Coding Interview University John Washam:\nI originally created this as a short to-do list of study topics for becoming a software engineer, but it grew to the large list you see today. After going through this study plan, I got hired as a Software Development Engineer at Amazon! You probably won\u0026rsquo;t have to study as much as I did. Anyway, everything you need is here.\nI studied about 8-12 hours a day, for several months.","title":"[Washam] Way to Software Engineer"}]