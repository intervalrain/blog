[{"content":"HDLBits  HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。 由教學的題型由淺入深，逐步建立起電路設計的技能。 每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。\n 1 Getting Started \\(\\text{assign one}\\)\n Build a circuit with no inputs and one output. The output should always drive 1 (or logic high).  module top_module( output one);   assign one = 1\u0026#39;b1;  endmodule  \\(\\text{assign zero}\\)\n Build a circuit with no inputs and one output that outputs a constant 0.  module top_module(  output zero );   assign zero = 1\u0026#39;b0;  endmodule 2 Verilog Language 2.1 Basics \\(\\text{wire}\\)\n Create a module with one input and ont output that behaves like a wire   module top_module( input in, output out);   assign out = in;  endmodule  \\(\\text{multi-in-out}\\)\n Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:   module top_module(  input a,b,c,  output w,x,y,z );   assign w = a;  assign x = b;  assign y = b;  assign z = c;  endmodule  \\(\\text{not gate}\\)\n Create a module that implements a NOT gate.   module top_module( input in, output out );   assign out = ~in;  endmodule  \\(\\text{and gate}\\)\n Create a module that implments an AND gate.   module top_module(  input a,b,  output out );   assign out = a \u0026amp; b;  endmodule  \\(\\text{nor gate}\\)\n Create a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog.   module top_module(  input a,b,  output out );   assign out = ~(a|b);  endmodule  \\(\\text{xnor gate}\\)\n Create a module that implements a XNOR gate.   module top_module(  input a, b,  output out );   assign out = ~(a^b);  endmodule  \\(\\text{wire declaration}\\)\n Implement following circuits. Create two intermediate wires to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire out, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.   module top_module(  input a,b,c,d,  output out, out_n );   wire w1, w2;  assign w1 = a \u0026amp; b;  assign w2 = c \u0026amp; d;  assign out = w1 | w2;  assign out_n = ~out;  endmodule  \\(\\text{7458}\\)\n The 7458 is a chip with four AND gates and two OR gates. Create a module with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs.   module top_module(  input p1a, p1b, p1c, p1d, p1e, p1f,  output p1y,  intput p2a, p2b, p2c, p2d,  output p2y );   wire w1a, w1b;  wire w2a, w2b;   assign w1a = p1a \u0026amp; p1b \u0026amp; p1c;  assign w1b = p1d \u0026amp; p1e \u0026amp; p1f;  assign p1y = w1a | w1b;  assign w2a = p2a \u0026amp; p2b;  assign w2b = p2c \u0026amp; p2d;  assign p2y = w2a | w2b;  endmodule 2.2 Vectors \\(\\text{vector}\\)\n Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect outputs o0 to the input vector\u0026rsquo;s position 0, o1 to position 1, etc.\nIn a diagram, a tick mark with a number next to it indicates the width of the vector (or \u0026ldquo;bus\u0026rdquo;), rather than drawing a separate line for each bit in the vector.   module top_module (  input wire [2:0] vec,  output wire [2:0] outv,  output wire o2,  output wire o1,  output wire o0 );   assign outv = vec;  assign o0 = vec[0];  assign o1 = vec[1];  assign o2 = vec[2];  endmodule  \\(\\text{vector select}\\)\n Build a combinational circuit that splits an input half-word (16 bits, [15:0]) into lower [7:0] and upper [15:8] bytes.  module top_module (  input [15:0] in,  output [7:0] out_hi,  output [7:0] out_lo );   assign out_hi = in[15:8];  assign out_lo = in[7:0];  endmodule  \\(\\text{vector swap}\\)\n A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of the 4-byte word.\nAaaaaaaaBbbbbbbbCcccccccDddddddd =\u0026gt; DdddddddCcccccccBbbbbbbbAaaaaaaa\nThis operation is often used when the endianness of a piece of data needs to be swapped, for example between little-endian x86 systems and the big-endian formats used in many Internet protocols.  module top_module (  input [31:0] in,  output [31:0] out );  assign out[31:24] = in[ 7: 0];  assign out[23:16] = in[15: 8];  assign out[15: 8] = in[23:16];  assign out[ 7: 0] = in[31:24];  endmodule  \\(\\text{vector gates}\\)\n uild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.   module top_module (  input [2:0] a,  input [2:0] b,  output [2:0] out_or_bitwise,  output out_or_logical,  output [5:0] out_not );   assign out_or_bitwise = a | b;  assign out_or_logical = a || b;  assign out_not[2:0] = ~a;  assign out_not[5:3] = ~b;  endmodule  \\(\\text{gate-prefix vector}\\)\n Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs:  out_and: output of a 4-input AND gate. out_or: output of a 4-input OR gate. out_xor: outout of a 4-input XOR gate.    module top_module (  input [3:0] in,  output out_and,  output out_or,  output out_xor );   assign out_and = \u0026amp; in;  assign out_or = | in;  assign out_xor = ^ in;  endmodule  \\(\\text{vector concatenate}\\)\n Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for   module top_module (  input [4:0] a, b, c, d, e, f,  output [7:0] w, x, y, z );   assign {w, x, y, z} = {a, b, c, d, e, f, 2\u0026#39;b11};  endmodule  \\(\\text{vector reverse}\\)\n Given an 8-bit input vector [7:0], reverse its bit ordering.  module top_module(  input [7:0] in,  output [7:0] out );   assign {out[0], out[1], out[2], out[3], out[4], out[5], out[6], out[7]} = in  endmodule module top_module(  input [7:0] in,  output [7:0] out );   always @(*) begin  for (int i=0; i\u0026lt;8; i++)  out[i] = in[8-i-1];  end  endmodule module top_module(  input [7:0] in,  output [7:0] out );  \tgenerate \tgenvar i; \tfor (i=0; i\u0026lt;8; i = i+1) begin: my_block_name \tassign out[i] = in[8-i-1]; \tend \tendgenerate  endmodule  \\(\\text{vector replication}\\)\n Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.  module top_module (  input [7:0] in,  output [31:0] out );   assign out = {{24{in[7]}}, in};  endmodule  \\(\\text{vector replication2}\\)\n Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.   module top_module (  input a, b, c, d, e,  output [24:0] out );   assign out = ~{{5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}}} ^ {5{a,b,c,d,e}};  endmodule 2.3 Modules: Hierarchy By now, you\u0026rsquo;re familiar with a module, which is a circuit that interacts with its outside through input and output ports. Larger, more complex circuits are built by composing bigger modules out of smaller modules and other pieces (such as assign statements and always blocks) connected together. This forms a hierarchy, as modules can contain instances of other modules.\nThe figure below shows a very simple circuit with a sub-module. In this exercise, create one instance of module mod_a, then connect the module\u0026rsquo;s three pins (in1, in2, and out) to your top-level module\u0026rsquo;s three ports (wires a, b, and out). The module mod_a is provided for you — you must instantiate it.\nWhen connecting modules, only the ports on the module are important. You do not need to know the code inside the module. The code for module mod_a looks like this:\nmodule mod_a ( input in1, input in2, output out );  // Module body endmodule The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written inside another module\u0026rsquo;s body (Code for different modules are not nested).\nYou may connect signals to the module by port name or port position. For extra practice, try both methods. Connecting Signals to Module Ports\nThere are two commonly-used methods to connect a wire to a port: by position or by name.\nBy position\nThe syntax to connect wires to ports by position should be familiar, as it uses a C-like syntax. When instantiating a module, ports are connected left to right according to the module\u0026rsquo;s declaration. For example:\nmod_a instance1 ( wa, wb, wc );\nThis instantiates a module of type mod_a and gives it an instance name of \u0026ldquo;instance1\u0026rdquo;, then connects signal wa (outside the new module) to the first port (in1) of the new module, wb to the second port (in2), and wc to the third port (out). One drawback of this syntax is that if the module\u0026rsquo;s port list changes, all instantiations of the module will also need to be found and changed to match the new module.\nBy name\nConnecting signals to a module\u0026rsquo;s ports by name allows wires to remain correctly connected even if the port list changes. This syntax is more verbose, however.\nmod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );\nThe above line instantiates a module of type mod_a named \u0026ldquo;instance2\u0026rdquo;, then connects signal wa (outside the module) to the port named in1, wb to the port named in2, and wc to the port named out. Notice how the ordering of ports is irrelevant here because the connection will be made to the correct name, regardless of its position in the sub-module\u0026rsquo;s port list. Also notice the period immediately preceding the port name in this syntax.\n \\(\\text{module}\\) module top_module ( input a, input b, output out );   mod_a u_mod_a (  .in1 (a),  .in2 (b),  .out (out)  );  endmodule  \\(\\text{module\\_pos}\\)\n This problem is similar to the previous one (module). You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. You must connect the 6 ports by position to your top-level module\u0026rsquo;s ports out1, out2, a, b, c, and d, in that order. You are given the following module:   module top_module (  input a, b, c, d,  output out1, out2 );   mod_a u_mod_a(out1, out2, a, b, c, d);  endmodule  \\(\\text{module\\_name}\\)\n This problem is similar to module. You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. You must connect the 6 ports by name to your top-level module\u0026rsquo;s ports:You are given the following module:   module top_module (  input a,  input b,  input c,  input d,  output out1,  output out2 );   mod_a u_mod_a(  .out1 (out1),  .out2 (out2),  .in1 (a),  .in2 (b),  .in3 (c),  .in4 (d)  );  endmodule  \\(\\text{module\\_shift}\\)\n You are given a module my_dff with two inputs and one output (that implements a D flip-flop). Instantiate three of them, then chain them together to make a shift register of length 3. The clk port needs to be connected to all instances. Note that to make the internal connections, you will need to declare some wires. Be careful about naming your wires and module instances: the names must be unique.\nThe module provided to you is: module my_dff ( input clk, input d, output q );   module top_module ( input clk, input d, output q );   wire q1;  wire q2;   my_dff(clk, d, q1);  my_dff(clk, q1, q2);  my_dff(clk, q2, q); \tendmodule  \\(\\text{module\\_shift8}\\)\n You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: The value at the input d, after the first, after the second, or after the third D flip-flop. (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.) The module provided to you is: module my_dff8 ( input clk, input [7:0] d, output [7:0] q );\nThe multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.   module top_module (  input clk,  input [7:0] d,  input [1:0] sel,  output [7:0] q );  wire [7:0] q1;  wire [7:0] q2;  wire [7:0] q3;  my_dff8 (clk, d, q1);  my_dff8 (clk, q1, q2);  my_dff8 (clk, q2, q3);   // multiplexer: mux9to1v  always@(*) begin  case(sel)  2\u0026#39;d0: q = d;  2\u0026#39;d1: q = q1;  2\u0026#39;d2: q = q2;  2\u0026#39;d3: q = q3;  endcase  end  endmodule  \\(\\text{module\\_Half Adder}\\)\n You are given a module add16 that performs a 16-bit addition. Instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result, after receiving the carry-out from the first adder. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored), but the internal modules need to in order to function correctly. (In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).\nConnect the modules together as shown in the diagram below. The provided module add16 has the following declaration: module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );   module top_module(  input [31:0] a,  input [31:0] b,  output [31:0] sum );  wire [15:0] sum1;  wire [15:0] sum2;  wire cout1;  wire cout2;   add16 (a[15:0], b[15:0], 1\u0026#39;b0, sum1, cout1);  add16 (a[31:16], b[31:16], cout1, sum2, cout2);   assign sum = {sum2, sum1};  endmodule  \\(\\text{module\\_Full Adder}\\)\n You are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).\nConnect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nWithin each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. You must write the full adder module that has the following declaration:\nmodule add1 ( input a, input b, input cin, output sum, output cout );\nRecall that a full adder computes the sum and carry-out of a+b+cin.\nIn summary, there are three modules in this design:  top_module — Your top-level module that contains two of\u0026hellip; add16, provided — A 16-bit adder module that is composed of 16 of\u0026hellip; add1 — A 1-bit full adder module.     module top_module (  input [31:0] a,  input [31:0] b,  output [31:0] sum );   wire [15:0] sum1;  wire [15:0] sum2;  wire cout1;  wire cout2;   add16 (a[15:0], b[15:0], 1\u0026#39;b0, sum1, cout1);  add16 (a[31:16], b[31:16], cout1, sum2, cout2);  assign sum = {sum2, sum1};  endmodule  module add1 ( input a, input b, input cin, output sum, output cout );  assign sum = a ^ b ^ cin;  assign cout = (a\u0026amp;b)|(b\u0026amp;cin)|(cin\u0026amp;a);  // assign {cout, sum} = a + b + cin; endmodule  \\(\\text{Module\\_Carry Select Adder}\\)\n One drawback of the ripple carry adder is that the delay for an adder to compute the carry out (from the carry-in, in the worst case) is fairly slow, and the second-stage adder cannot begin computing its carry-out until the first-stage adder has finished. This makes the adder slow. One improvement is a carry-select adder, shown below. The first-stage adder is the same as before, but we duplicate the second-stage adder, one assuming carry-in=0 and one assuming carry-in=1, then using a fast 2-to-1 multiplexer to select which result happened to be correct.\nYou are provided with the same module add16 as the previous exercise, which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. You must instantiate three of these to build the carry-select adder, using your own 16-bit 2-to-1 multiplexer.\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nConnect the modules together as shown in the diagram below. The provided module add16 has the following declaration:   module top_module(  input [31:0] a,  input [31:0] b,  output [31:0] sum );   wire sel;  wire [15:0] wire0, wire1;  add16 (a[15: 0], b[15: 0], 1\u0026#39;b0, sum[15:0], sel);  add16 (a[31:16], b[31:16], 1\u0026#39;b0, wire0, );  add16 (a[31:16], b[31:16], 1\u0026#39;b1, wire1, );   // selector  always@(*) begin  case(sel)  1\u0026#39;b0: sum[31:16] = wire0;  1\u0026#39;b1: sum[31:16] = wire1;  endcase  end   // ternary operator  // assign sum[31:16] = sel ? wire1 : wire0;  endmodule  \\(\\text{Module\\_Adder-Subtractor}\\)\n An adder-subtractor can be built from an adder by optionally negating one of the inputs, which is equivalent to inverting the input then adding 1. The net result is a circuit that can do two operations: (a + b + 0) and (a + ~b + 1). Build the adder-subtractor below. You are provided with a 16-bit adder module, which you need to instantiate twice:\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nUse a 32-bit wide XOR gate to invert the b input whenever sub is 1. (This can also be viewed as b[31:0] XORed with sub replicated 32 times. See replication operator.). Also connect the sub input to the carry-in of the adder.  module top_module(  input [31:0] a,  input [31:0] b,  input sub,  output [31:0] sum );  wire cout;  wire [31:0] bin;   assign bin = {32{sub}} ^ b;   add16 (a[15: 0], bin[15: 0], sub, sum[15: 0], cout);  add16 (a[31:16], bin[31:16], cout, sum[31:16], );  endmodule  2.4 Procedures 2.5 More Verilog Features 3 Circuits 3.1 Combinational Logic 3.1.1 Basic Gates 3.1.2 Multiplexers 3.1.3 Arithmetic Circuits 3.1.4 Karnaugh Map to Circuit 3.2 Sequential Logic 3.2.1 Latches and Flip-Flops 3.2.2 Counters 3.2.3 Shift Registers 3.2.4 More Circuits 3.2.5 Finite State Machines 3.3 Building Larger Circuits 4 Verification: Reading Simulations 4.1 Finding bugs in code 4.2 Build a circuit from a simulation waveform 5 Verification: Writing Testbenches 6 CS450 ","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits/","summary":"HDLBits  HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。 由教學的題型由淺入深，逐步建立起電路設計的技能。 每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。\n 1 Getting Started \\(\\text{assign one}\\)\n Build a circuit with no inputs and one output. The output should always drive 1 (or logic high).  module top_module( output one);   assign one = 1\u0026#39;b1;  endmodule  \\(\\text{assign zero}\\)\n Build a circuit with no inputs and one output that outputs a constant 0.  module top_module(  output zero );   assign zero = 1\u0026#39;b0;  endmodule 2 Verilog Language 2.","title":"[VHDL] HDLbits"},{"content":"TCAD 模擬收斂問題 收斂問題 Sentaurus Device 有非常多種可模擬大電場下之飽和遷移率的模型，而這主要是設定有效電場的模型。其中，最自然的選擇就是 Eparallel driving model。這種模型取總電場平行於電流方向上的分量。不過這通常會導致嚴重的收斂問題。主要是因為電場跟電流有著極為密切的關係，除此之外，以 MOSFET 通道為例，通常垂直與平行通道方向之電場數量級差很多，因為演算之數值誤差會「混合」這兩個分量，所以這種 Eparallel 模型會使得每個節點上的 driving force變化許多，進而改變電流方向，又接著改變電場分量，所以會造成極為不穩定的情況。\n其中一個折衷的辦法，就是只考慮平行於 silicon-oxide 界面上的電場，可以使用 HighFieldSaturation(EparallelToInterface) 指令來啟動這模型。只要大部分的電流都平行於界面，那基本上這就是個很好的模型。然而，目前最新科技通常會使得 source/drain 的電流以「向外散開，向內吸入」的方式進入與離開。例如說目前的 ultrashalow source and drain extensions。電流散開之後，電流就不再平行於界面，而這模型可能會帶來將近 5-15 % 的誤差。因此，如果你知道電流的方向，那麼你也可以設定用來計算平行電場分量之方向向量，而不再只是單純地與最鄰近的界面平行的方向。例如說，如果你覺得電流主要是沿著 x 軸在流動，那麼可以在 Math section 設定 EparallelToInterface (Direction = (1 0 0))。\n最常用的 driving force 是 quasi-Fermi potential 的梯度模型。通常這跟平行電場模型是一樣的，但它的演算法比較穩定。可以用 HighFieldSaturation(GradQuasiFermi) 選項來啟動它。不過，即便如此，還是可能會造成收斂問題。這是因為通常 quasi-Fermi potential 的梯度都非常的陡峭，變化得太過劇烈或是非常的不平滑，而這往往切得比較不好的網格所造成的。\n但在有些時候，即便網格切得很好，還是沒辦法收斂。有時是因為低載子濃度的區域的濃度相對誤差都滿高的，而這會進一步導致 quasi-Fermi potential 的誤差變得滿大的。因為這些區域通常對總電流的貢獻並不是很顯著，所以算得太準反而會讓模擬跑得更慢。不過，你確實需要確認一下這些低密度是不是導致發散。\n除此之外，也可藉由設定 RefDens_eGradQuasiFermi_EparallelToInterface 與 RefDens_hGradQuasiFermi_EparallelToInterface 來使用「內插 GradQuasiFermi 與 Eparallel」的 driving force 模型。該參數定義了 gradual transition 發生的局域載子濃度。例如說，如果設定為 1e12，那麼當載子濃度高於 1e12，就使用 GradQuasiFermi model，反之則使用 Eparallel model。通常 1e12 並不會影響到總電流，但仍能改善收斂問題。有時甚至需要用到 1e14 ～ 1e16 以獲得更好的收斂，但要留意不同設定所得到的電流是否一致，以確定 Eparallel driving force 帶來的誤差仍可接受。\n另一種內插法是 QausiGradFermi 與 電場本身，可使用 RefDens_eGradQuasiFermi_ElectricField 與 RefDens_eGradQuasiFermi_ElectricField 參數來設定。\n還有一種方法改善收斂，就是在低濃度的地方逐漸忽略 driving force。可以藉由 RefDens_eGradQuasiFermi_Zero (for electrons) and RefDens_hGradQuasiFermi_Zero (for holes) 設定，將它們設定為正值即可。例如說，如果設定為 1e10，那麼在 1e10 濃度以下的地方就不會用到 driving force。\n還有一個在物理上可行的做法，就是使用 hydrodynamic transport model。這時 sdevice 會計算局域載子溫度，接著並用來計算 driving force。可以藉由 HighFieldSaturation(CarrierTempDrive) 來開啟它。有時會因為有比較好的收斂而改善通常 HT model 算太慢的現象。總之，如果你在使用 GradQuasiFermi 時遇到了收斂問題。那麼你可以：\n 確保通道的網格足夠細緻與均勻 考慮改成 EparallelToInterface 如果 terminal currents 誤差實在很大，那麼可考慮將 RefDens_e/hGradQuasiFermi_ElectricField 設定為 1e12 或者更高。 設定 RefDens_e/hGradQuasiFermi_Zero 到 1e10 或者更高以忽略在低於該濃度時的 driving force 計算 最後可以考慮改用 hydrodynamic transport model。  常見模擬參數之意義  HighFieldSaturation(GradQuasiFermi) RefDens_hGradQuasiFermi_Zero：低於其值則忽略 damp 有效電場 RefDens_eGradQuasiFermi_EparallelToInterface：高於其值則使用 GradQuasiFermi，低於則 EparallelToInterface。 RefDens_eGradQuasiFermi_ElectricField：高於其值則使用 GradQuasiFermi，低於則 Eparallel  External resistor method 這方法很有用，但是非常慢。\n 簡單來說，只是在元件上串聯一個電阻。\n 但因為我們設定 \\(R=V_b/I_b\\)，所以在 InnerVoltage 到達 \\(V_b\\) 時，OuterVoltage 會是兩倍的崩潰電壓。而在那之前，因為電流實在是很小，所以外接電阻分配到的分壓並沒有追到元件分壓，使得大部分分壓都會正常地落在元件上。設定方法為，先在其中一個電極設定電阻，如下所示。\nElectrode { { Name= \u0026#34;substrate\u0026#34; Voltage= 0.0 } #if \u0026#34;@BVmethod@\u0026#34; == \u0026#34;resistor\u0026#34; { Name= \u0026#34;anode\u0026#34; Voltage= 0.0 Resistor= @R@} #else { Name= \u0026#34;anode\u0026#34; Voltage= 0.0 } #endif } 設定好之後其實就大功告成了。不過此時因為你只能夠控制某電極的電位，而在其中一個電極電位被設定為 Voltage=0.0 的情況下，這相當於設定兩電極（anode與substrate）之間的電壓，即「元件與電阻」的總跨壓。因此，倘若元件開始崩潰，電流開始爆增，那麼「元件與電阻」的總跨壓將會變得非常大。因此如果將後續的模擬目標電壓設定為-50V 或甚至是 -100V，那因為元件分到的跨壓一定比較小，所以很可能沒達到目標。因此這時需要將最後的目標電壓設定得高一點，通常我都設定-500到-1000。有時為了更加準確而會設定為-2000。\nTrap 設定(sdevice)  Another available species is the fixed charge, which is a trap fully occupied by either electrons or holes. Therefore, its charge stays constant throughout the entire simulation and does not depend on electrical bias conditions. Electron–hole recombination through such a trap is not allowed. This type of trap uses the FixedCharge keyword for a trap specification.\n Recombination \u0026amp; Generation rate  基本上它們都遵守 SRH recombination rate:\n$$ R_{SRH}=\\frac{np-n_i^2}{\\tau_{p0}(n+n_1)+\\tau_{n_0}(p+p_1)} $$  但是沒辦法在 sdevice 用 SRHRecombination( Integrate( Semiconductor ) ) 觀察到這些特地、額外設定的 trap 造成的 SHR recombination rate，反而必須使用：\nCurrentPlot { eGapStatesRecombination( Integrate( Semiconductor ) ) eGapStatesRecombination( Integrate( Region=\u0026#34;Absorption\u0026#34; ) ) eGapStatesRecombination( Integrate( Region=\u0026#34;Multiplication\u0026#34; ) ) hGapStatesRecombination( Integrate( Semiconductor ) ) hGapStatesRecombination( Integrate( Region=\u0026#34;Absorption\u0026#34; ) ) hGapStatesRecombination( Integrate( Region=\u0026#34;Multiplication\u0026#34; ) ) } 才能夠看見這些 trap 的貢獻。\nTrap-assisted tunneling 這些 Trap 預設並沒有 trap-assisted tunneling 效果。換言之，即便之前設定了 Physics{Recombination(SRH(ElectricField(Lifetime=Hurkx)))}，也不會讓 trap 有此效應。這需要額外設定：\nPhysics(Region=\u0026#34;Absorption\u0026#34;){ Traps(eNeutral Level fromMidBandGap EnergyMid=@Eti@ Conc=1e15 eXsection=@eXsec@ hXsection=@hXsec@ SpatialShape=Gaussian SpaceMid=(@PosX@, 1.5) SpaceSig=(@Lx@, 1e3) Tunneling(Hurkx) ) } 上面的Tunneling(Hurkx)就是 trap-assisted tunneling 效應。\nLifetime 雖然 lifetime 滿足底下公式：\n$$ \\tau_{n,p}=\\frac{1}{\\sigma_{n,p}v_{n,p}N_t} $$\n但是沒辦法直接使用eLifetime與hLifetime觀察，需要手動將上述數據相乘。\n","permalink":"http://intervalrain.github.io/posts/device/simulationconvergece/","summary":"TCAD 模擬收斂問題 收斂問題 Sentaurus Device 有非常多種可模擬大電場下之飽和遷移率的模型，而這主要是設定有效電場的模型。其中，最自然的選擇就是 Eparallel driving model。這種模型取總電場平行於電流方向上的分量。不過這通常會導致嚴重的收斂問題。主要是因為電場跟電流有著極為密切的關係，除此之外，以 MOSFET 通道為例，通常垂直與平行通道方向之電場數量級差很多，因為演算之數值誤差會「混合」這兩個分量，所以這種 Eparallel 模型會使得每個節點上的 driving force變化許多，進而改變電流方向，又接著改變電場分量，所以會造成極為不穩定的情況。\n其中一個折衷的辦法，就是只考慮平行於 silicon-oxide 界面上的電場，可以使用 HighFieldSaturation(EparallelToInterface) 指令來啟動這模型。只要大部分的電流都平行於界面，那基本上這就是個很好的模型。然而，目前最新科技通常會使得 source/drain 的電流以「向外散開，向內吸入」的方式進入與離開。例如說目前的 ultrashalow source and drain extensions。電流散開之後，電流就不再平行於界面，而這模型可能會帶來將近 5-15 % 的誤差。因此，如果你知道電流的方向，那麼你也可以設定用來計算平行電場分量之方向向量，而不再只是單純地與最鄰近的界面平行的方向。例如說，如果你覺得電流主要是沿著 x 軸在流動，那麼可以在 Math section 設定 EparallelToInterface (Direction = (1 0 0))。\n最常用的 driving force 是 quasi-Fermi potential 的梯度模型。通常這跟平行電場模型是一樣的，但它的演算法比較穩定。可以用 HighFieldSaturation(GradQuasiFermi) 選項來啟動它。不過，即便如此，還是可能會造成收斂問題。這是因為通常 quasi-Fermi potential 的梯度都非常的陡峭，變化得太過劇烈或是非常的不平滑，而這往往切得比較不好的網格所造成的。\n但在有些時候，即便網格切得很好，還是沒辦法收斂。有時是因為低載子濃度的區域的濃度相對誤差都滿高的，而這會進一步導致 quasi-Fermi potential 的誤差變得滿大的。因為這些區域通常對總電流的貢獻並不是很顯著，所以算得太準反而會讓模擬跑得更慢。不過，你確實需要確認一下這些低密度是不是導致發散。\n除此之外，也可藉由設定 RefDens_eGradQuasiFermi_EparallelToInterface 與 RefDens_hGradQuasiFermi_EparallelToInterface 來使用「內插 GradQuasiFermi 與 Eparallel」的 driving force 模型。該參數定義了 gradual transition 發生的局域載子濃度。例如說，如果設定為 1e12，那麼當載子濃度高於 1e12，就使用 GradQuasiFermi model，反之則使用 Eparallel model。通常 1e12 並不會影響到總電流，但仍能改善收斂問題。有時甚至需要用到 1e14 ～ 1e16 以獲得更好的收斂，但要留意不同設定所得到的電流是否一致，以確定 Eparallel driving force 帶來的誤差仍可接受。","title":"[TCAD] 模擬收斂問題"},{"content":"1 Verilog HDL 1.1 Verilog 簡介  一套硬體描述語言  輔助設計數位系統 描述電路的行為 電子自動化工具   類似C語言的硬體描述語言  易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的)   支援多種硬體層級的描述方式  從低階到高階模式 依照不同的方法設計   支援階層式的設計方法  樹狀式的設計結構 由繁化簡    1.2 Verilog 的模型 1.2.1 電晶體層級  Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計  1.2.2 邏輯閘層級  Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖  1.2.3 資料流層級  Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式  如：out = a + b + c    1.2.4 行為模型  Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具  1.2.5 結構式模型  Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法  將複雜電路分為層狀結構 架構上類似樹狀結構  Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統)  \\( \\boxed{\\text{Full Adder}} \\begin{cases} \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{OR}} \\end{cases}\\\\ \\text{設計目標}\\qquad\\qquad\\text{子模組}\\qquad\\text{元件} \\)        1.3 Verilog 語法詞彙  由一連串的標記(token)所組成  識別字(identifiers) 關鍵字(keywords) 字串(strings) 註解(comments) 空白(whitespace) 數值(numbers)    1.3.1 識別字(identifiers)  描述電路行為所使用的自訂物件  不違反命名規則，工程師自行定義的物件名稱   命名規則  字母、數字、底線_或是錢字號$所組合而成。 開頭只能使用字母或底線。 識別字是有大小寫之分的。   舉例 Shift_reg_b (Valid) _bus123 (Valid) $error_condition (Invalid) NT$899 (Valid) 3_bit_data (Invalid)   1.3.2 關鍵字(keywords)  描述電路語法所保留的一組特殊名稱的標記 定義語言的結構來描述電路  輸入(input)、輸出(output) 資料型態、電路行為   所有關鍵字都必須使用小寫表示 不可當作識別字使用 常見關鍵字 \\(\\begin{array}{|l|l|l|l|l|l|}\\hline \\text{always}\u0026amp;\\text{and}\u0026amp;\\text{assign}\u0026amp;\\text{begin}\u0026amp;\\text{buf}\u0026amp;\\text{bufif0}\\\\\\hline \\text{bufif1}\u0026amp;\\text{case}\u0026amp;\\text{casex}\u0026amp;\\text{casez}\u0026amp;\\text{cmos}\u0026amp;\\text{default}\\\\\\hline \\text{defparam}\u0026amp;\\text{else}\u0026amp;\\text{end}\u0026amp;\\text{endcase}\u0026amp;\\text{endfunction}\u0026amp;\\text{endmodule}\\\\\\hline \\text{endtask}\u0026amp;\\text{event}\u0026amp;\\text{for}\u0026amp;\\text{forever}\u0026amp;\\text{fork}\u0026amp;\\text{function}\\\\\\hline \\text{highz0}\u0026amp;\\text{highz1}\u0026amp;\\text{if}\u0026amp;\\text{initial}\u0026amp;\\text{inout}\u0026amp;\\text{input}\\\\\\hline \\text{integer}\u0026amp;\\text{join}\u0026amp;\\text{module}\u0026amp;\\text{nand}\u0026amp;\\text{negedge}\u0026amp;\\text{nmos}\\\\\\hline \\text{nor}\u0026amp;\\text{not}\u0026amp;\\text{notif0}\u0026amp;\\text{notif1}\u0026amp;\\text{or}\u0026amp;\\text{output}\\\\\\hline \\text{parameter}\u0026amp;\\text{pmos}\u0026amp;\\text{posedge}\u0026amp;\\text{pull0}\u0026amp;\\text{pull1}\u0026amp;\\text{pulldown}\\\\\\hline \\text{pullup}\u0026amp;\\text{rcmos}\u0026amp;\\text{real}\u0026amp;\\text{realtime}\u0026amp;\\text{reg}\u0026amp;\\text{repeat}\\\\\\hline \\text{rnmos}\u0026amp;\\text{rpmos}\u0026amp;\\text{rtran}\u0026amp;\\text{rtranif0}\u0026amp;\\text{rtranif1}\u0026amp;\\text{strong0}\\\\\\hline \\text{string1}\u0026amp;\\text{supply0}\u0026amp;\\text{supply1}\u0026amp;\\text{task}\u0026amp;\\text{time}\u0026amp;\\text{tran}\\\\\\hline \\text{tranif0}\u0026amp;\\text{tranif1}\u0026amp;\\text{tri}\u0026amp;\\text{tri0}\u0026amp;\\text{tri1}\u0026amp;\\text{triand}\\\\\\hline \\text{trior}\u0026amp;\\text{trireg}\u0026amp;\\text{wait}\u0026amp;\\text{wand}\u0026amp;\\text{weak0}\u0026amp;\\text{weak1}\\\\\\hline \\text{while}\u0026amp;\\text{wire}\u0026amp;\\text{wor}\u0026amp;\\text{xnor}\u0026amp;\\text{xor}\\\\\\hline \\end{array}\\)  1.3.3 字串(strings)  一連串字元(character)組成的單一個體 可含有字母、數字、及一些特殊字元 字串的所有字元必須在同一行上，並在雙引號之間  1.3.4 註解(comments)  程式碼中加入說明文字  可讀性(readability) 文件化(documentation) 版權宣告(license declaration)   以//開頭的單行註解(one-line comment) 以/*為開頭，並以*/為結尾的多行註解(multiple-line comment) 多行註解不支援巢狀結構  1.3.5 空白(whitespace)  區隔不同物件 空格(blank spaces，\\b) 欄位(tabs，\\t) 換行(newlines，\\n) 除字串內空白，註解與空白在編譯與合成時會被忽略  1.3.6 數值(numbers)  Verilog 有兩種數值表示法  固定長度(\u0008sized): 定義位元寬度  \u0026lt;size\u0026gt;'\u0026lt;bsase format\u0026gt;\u0026lt;number\u0026gt;  \u0026lt;size\u0026gt;：十進位來表示此數的位元數(bits) \u0026lt;base format\u0026gt;：定義進制  'H|'h：十六進制 'D|'d：十進制 'O|'p：八進制 'B|'b：二進制   \u0026lt;number\u0026gt;：用\u0026lt;base format\u0026gt;來表示數值 若為負號，將-放在\u0026lt;size\u0026gt;前面   舉例：  18'h47CB：18 bits 的十六進位數 47CB 13'h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB 12'd1023：12 bits 的十進位數 1023 9'o723：9 bits 的八進位數 723 5'b11101：5bits 的二進位數 11101 5'b1xx01：含有 unknown values 的表示法     不定長度(unsized): 未定義位元寬度  \u0026lsquo;\u0026lt;base format\u0026gt;\u0026lt;number  不使用\u0026lt;size\u0026gt;規定位元長度 使用 HDL 編譯器內定的長度(32bit的寬度) 沒有寫明\u0026lt;base format\u0026gt;，則內定為十進制   舉例：  'h47CB：32 bits 的十六進位數 47CB 1023：32 bits 的十進位數 1023 'o723：32 bits 的八進位數 723 'b11101：32 bits 的二進位數 11101       Verilog 有四種數值位準(value level)  \\(\\begin{array}{|c|l|}\\hline \\text{數值位準}\u0026amp;\\text{實際電路狀態}\\\\\\hline \\text{0}\u0026amp;\\text{邏輯0，假(false)，接地}\\\\\\hline \\text{1}\u0026amp;\\text{邏輯1，真(true)，接壓電源}\\\\\\hline \\text{x}\u0026amp;\\text{不確定值(unknown value)}\\\\\\hline \\text{z}\u0026amp;\\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\\\\hline \\end{array} \\)    1.4 Verilog 資料物件與型態  資料物件(data objects)  描述行為過程中所使用的訊號載具 一個物件經過處理再傳到另一個物件   資料型態(data type)  定義資料物件的類型 接線、暫存器、參數等    1.4.1 接線(Nets)  接線(nets)是連接實體元件的連接線 要被驅動才能改變其內部的值 最主要的關鍵字是 wire  一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 z(高阻抗、浮接)   宣告方式 wire w; // 宣告一條接線，命名為\u0008w，內定預設值為z wire x = 1\u0026#39;b0; // 宣告一條接線，命名為x，並指定x為邏輯0 wire a, b, c // 宣告三條接線，命名為a, b, c   1.4.2 暫存器(Registers)  抽象的資料儲存物件(有別於實體暫存器 D flip-flop) 保留一個數值直到下一次指定新值為止 觀念類似 C 語言中的變數 主要的關鍵字是 reg  一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 x(未知)   \\(\\begin{array}{|l|l|}\\hline \\text{reg}\u0026amp;\\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\\\\hline \\text{integer}\u0026amp;\\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\\\ \u0026amp;\\text{算術運算產生2補數結果(2\u0026rsquo;s complement results))}\\\\\\hline \\text{real}\u0026amp;\\text{雙倍精確度之有號浮點數}\\\\ \u0026amp;\\text{(signed floating-point variable with double precision)}\\\\\\hline \\text{time}\u0026amp;\\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\\\\hline \\end{array}\\)  設計電路請以reg為主，其他類型合成器可能不支援。   宣告方式 reg a; // 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x reg x, y; // 宣告 2 個宣存器，命名為 x, y integer count; // 宣告 1 個整數為 count，值可以為正負 real fraction; // 宣告 1 個浮點數為 fraction，值含小數點   1.4.3 純量與向量(scalar and vector)  純量(scalar)  一個位元的物件   向量(vector)  多個位元的物件   接線(ex. wire) 與 reg  內定一位元 [大數字:小數字]、[小數字:大數字]→[MSB:LSB]   宣告方式 wire a; // 宣告 1 個 1-bits 接線 wire [4:0] x; // 宣告 1 個 5-bits 接線 reg b; // 宣告 1 個 1-bits 暫存器 reg [0:7] y; // 宣告 1 個 8-bits 暫存器 reg [31:0] z; // 宣告 1 個 32-bits 暫存器   1.4.4 陣列(Array)  多個暫存器、接線的聚合體 索引值(index)定義聚合體中的個別物件 支援多維度的陣列 記憶體(memory)、暫存器檔案(register file) 陣列中暫存器、接線的個數  [大數字:小數字]、[小數字:大數字]   宣告方式 // mem_block 是一個包含 128 個暫存器的陣列， // 每個暫存器皆為 32 位元寬 reg [31:0] mem_block [127:0]; // mem_2D 是一個 2 維 4x64 的暫存器陣列， // 每個暫存器皆為 8 位元寬 reg [7:0] mem_2D [3:0][63:0];   1.4.5 參數(parameter)  定義編譯合成電路時的常數 每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路 重複使用 關鍵字 parameter 宣告方式 parameter width = 4; wire [width-1:0] a, b; // 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動 reg [width-1:0] y; // 暫存器 y 的位元寬度，會隨著參數值的改變而變動   1.5 模組(Module)、埠(Port) 1.5.1 模組(Module)  一個電路區塊、可以由其他模組組成 連接模組時  考慮模組的輸入與輸出介面 不需要考慮模組內部的詳細電路   電路設計時  只修改模組內部電路 不會改變電路外部及周遭的模組   模組內部的電路描述可包含  訊號資料型態宣告 引用其他模組(邏輯閘) assign 資料處理模型之描述 always 行為模型之描述 函數(function) 與 任務(task) 除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為   模組宣告  以關鍵字 module 為開頭，在其後加一個識別用的模組名稱(module name) 再來是輸入與輸出埠列(module terminal list)和埠列宣告，接著是模組內部關於電路的描述 以關鍵字 endmodule 做為模組結尾 支援階層`式的設計概念  module module_name(terminal_list) port_declaration(...) param_declaration(optional) data_type_declaration(wire, reg) other_module(logic_gate) assign data_flow_model always behavior_model function, task endmodule   1.5.2 埠(port)  終端點、模組與外界溝通的介面接點(門) 一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通 若模組與外界不需要溝通，則埠列也就不存在(封閉系統)  測試環境(test bench)   埠的宣告  埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。 埠的宣告型態內定為接線(net)的 wire，若需要將訊號儲存起來則埠號型態須宣告成暫存器 reg。 輸入埠和雙向埠只能是接線(net)，不可宣告成暫存器。 輸出埠可以宣告成接線(net)或暫存器。  module full_adder(a, b, carry, sum); // 埠列 input [3:0] a, b; // 輸入埠(4位元向量) input carry // 輸入埠(1位元純量) output [4:0] sum; // 輸出埠(5位元向量) reg [4:0] sum; // 因輸出sum需儲存資料，故宣告成暫存器 ... endmodule   1.6 邏輯閘層次模型  利用關鍵字即可引用基本的邏輯閘元件 基本的邏輯閘關鍵字  and nand or nor not xor xnor    1.6.1 多個輸入邏輯閘(Multiple-Input Gates)  and、nand、or、nor、xor、xnor 具有多個純量(scalar)的輸入，但是只有一個純量的輸出 多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面 輸出必須透過接線(wire)連接，輸入無規定 多個輸入邏輯閘的別名可以加或是不加 使用方法 gate_type instance(out, in_1, in_2, in_3, ..., in_n); gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n),  inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n),  inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n),  ...  inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn);  \\(\\begin{array}{ccc} \\underbrace{\\text{a, b, c, d}}_{\\text{輸入}} \\rightarrow \\boxed{\\text{Multiple-Input Gate}} \\rightarrow \\underbrace{\\text{e}} _{\\text{輸出}} \\end{array} \\) \\(\\text{and\\quad a1(} \\underbrace{\\text{e}}_{\\text{輸出}} \\text{, } \\underbrace{\\text{a, b, c, d}} _{\\text{輸入}} \\text{);} \\)  1.6.2 多個輸出邏輯閘(Multiple-Output Gates)   not、buf\n  具有一個或是多個純量(scalar)的輸出，但是只有一個純量的輸入\n  多個輸出邏輯閘的輸出是放在埠列(port list)的前面位置，而輸入則是放在列後面位置\n 輸出必須透過接線(wire)連接，輸入無規定    多個輸出邏輯閘的別名可以加或是不加\n  使用方法\ngate_type instance(out_1, out_2, out_3, ..., out_n, in); gate_type inst_1(out1_1, out1_2, out1_3, ..., out1_n, in1),  inst_2(out2_1, out2_2, out2_3, ..., out2_n, in2),  inst_3(out3_1, out3_2, out3_3, ..., out3_n, in3),  ...  inst_m(out_m1, out_m2, out_m3, ..., out_mn, in_m);   \\(\\begin{array}{ccc} \\underbrace{\\text{d}}_{\\text{輸入}} \\rightarrow \\boxed{\\text{Multiple-Output Gate}} \\rightarrow \\underbrace{\\text{a, b, c}} _{\\text{輸出}} \\end{array} \\)\n  \\(\\text{not\\quad n1(} \\underbrace{\\text{a, b, c}}_{\\text{輸出}} \\text{, } \\underbrace{\\text{d}} _{\\text{輸入}} \\text{);} \\)\n  邏輯閘層次模型範例\n module and_or_gate(in1, in2, in3, in4, out;  input in1, in2, in3, in4; output out;  wire w1, w2;  and a1(w1, in1, in2); and a2(w2, in3, in4); or o1(out, w1, w2);  endmodule     ","permalink":"http://intervalrain.github.io/posts/verilog/intro/","summary":"1 Verilog HDL 1.1 Verilog 簡介  一套硬體描述語言  輔助設計數位系統 描述電路的行為 電子自動化工具   類似C語言的硬體描述語言  易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的)   支援多種硬體層級的描述方式  從低階到高階模式 依照不同的方法設計   支援階層式的設計方法  樹狀式的設計結構 由繁化簡    1.2 Verilog 的模型 1.2.1 電晶體層級  Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計  1.2.2 邏輯閘層級  Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖  1.2.3 資料流層級  Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式  如：out = a + b + c    1.","title":"[VHDL] Verilog Hardware Description Language"},{"content":"前言 MVC  MVC 是一種軟體架構模式。  模型 (Model) 視圖 (View) 控制器 (Controller)   目的是實現一種動態且有彈性的程式設計，使後續對程式設計的維護與擴充都變得更容易，另一方面也能使程式的某一部分被重複使用而提升設計效率。  SSH  SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成：  Struts Spring Hibernate    SSM  SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成：  Spring-MVC Spring MyBatis    SSH v.s. SSM Spring-MVC v.s. Struts  Struts 和 Spring-MVC 都負責取轉發，但兩者針對 request 的請求上區別很大，  Struts 是針對一個 Action class 來進行 request，即一個 Action 對應一個 request，屬於類攔截，請求的數據類共享。 Spring-MVC 則是針對 method 級別的 request，即一個 method 對應一個 request，屬於方法攔截，請求的數據方法不共享。   Spring-MVC 的配置文件相對較少，容易上手，方便開發。 Spring-MVC 的入口是 Servlet 級別的而 Struts 的級別是 Filter 級別的。  Hibernate v.s. MyBatis  Hibernate 是一種 O/R 關係型，即完成資料庫和持久化類別之間的映射；而 MyBatis 是針對的 SQL-Mapping。猶如 Hibernate 是對資料庫封裝完成後，調用相對應的語句(HQL)來控制資料庫；而 MyBatis 是用原生的資料庫語法。 基於以上原因，Hibernate 的優化較 MyBatis 難，MyBatis 不需要額外學習新的語法，入門較快。 對於更高級的 Queuy，MyBatis 需要編寫 SQL 語句與 ResultMap。而 Hibernate 有因應的映射機制，無需關心 SQL 的生成與結果映射，可以專注於開發流程。 Hibernate 的資料庫移植性很好，MyBatis 的資料庫移植性不好，不同的資料庫需要寫不同的 SQL。  Spring Spring、Spring MVC、Spring Boot  Spring  是一種框架，包含一系列的 IoC 容器的設計和依賴注入(DI) 及 整合AOP功能。   Spring MVC  是一種以 Spring 為核心的框架。   Spring Boot  是一種以 Spring 為核心的框架，同時又能簡化配置(configuration)。    Spring 的核心基礎 DI  DI = 依賴注入 Dependency Injection 一種 coding style，為了未來在維護上能更加的靈活，概念類似：  // 1 System.out.println(\u0026#34;This is Spring\u0026#34;);  // 2 String str = \u0026#34;This is Spring\u0026#34;; System.out.println(str); IoC  IoC = 控制反轉 Inversion of Control 將產生物件這件事交給IoC去做。簡單來說，IoC是一個xml檔，也可以是一個class(Bean class)。 IoC做的事情就是設定其他class(Bean class)的名稱，以及 Constructor 會用到的參數或物件。  public class User{ Family family = new Family(\u0026#34;Jason\u0026#34;, \u0026#34;Jocelyn\u0026#34;, \u0026#34;Mark\u0026#34;, \u0026#34;Eva\u0026#34;); public void showAll(){ family.showFamily(); } } public class Family{ String dad; String mom; String son; String dau; public Family(String dad, String mom, String son, String dau){ this.dad = dad; this.mom = mom; this.son = son; this.dau = dau; } public void showFamily(){ System.out.println(dad + \u0026#34; \u0026#34; + mom + \u0026#34; \u0026#34; + son + \u0026#34; \u0026#34; + dau); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;  \u0026lt;beans\u0026gt;  \u0026lt;bean id=\u0026#34;family\u0026#34; class=\u0026#34;Family\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;dad\u0026#34; value=\u0026#34;Jason\u0026#34; /\u0026gt;  \u0026lt;property name=\u0026#34;mom\u0026#34; value=\u0026#34;Jocelyn\u0026#34; /\u0026gt;  \u0026lt;property name=\u0026#34;son\u0026#34; value=\u0026#34;Mike\u0026#34; /\u0026gt;  \u0026lt;property name=\u0026#34;dau\u0026#34; value=\u0026#34;Eva\u0026#34; /\u0026gt;  \u0026lt;/bean\u0026gt;  \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;User\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;allFamily\u0026#34; value=\u0026#34;family\u0026#34; /\u0026gt;  \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 實例 DI + IoC  Dinner  public class Diner{  Food food;  public void getDinner(){  food.getFood();  } }  xml  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;  \u0026lt;beans\u0026gt;  \u0026lt;bean id=\u0026#34;pork\u0026#34; class=\u0026#34;Pork\u0026#34;/\u0026gt;  \u0026lt;bean id=\u0026#34;chicken\u0026#34; class=\u0026#34;Chicken\u0026#34;/\u0026gt;  \u0026lt;bean id=\u0026#34;food\u0026#34; class=\u0026#34;Food\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;food\u0026#34; value=\u0026#34;chicken\u0026#34; /\u0026gt;  \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;  classes  public interface Food{ public void getFood(); } public class Chicken implements Food{ @override public void getFood(){ System.out.println(\u0026#34;Eat chicken\u0026#34;); } } public class Pork implements Food{ @override public void getFood(){ System.out.println(\u0026#34;Eat pork\u0026#34;); } } Spring Boot  由 Pivotal 團隊在 2013 年開始研發、2014年4月發布第一個版本。 是基於 Spring4.0 所設計的一種新型框架，繼承的 Spring 框架原有的優秀特性，還通過簡化配置來進一步簡化了 Spring 應用的整個搭建和開發過程。 通過集成大量的框架使得依賴包的版本衝突與引用的不穩定性得到很好的解決。 官方說明:   Spring Boot makes it easy to create stand-alone, production-grade Spring baesd Applications that you can \u0026ldquo;just run\u0026rdquo;. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.\n  String Boot 預設了各種合理的默認配置包括放棄了 XML，Spring Boot Web 應用程式使用了一個嵌入式 Tomcat 容器，可以自定義 Spring Boot 應用程式等。 簡而言之，Spring Boot 提供一組工具，可以快速構建且容易配置的 Spring 應用程式。同時不需要在重新定義基本的配置，從而成為可以達到快速開發的效果。  特色  創建獨立的 Spring 應用程式 嵌入式 Tomcat、Jetty; Undertow(不用部署 WAR 包) 提出自主的 starter 來簡化配置 隨時自動地配置 Spring 及相關的第三方庫 提供已隨時就緒的功能如 Metrics，程式的健檢及外部化配置 不會生成任何代碼及無任何 XML 配置的前設要求  ","permalink":"http://intervalrain.github.io/posts/java/java_mvc/","summary":"前言 MVC  MVC 是一種軟體架構模式。  模型 (Model) 視圖 (View) 控制器 (Controller)   目的是實現一種動態且有彈性的程式設計，使後續對程式設計的維護與擴充都變得更容易，另一方面也能使程式的某一部分被重複使用而提升設計效率。  SSH  SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成：  Struts Spring Hibernate    SSM  SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成：  Spring-MVC Spring MyBatis    SSH v.s. SSM Spring-MVC v.s. Struts  Struts 和 Spring-MVC 都負責取轉發，但兩者針對 request 的請求上區別很大，  Struts 是針對一個 Action class 來進行 request，即一個 Action 對應一個 request，屬於類攔截，請求的數據類共享。 Spring-MVC 則是針對 method 級別的 request，即一個 method 對應一個 request，屬於方法攔截，請求的數據方法不共享。   Spring-MVC 的配置文件相對較少，容易上手，方便開發。 Spring-MVC 的入口是 Servlet 級別的而 Struts 的級別是 Filter 級別的。  Hibernate v.","title":"[Java] 淺談 Java MVC"},{"content":"Microservices Definition  Separate business logic functions. Instead of one big problem, several smaller applications. Communicative via well defined APIs - usually HTTP In demand   Advantages and Disavantages  Advantages  Language independent Fast iterations Small teams Fault Isolation Pair well with containers Scalable  Big plus     Disavantages  Complex networking Overhead  Databases Servers      Docker  is an open platform for developers and sysadmins to build, ship, and run distributed applications, whether on laptops, data center VMs, or the cloud.  Definition  Containers are a way to package software in a format that can run isolated on a shared operating system. Unlike VMs, containers do not bundle a full operating system - only libraries and setting required to make the software work are needed. This makes for efficientm, lightweight, self-contained systems and guarantees that software will always run the same, regardless of where it\u0026rsquo;s deployed.  Docker vs VM  VM = App + Bins/Libs + guest OS Container = App + Bins/Libs + Docker  Dockerfile  Describes the build process for an image Can be run to automatically create an image Contains all the commands necessary to build the image and run your application.  Kubernetes Components  Node  Kubelet Communicates with master Run Pods   Pod  Runs 1+ containers Exists on a node   Service  Handles requests Usually a load balancer   Deployment  Defines desired state - kubernetes handles the rest    ","permalink":"http://intervalrain.github.io/posts/it/microservices_docker_kubernetes/","summary":"Microservices Definition  Separate business logic functions. Instead of one big problem, several smaller applications. Communicative via well defined APIs - usually HTTP In demand   Advantages and Disavantages  Advantages  Language independent Fast iterations Small teams Fault Isolation Pair well with containers Scalable  Big plus     Disavantages  Complex networking Overhead  Databases Servers      Docker  is an open platform for developers and sysadmins to build, ship, and run distributed applications, whether on laptops, data center VMs, or the cloud.","title":"[IT] Introduction to Microservices, Docker and Kubernetes"},{"content":"map 宣告 map \u0026lt;int, int\u0026gt; mp; // key和value都是整數 方法 mp[key] = value;  加入新的key-value pair  mp.count(key);  檢查 key 是否存在 map 中  mp.erase(key);  刪除 key  mp.clear();  清空 map 中的所有元素：  value = mp[key]  利用 key 取值  mp.empty()  判斷是否為空的map  map 的遍歷  遍歷整個map時，利用iterator操作： 取key：it-\u0026gt;first 或 *(it).first 取value：it-\u0026gt;second 或 *(it).second  for (auto it = mp.begin(); it != mp.end(); ++it){  cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }  for (auto it = mp.begin(); it != mp.end(); ++it){  cout \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"http://intervalrain.github.io/posts/c++/stl_map/","summary":"map 宣告 map \u0026lt;int, int\u0026gt; mp; // key和value都是整數 方法 mp[key] = value;  加入新的key-value pair  mp.count(key);  檢查 key 是否存在 map 中  mp.erase(key);  刪除 key  mp.clear();  清空 map 中的所有元素：  value = mp[key]  利用 key 取值  mp.empty()  判斷是否為空的map  map 的遍歷  遍歷整個map時，利用iterator操作： 取key：it-\u0026gt;first 或 *(it).first 取value：it-\u0026gt;second 或 *(it).second  for (auto it = mp.begin(); it != mp.end(); ++it){  cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }  for (auto it = mp.","title":"[C++] The C++ Standard Template Library(STL) - map"},{"content":"rand() 函數  在 C/C++ 中可以使用 rand() 這個函數，產生最簡單的亂數： 需引用 \u0026lt;stdlib.h\u0026gt; 函式庫 在呼叫 rand() 前需要先使用srand()設定初始的亂數種子，增加「亂度」。(實際上產生的亂數是有規則的，以示例為例，是以時間做為種子，故是有可能被預測的) 其產生的亂數是一個介於 0 到 RAND_MAX(INT_MAX)的整數。 C 與 C++ 幾乎一樣，只差在表頭檔的使用。  C-style #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt; int main(){  srand(time(NULL)); // random seed  int x = rand();   printf(\u0026#34;x = %d\\n\u0026#34;, x);  return 0; } Cpp-style #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;ctime\u0026gt; using namespace std;  int main(){  srand(time(NULL));  int x = rand();   cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;  cout \u0026lt;\u0026lt; \u0026#34;x is between 0 and \u0026#34; \u0026lt;\u0026lt; RAND_MAX \u0026lt;\u0026lt; endl;   return 0; } 亂數種子  由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。 上例中使用的亂數種子是時間，因為時間每分每秒都在變化，所以每次產生的亂數都會不同，如果是用於數值模擬的話，  固定亂數種子  由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。若是做數值模擬的話，通常會讓模擬結果具有可重復性(repeatability)，方便除錯與驗證，這種狀況就可以將亂數種子固定不變，以確保每次的結果都相同。  [0, 1) 浮點數亂數  [0, 1) 代表 0 \u0026lt;= x \u0026lt; 1 若要產生 0 到 1 之間的浮點數亂數，可以這樣寫：  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;ctime\u0026gt; using namespace std;  int main(){  srand(time(NULL));  double x = (double)rand()/(RAND_MAX + 1.0);   cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;   return 0; } [a, b)特定範圍浮點數亂數  [a, b) 表 a \u0026lt;= x \u0026lt; b  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;ctime\u0026gt; using namespace std;  int main(){  srand(time(NULL));  double x = (double)rand()/(RAND_MAX + 1.0);   cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;   return 0; } [a, b)特定範圍整數亂數 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;ctime\u0026gt; using namespace std;  int main(){  srand(time(NULL));   int a = 1; // min  int b = 100; // max   int x = rand() % (b - a + 1) + a;   cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;   return 0; }   上面這種使用餘數運算（%）的方式只是比較方便的寫法，事實上使用餘數運算所產生的整數亂數在理論上不是標準的均勻分布。\n  我們以一個簡單的例子來解釋，假設 RAND_MAX 的值為 10，而我們要產生介於 3 到 5 之間的整數亂數（亦即 min = 3、max = 5），以下是所有的可能性對照表：\n \\(\\def\\arraystretch{1.4}\\begin{array}{c|l|c} 轉換後的整數亂數\u0026amp;\\text{rand()}函數產生的亂數\u0026amp;出現機率\\\\\\hline 3\u0026amp;0,3,6,9\u0026amp;4/11\\\\\\hline 4\u0026amp;1,4,7,10\u0026amp;4/11\\\\\\hline 5\u0026amp;2,5,8\u0026amp;3/11 \\end{array}\\)    rand() 函數所產生的每一個整數其出現的機率是均等的，但是經過於數運算的轉換之後，因為 RAND_MAX 通常不會被整除，所以轉換之後的整數亂數出現機率就存在有細微的偏差，以這個例子來說，3、4、5 三個數字出現的機率比是 4:4:3。\n  另外有些人會先產生固定範圍的浮點數亂數，再將浮點數轉型為整數，例如產生 [3, 6) 的浮點數亂數，然後轉型為 [3, 5] 的整數亂數，其實這種方式跟餘數運算一樣會有每個整數出現機率不均等的問題，簡單來說就是現在有 11 個球要放進 3 個籃子裡，不管怎麼放，每個籃子的球都不可能一樣多。\n  均勻分布亂數(uniform distribution) #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;ctime\u0026gt; using namespace std;  int randint(int n){  if ((n - 1) == RAND_MAX)  return rand();  long end = RAND_MAX / n;  assert (end \u0026gt; 0L);  end *= n;  int r;  while ((r = rand()) \u0026gt;= end);   return r % n; }  int main(){  int x = randint(5);  cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } 使用 randint 函數產生特定範圍整數亂數： int x = randint(max - min + 1) + min;   這種作法就好像要把 11 個球要放進 3 個籃子裡，而最後多出來的 2 顆球就直接丟掉，確保每個籃子都一樣只有 3 顆，這樣大家的機率就可以相等了。\n  這種使用截斷分布（truncated distribution）來校正機率的方式雖然在理論上是正確的，但是 rand 函數是使用 LCG（Linear Congruential Generator）來產生亂數的，他的優點只是快速、方便而已，但它本身所產生的亂數品質沒有非常好，再怎麼校正效果都有限，若需要高品質的亂數，請改用 C++11 標準的 函式庫。\n  ","permalink":"http://intervalrain.github.io/posts/c++/random/","summary":"rand() 函數  在 C/C++ 中可以使用 rand() 這個函數，產生最簡單的亂數： 需引用 \u0026lt;stdlib.h\u0026gt; 函式庫 在呼叫 rand() 前需要先使用srand()設定初始的亂數種子，增加「亂度」。(實際上產生的亂數是有規則的，以示例為例，是以時間做為種子，故是有可能被預測的) 其產生的亂數是一個介於 0 到 RAND_MAX(INT_MAX)的整數。 C 與 C++ 幾乎一樣，只差在表頭檔的使用。  C-style #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt; int main(){  srand(time(NULL)); // random seed  int x = rand();   printf(\u0026#34;x = %d\\n\u0026#34;, x);  return 0; } Cpp-style #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;ctime\u0026gt; using namespace std;  int main(){  srand(time(NULL));  int x = rand();   cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl;  cout \u0026lt;\u0026lt; \u0026#34;x is between 0 and \u0026#34; \u0026lt;\u0026lt; RAND_MAX \u0026lt;\u0026lt; endl;   return 0; } 亂數種子  由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。 上例中使用的亂數種子是時間，因為時間每分每秒都在變化，所以每次產生的亂數都會不同，如果是用於數值模擬的話，  固定亂數種子  由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。若是做數值模擬的話，通常會讓模擬結果具有可重復性(repeatability)，方便除錯與驗證，這種狀況就可以將亂數種子固定不變，以確保每次的結果都相同。  [0, 1) 浮點數亂數  [0, 1) 代表 0 \u0026lt;= x \u0026lt; 1 若要產生 0 到 1 之間的浮點數亂數，可以這樣寫：  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;ctime\u0026gt; using namespace std;  int main(){  srand(time(NULL));  double x = (double)rand()/(RAND_MAX + 1.","title":"[C++] 如何產生 random 值"},{"content":"程式碼 static final int hash(Object key){  int h;  return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } h \u0026raquo; 16 的用途  h是key.hashCode()，h \u0026gt;\u0026gt;\u0026gt; 16代表的是取其高位的16位  key.hashCode() ^ (h \u0026raquo; 16)  這與 Java1.8 中 tab[(n-1) \u0026amp; hash] 的原理有關 static int indexFor(int h, int length){  return h \u0026amp; (length - 1); }  返回的值即為陣列的下標。 大多數情況下，capacity 都小於2^16，所以在此的 \u0026amp; 運算，只會對 h 的低16位進行 \u0026amp; 運算。 若將高位16位也加入計算，可以增加下標的發散度，避免衝突的次數。 而使用 XOR 的原因是，更較於 AND 或 OR 均勻，因為 AND 會使結果趨向於 0，OR 會使結果趨向於 1。    ","permalink":"http://intervalrain.github.io/posts/java/hashmap/hashcode/","summary":"程式碼 static final int hash(Object key){  int h;  return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } h \u0026raquo; 16 的用途  h是key.hashCode()，h \u0026gt;\u0026gt;\u0026gt; 16代表的是取其高位的16位  key.hashCode() ^ (h \u0026raquo; 16)  這與 Java1.8 中 tab[(n-1) \u0026amp; hash] 的原理有關 static int indexFor(int h, int length){  return h \u0026amp; (length - 1); }  返回的值即為陣列的下標。 大多數情況下，capacity 都小於2^16，所以在此的 \u0026amp; 運算，只會對 h 的低16位進行 \u0026amp; 運算。 若將高位16位也加入計算，可以增加下標的發散度，避免衝突的次數。 而使用 XOR 的原因是，更較於 AND 或 OR 均勻，因為 AND 會使結果趨向於 0，OR 會使結果趨向於 1。    ","title":"[Java] HashMap中的hashCode設計原理"},{"content":"C++ 易錯題目收集 1. bit-format expression #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main(){  unsigned int x = -1;  int y = ~0;  if (x==y)  cout \u0026lt;\u0026lt; \u0026#34;same\u0026#34;;  else  cout \u0026lt;\u0026lt; \u0026#34;not same\u0026#34;;  return 0; }  結果  same  解析  unsigned int x = -1 相當於11111111 y = ~0 也相當於11111111     2. 如何使 C(n,3) 正確且 n 的有效值最大?  結果  return n*(n-1)/2*(n-2)/3;  解析  n*(n-1)必為基偶相乘 n*(n-1)*(n-2)必為3的倍數 故此題的作法可避免因整數除法而造成的小數位消去     3. register在C++中的用法 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main(){  register int i = 10;  int *ptr = \u0026amp;i;  cout \u0026lt;\u0026lt; *ptr;  return 0; }  選項  Prints 10 on all compilers Prints 0 on all compilers May generate Compilation Error May generate Runtime Error   結果  May generate Compilation Error  解析  register關鍵字用來分配變數儲存於CPU的register，以達到快速存取。所以對其提取有可能造成編譯錯誤，因為指標指向的位址不在在RAM上。 在大部分的C++編譯器，不推薦使用register關鍵字，因為沒有任何意義，儘管他會被默認成auto關鍵字，使得C++編譯器可能可能適用。     4. 有趣的 for loop 問題 int fun(){  static int num = 16;  return num--; } int main(){  for(fun(); fun(); fun())  cout \u0026lt;\u0026lt; fun();  return 0; }  結果  14 11 8 5 2  解析  main()中的 for-loop 可以寫成等效的 while-loop 如下  int main(){  int num = 16;  num--; // num = 15  while (num-- != 0){ // 先判斷後遞減 15 !=0, num = 14  cout \u0026lt;\u0026lt; (num--) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 先印出後遞減印出 14, num = 13  num--; // 遞減後回到while, num = 12  }  return 0; }  static int num = 16 設定初值為 16，並遞減，故 num = 15 判斷 num 是否為真，後遞減。15 != 0，遞減使 num = 14，進入迴圈 印出 num = 14 後，遞減，num = 13 迴圈結束前作遞減，num = 12，重新回到 step2     5. const 與 volatile Pick the correct statemewnt for const and volatile keywords.  選項  const is the opposite of volatile and vice versa const and volatile can\u0026rsquo;t be used for struct and union const and volatile can\u0026rsquo;t be used for enum const and volatile can\u0026rsquo;t be used for typedef const and volatile are independent i.e. it\u0026rsquo;s possible that a variable is defined as both const and volatile   結果  const and volatile are independent i.e. it\u0026#39;s possible that a variable is defined as both const and volatile  解析  const 是確保變數不會變修改，使其值變成唯讀。 volatile 通常用在具有最佳化或多執行緒相關的變數或物件，volatile用來阻止編譯器因誤認某段程式碼無法被程式碼本身所改變，而造成的過度優化。volatile會使得每次存取這個變數或物件時，都會直接從變數位址中取得資料，避免可能使用暫存器中的值，在變數可能被其他程式更新的狀況下，產生錯誤的值。     6. operator priority int main(){  cout \u0026lt;\u0026lt; (1 \u0026lt;\u0026lt; 2 + 3 \u0026lt;\u0026lt; 4);  return 0 }  結果  512  解析  +優先於\u0026lt;\u0026lt; 故此段敘述等效於 cout \u0026lt;\u0026lt; (1 \u0026lt;\u0026lt; (2 + 3) \u0026lt;\u0026lt; 4); cout \u0026lt;\u0026lt; (1 \u0026lt;\u0026lt; 5 \u0026lt;\u0026lt; 4); cout \u0026lt;\u0026lt; (32 \u0026lt;\u0026lt; 4); cout \u0026lt;\u0026lt; 512;     7. floating constant Suppose a C++ program has floating constant 1.414, what\u0026#39;s the best way to convert this as \u0026#34;float\u0026#34; data type?  選項  (float)1.414 float(1.414) 1.414f or 1.414F 1.414 itself of \u0026ldquo;float\u0026rdquo; data type i.e. nothing else required   結果  `1.414f` or `1.414F`  解析  floating constant 被預設為 double 資料型態，故利用f或F的suffix，即可將之轉為 float 資料型態。     8. array pointer int main(){  int arr[5];  // Assume base address of arr is 2000 and size of integer is 32 bit  printf(%u %u, arr+1, \u0026amp;arr+1);  return 0; }  結果  2004 2020  解析  array 的名稱會傳回第一個元素的地址(除了使用 sizeof)。 對 array 加 1 會加上 sizeof(type)。 \u0026amp;array 代表整個 array 的地址，加 1 回加上 sizeof(while array)。     9. initialize array int main(){  int a[][] = {{1,2},{3,4}};  int i, j;  for (int i = 0; i \u0026lt; 2; i++){  for (int j = 0; j \u0026lt; 2; j++){  printf(\u0026#34;%d \u0026#34;, a[i][j]);  }  }  return 0; }  結果  Compilation Error  解析  Array 在記憶體中是以row-major的型式儲存的。 儘管 array 是多維陣列，他都是被儲存成單一線性的區塊 下列 assign 的方式是合法的，(第一個可被省略)  int a[] = {...}; int a[][10] = {{...}, ...}; int a[][5][10] = {{{...},...},...};    ","permalink":"http://intervalrain.github.io/posts/c++/question/","summary":"C++ 易錯題目收集 1. bit-format expression #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int main(){  unsigned int x = -1;  int y = ~0;  if (x==y)  cout \u0026lt;\u0026lt; \u0026#34;same\u0026#34;;  else  cout \u0026lt;\u0026lt; \u0026#34;not same\u0026#34;;  return 0; }  結果  same  解析  unsigned int x = -1 相當於11111111 y = ~0 也相當於11111111     2. 如何使 C(n,3) 正確且 n 的有效值最大?  結果  return n*(n-1)/2*(n-2)/3;  解析  n*(n-1)必為基偶相乘 n*(n-1)*(n-2)必為3的倍數 故此題的作法可避免因整數除法而造成的小數位消去     3.","title":"[C++]易錯題目收集"},{"content":"list  Lists 是序列式容器，但其記憶體的分配並非連續的。 跟 vector 相比，其遍歷的速度會較慢\\(O(n)\\，但一旦位置確定後，其插入(insert)或移除(delete)元素的速度很快\\(O(1)\\)。 一般來說，List 指的是雙向鏈結陣列(doubly linked list)。 而單向鏈結陣列則為 forward_list。  #include \u0026lt;iostream\u0026gt;#include \u0026lt;iterator\u0026gt;#include \u0026lt;list\u0026gt; using namespace std;  void print(list\u0026lt;int\u0026gt; lst){  list\u0026lt;int\u0026gt;::iterator it;  for (it = lst.begin(); it != lst.end(); ++it){  cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  }  cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }  int main(){  list\u0026lt;int\u0026gt; lst1, lst2;  for (int i = 0; i \u0026lt; 10; ++i){  lst1.push_back(i);  lst2.push_front(i);  }  cout \u0026lt;\u0026lt; \u0026#34;List1 is : \u0026#34;;  print(lst1);  cout \u0026lt;\u0026lt; \u0026#34;List2 is : \u0026#34;;  print(lst2);   cout \u0026lt;\u0026lt; \u0026#34;List1.front() : \u0026#34; \u0026lt;\u0026lt; lst1.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;List2.back() : \u0026#34; \u0026lt;\u0026lt; lst2.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;   cout \u0026lt;\u0026lt; \u0026#34;After List1.pop_front() : \u0026#34;;  lst1.pop_front();  print(lst1);  cout \u0026lt;\u0026lt; \u0026#34;After List2.pop_back() : \u0026#34;;  lst2.pop_back();  print(lst2);   cout \u0026lt;\u0026lt; \u0026#34;After List1.reverse() : \u0026#34;;  lst1.reverse();  print(lst1);   cout \u0026lt;\u0026lt; \u0026#34;After List2.sort() : \u0026#34;;  lst2.sort();  print(lst2);   return 0; } 函式(functions) 1. list.front()  Returns the value of the first element in the list.  2. list.back()  Returns the value of the last element in the list.  3. list.push_front(E val)  Adds a new element val at the beginning of the list.  4. list.push_back(E val)  Adds a new element val at the end of the list.  5. list.pop_front()  Removes the first element of the list, and reduces size of the list by 1. Won\u0026rsquo;t return value.  6. list.pop_back()  Removes the last element of the list, and reduces size of the list by 1. Won\u0026rsquo;t return value.  7. list.begin()  Returns a iterator pointing to the first element of the list.  6. list.end()  Returns a iterator pointing to the theoretical last element which follows the last element.  7. list.rbegin()  Returns a reverse iterator which points to the last element of the list.  8. list.rend()  Returns a reverse iterator which points to the position before the beginning of the list.  9. list.cbegin()  Returns a constant random access iterator which points to the beginning of the list.  10. list.cend()  Returns a constant random access iterator which points to the end of the list.  11. list.crbegin()  Returns a constant reverse random access iterator which points to the beginning of the list.  12. list.crend()  Returns a constant reverse random access iterator which points to the end of the list.  13. list.empty()  Returns whether the list is empty or not.  14. list.insert(pos, n, val)  pos: iterator, to point out the position to insert n: the numbers of val to insert (optional, default = 1) val: the insert elements Inserts new elements in the list before the element at a specified position.  15. list.erase(pos)  pos: iterator, to point out the position to erase Removes a single element from the list.  16. list.erase(first, last)  first: iterator, to point out the begining of the range. last: iterator, to point out the end of the range. Removes a range of elements from the list.  16. list.assign() 17. list.remove() 18. list.remove_if() 19. list.reverse() 20. list.size() 21. list.resize() 22. list.sort() 23. list.max_size() 24. list.unique() 25. list.emplace_front() 26. list.emplace_back() 27. list.clear() 28. list.swap() 29. list.splice() 30. list.merge() 31. list.emplace()  你可能會想繼續閱讀…  回到容器(Containers) vector deque arrays forward_list    ","permalink":"http://intervalrain.github.io/posts/c++/stl_list/","summary":"list  Lists 是序列式容器，但其記憶體的分配並非連續的。 跟 vector 相比，其遍歷的速度會較慢\\(O(n)\\，但一旦位置確定後，其插入(insert)或移除(delete)元素的速度很快\\(O(1)\\)。 一般來說，List 指的是雙向鏈結陣列(doubly linked list)。 而單向鏈結陣列則為 forward_list。  #include \u0026lt;iostream\u0026gt;#include \u0026lt;iterator\u0026gt;#include \u0026lt;list\u0026gt; using namespace std;  void print(list\u0026lt;int\u0026gt; lst){  list\u0026lt;int\u0026gt;::iterator it;  for (it = lst.begin(); it != lst.end(); ++it){  cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  }  cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }  int main(){  list\u0026lt;int\u0026gt; lst1, lst2;  for (int i = 0; i \u0026lt; 10; ++i){  lst1.push_back(i);  lst2.","title":"[C++] The C++ Standard Template Library(STL) - List"},{"content":"vector  Vectors 是一動態陣列，可以自動的調整其容器的容量。 Vector 的元素被儲存在連續的記憶體空間，所以可以使用迭代器(iterators)來進行存取。 在 vectors 中，元素是被插入在尾端的，插入尾端的時間取決於是否須進行容量的調整。 在 vectors 中，刪除尾端元素的時間複雜度則是固定的\\(O(1)\\)，因為不會發生容量調整。 在 vectors 的前端或中間插入元素或是清除元素，時間的複雜度都是\\(O(n)\\)。  迭代器(Iterators) 1. vec.begin()  回傳指向 vector 中第一個元素的迭代器 (vec[0])  2. vec.end()  回傳指向 vector 中最後一個元素之後一個的迭代器 (vec[n+1])  3. vec.rbegin()  回傳指向 vector 中最後一個元素的反向迭代器 (vec[n])  4. vec.rend()  回傳指向 vector 中第一個元素之前一個的反向迭代器 (vec[-1])  5. vec.cbegin()  回傳指向 vector 中第一個元素的常數迭代器 (vec[0])  6. vec.cend()  回傳指向 vector 中最後一個元素之後一個的常數迭代器 (vec[n+1])  7. vec.crbegin()  回傳指向 vector 中最後一個元素的反向常數迭代器 (vec[n])  8. vec.crend()  回傳指向 vector 中第一個元素之前一個的反向常數迭代器 (vec[-1])  #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std;  int main(){  int arr[] = {1,1,2,3,5,8,13,21,34,55};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n); // initialize with array   cout \u0026lt;\u0026lt; \u0026#34;Output of begin() and end(): \u0026#34;;  for (auto i = vec.begin(); i != vec.end(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;;   cout \u0026lt;\u0026lt; \u0026#34;\\nOutput of rbegin() and rend(): \u0026#34;;  for (auto i = vec.rbegin(); i != vec.rend(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;;   cout \u0026lt;\u0026lt; \u0026#34;\\nOutput of cbegin() and cend(): \u0026#34;;  for (auto i = vec.cbegin(); i != vec.cend(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;;   cout \u0026lt;\u0026lt; \u0026#34;\\nOutput of crbegin() and crend(): \u0026#34;;  for (auto i = vec.crbegin(); i != vec.crend(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;;   return 0; } 結果：\nOutput of begin() and end(): 1 1 2 3 5 8 13 21 34 55 Output of rbegin() and rend(): 55 34 21 13 8 5 3 2 1 1 Output of cbegin() and cend(): 1 1 2 3 5 8 13 21 34 55 Output of crbegin() and crend(): 55 34 21 13 8 5 3 2 1 1 容量(capacity) 1. vec.size()  回傳 vector 的元素數量  2. vec.max_size()  回傳 vector 可以持有的最大元素數量  3. vec.capacity()  回傳 vector 當前被分配到的儲存空間，以元素數目表示  4. vec.empty()  回傳容器是否沒有元素的  5. vec.shrink_to_fit()  將容器的容量縮減到剛好符合它的元素數量，並丟棄所有超出容量的元素  6. vec.resize(int n)  將容器的容量重新調整到 n 個元素的大小  7. vec.reserve(int n)  將容器的容量重新調整到至少可以容納 n 個元素的大小。  #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026#34;print.cc\u0026#34; using namespace std;  int main(){  vector\u0026lt;int\u0026gt; vec;  for (int i = 0; i \u0026lt;= 12; ++i)  vec.push_back(i);  cout \u0026lt;\u0026lt; \u0026#34;Max_size: \u0026#34; \u0026lt;\u0026lt; vec.max_size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;   cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;Initial\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  print(vec);  cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;;   vec.resize(8);  cout \u0026lt;\u0026lt; \u0026#34;After resize(8)\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  print(vec);  cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;;   vec.shrink_to_fit();  cout \u0026lt;\u0026lt; \u0026#34;After fitting\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  print(vec);  cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;;   vec.reserve(20);  cout \u0026lt;\u0026lt; \u0026#34;After reserve(20)\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  print(vec);  cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;;   cout \u0026lt;\u0026lt; \u0026#34;If the vector is empty: \u0026#34;;  vec.empty() ? (cout \u0026lt;\u0026lt; \u0026#34;Empty\u0026#34;) : (cout \u0026lt;\u0026lt; \u0026#34;Not empty\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;   return 0; } 結果：\nMax_size: 4611686018427387903 ================================== Initial Size: 13 Capacity: 16 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] ================================== After resize(8) Size: 8 Capacity: 16 [0, 1, 2, 3, 4, 5, 6, 7] ================================== After fitting Size: 8 Capacity: 8 [0, 1, 2, 3, 4, 5, 6, 7] ================================== After reserve(20) Size: 8 Capacity: 20 [0, 1, 2, 3, 4, 5, 6, 7] ================================== If the vector is empty: Not empty 存取元素(access elements) 1. vec[int n]  回傳 n 指標位置的值  2. at(int n)  回傳 n 指標位置的位  3. front()  回傳第一個元素的值  4. back()  回傳最後一個元素的值  5. data()  回傳一個直接的指標指向 vector 的記憶體位置  #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026#34;print.cc\u0026#34; using namespace std;  int main(){  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n);  print(vec);   cout \u0026lt;\u0026lt; \u0026#34;vec[2]: \u0026#34; \u0026lt;\u0026lt; vec[2] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;vec.at(4): \u0026#34; \u0026lt;\u0026lt; vec.at(4) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;vec.front(): \u0026#34; \u0026lt;\u0026lt; vec.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  cout \u0026lt;\u0026lt; \u0026#34;vec.back(): \u0026#34; \u0026lt;\u0026lt; vec.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;   int* pos = vec.data();   for (int* i = pos; i != pos + vec.size(); i++){  cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  }   return 0; } 結果\n[0, 1, 2, 3, 4, 5, 6, 7] vec[2]: 2 vec.at(4): 4 vec.front(): 0 vec.back(): 7 0 1 2 3 4 5 6 7 修改元素(modify elements) 1. assign(int n, E val)  指派新的值到 vector 中，並取代舊的值  2. push_back(E val)  將新的值加到 vector 的尾端  3. pop_back()  將 vector 的尾端的值取出並移除  4. insert(iterator it, E val)  在 vector 的指定位置加入新的值  5. erase(iterator it)  移除 vector 指定位置的移  6. v1.swap(v2)  交換兩個 vector 的值  7. vec.clear()  清除 vector 的所有值  #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026#34;print.cc\u0026#34; using namespace std;  int main(){ \tvector\u0026lt;int\u0026gt; vec;   cout \u0026lt;\u0026lt; \u0026#34;After assign(5, 10): \\n\u0026#34;; \tvec.assign(5, 10);  print(vec);   cout \u0026lt;\u0026lt; \u0026#34;After push_back(15): \\n\u0026#34;; \tvec.push_back(15);  print(vec); \tint n = vec.size(); \tcout \u0026lt;\u0026lt; \u0026#34;The last element is: \u0026#34; \u0026lt;\u0026lt; vec.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;   cout \u0026lt;\u0026lt; \u0026#34;After pop_back(): \\n\u0026#34;; \tvec.pop_back();  print(vec);   cout \u0026lt;\u0026lt; \u0026#34;After insert(vec.begin(), 5): \\n\u0026#34;; \tvec.insert(vec.begin(), 5);  print(vec);   cout \u0026lt;\u0026lt; \u0026#34;After erase(vec.begin()): \\n\u0026#34;; \tvec.erase(vec.begin());  print(vec);  \tvec.clear(); \tcout \u0026lt;\u0026lt; \u0026#34;Vector size after clear(): \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  \tvector\u0026lt;int\u0026gt; v1, v2; \tv1.push_back(1); \tv1.push_back(2); \tv2.push_back(3); \tv2.push_back(4);  \tcout \u0026lt;\u0026lt; \u0026#34;Vector 1: \u0026#34;; \tprint(v1);  \tcout \u0026lt;\u0026lt; \u0026#34;Vector 2: \u0026#34;; \tprint(v2);  \t// Swaps v1 and v2 \tv1.swap(v2);  \tcout \u0026lt;\u0026lt; \u0026#34;After Swap \\nVector 1: \u0026#34;; \tprint(v1);  \tcout \u0026lt;\u0026lt; \u0026#34;Vector 2: \u0026#34;; \tprint(v2);   return 0; } 結果\nAfter assign(5, 10): [10, 10, 10, 10, 10] After push_back(15): [10, 10, 10, 10, 10, 15] The last element is: 15 After pop_back(): [10, 10, 10, 10, 10] After insert(vec.begin(), 5): [5, 10, 10, 10, 10, 10] After erase(vec.begin()): [10, 10, 10, 10, 10] Vector size after clear(): 0 Vector 1: [1, 2] Vector 2: [3, 4] After Swap Vector 1: [3, 4] Vector 2: [1, 2]  你可能會想繼續閱讀…  回到容器(Containers) list deque arrays forward_list    ","permalink":"http://intervalrain.github.io/posts/c++/stl_vector/","summary":"vector  Vectors 是一動態陣列，可以自動的調整其容器的容量。 Vector 的元素被儲存在連續的記憶體空間，所以可以使用迭代器(iterators)來進行存取。 在 vectors 中，元素是被插入在尾端的，插入尾端的時間取決於是否須進行容量的調整。 在 vectors 中，刪除尾端元素的時間複雜度則是固定的\\(O(1)\\)，因為不會發生容量調整。 在 vectors 的前端或中間插入元素或是清除元素，時間的複雜度都是\\(O(n)\\)。  迭代器(Iterators) 1. vec.begin()  回傳指向 vector 中第一個元素的迭代器 (vec[0])  2. vec.end()  回傳指向 vector 中最後一個元素之後一個的迭代器 (vec[n+1])  3. vec.rbegin()  回傳指向 vector 中最後一個元素的反向迭代器 (vec[n])  4. vec.rend()  回傳指向 vector 中第一個元素之前一個的反向迭代器 (vec[-1])  5. vec.cbegin()  回傳指向 vector 中第一個元素的常數迭代器 (vec[0])  6. vec.cend()  回傳指向 vector 中最後一個元素之後一個的常數迭代器 (vec[n+1])  7. vec.crbegin()  回傳指向 vector 中最後一個元素的反向常數迭代器 (vec[n])  8.","title":"[C++] The C++ Standard Template Library(STL) - Vector"},{"content":"容器(Containers) 序列式容器(Sequence Containers)  特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。  vector list deque arrays forward_list 容器適配器(Container Adaptors)  用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。  queue priority_queue stack 關聯性容器(Associative Containers)  又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。  set multiset map multimap 無序關聯容器(Unordered Associative Containers(C++11))  通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。  unordered_set unordered_multiset unordered_map unordered_mutlimap  你可能會想繼續閱讀…  演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library    ","permalink":"http://intervalrain.github.io/posts/c++/stl_container/","summary":"容器(Containers) 序列式容器(Sequence Containers)  特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。  vector list deque arrays forward_list 容器適配器(Container Adaptors)  用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。  queue priority_queue stack 關聯性容器(Associative Containers)  又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。  set multiset map multimap 無序關聯容器(Unordered Associative Containers(C++11))  通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。  unordered_set unordered_multiset unordered_map unordered_mutlimap  你可能會想繼續閱讀…  演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library    ","title":"[C++] The C++ Standard Template Library(STL) - Container"},{"content":"前言  在做 WAT 量測後的資料處理時，IDAS 老舊的 VBA macro 執行時間實在過於久，且佔用大量的記憶體，於是就下了一個命題，想減少產生報表的時間。  想法  通常量測多片 wafer 的狀況下，不同 wafer 的排列順序是一致的，如果可以加入 Java 中 HashMap 的資料結構來處理 VBA 中 Lookup()，便可大幅減少 summary table 時，對 rawdata 做搜尋的時間。 令時間複雜度從\\(O(n)\\)進步到\\(O(1)\\)。  做法 產生 Dictionary 物件  由於 VBA 預設並沒有 Dictionary 的物，所以需要用 CreateObject(\u0026quot;Scritping.Dictionary\u0026quot;) 的程式碼，引入 Dictionary。 其 Dictionary 物件的 method 可參考 Microsoft 的文件：點此 在此先預先定義一個 function setDict() 可以對初始化 Dictionary。 接著宣告兩個 Dictionary 物件來存取 spec 和 data 工作頁的列數(\u0008row)。  Dim SpecDict As Object \u0026#39; Claim a dict to store spec rows in worksheet SPEC. Dim DataDict As Object \u0026#39; Claim a dict to store rawdata rows in worksheet Data.  Set SpecDict = CreateObject(\u0026#34;Scripting.Dictionary\u0026#34;) Set DataDict = CreateObject(\u0026#34;Scripting.Dictionary\u0026#34;)  Call setDict(\u0026#34;SPEC\u0026#34;, 3, SpecDict, Worksheets(\u0026#34;SPEC\u0026#34;).UsedRange, True) Call setDict(\u0026#34;Data\u0026#34;, 2, DataDict, Range(Worksheets(\u0026#34;Data\u0026#34;).Names(1)), True) 實作 setDict() 函數  利用 HashTable 的概念對不同的 parameter 列數先做一次記錄，因為只需一次迴圈，故時間複雜度是 \\(O(n)\\)，其中 n = SPEC 的列數 或是 量測的 parameter 數。 在此設計了五個 arguments，方便在未來如果還有使用到 Dictionary 的需求時，可以方便使用。  sheetName 字串，需要作儲存的工作頁(worksheet)。 Target 要儲存的列數(row)或欄數(column)。 Dict 要存放的 Dictionary 物件。 mRange 要做儲存的資料範圍，若表頭並是在第一列或第一欄時可指定。  若表頭是第一列或第一欄時，可直接代入 Worksheets(\u0026quot;工作頁名稱\u0026quot;).UsedRange   byRows 看要儲存的對象是列(row)或是欄(column)，預設是以列來搜尋。    Public Function setDict(ByVal sheetName As String, ByVal Target As Integer, ByRef Dict As Object, ByVal mRange As Range, Optional ByVal byRows As Boolean = True)   Dim nowSheet As Worksheet  If Not IsExistSheet(sheetName) Then Exit Function  Set nowSheet = Worksheets(sheetName)   Dim i As Long  Dim n As Long   On Error Resume Next   If byRows = True Then  For i = 1 To mRange.Rows.Count  If Not Trim(mRange.Cells(i, Target).Value) = \u0026#34;\u0026#34; Then  Dict.Add mRange.Cells(i, Target).Value, i  End If  Next i  Else  For i = 1 To mRange.Columns.Count  If Not Trim(mRange.Cells(Target, i).Value) = \u0026#34;\u0026#34; Then  Dict.Add mRange.Cells(Target, i).Value, i  End If  Next i  End If  End Function 對 getSPECByPara() 做重製  將 parameter or SPEC 做 hashing 的處理後，可以用 Dictionary 物件來查值，時間複雜度為 \\(O(1)\\)。 在此不對原本的設計做更動，只做單純的 implement。  nowPara 要搜尋的 parameter 字串。 n 要搜尋的欄數(column)，specColumn是原作者預設的 enum，存放工作頁 SPEC 的每一欄的表頭。 \u0008sheetName 要搜尋的工作頁，預設為 SPECTEMP，是按完 initial，從 SPEC 工作頁複製出來的隱藏工作頁。    Public Function getSPECByPara(ByVal nowPara As String, ByVal n As specColumn, Optional sheetName As String = \u0026#34;SPECTEMP\u0026#34;)   Dim reValue  Dim nowRange As Range  Dim TargetSheet As Worksheet   If Left(nowPara, 1) = \u0026#34;\u0026#39;\u0026#34; Then nowPara = Mid(nowPara, 2)   Set TargetSheet = Worksheets(sheetName)  Set nowRange = TargetSheet.UsedRange  On Error Resume Next  reValue = TargetSheet.Cells(SpecDict(nowPara), n)  If Not IsEmpty(reValue) Then  If Trim(reValue) = \u0026#34;\u0026#34; Then Set reValue = Nothing  End If  getSPECByPara = reValue End Function 對 getRangeByPara() 做重製  將 parameter or SPEC 做 hashing 的處理後，可以用 Dictionary 物件來查值，時間複雜度為 \\(O(1)\\)。  Public Function getRangeByPara(nowWafer As String, nowPara As String, Optional dieNum As Integer = 0)  Dim nowRow As Long  Dim nowRange As Range   Set nowRange = Worksheets(\u0026#34;Data\u0026#34;).Range(\u0026#34;wafer_\u0026#34; \u0026amp; nowWafer)  Set getRangeByPara = Nothing   If DataDict.Exists(nowPara) Then  nowRow = DataDict(nowPara)  Set getRangeByPara = nowRange.Range(N2L(4) \u0026amp; CStr(nowRow) \u0026amp; \u0026#34;:\u0026#34; \u0026amp; N2L(dieNum + 3) \u0026amp; CStr(nowRow))  End If  End Function 解析  優點：較快的執行速度。經測試可以將 2~3 分鐘的執行時間縮短到 30 秒內。 缺點：若修改 rawdata，會發生錯誤。但若針對每一片 wafer 都做 setDict()的話，會浪費太多 memory。  ","permalink":"http://intervalrain.github.io/posts/vba/idas+_record/","summary":"前言  在做 WAT 量測後的資料處理時，IDAS 老舊的 VBA macro 執行時間實在過於久，且佔用大量的記憶體，於是就下了一個命題，想減少產生報表的時間。  想法  通常量測多片 wafer 的狀況下，不同 wafer 的排列順序是一致的，如果可以加入 Java 中 HashMap 的資料結構來處理 VBA 中 Lookup()，便可大幅減少 summary table 時，對 rawdata 做搜尋的時間。 令時間複雜度從\\(O(n)\\)進步到\\(O(1)\\)。  做法 產生 Dictionary 物件  由於 VBA 預設並沒有 Dictionary 的物，所以需要用 CreateObject(\u0026quot;Scritping.Dictionary\u0026quot;) 的程式碼，引入 Dictionary。 其 Dictionary 物件的 method 可參考 Microsoft 的文件：點此 在此先預先定義一個 function setDict() 可以對初始化 Dictionary。 接著宣告兩個 Dictionary 物件來存取 spec 和 data 工作頁的列數(\u0008row)。  Dim SpecDict As Object \u0026#39; Claim a dict to store spec rows in worksheet SPEC.","title":"[IDAS+] Optimize Summary Table Function"},{"content":"cout Functions 設定顯示小數點位數  setprecision(int n) and fixed  #include \u0026lt;iostream\u0026gt;#include \u0026lt;iomanip\u0026gt; using namespace std;  int main(){   double a = 5.43/2.653;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.04674  cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; fixed;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.047   return 0; } 顯示 Boolean 值  std::boolalpha  #include \u0026lt;iostream\u0026gt; using namespace std;  int main(){   bool a = true;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 1  cout \u0026lt;\u0026lt; std::boolalpha;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // true   return 0; } ","permalink":"http://intervalrain.github.io/posts/c++/cout/","summary":"cout Functions 設定顯示小數點位數  setprecision(int n) and fixed  #include \u0026lt;iostream\u0026gt;#include \u0026lt;iomanip\u0026gt; using namespace std;  int main(){   double a = 5.43/2.653;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.04674  cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; fixed;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.047   return 0; } 顯示 Boolean 值  std::boolalpha  #include \u0026lt;iostream\u0026gt; using namespace std;  int main(){   bool a = true;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 1  cout \u0026lt;\u0026lt; std::boolalpha;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // true   return 0; } ","title":"[C++] Cout functions"},{"content":"演算法(Algorithms) Non-Manupulating Algorithms 1. sort()  sort(first_iterator, last_iterator) 對 vector 作排序  2. reverse()  reverse(first_iterator, last_iterator) 反轉 vector 的排序  3. *max_element()  *max_element(first_iterator, last_iterator) 找出 vector 的最大值  4. *min_element()  *min_element(first_iterator, last_iterator)` 找出 vector 的最小值  5. accumulate  accumulate(first_iterator, last_iterator, initial value of sum) 計算 vector 的總和  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;numeric\u0026gt; using namespace std;  void print(vector\u0026lt;int\u0026gt;\u0026amp; vec){  for (vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it != vec.end(); it++){  cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  }  cout \u0026lt;\u0026lt; endl; }  int main(){  int arr[] = {10, 20, 5, 23, 42, 15};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n);   // print initial vector  print(vec); // [10, 20, 5, 23, 42, 15]   // sort  sort(vec.begin(), vec.end()); // [5, 10, 15, 20, 23, 42]  print(vec);   // reverse  reverse(vec.begin(), vec.end()); // [42, 23, 20, 15, 10, 5]  print(vec);   // max \u0026amp; min  cout \u0026lt;\u0026lt; *max_element(vec.begin(), vec.end()) \u0026lt;\u0026lt; endl; // 42  cout \u0026lt;\u0026lt; *min_element(vec.begin(), vec.end()) \u0026lt;\u0026lt; endl; // 5   // accumulate  cout \u0026lt;\u0026lt; accumulate(vec.begin(), vec.end(), 0) \u0026lt;\u0026lt; endl; // 115   return 0; } 6. count()  count(first_iterator, last_iterator, x) 計算 vector 中 x 的數量  7. find()  find(fist_iterator, last_iterator, x) 回傳 vector 中第一個符合的 iterator，若無則傳回 v.end()。  #include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main() { \tint arr[] = {10, 20, 5, 23 ,42, 20, 15}; \tint n = sizeof(arr)/sizeof(arr[0]); \tvector\u0026lt;int\u0026gt; vec(arr, arr + n); \tcout \u0026lt;\u0026lt; count(vec.begin(), vec.end(), 20); // 2  \tfind(vec.begin(), vec.end(),5) != vec.end() ? // Element found \tcout \u0026lt;\u0026lt; \u0026#34;\\nElement found\u0026#34;: \tcout \u0026lt;\u0026lt; \u0026#34;\\nElement not found\u0026#34;;  \treturn 0; } x\n8. binary_search()  binary_search(first_iterator, last_iterator, x) 測試 x 是否存在已排序的 vector 中  9. lower_bound()  lower_bound(first_iterator, last_iterator, x) 傳回指向不小於 x 的元素的 iterator  10. upper_bound()  upper_bound(first_iterator, last_iterator, x) 傳回指向大於 x 的元素的 iterator  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main(){  int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n);  sort(vec.begin(), vec.end());   cout \u0026lt;\u0026lt; binary_search(vec.begin(), vec.end(), 20) \u0026lt;\u0026lt; endl; // 1  cout \u0026lt;\u0026lt; (lower_bound(vec.begin(), vec.end(), 20) - vec.begin()) \u0026lt;\u0026lt; endl; // 3  cout \u0026lt;\u0026lt; (upper_bound(vec.begin(), vec.end(), 20) - vec.begin()) \u0026lt;\u0026lt; endl; // 5   return 0; } Manipulating Algorithms 1. vec.erase()  arr.erase(position_to_be_deleted) 移除指定位置的元素  2. vec.erase(unique())  arr.erase(unique(arr.begin(), arr.end()), arr.end()) 移除已排序的 vector 中重複的元素  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main(){  int arr[] = {5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n); // [5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20]   vec.erase(vec.begin() + 1); // [5, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20]  sort(vec.begin(), vec.end()); // [5, 15, 20, 20, 20, 20, 20, 20, 20, 23, 42, 45]  vec.erase(unique(vec.begin(), vec.end()), vec.end()); // [5, 15, 20, 23, 42, 45]   return 0; } 3. next_permutation()  next_permutation(first_iterator, last_iterator) 對 vector 作動成下一個字典排序  4. prev_permutation()  prev_permutation(first_iterator, last_iterator) 對 vector 作動成上一個字典排序  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main(){  int arr[] = {1,2,3,4,5,6,7};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n); // [1,2,3,4,5,6,7]   next_permutation(vec.begin(), vec.end()); // [1,2,3,4,5,7,6]  next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,5,7]  next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5]  next_permutation(vec.begin(), vec.end()); // [1,2,3,4,7,5,6]  prev_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5]   return 0; } 5. distance()  distance(first_iterator, last_iterator)  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026#34;print.cc\u0026#34; using namespace std;  int main(){  int arr[] = {5\u0008,10,15,20,20,23,42,45};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n);   cout \u0026lt;\u0026lt; distance(vec.begin(), max_element(vec.begin(), vec.end())) \u0026lt;\u0026lt; endl; // 7  // == max_element(vec.begin(), vec.end()) - vec.begin();   return 0; } Array algorithms 1. any_of()  any_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否有任何元素滿足條件  2. all_of()  all(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否有全部元素滿足條件  3 none_of()  none_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否沒有元素滿足條件  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std;  int main(){  vector\u0026lt;int\u0026gt; vec1 {1,3,7,9,11,17,23};  all_of(vec1.begin(), vec1.end(), [](int x) { return (x \u0026amp; 1) == 1;}) ? cout \u0026lt;\u0026lt; \u0026#34;All odds\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;Not all odds\\n\u0026#34;;   vector\u0026lt;int\u0026gt; vec2 {1,3,6,8,9,11,13};  any_of(vec2.begin(), vec2.end(), [](int x) { return (x \u0026amp; 1) == 0;}) ? cout \u0026lt;\u0026lt; \u0026#34;There are at least one even\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;There are no any even\\n\u0026#34;;   none_of(vec1.begin(), vec1.end(), [](int x) { return (x \u0026amp; 1) == 0;}) ? cout \u0026lt;\u0026lt; \u0026#34;There are no any even\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;There are at least one even\\n\u0026#34;;   return 0; } 4. copy_n()  copy_n(source_array, array_size, target_array) 複製陣列  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std;  int main(){  int arr[] = {1,2,3,4,5,6};  int arr2[6];   copy_n(arr, 6, arr2);   for (int i : arr2){  cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  }   return 0; } 5. iota()  iota(array_name, array_size, starting_number) 逐一增加並寫入指定大小的陣列  // C++ code to demonstrate working of iota() #include\u0026lt;iostream\u0026gt;#include\u0026lt;numeric\u0026gt; // for iota()using namespace std; int main(){ \t// Initializing array with 0 values \tint ar[6] = {0};  \t// Using iota() to assign values \tiota(ar, ar+6, 20);  \t// Displaying the new array \tcout \u0026lt;\u0026lt; \u0026#34;The new array after assigning values is : \u0026#34;; \tfor (int i=0; i\u0026lt;6 ; i++) \tcout \u0026lt;\u0026lt; ar[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  \treturn 0;  } Partition operations  C++ 在標準模板資料庫(STL)中有一個 class 可以來做 partition 的演算法。 Partition 就是用來將容器裡面的元素依指定的條件做分隔。  1. partition()  partition(begin, end, conditon) 依照指定條件做分隔。  2. is_partition()  is_partitioned(begin, end, condition 判斷元素是否依照條件分開。  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main(){  vector\u0026lt;int\u0026gt; vec = {2,1,5,6,8,7};   is_partitioned(vec.begin(), vec.end(), [](int x){  return x % 2 == 0;  }) ?  cout \u0026lt;\u0026lt; \u0026#34;Vector is partitioned\u0026#34;:  cout \u0026lt;\u0026lt; \u0026#34;Vector is not partitioned\u0026#34;;  cout \u0026lt;\u0026lt; endl;   partition(vec.begin(), vec.end(), [](int x){  return x % 2 == 0;  }) ?   cout \u0026lt;\u0026lt; \u0026#34;The partitioned vector is : \u0026#34;;  for (int \u0026amp;x : vec) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;;   return 0; } 3. stable_partition()  stable_partition(begin, end, condition) This function is used to partition the elements on basis of condition mentioned in its arguments in such a way that the relative order of the elements is preserved..  partition_point()   partition_point(begin, end, condition) This function returns an iterator pointing to the partition point of container i.e. the first element in the partitioned range [beg,end) for which condition is not true. The container should already be partitioned for this function to work.  // C++ code to demonstrate the working of // stable_partition() and partition_point() #include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt; // for partition algorithm#include\u0026lt;vector\u0026gt; // for vectorusing namespace std; int main() { \t// Initializing vector \tvector\u0026lt;int\u0026gt; vect = { 2, 1, 5, 6, 8, 7 }; \t\t// partitioning vector using stable_partition() \t// in sorted order \tstable_partition(vect.begin(), vect.end(), [](int x) \t{ \treturn x%2 == 0;\t\t}); \t\t// Displaying partitioned Vector \tcout \u0026lt;\u0026lt; \u0026#34;The partitioned vector is : \u0026#34;; \tfor (int \u0026amp;x : vect) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl; \t\t// Declaring iterator \tvector\u0026lt;int\u0026gt;::iterator it1; \t\t// using partition_point() to get ending position of partition \tauto it = partition_point(vect.begin(), vect.end(), [](int x) \t{ \treturn x%2==0; \t}); \t\t// Displaying partitioned Vector \tcout \u0026lt;\u0026lt; \u0026#34;The vector elements returning true for condition are : \u0026#34;; \tfor ( it1= vect.begin(); it1!=it; it1++) \tcout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl; \t\treturn 0; \t} partition_copy(begin, end, begin1, begin2, condition): This function copies the partitioned elements in the different containers mentioned in its arguments. It takes 5 arguments. Beginning and ending position of container, beginning position of new container where elements have to be copied (elements returning true for condition), beginning position of new container where other elements have to be copied (elements returning false for condition) and the condition. Resizing new containers is necessary for this function.  // C++ code to demonstrate the working of // partition_copy() #include\u0026lt;iostream\u0026gt;#include\u0026lt;algorithm\u0026gt; // for partition algorithm#include\u0026lt;vector\u0026gt; // for vectorusing namespace std; int main() { \t// Initializing vector \tvector\u0026lt;int\u0026gt; vect = { 2, 1, 5, 6, 8, 7 }; \t\t// Declaring vector1 \tvector\u0026lt;int\u0026gt; vect1; \t\t// Declaring vector1 \tvector\u0026lt;int\u0026gt; vect2; \t\t// Resizing vectors to suitable size using count_if() and resize() \tint n = count_if (vect.begin(), vect.end(), [](int x) \t{ \treturn x%2==0; \t\t} ); \tvect1.resize(n); \tvect2.resize(vect.size()-n); \t\t// Using partition_copy() to copy partitions \tpartition_copy(vect.begin(), vect.end(), vect1.begin(), \tvect2.begin(), [](int x) \t{ \treturn x%2==0; \t}); \t\t\t// Displaying partitioned Vector \tcout \u0026lt;\u0026lt; \u0026#34;The elements that return true for condition are : \u0026#34;; \tfor (int \u0026amp;x : vect1) \tcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl; \t\t// Displaying partitioned Vector \tcout \u0026lt;\u0026lt; \u0026#34;The elements that return false for condition are : \u0026#34;; \tfor (int \u0026amp;x : vect2) \tcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl; \t\treturn 0; } Numeric algorithms 1. apply()  apply([](int x){return operation;}) 對陣列所有元素做運算  2. arr.sum()  arr.sum() 計算陣列所有元素的總合  // C++ code to demonstrate the working of // apply() and sum() #include\u0026lt;iostream\u0026gt;#include\u0026lt;valarray\u0026gt; // for valarray functionsusing namespace std; int main() { \t// Initializing valarray \tvalarray\u0026lt;int\u0026gt; varr = { 10, 2, 20, 1, 30 }; \t\t// Declaring new valarray \tvalarray\u0026lt;int\u0026gt; varr1 ; \t\t// Using apply() to increment all elements by 5 \tvarr1 = varr.apply([](int x){return x=x+5;}); \t\t// Displaying new elements value \tcout \u0026lt;\u0026lt; \u0026#34;The new valarray with manipulated values is : \u0026#34;; \tfor (int \u0026amp;x: varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl; \t\t// Displaying sum of both old and new valarray \tcout \u0026lt;\u0026lt; \u0026#34;The sum of old valarray is : \u0026#34;; \tcout \u0026lt;\u0026lt; varr.sum() \u0026lt;\u0026lt; endl; \tcout \u0026lt;\u0026lt; \u0026#34;The sum of new valarray is : \u0026#34;; \tcout \u0026lt;\u0026lt; varr1.sum() \u0026lt;\u0026lt; endl;  \treturn 0; \t} 3. arr.min()  arr.min() 傳回陣列中最小的元素  4. arr.max()  arr.max() 傳回陣列中最大的元素  // C++ code to demonstrate the working of // max() and min() #include\u0026lt;iostream\u0026gt;#include\u0026lt;valarray\u0026gt; // for valarray functionsusing namespace std; int main() { \t// Initializing valarray \tvalarray\u0026lt;int\u0026gt; varr = { 10, 2, 20, 1, 30 }; \t\t// Displaying largest element of valarray \tcout \u0026lt;\u0026lt; \u0026#34;The largest element of valarray is : \u0026#34;; \tcout \u0026lt;\u0026lt; varr.max() \u0026lt;\u0026lt; endl; \t\t// Displaying smallest element of valarray \tcout \u0026lt;\u0026lt; \u0026#34;The smallest element of valarray is : \u0026#34;; \tcout \u0026lt;\u0026lt; varr.min() \u0026lt;\u0026lt; endl;  \treturn 0; \t} 5. arr.shift()  \u0008arr.shift(int n) 對陣列做 n 個位的移動，正為向右移，負為向左移，缺位補零。  6. cshift()  arr.cshift(int n) 對陣列做 n 個位的移動，正為向右移，負為向左移，缺位使用循環補位。  // C++ code to demonstrate the working of // shift() and cshift() #include\u0026lt;iostream\u0026gt;#include\u0026lt;valarray\u0026gt; // for valarray functionsusing namespace std; int main() { \t// Initializing valarray \tvalarray\u0026lt;int\u0026gt; varr = { 10, 2, 20, 1, 30 }; \t\t// Declaring new valarray \tvalarray\u0026lt;int\u0026gt; varr1; \t\t// using shift() to shift elements to left \t// shifts valarray by 2 position \tvarr1 = varr.shift(2); \t\t// Displaying elements of valarray after shifting \tcout \u0026lt;\u0026lt; \u0026#34;The new valarray after shifting is : \u0026#34;; \tfor ( int\u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl; \t\t// using cshift() to circulary shift elements to right \t// rotates valarray by 3 position \tvarr1 = varr.cshift(-3); \t\t// Displaying elements of valarray after circular shifting \tcout \u0026lt;\u0026lt; \u0026#34;The new valarray after circular shifting is : \u0026#34;; \tfor ( int\u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl;  \treturn 0; \t} 7. arr1.swap(arr2)  arr1.swap(arr2) 陣列做交換  // C++ code to demonstrate the working of // swap() #include\u0026lt;iostream\u0026gt;#include\u0026lt;valarray\u0026gt; // for valarray functionsusing namespace std; int main(){ // Initializing 1st valarray \tvalarray\u0026lt;int\u0026gt; varr1 = {1, 2, 3, 4}; \t\t// Initializing 2nd valarray \tvalarray\u0026lt;int\u0026gt; varr2 = {2, 4, 6, 8}; \t\t// Displaying valarrays before swapping \tcout \u0026lt;\u0026lt; \u0026#34;The contents of 1st valarray \u0026#34; \t\u0026#34;before swapping are : \u0026#34;; \tfor (int \u0026amp;x : varr1) \tcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl; \tcout \u0026lt;\u0026lt; \u0026#34;The contents of 2nd valarray \u0026#34; \t\u0026#34;before swapping are : \u0026#34;; \tfor (int \u0026amp;x : varr2) \tcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl; \t\t// Use of swap() to swap the valarrays \tvarr1.swap(varr2); \t\t// Displaying valarrays after swapping \tcout \u0026lt;\u0026lt; \u0026#34;The contents of 1st valarray \u0026#34; \t\u0026#34;after swapping are : \u0026#34;; \tfor (int \u0026amp;x : varr1) \tcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl; \t\tcout \u0026lt;\u0026lt; \u0026#34;The contents of 2nd valarray \u0026#34; \t\u0026#34;after swapping are : \u0026#34;; \tfor (int \u0026amp;x : varr2) \tcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; \tcout \u0026lt;\u0026lt; endl;  \treturn 0;\t}  你可能會想繼續閱讀…  容器(Containers) 函式(Functions) 迭代器(Iterators) Utility Library    ","permalink":"http://intervalrain.github.io/posts/c++/stl_algo/","summary":"演算法(Algorithms) Non-Manupulating Algorithms 1. sort()  sort(first_iterator, last_iterator) 對 vector 作排序  2. reverse()  reverse(first_iterator, last_iterator) 反轉 vector 的排序  3. *max_element()  *max_element(first_iterator, last_iterator) 找出 vector 的最大值  4. *min_element()  *min_element(first_iterator, last_iterator)` 找出 vector 的最小值  5. accumulate  accumulate(first_iterator, last_iterator, initial value of sum) 計算 vector 的總和  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;numeric\u0026gt; using namespace std;  void print(vector\u0026lt;int\u0026gt;\u0026amp; vec){  for (vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it !","title":"[C++] The C++ Standard Template Library(STL) - Algorithm"},{"content":"STL  \u0008標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。\nSTL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。\n STL 的四大組成  演算法(Algorithms) 容器(Containers) 函式(Functions) 迭代器(Iterators)  補充  Utility Library  ","permalink":"http://intervalrain.github.io/posts/c++/stl/","summary":"STL  \u0008標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。\nSTL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。\n STL 的四大組成  演算法(Algorithms) 容器(Containers) 函式(Functions) 迭代器(Iterators)  補充  Utility Library  ","title":"[C++] The C++ Standard Template Library(STL)"},{"content":"vector 的介紹  vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include \u0026lt;vector\u0026gt;  vector 的使用 建構式 constructor vector\u0026lt;int\u0026gt; v1; // 不進行初始化 vector\u0026lt;int\u0026gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector\u0026lt;int\u0026gt; v3(v2); // 利用vector初始化 vector\u0026lt;int\u0026gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector\u0026lt;int\u0026gt; v5(3, 0); // 含有3個0的vector  談一下特殊的二維vector，其實就是二維矩陣，寫法為  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vv(3, vector\u0026lt;int\u0026gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse  遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。  vector\u0026lt;int\u0026gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3};  // 1. iterator vector\u0026lt;int\u0026gt;::iterator it = v.begin(); while (it != v.end()){  cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  it++; } cout \u0026lt;\u0026lt; endl;  // 2. for loop for (int e : v){  cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; }  // 3. [] for (size_t i = 0; i \u0026lt; v.size(); ++i){  cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } 資料的資刪查改 \\( \\def\\arraystrecth{1.4}\\begin{array}{|l|l|}\\hline \\text{methods}\u0026amp;\\text{description}\\\\\\hline\\hline \\text{push\\_back}\u0026amp;\\text{Add element at the end}\\\\\\hline \\text{pop\\_back}\u0026amp;\\text{Delete last element}\\\\\\hline \\text{insert}\u0026amp;\\text{Insert elements}\\\\\\hline \\text{erase}\u0026amp;\\text{Erase elements}\\\\\\hline \\end{array} \\)\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main(){  vector\u0026lt;int\u0026gt; vec;  vec.push_back(0); [0]  vec.push_back(1); [0,1]  vec.push_back(3); [0,1,3]  vec.push_back(4); [0,1,3,4]  vec.pop_back(); [0,1,3]  vector\u0026lt;int\u0026gt;::iterator it = vec.begin();  vec.insert(it + 2, 2); // 在下標為1的位置，插入2 [0,1,2,3]  vec.erase(it); [1,2,3]   return 0; } resize 和 reserve int main(){  cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 0  cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 0  v.resize(30);  cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30  cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30  v.reservse(50);  cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30  cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 50 } vector 的實作 member variables template \u0026lt;class T\u0026gt; class myVector{ private:  size_t _size; // 儲存現有 elements 的數目  size_t _capacity; // 此時陣列所有的最大容量 public:  T* arr; // 儲存 elements 的陣列指標 }; 建構式 constructor public:  // 無引數的初始化  myVector(){  this-\u0026gt;_size = 0;  this-\u0026gt;_capacity = DEFAULT_CAPACITY;  this-\u0026gt;arr = new int[this-\u0026gt;_capacity];  }   // 指定容量的初始化  myVector(int capacity){  this-\u0026gt;_size = 0;  this-\u0026gt;_capacity = capacity;  this-\u0026gt;arr = new int[this-\u0026gt;capacity];  }   // 以另一個 myVector 初始化  myVector(const myVector\u0026lt;T\u0026gt;\u0026amp; v):  _size(v.size),  _capacity(v._capacity)  {  this-\u0026gt;reserve(v.capacity);  for (size_t i = 0; i \u0026lt; v._size; ++i){  this-\u0026gt;push_back(v[i]);  }  }   // 填滿 n 個 val 的初始化  myVector(size_t n, T val):  _size(n),  _capacity(n)  {  this-\u0026gt;arr = new int[this-\u0026gt;_capacity];  for (size_t i = 0; i \u0026lt; n; ++i){  this-\u0026gt;arr[i] = val;  }  } 解構式 destructor public:  ~myVector(){  // 將原有的陣列丟棄  delete[] this-\u0026gt;arr;  } 運算子多載 operator overload public:  // 令 myVector 可讀可寫  T\u0026amp; operator[](size_t i){  assert (i \u0026lt; this-\u0026gt;_size);  return this-\u0026gt;arr[i];  } 函式 Methods public:  // 回傳 vector 元素的數目  size_t size(){  return this-\u0026gt;_size;  }   // 回傳當前 vector 的容量  size_t capacity(){  return this-\u0026gt;_capacity;  }   // 回傳指向陣列的下標 0 位置  T* begin(){  return this-\u0026gt;arr;  }   // 回傳指向陣列的最末位 + 1  T* end(){  return this-\u0026gt;arr + this-\u0026gt;_size;  }   const T* begin() const{  return this-\u0026gt;arr;  }   const T* end() const{  return this-\u0026gt;arr + this-\u0026gt;_size;  }   // 回傳此 myVector 是否含有元素  bool isEmpty(){  return this-\u0026gt;_size == 0;  } reserve 和 resize public:  // force to resize with a n capacity  void reserve(size_t n){  if (n \u0026gt; this-\u0026gt;_capacity){  T* tmp = new T[n];  if (arr != nullptr){  for (size_t i = 0; i \u0026lt; this-\u0026gt;_size; ++i){  tmp[i] = this-\u0026gt;arr[i];  }  delete[] this-\u0026gt;arr;  }  this-\u0026gt;arr = tmp;  _capacity = n;  }  }   // expand the capacity while adding elements  void resize(){  this-\u0026gt;_capacity *= 2;  int* tmp = new int[this-\u0026gt;_capacity];  for (size_t i = 0; i \u0026lt; this-\u0026gt;_size; ++i){  tmp[i] = this-\u0026gt;arr[i];  }  delete[] this-\u0026gt;arr;  this-\u0026gt;arr = tmp;  } 資料的增刪查改 public:   // adding elements in the last of vector  void push_back(T val){  if (this-\u0026gt;_capacity \u0026lt; this-\u0026gt;_size + 1)  resize();  this-\u0026gt;arr[this-\u0026gt;_size] = val;  this-\u0026gt;_size++;  }   // remove elements in the last of vector  T pop_back(){  assert(!this-\u0026gt;isEmpty());  T tmp = *(this-\u0026gt;end()-1);  this-\u0026gt;_size--;  return tmp;  }   // insert element by the index.  void insert(size_t i, T val){  assert (i \u0026lt;= this-\u0026gt;_size);  if (this-\u0026gt;_size + 1 \u0026gt; this-\u0026gt;capacity()) resize();  int* ptr = this-\u0026gt;begin() + i;  for (int* it = this-\u0026gt;end(); it != ptr; --it)  *it = *(it - 1);  *ptr = val;  this-\u0026gt;_size++;  }   //erase element by the index  T erase(size_t i){  assert(i \u0026lt; this-\u0026gt;_size);  int* it = this-\u0026gt;begin() + i;  T tmp = *it;  for (; it != this-\u0026gt;end(); ++it){  *it = *(it + 1);  }  this-\u0026gt;_size--;  return tmp;  } Reference: 有解無憂 UJ5U.com\n","permalink":"http://intervalrain.github.io/posts/c++/vector/","summary":"vector 的介紹  vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include \u0026lt;vector\u0026gt;  vector 的使用 建構式 constructor vector\u0026lt;int\u0026gt; v1; // 不進行初始化 vector\u0026lt;int\u0026gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector\u0026lt;int\u0026gt; v3(v2); // 利用vector初始化 vector\u0026lt;int\u0026gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector\u0026lt;int\u0026gt; v5(3, 0); // 含有3個0的vector  談一下特殊的二維vector，其實就是二維矩陣，寫法為  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vv(3, vector\u0026lt;int\u0026gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse  遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。  vector\u0026lt;int\u0026gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3};  // 1.","title":"[C++] STL: Vector 的使用與實作"},{"content":"TCAD 常用的三種程式語言 工具語言  用於操作 Sentaurus 工具的指令，例如：  snmesh sdevice    預處理語言  Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro)  例如：  #define __x__ 1 // 將所有 __x__ 字串取代成字串 1   TCL  公用語言，通常用來處理字串與數據。  範例  SPP 語言：@...@、#開頭的敘述都是 SPP 語言  #if \u0026#34;@tunneling@ == \u0026#34;Hurkx\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1_5\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E2\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif  TCL 語言：set 與 puts  其中 @\u0026hellip;@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 .cmd 檔。    set A [expr -@BF_Thick@-@AB_Thick@-@GR_Thick@-@CH_Thick@-@ML_Thick@] puts \u0026#34;DOE: Xmin [format %.2f $A]\u0026#34; ","permalink":"http://intervalrain.github.io/posts/device/tcad/","summary":"TCAD 常用的三種程式語言 工具語言  用於操作 Sentaurus 工具的指令，例如：  snmesh sdevice    預處理語言  Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro)  例如：  #define __x__ 1 // 將所有 __x__ 字串取代成字串 1   TCL  公用語言，通常用來處理字串與數據。  範例  SPP 語言：@...@、#開頭的敘述都是 SPP 語言  #if \u0026#34;@tunneling@ == \u0026#34;Hurkx\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1_5\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E2\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif  TCL 語言：set 與 puts  其中 @\u0026hellip;@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 .","title":"[TCAD] 工具語言"},{"content":"計算機的抽象化與科技 電腦的定義  一種可以進行計算的裝置，特指可編程(programmable) 且可執行高速的數學或邏輯的運算，或可收集、儲存、處理資料的電子器械。  一般用途 or 特別用途 可編程 or 不可編程 科學用 or 商務 機械械 or 電子式 or 電機 \u0026hellip;  Instruction 與 data 分開儲存的結構稱為 哈佛架構Harvard Architecture\u0008      電腦的歷史  ENIAC (Electronic Numberical Integrator and Calculator)  1943 - 1946 at the University of Pennsylvania 約 25 公尺長、2.5 公尺高 由真空管製成: 耗能、易燒壞KJKKI 1900個加法/每秒   商業化、電晶體的發現 in 1947 使用電晶體的電腦 (IBM 14001, Big Blue) in 1959 IC(Integrated Circuit) in 1958 at 德儀 微處理器(Intel 4004) in 1971 Apple II in 1977 個人電腦(IBM PC) in 1981 IBM 開放式系統(open system)使得周邊設備大量的發展  Xerox PARC Alto: 具備滑鼠、以太網路、點陣圖、按鍵、菜單、WYSIWYG編輯器 區域網路 雷射列印 client / server 分散式計算   應用程式  VisiCalc for Applie II in 1979   超大型積體電路 VLSI(Very-Large-Scale Integration) RISC(Reduced Instruction Set Computer) 的出現，對應於 CISC(Complex Instruction Set Computer)  RISC: MIPS CISC: Intel x86 processor   Post PC Era: Embedded Computer  冰箱、手機、手錶…    電腦的發展  應用  行動電腦 手機 人類基因體計畫 世界網路 搜尋引擎   摩爾定律 Moore\u0026rsquo;s Law  Line Width/Feature Size: 電晶體的 Source 與 Drain 的距離，約是 gate length。     電腦的分類  通用電腦  特性：  軟體相容性 產品生命週期短 更好的效能(more transistors)與人機介面   個人電腦 Personal Computers  一般用途、軟體多樣性 取決於成本與效能的權衡   伺服器電腦 Server Computers  基於網路的 高容量、效能、可靠度 範圍可小至伺服，大至建築   超級電腦 Supercomputers  高端的科學與工程計算 最高的效能，但小的市佔     特殊用途電腦  特性：  通常沒有浮點數、記憶體管理 會與各種功能的外部裝置(peripherals)協作 e.g. DSP  多元的 ISA、效能、外部裝置 較不需考量相容性(通常是 pre-determined program)，ISA更簡單、低功耗   更多元的結構、生命週期更長 高產低銷 (Large volume sale and low price) 趨勢：低成本、更多功  SoC(system-on-chip)、micro P core on ASIC     嵌入式電腦 Embedded Computers  隱身在系統中 嚴格的功耗、效能、成本考量        ","permalink":"http://intervalrain.github.io/posts/ca/lec1/","summary":"計算機的抽象化與科技 電腦的定義  一種可以進行計算的裝置，特指可編程(programmable) 且可執行高速的數學或邏輯的運算，或可收集、儲存、處理資料的電子器械。  一般用途 or 特別用途 可編程 or 不可編程 科學用 or 商務 機械械 or 電子式 or 電機 \u0026hellip;  Instruction 與 data 分開儲存的結構稱為 哈佛架構Harvard Architecture\u0008      電腦的歷史  ENIAC (Electronic Numberical Integrator and Calculator)  1943 - 1946 at the University of Pennsylvania 約 25 公尺長、2.5 公尺高 由真空管製成: 耗能、易燒壞KJKKI 1900個加法/每秒   商業化、電晶體的發現 in 1947 使用電晶體的電腦 (IBM 14001, Big Blue) in 1959 IC(Integrated Circuit) in 1958 at 德儀 微處理器(Intel 4004) in 1971 Apple II in 1977 個人電腦(IBM PC) in 1981 IBM 開放式系統(open system)使得周邊設備大量的發展  Xerox PARC Alto: 具備滑鼠、以太網路、點陣圖、按鍵、菜單、WYSIWYG編輯器 區域網路 雷射列印 client / server 分散式計算   應用程式  VisiCalc for Applie II in 1979   超大型積體電路 VLSI(Very-Large-Scale Integration) RISC(Reduced Instruction Set Computer) 的出現，對應於 CISC(Complex Instruction Set Computer)  RISC: MIPS CISC: Intel x86 processor   Post PC Era: Embedded Computer  冰箱、手機、手錶…    電腦的發展  應用  行動電腦 手機 人類基因體計畫 世界網路 搜尋引擎   摩爾定律 Moore\u0026rsquo;s Law  Line Width/Feature Size: 電晶體的 Source 與 Drain 的距離，約是 gate length。     電腦的分類  通用電腦  特性：  軟體相容性 產品生命週期短 更好的效能(more transistors)與人機介面   個人電腦 Personal Computers  一般用途、軟體多樣性 取決於成本與效能的權衡   伺服器電腦 Server Computers  基於網路的 高容量、效能、可靠度 範圍可小至伺服，大至建築   超級電腦 Supercomputers  高端的科學與工程計算 最高的效能，但小的市佔     特殊用途電腦  特性：  通常沒有浮點數、記憶體管理 會與各種功能的外部裝置(peripherals)協作 e.","title":"[CA] Lec 1 - Computer Abstraction and Technology"},{"content":"計算機結構簡介 二進制  從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。  現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。   電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機  計算機結構/組織  計算機結構 Computer Architecture  處理器(processor)  Control Datapath   記憶體(memory) 裝置(Devices)  Input: 鍵盤、滑鼠、磁碟 Output: 磁碟、顯示器、影印機      計算機組織 Computer Organization(架構)  功能元件的性能: registers, ALU, shifters Structure Dataflow Control logic Register Transfer Level(RTL) description     計算機結構  Computer Architecture = Instruction Set Architecture(ISA) + Machine Organization Software 與 Hardware 間的 interface。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。  選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置   指令集Instruction Set Architecture(ISA)  可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) Instruction Set Instruction Formats 讀寫資料的模式與指令 例外狀況 e.g. Intel(CISC)、Arm(RISC)  CISC: Complex Instruction Set Computer RISC: Reduced Instruction Set Computer        [目錄]  Chapter 1. Computer Abstractions and Technology Chapter 2. Instruction Set Architecture Chapter 3. Computer Arithmetic Chapter 4. Designing a Single-Cycle Processor Chapter 5. Pipelining Chapter 6. Memory Hierarchy  ","permalink":"http://intervalrain.github.io/posts/ca/lec0/","summary":"計算機結構簡介 二進制  從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。  現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。   電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機  計算機結構/組織  計算機結構 Computer Architecture  處理器(processor)  Control Datapath   記憶體(memory) 裝置(Devices)  Input: 鍵盤、滑鼠、磁碟 Output: 磁碟、顯示器、影印機      計算機組織 Computer Organization(架構)  功能元件的性能: registers, ALU, shifters Structure Dataflow Control logic Register Transfer Level(RTL) description     計算機結構  Computer Architecture = Instruction Set Architecture(ISA) + Machine Organization Software 與 Hardware 間的 interface。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。  選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置   指令集Instruction Set Architecture(ISA)  可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) Instruction Set Instruction Formats 讀寫資料的模式與指令 例外狀況 e.","title":"[CA] Lec 0 - Introduction to Computer Architecture"},{"content":"題目 題目描述  設計一個類似 stack 的資料結構，實行 push() 跟 pop() 的功能，其中 pop() 會丟出 stack 中出現最多次的元素。 FreqStack class 必須實現：  FreqStack() 建構子必須初始化一個空的 FreqStack。 void push(int val) 將 val 推至 stack 的頂端。 int pop() 將 stack 中最頻繁出現的元素移除，並返回。  如果 stack 中最頻繁出現的元素出現平手的狀況，則返回平手的元素中最接近 stack 頂端的元素。      題目範例 輸入\n[\u0026ldquo;FreqStack\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n輸出\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n說明\nFreqStack freqStack = new FreqStack(); freqStack.push(5); // The stack is [5] freqStack.push(7); // The stack is [5,7] freqStack.push(5); // The stack is [5,7,5] freqStack.push(7); // The stack is [5,7,5,7] freqStack.push(4); // The stack is [5,7,5,7,4] freqStack.push(5); // The stack is [5,7,5,7,4,5] freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. freqStack.pop(); // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,4]. freqStack.pop(); // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]. 解題 想法  在解題時，我打算在 push 時動手腳，將 push 的元素直接 push 到對的位置後，執行 pop 的動作時，就只要將最頂端的元素取出即可。  FreqStack freqStack = new FreqStack(); freqStack.push(5); // [5] freqStack.push(7); // [5,7] freqStack.push(5); // [5,7,5] freqStack.push(7); // [5,7,5,7] freqStack.push(4); // [5,7,5,7,4] // 此時 4 因為並非最頻繁的元素，所以要將 4 往下推，即變成 [5,7,4,5,7] freqStack.push(5); // [5,7,4,5,7,5] freqStack.pop(); // return 5, [5,7,4,5,7] freqStack.pop(); // return 7, [5,7,4,5] freqStack.pop(); // return 5, [5,7,4] freqStack.pop(); // return 4, [5,7]  為了實現以上的想法，我試想將出現次數相同的元素放在同一個 stack，取出時則從頻率最高的 stack 開始取，即為：  freqStack[0] = [5,7,4] // 檢查元素是否出現在 freqStack[0] 否則則往freqStack[1] 移動 freqStack[1] = [5,7] freqStack[2] = [5] // pop 的時候，從freqStack[2] 開始取，空了則將 freqStack[2] 移除 實作1: List of Stacks public class freqStack{  // Field  List\u0026lt;Stack\u0026lt;Integer\u0026gt;\u0026gt; stacks;   // Constructor  public freqStack(){  stacks = new ArrayList\u0026lt;\u0026gt;();  }   // Methods  public void push(int val){  push(val, 0);  }   private void push(int val, int freq){  // 當 stacks[freq] 是空的時候，則新建一個 stack。  Stack\u0026lt;Integer\u0026gt; stack;  if (freq \u0026gt;= stacks.size()){  stack = new Stack\u0026lt;\u0026gt;();  stacks.add(stack);  } else {  stack = stacks.get(freq);  }  // 當該 stacks[freq] 已經有該元素，則往下一個 stacks 找  if (stack.contains(val)){  push(val, freq + 1);  } else {  stack.push(val);  }  }   public int pop(){  // 直接找到最高的 stack，然後把頂端的元素 pop 出。  Stack\u0026lt;Integer\u0026gt; stack = stacks.get(stacks.size() - 1);  int top = stack.pop();  if (stack.isEmpty()){  stacks.remove(stacks.size() - 1);  }  return top;  } }  然而，此時 push 的 \u0008complexity 與欲 push 的元素的出現次數 n 有關，元素出現 n 次，則需要往下找 n 個 stack，也就是 \\(O(n)\\)。  實作2: Use HashMap to record freqency  為了優化，我們可以加入一個 HashMap 來記錄出現的次數，再下次要 push 此元素時，只需要到 HashMap 中查詢出現的次數即可。  public class freqStack{  // Field  List\u0026lt;Stack\u0026lt;Integer\u0026gt;\u0026gt; stacks;  Map\u0026lt;Integer, Integer\u0026gt; map; // 用來記錄出現次數   // Constructor  public freqStack(){  stacks = new ArrayList\u0026lt;\u0026gt;();  map = new HashMap();  }   // Methods  public void push(int val){  Stack\u0026lt;Integer\u0026gt; stack;  // 還沒有此出現次數的元素出現，則新增此 stack  if (stacks.size() \u0026lt; map.getOrDefault(val, 0) + 1){  stack = new Stack\u0026lt;\u0026gt;();  } else {  // 取得此元素出現的次數，若沒出現過則取得 stacks[0]  stack = stacks.get(map.getOrDefault(val, 0));  }  stack.push(val);  map.put(val, map.getOrDefault(val, 0) + 1); // 更新出現次數  }   public int pop(){  // 直接找到最高的 stack，然後把頂端的元素 pop 出。  Stack\u0026lt;Integer\u0026gt; stack = stacks.get(stacks.size() - 1);  int top = stack.pop();  map.put(val, map.get(val) - 1); // 更新出現次數  if (stack.isEmpty()){  stacks.remove(stacks.size() - 1);  }  return top;  } } 程式碼  題解：請點此 測試檔：請點此  Reference: Leetcode: 895. Maximum Frequency Stack\n","permalink":"http://intervalrain.github.io/posts/algorithm/freqstack/","summary":"題目 題目描述  設計一個類似 stack 的資料結構，實行 push() 跟 pop() 的功能，其中 pop() 會丟出 stack 中出現最多次的元素。 FreqStack class 必須實現：  FreqStack() 建構子必須初始化一個空的 FreqStack。 void push(int val) 將 val 推至 stack 的頂端。 int pop() 將 stack 中最頻繁出現的元素移除，並返回。  如果 stack 中最頻繁出現的元素出現平手的狀況，則返回平手的元素中最接近 stack 頂端的元素。      題目範例 輸入\n[\u0026ldquo;FreqStack\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n輸出","title":"[Algorithm] Maximum Frequency Stack 最大頻率堆疊"},{"content":"1. 請說明 Final, Finally, Finalize 三者不同?  Final:  一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。   Finally:  例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。   Finalize:  是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。    2. 請說明 String 字串中 == 與 .equals() 哪裡不同?   ==:\n 比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。    equals():\n 是 String 覆寫後的 equals 方法，比較值。    補充：\n Java 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。  若使用 String s1 = \u0026quot;Hello World\u0026quot;; 來宣告，則會透過字串池。 若使用 String s2 = new String(\u0026quot;Hello World\u0026quot;) 來宣告，則字串會存在 Heap 中，與上者的址不同。      3. 使用 \u0026ldquo;abc\u0026rdquo;.equals(s) 比較好還是 s.equals(\u0026ldquo;abc\u0026rdquo;)?  等效。 前者不會出現 NullPointerException。  4. Arrays 與 ArrayList 的差異?  Arrays 可包含原始(primitive)及物件(object)，ArrayList只允許物件。 Arrays 大小固定，ArrayList 可動態調整。 ArrayList 提供許多方法，如 removeAll、iterator等。  5. stack 與 heap 的區別?  stack: 可被預測生命週期的變數或函數資訊都放在 stack，例如：區域變數(local variable)、物件或陣列的返回位址(function/method return address)等資訊。 heap: 動態配置的記憶體空間，放置被 new 出來的物件以及內含的成員變數。  6. Arrays 與 String 的大小  Arrays 有 length 這個屬性。 String 有 legnth() 這個方法。  7. throw 與 throws 的區別  throws: throws 關鍵字通常被應用在聲明方法時，放在方法的大括號前，用來拋出異常，多個異常可以使用逗號隔開。後續使用者要調用方法時必須要拋出異常或者使用 try-catch 語句處理異常。 throw: throw 關鍵字通常用在設計方法時，預先宣告可能會產生的例外，後續方法使用者需要使用 try-catch 處理例外，或者使用 throws 關鍵字再拋出例外。 補充：  throw 用於方法內，throws 用於方法的聲明。 throw 用於方法內拋出異常，throws 用於方法聲明上拋出異常。 throw 後面只能有一個異常，throws 可以聲明多個異常。    8. int 和 Integer 何者會占用更多記憶體?  Integer，Integer 是一個物件，會在 heap 中儲存，並儲存址的值到 stack 中，而 int 只會保存值在 stack 中。  9. 是否能將 int 強制轉型為 byte?  可以，可以使用 b = (byte) a 來進行強制轉換，但是超過範圍的部分會被丟棄。  10. 是否能保證 gc 的執行?  否，垃報回收機制程式設計師無法保證，但可以透過 System.gc() 呼叫。  11. abstract class 與 interface 的區別?  abstract class 可以宣告抽象方法，提供子類別實作。 interface 的方法必定是抽象方法。 一個類別可以繼承多個介面，但只能繼承一個抽象類別。  12. List 與 Set 區別?  List:  有順序性(索引值)。 可重複。 ArrayList 實作了 List 介面。 ArrayList: 插入、刪除速度 \\(O(n)\\)，走訪速度\\(O(1)\\)。 \u0008LinkedList: 插入、刪除速度 \\O(1)\\)，走訪速度\\(O(n)\\)。   Set  無順序性(配合 iterator) 不可重複，走訪速度\\(O(1)\\)。 HashSet 實作了 Set 介面。 HashSet: 無順序性，查找速度快。 LinkedHashSet: 有順序性 TreeSet: 有排序性(依字母)   Map 1.有元素鍵值(Key-Value)，搜尋快 2.元素可重複，鍵值如果重複新加入值會覆蓋舊有值 3.HashMap: 查找速度慢，插入刪除速度快 4.TreeMap: 有排序性  ","permalink":"http://intervalrain.github.io/posts/java/interviewq/","summary":"1. 請說明 Final, Finally, Finalize 三者不同?  Final:  一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。   Finally:  例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。   Finalize:  是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。    2. 請說明 String 字串中 == 與 .equals() 哪裡不同?   ==:\n 比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。    equals():\n 是 String 覆寫後的 equals 方法，比較值。    補充：\n Java 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。  若使用 String s1 = \u0026quot;Hello World\u0026quot;; 來宣告，則會透過字串池。 若使用 String s2 = new String(\u0026quot;Hello World\u0026quot;) 來宣告，則字串會存在 Heap 中，與上者的址不同。      3.","title":"[Java] 面試常見問題"},{"content":"C  當我們要去評價程式碼的品質時，我們會考慮以下元素：  正確性(correctness): 程式碼是否有正確的解決我們的問題 設計(design): 程式碼的好壞決定於它的效率與可讀性 風格(style): 程式碼在視覺上是否有良好的format   我們的第一個 C 語言程式：  #include \u0026lt;stdio.h\u0026gt; int main(void) {  printf(\u0026#34;hello, world\\n\u0026#34;); } 整合開發環境、編譯器、介面 IDEs, compilers, interfaces  在執行程式前，我們必須將程式碼轉變成電腦可讀的 binary codes，也就是 0 與 1。 IDE(integrated development environments) 可以協助我們開發、編譯程式碼。如Visual Studio Code 我們撰寫的程式碼為開源碼(source code)，我們必須將他轉變成機器碼(machine code)，才能被電腦執行。 編譯器(compiler)是將一種語言轉變成另一種語言的程式，例如將開源碼編譯成機器碼。 在 IDE 中，我們可以在一個叫作 terminal 的視窗中輸入指令。 terminal 提供了 command-line interface(CLI) 當我們輸入 make hello，會產生一個叫作 hello 的檔案，我們可以透過輸入 ./hello 執行它。  . 代表當下的目錄，上面的指令代表我們要執行當下目錄中叫作 hello 的檔案。 hello 即是內含機器碼的檔案。   欲刪除檔案可以用 rm 指令。 輸入 ls 列出當下目錄所包含的檔案。 若源碼檔經過修過，則必須重新編譯，才能對執行檔進行修改。  函式、引數、傳回值、變數 Functions, Arguments, Return Values, Variables printf(\u0026#34;Hello, world\u0026#34;);  此處，介紹一個叫作 printf 的函數  f 代表 formatted 的字串。字串是多個字元(characters)組成的字詞，在 C 中，我們需要用雙引號(\u0026quot;\u0026quot;)來包住它。 括號 () 使我們可以輸入引數，也就是 printf 函數的 input。 最後，我們需要分號 ;，來宣告述句的結束。   其中，函式的一種產物叫作 side effect，也就是我們可以觀察到的變化，如螢幕印出字樣，或是發出聲響。 相比與 **side effects，我們也可以將函式的回傳值用於程式中，回傳值通被儲存於變數中。  string answer = get_string(\u0026#34;What\u0026#39;s your name? \u0026#34;);  此處，示範 CS50 IDE 中的一個函數。  這裡的 get_string為函式，而What's your name?  為引數。 然後，我們可以將回傳值存入到變數中，以上例，我們可利用賦值運算子(=)將右值(r_value)傳給左值(l_value)的answer。 最後，我們宣告變數的變數型別(type)。  如果我們嘗試將上述的變數改為其他變數型別，編譯器會顯示錯誤。      printf(\u0026#34;Hello, world\\n\u0026#34;);  我們此處為了換行，而使用了 escape sequence \\n。  ","permalink":"http://intervalrain.github.io/posts/cs50/lec1/","summary":"C  當我們要去評價程式碼的品質時，我們會考慮以下元素：  正確性(correctness): 程式碼是否有正確的解決我們的問題 設計(design): 程式碼的好壞決定於它的效率與可讀性 風格(style): 程式碼在視覺上是否有良好的format   我們的第一個 C 語言程式：  #include \u0026lt;stdio.h\u0026gt; int main(void) {  printf(\u0026#34;hello, world\\n\u0026#34;); } 整合開發環境、編譯器、介面 IDEs, compilers, interfaces  在執行程式前，我們必須將程式碼轉變成電腦可讀的 binary codes，也就是 0 與 1。 IDE(integrated development environments) 可以協助我們開發、編譯程式碼。如Visual Studio Code 我們撰寫的程式碼為開源碼(source code)，我們必須將他轉變成機器碼(machine code)，才能被電腦執行。 編譯器(compiler)是將一種語言轉變成另一種語言的程式，例如將開源碼編譯成機器碼。 在 IDE 中，我們可以在一個叫作 terminal 的視窗中輸入指令。 terminal 提供了 command-line interface(CLI) 當我們輸入 make hello，會產生一個叫作 hello 的檔案，我們可以透過輸入 ./hello 執行它。  . 代表當下的目錄，上面的指令代表我們要執行當下目錄中叫作 hello 的檔案。 hello 即是內含機器碼的檔案。   欲刪除檔案可以用 rm 指令。 輸入 ls 列出當下目錄所包含的檔案。 若源碼檔經過修過，則必須重新編譯，才能對執行檔進行修改。  函式、引數、傳回值、變數 Functions, Arguments, Return Values, Variables printf(\u0026#34;Hello, world\u0026#34;);  此處，介紹一個叫作 printf 的函數  f 代表 formatted 的字串。字串是多個字元(characters)組成的字詞，在 C 中，我們需要用雙引號(\u0026quot;\u0026quot;)來包住它。 括號 () 使我們可以輸入引數，也就是 printf 函數的 input。 最後，我們需要分號 ;，來宣告述句的結束。   其中，函式的一種產物叫作 side effect，也就是我們可以觀察到的變化，如螢幕印出字樣，或是發出聲響。 相比與 **side effects，我們也可以將函式的回傳值用於程式中，回傳值通被儲存於變數中。  string answer = get_string(\u0026#34;What\u0026#39;s your name?","title":"[CS50] Lec 1 - C"},{"content":"1. transient 的作用及使用方法  當一個物件繼承(implements)了 Serializable 介面，這個物件就可以被序列化，Java 的序列化模式為開發者提供了許多便利，開發者可以不必關心具體序列化的過程，只要繼承了 Serializable 介面，該類別(class)的所有屬性(property)和方法(method)都會自動序列化。 然而在實際開發過程中，有些屬性需要序列化，有些屬性則不需要。  用戶的私密訊息如密碼、銀行帳號等，通常不希望在網路操作時被傳輸。   此時，便可在這些對應的變數前加上 transient。 如此一來，這些私密訊息的生命週期只會存在於調用者的記憶體(memory)中，不會寫到磁碟(disk)裡。   注意讀取時，讀取數據的順序一定要和存放數據的順序保持一致。\n  範例：  import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; import java.io.Serializable;  public class TransientExample {  public static void main(String[] args){  User user = new User();  user.setUsername(\u0026#34;Rain\u0026#34;);  user.setPassword(\u0026#34;12345678\u0026#34;);   System.out.println(\u0026#34;Read before Serializable: \u0026#34;);  System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername());  System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword());   try {  ObjectOutput os = new ObjectOutputStream(new FileOutputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;));  os.writeObject(user);  os.flush();  os.close();  } catch (FileNotFoundException e){  e.printStackTrace();  } catch (IOException e){  e.printStackTrace();  }  try {  ObjectInputStream is = new ObjectInputStream(new FileInputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;));  user = (User) is.readObject();  is.close();   System.out.println(\u0026#34;Read after Serializable: \u0026#34;);  System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername());  System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword());  } catch (FileNotFoundException e){  e.printStackTrace();  } catch (IOException e){  e.printStackTrace();  } catch (ClassNotFoundException e){  e.printStackTrace();  }  } }  class User implements Serializable{  private static final long serialVersionID = 8294180014912103005L;   private String username;  private transient String password;   public String getUsername(){  return username;  }   public void setUsername(String username){  this.username = username;  }   public String getPassword(){  return password;  }   public void setPassword(String password){  this.password = password;  } }  輸出的結果是：   Read before Serializable:\nUsername: Rain\nPassword: 12345678\nRead after Serializable:\nUsername: Rain\nPassword: null\n  也就是說反序列化並沒有成功從文件獲取到訊息。  2. transient 的小結  一旦變數被 transient 修飾，變數將不再是物件持久化的一部分，該變敗內容將在序列化後無法再次訪問。 transient 關鍵字只能飾飾變數(variable)，不能修飾方法(method)和類別(class)。注意，區域變數是無法被 transient 修飾的。 被 transient 修飾的變數不能再被序列化，一個靜態變數不管是否被 transient 修飾，都不能被序列化。   其中，在上例中的 username 帶有 static 關鍵字，實際上是沒有被序列化的，也就是說我們在讀取之前改變 username 的值，讀取完並不會改變 username 的值，而是 JVM 中對應靜態變數的值。  3. 當遇上了 Externalizable  當被 transient 修飾的變數在存於一個繼承了 Externalizable 的介面，則代表沒有任何東西被自動序列化。 需要在 writeExternal方法中手工指定所要序列化的變數，這與是否被 transient 修飾無關。  ","permalink":"http://intervalrain.github.io/posts/java/transient/","summary":"1. transient 的作用及使用方法  當一個物件繼承(implements)了 Serializable 介面，這個物件就可以被序列化，Java 的序列化模式為開發者提供了許多便利，開發者可以不必關心具體序列化的過程，只要繼承了 Serializable 介面，該類別(class)的所有屬性(property)和方法(method)都會自動序列化。 然而在實際開發過程中，有些屬性需要序列化，有些屬性則不需要。  用戶的私密訊息如密碼、銀行帳號等，通常不希望在網路操作時被傳輸。   此時，便可在這些對應的變數前加上 transient。 如此一來，這些私密訊息的生命週期只會存在於調用者的記憶體(memory)中，不會寫到磁碟(disk)裡。   注意讀取時，讀取數據的順序一定要和存放數據的順序保持一致。\n  範例：  import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; import java.io.Serializable;  public class TransientExample {  public static void main(String[] args){  User user = new User();  user.setUsername(\u0026#34;Rain\u0026#34;);  user.setPassword(\u0026#34;12345678\u0026#34;);   System.out.println(\u0026#34;Read before Serializable: \u0026#34;);  System.out.println(\u0026#34;Username: \u0026#34; + user.","title":"[Java] transient 關鍵字"},{"content":"Mismatch 的重要性  Mismatch 就是當元件的結構設計相同，且尺寸相等，發生性質差異的一種行為。 當尺寸漸縮，變異(viriability)的程度會愈來愈大。 變異(viriability)變大會影響到類比邏輯應用的表現。  Variability/Fluctuation 變異度/誤差定義  元件的單體量測值到整體的 Stardard Target 或 Median 的差距。 可分為系統誤差與隨機誤差。  Systematic variability 系統誤差 (Global)  外質特性(extrinsic) 可以透過製程改良或控制來改善  W2W: 裝置穩定度 equipment stability Wafer level: 裝置均勻度 equipment uniformity、黃光穩定度 Litho. stability Die level: 黃光均勻度 Litho. uniformity、溫度均勻度 temp. non-uniformity  pattern density like poly gate density might impact temperature uniformity   Layout-Dependent: 光學偏移效應 Optical proximity effect、機械應力 Mechanical stress    Random variability 隨機誤差 (Local/Mismatch)  本質特性(intrinsic) 較難被改善 沒有空間相關性 尺寸漸縮，比例可能被放大  微擾動: 參雜 dopant, LER, \u0026hellip;  random dopant fluctuation(RDF): dopant diffuse randomly gate dieletric roughness line edge roughness(LER) grain irregularity      統計手法 常態分佈  大部分的元件特性都呈常態分布(normal distribution) 中央極限定理 Advanced Central Limit Therem: 相互獨立的隨機變數, 其均值以常態分佈為極限 Sum of normally distributed random variables: 常態分佈的線性組合依然是常態分布 可簡單透過 median 與 sigma 來描述一組數據, 並用來預測數據 常態分布的函數式為 \\(f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}}\\)  分析手法  透過刪減 outlier 使 rawdata 盡量接近常態分布 (刪除 3倍 sigma 以外的 outlier，重複 6 次) 通常 Full mapping 量測(66pts) 會有 0~2 點的 outliers 數學公式: A = B + C 且 B 與 C 為不相依的變數時 \\((\\sigma_A)^2=(\\sigma_B)^2+(\\sigma_C)^2\\) $$(\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2$$ Total:  \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in wafer   Global:  \\((\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2\\) \\(\\text{Median(Vt1,Vt2,\u0026hellip;Vtn)}\\) \\(\\sigma(\\text{Med1,Med2,\u0026hellip;Medn})\\)   Local:  \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in die local = \\(\\sqrt{\\frac{\\sum\\sigma_i}{n}})\\) mismatch = \\(\\sigma(\\Delta\\text{Vt1},\\Delta\\text{Vt2},\u0026hellip;\\Delta\\text{Vtn})\\)    Mismatch量測  量測 Full mapping data 將同個 die 裡面的 device pair(the same W \u0026amp; L) 計算差值  \\(\\Delta\\text{Vt}=Vt1-Vt2\\) \\(\\Delta\\text{Ion}=\\frac{2\\times(\\text{Ion}_1-\\text{Ion}_2)}{\\text{Ion}_1+\\text{Ion}_2}\\)   Normalization  同一組 device pair 內，去除 outlier，使數據接近常態分佈 因為 mismatch 受 sacle 影響，故須對 scale 做正常化 1/sqrt(WL)，Standard variation of mismatch is proportional to inverse of square root of area.   Draw \\(\\Delta\\text{Vt}-\\frac{1}{\\sqrt{W/L}}\\)圖  斜率即為 Mismatch    ","permalink":"http://intervalrain.github.io/posts/device/mismatch/","summary":"Mismatch 的重要性  Mismatch 就是當元件的結構設計相同，且尺寸相等，發生性質差異的一種行為。 當尺寸漸縮，變異(viriability)的程度會愈來愈大。 變異(viriability)變大會影響到類比邏輯應用的表現。  Variability/Fluctuation 變異度/誤差定義  元件的單體量測值到整體的 Stardard Target 或 Median 的差距。 可分為系統誤差與隨機誤差。  Systematic variability 系統誤差 (Global)  外質特性(extrinsic) 可以透過製程改良或控制來改善  W2W: 裝置穩定度 equipment stability Wafer level: 裝置均勻度 equipment uniformity、黃光穩定度 Litho. stability Die level: 黃光均勻度 Litho. uniformity、溫度均勻度 temp. non-uniformity  pattern density like poly gate density might impact temperature uniformity   Layout-Dependent: 光學偏移效應 Optical proximity effect、機械應力 Mechanical stress    Random variability 隨機誤差 (Local/Mismatch)  本質特性(intrinsic) 較難被改善 沒有空間相關性 尺寸漸縮，比例可能被放大  微擾動: 參雜 dopant, LER, \u0026hellip;  random dopant fluctuation(RDF): dopant diffuse randomly gate dieletric roughness line edge roughness(LER) grain irregularity      統計手法 常態分佈  大部分的元件特性都呈常態分布(normal distribution) 中央極限定理 Advanced Central Limit Therem: 相互獨立的隨機變數, 其均值以常態分佈為極限 Sum of normally distributed random variables: 常態分佈的線性組合依然是常態分布 可簡單透過 median 與 sigma 來描述一組數據, 並用來預測數據 常態分布的函數式為 \\(f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}}\\)  分析手法  透過刪減 outlier 使 rawdata 盡量接近常態分布 (刪除 3倍 sigma 以外的 outlier，重複 6 次) 通常 Full mapping 量測(66pts) 會有 0~2 點的 outliers 數學公式: A = B + C 且 B 與 C 為不相依的變數時 \\((\\sigma_A)^2=(\\sigma_B)^2+(\\sigma_C)^2\\) $$(\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2$$ Total:  \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in wafer   Global:  \\((\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2\\) \\(\\text{Median(Vt1,Vt2,\u0026hellip;Vtn)}\\) \\(\\sigma(\\text{Med1,Med2,\u0026hellip;Medn})\\)   Local:  \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in die local = \\(\\sqrt{\\frac{\\sum\\sigma_i}{n}})\\) mismatch = \\(\\sigma(\\Delta\\text{Vt1},\\Delta\\text{Vt2},\u0026hellip;\\Delta\\text{Vtn})\\)    Mismatch量測  量測 Full mapping data 將同個 die 裡面的 device pair(the same W \u0026amp; L) 計算差值  \\(\\Delta\\text{Vt}=Vt1-Vt2\\) \\(\\Delta\\text{Ion}=\\frac{2\\times(\\text{Ion}_1-\\text{Ion}_2)}{\\text{Ion}_1+\\text{Ion}_2}\\)   Normalization  同一組 device pair 內，去除 outlier，使數據接近常態分佈 因為 mismatch 受 sacle 影響，故須對 scale 做正常化 1/sqrt(WL)，Standard variation of mismatch is proportional to inverse of square root of area.","title":"[Device] Mismatch Introduction"},{"content":"如何初始化 vector 事先準備  #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std;  1. 利用 push_back() 函式 vector\u0026lt;int\u0026gt; A; A.push_back(1); A.push_back(2); A.push_back(3); // A = [1,2,3] 2. 利用重載建構子(overloaded constructor) int size = 5; int fill = 2; vector\u0026lt;int\u0026gt; B(size, fill); // B = [2,2,2,2,2] 3. 將 array 傳給 vector 的建構子(-std=c++11) vector\u0026lt;int\u0026gt; C{1, 2, 3, 4, 5}; // C = [1,2,3,4,5] 4. 利用既有的 array int array[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; D(array, array+4); // D = [1,2,3,4] 5. 利用既有的 vector vector\u0026lt;int\u0026gt; E(C.begin()+1, C.end()-3); // E = [2] 6. 利用 fill 函式 vector\u0026lt;int\u0026gt; F(6); fill(F.begin(), F.end(), 3); // F = [3,3,3,3,3,3] Reference\n","permalink":"http://intervalrain.github.io/posts/c++/newvector/","summary":"如何初始化 vector 事先準備  #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std;  1. 利用 push_back() 函式 vector\u0026lt;int\u0026gt; A; A.push_back(1); A.push_back(2); A.push_back(3); // A = [1,2,3] 2. 利用重載建構子(overloaded constructor) int size = 5; int fill = 2; vector\u0026lt;int\u0026gt; B(size, fill); // B = [2,2,2,2,2] 3. 將 array 傳給 vector 的建構子(-std=c++11) vector\u0026lt;int\u0026gt; C{1, 2, 3, 4, 5}; // C = [1,2,3,4,5] 4. 利用既有的 array int array[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; D(array, array+4); // D = [1,2,3,4] 5.","title":"[C++] How to Initialize vector in C++"},{"content":"Integer.bitCount 的函式解析  要計算整數以二進制的方式表示時，所有 bit 位為 1 的總和。  雛形  從低位開始，檢查是否為 1。  public static int bitCount(int i){  int count = 0;  while (i \u0026gt; 0) {  if ((i \u0026amp; 1) == 1) // 如果最低位為 1，count就加 1  count++;  i \u0026gt;\u0026gt;= 1; // 向右推進 1 位，等同於 num /= 2;  }  return count; }  時間複雜度為 \\(O(n)\\)，\\(n\\) 為整數的位數(bit 數)。  優化  利用(i - 1) \u0026amp; i 可以消除最低位數的 1 的性質來計算。  public static bitCount(int i){  int count = 0;  while (i \u0026gt; 0){  i = i \u0026amp; (i - 1); // 0b0101_1100 - 1 = 0b0101_1011, 且 0b0101_1100 \u0026amp; 0b0101_1011 = 0b0101_1000;  count++;  }  return count; }  時間複雜度為 \\(O(n))\\)，\\(n\\) 為位數為 1 的個數。  利用 int 的特性再優化  \u0008因為 int 的最大正整數為 2^31，故我們可以兩兩錯位相加來求和  private static int bitCount(int i){  i = (i \u0026amp; 0x55555555) + ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); // 0b0101_0101_0101_0101_0101_0101_0101_0101  i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); // 0b0011_0011_0011_0011_0011_0011_0011_0011  i = (i \u0026amp; 0x0f0f0f0f) + ((i \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); // 0b0000_1111_0000_1111_0000_1111_0000_1111  i = (i \u0026amp; 0x00ff00ff) + ((i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); // 0b0000_0000_1111_1111_0000_0000_1111_1111  i = (i \u0026amp; 0x0000ffff) + ((i \u0026gt;\u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff); // 0b0000_0000_0000_0000_1111_1111_1111_1111  return i; }  時間複雜度為 \\(O(1))\\)。  Source Code(final) public static int bitCount(int i) {  // HD, Figure 5-2  i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555);  i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333);  i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f;  i = i + (i \u0026gt;\u0026gt;\u0026gt; 8);  i = i + (i \u0026gt;\u0026gt;\u0026gt; 16);  return i \u0026amp; 0x3f; }  一、三、四、五步不進行消位，在最後再利用 i \u0026amp; 0x3f 消去不必要的位數  ","permalink":"http://intervalrain.github.io/posts/java/bitcount/","summary":"Integer.bitCount 的函式解析  要計算整數以二進制的方式表示時，所有 bit 位為 1 的總和。  雛形  從低位開始，檢查是否為 1。  public static int bitCount(int i){  int count = 0;  while (i \u0026gt; 0) {  if ((i \u0026amp; 1) == 1) // 如果最低位為 1，count就加 1  count++;  i \u0026gt;\u0026gt;= 1; // 向右推進 1 位，等同於 num /= 2;  }  return count; }  時間複雜度為 \\(O(n)\\)，\\(n\\) 為整數的位數(bit 數)。  優化  利用(i - 1) \u0026amp; i 可以消除最低位數的 1 的性質來計算。  public static bitCount(int i){  int count = 0;  while (i \u0026gt; 0){  i = i \u0026amp; (i - 1); // 0b0101_1100 - 1 = 0b0101_1011, 且 0b0101_1100 \u0026amp; 0b0101_1011 = 0b0101_1000;  count++;  }  return count; }  時間複雜度為 \\(O(n))\\)，\\(n\\) 為位數為 1 的個數。  利用 int 的特性再優化  \u0008因為 int 的最大正整數為 2^31，故我們可以兩兩錯位相加來求和  private static int bitCount(int i){  i = (i \u0026amp; 0x55555555) + ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); // 0b0101_0101_0101_0101_0101_0101_0101_0101  i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); // 0b0011_0011_0011_0011_0011_0011_0011_0011  i = (i \u0026amp; 0x0f0f0f0f) + ((i \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); // 0b0000_1111_0000_1111_0000_1111_0000_1111  i = (i \u0026amp; 0x00ff00ff) + ((i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); // 0b0000_0000_1111_1111_0000_0000_1111_1111  i = (i \u0026amp; 0x0000ffff) + ((i \u0026gt;\u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff); // 0b0000_0000_0000_0000_1111_1111_1111_1111  return i; }  時間複雜度為 \\(O(1))\\)。  Source Code(final) public static int bitCount(int i) {  // HD, Figure 5-2  i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555);  i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333);  i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f;  i = i + (i \u0026gt;\u0026gt;\u0026gt; 8);  i = i + (i \u0026gt;\u0026gt;\u0026gt; 16);  return i \u0026amp; 0x3f; }  一、三、四、五步不進行消位，在最後再利用 i \u0026amp; 0x3f 消去不必要的位數  ","title":"[Java] Integer.bitCount 解析"},{"content":"一、OS 簡介 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：\n 資源分配者 監控使用者程式的執行，以防止不正常的運作造成對系統的危害。  一個標準 PC 的作業系統應該提供以下功能：  行程管理 (processing management) 記憶體管理 (memory management) 檔案系統 (file system) 網路通訊 (networking) 安全機制 (security) 使用者介面 (user integerface) 驅動程式 (device drivers)  OS 系統依大小來區分：  大型電腦：IBM OS/360 個人電腦：Windows、Linux、BSD、Mac OS X 嵌入式：VxWorks、eCos、Sysbian OS、Palm OS  依品牌來區分：  類 Unix 家族：包含 System V、BSD 與 Linux。 微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。 蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統 Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。  二、常見的系統類型  Multiprogramming System   系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel)) Multiprogramming Degree：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 Thrashing 現象)  當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。  [方法1] 降低 Multiprogramming Degree [方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 [方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。      分時系統 Time Sharing System   Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。 常見配置：  行程排程採用 RR 排程(Round-robin scheduling) 記憶體空間所有使用者分享 使用虛擬記憶體技術 I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。    分散式系統 Distributed System    須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：\n Client-Server System Peer-to-peer    舉例：志願計算，使用志願者電腦的閒置計算力，透過網際網路進行資料傳輸(如 Folding@home 蛋白質摺疊研究計畫)\n  分散式系統的好處：\n 資源共享 (Resource sharing) 加快計算速度 (Speed up) 可靠性 (Reliability)：指不容易因為一台電腦 shut down 而全部崩潰 通訊需求 (Coummunication Need)  補充：勿將 Multiprocessor 與分散式系統混為一談\n Symmetric Multiprocessing (SMP)：對稱式多元處理，每一個處理器具有相同的功能，可靠度高，強調負載平衡。 Asymmetric Multiprocessing (ASMP)：非對稱式多元處理，Master/Slave 架構。    即時系統 Real Time System   定義嚴謹的固定時間限制，電腦在處理工作時必須在這個定義的時間內完成，否則工作就算失效。  硬性即時系統(Hard Real Time Sydstem)：對於完成工作的時間有極嚴格的限制。若 Prcess 未能於規定的時間內完成，則 Process 即屬失效。(意義同即時系統之定義)  工廠自動化系統、軍事系統、核能安控等。 Application Program 設計上非常重要。 Data 及 Program 皆存在 ROM 或 RAM 中。 不使用虛擬記憶體，因為 Page Fault 的處理時間過長。 減少 os 的干預以降低 Dispatch Latency。   軟性即時系統(Soft Real Time System)：保證高優先權的 Process 必須先於所有低優先權的 Process 完成。  Multimedia System、Virtual Reality等。(影音多媒體的緩衝時間) CPU 的 Scheduling 應能支援 Priority Scheduling 且不能提供類似 Aging 技術。 可和分時系統、virtual memory 共存。      叢集系統 Clustered System   叢集系統共享儲存裝置，集合許多 CPU 並且經由 LAN 連線緊密地連結以完成工作。 叢集系統主要是利用多台獨立的電腦系統或是工作站來共同完成大型數值的平行計算。  Batch  較好的耐用度、安全性 常用於大量數據分析 常用於醫院、金融業 計算機一次只執行一件事 使用者與計算機的執行沒有互動性 CPU 時常處在閒置的狀態(因為 I/O speed 遠小於 CPU speed) OS 處理完一件事後，才將控制權交給下一個工作  Multi-programming   讓 I/O 與計算的工作可以同時進行，減少 CPU 閒置的時間。\n  Spooling(Simultaneous Peripheral Operation On-Line)。\n  但仍是一次執行一件事。   OS 的工作包含：\n 記憶體管控。  系統必須分配記憶體給不同的程式   CPU 排程。  系統必須決定哪些程式要執行   I/O 系統。  系統提供 I/O 的排程與裝置的分配      Time-sharing System   使用者與系統間具有互動性\n CPU 頻繁的切換不同的工作，所以會有很多時間點可以接收 I/O。 使用者可以及時看到結果。 使用者感受像是同時進行的，但其實是很快速的切換在不同的工作之間。    OS 的工作包含：\n Virtual memory，從硬碟中借儲存空間出來，當作 memory 來使用。 檔案系統和硬碟管理。 同步化(Synchronization) 和 死鎖(deadlock)。    \\( \\def\\arraystretch{1.5}\\begin{array}{|c|c|c|c|}\\hline \u0026amp;\\text{Batch}\u0026amp;\\text{Multi-programming}\u0026amp;\\text{Time-sharing}\\\\\\hline \\text{系統模型}\u0026amp;\\text{單一使用者、單一作業}\u0026amp;\\text{單一使用者、多作業排程}\u0026amp;\\text{多使用者、作業平行處理}\\\\\\hline \\text{目的}\u0026amp;\\text{簡單}\u0026amp;\\text{增加資源利用效率(機本)}\u0026amp;\\text{提升反應速度(人本)}\\\\\\hline \\text{特徵}\u0026amp;\\text{N.A.}\u0026amp;\\text{CPU 排程、記憶體管理、I/O系統}\u0026amp;\\text{檔案系統、虛擬記憶體、同步化、死鎖}\\\\\\hline \\end{array} \\)\n電腦系統結構 桌面系統(Desktop Systems)：單處理器(single processor)  PC(personal computer) GUI I/O devices: 鍵盤、滑書、螢幕、印表機… 多元的 OS  Window, MacOS, Unix, Linux   缺乏檔案與作業系統的保護  木馬、病毒    平行系統(Parallel Systems)：多處理器(multiprocessor/tightly couplde system)  多核、或多 CPU。 通常共享記憶體 優點：  Throughput: 提升計算能力 Economical: 很多裝置可以共用、節省成本 Reliability: 當其中一個 CPU 壞掉時，不會使得電腦完全無法操作。   分類：  對稱式多處理器系統 Symmetric multiprocessor system(SMP)  作業系統控制的每個處理器都扮演相同角色 大多 CPU 屬於這種 需要額外處理 synchronization   非對稱式多處理器系統Asymmetric multiprocessor system  每個處理器被指派處理不同的特殊工作 一個主要的 master CPU 與多個 slave CPUs 常見於極大的系統      多核處理器 Multi-Core Processor  在單一的 CPU 有多核 On-chip communication 比 between-chip communication 還快 One chip with multiple core 比 multiple single-core chips 還節能  Many-Core Processor  Nvidia General-Purpose GPU 圖形處理器  Single Instruction Multiple Data 處理矩陣更快   Intel Xeon Phi TILE64  記憶體存取結構(Memory Access Architecture) 統一記憶體存取架構 Uniform memory access(UMA) 非統一記憶體存取架構 Non-uniform memory access(NUMA) 分散式系統(Distributed Systems)： ","permalink":"http://intervalrain.github.io/posts/os/lec1/","summary":"一、OS 簡介 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：\n 資源分配者 監控使用者程式的執行，以防止不正常的運作造成對系統的危害。  一個標準 PC 的作業系統應該提供以下功能：  行程管理 (processing management) 記憶體管理 (memory management) 檔案系統 (file system) 網路通訊 (networking) 安全機制 (security) 使用者介面 (user integerface) 驅動程式 (device drivers)  OS 系統依大小來區分：  大型電腦：IBM OS/360 個人電腦：Windows、Linux、BSD、Mac OS X 嵌入式：VxWorks、eCos、Sysbian OS、Palm OS  依品牌來區分：  類 Unix 家族：包含 System V、BSD 與 Linux。 微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。 蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統 Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。  二、常見的系統類型  Multiprogramming System   系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel)) Multiprogramming Degree：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 Thrashing 現象)  當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。  [方法1] 降低 Multiprogramming Degree [方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 [方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。      分時系統 Time Sharing System   Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。 常見配置：  行程排程採用 RR 排程(Round-robin scheduling) 記憶體空間所有使用者分享 使用虛擬記憶體技術 I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。    分散式系統 Distributed System    須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：","title":"[OS] Lec 1 - Introduction"},{"content":"HashMap.comparableClassFor(Object x) 的函式解讀  原文敘述\nReturns x\u0026rsquo;s Class if it is of the form \u0026ldquo;class C implements Comparable\u0026rdquo;, else null.\n  我的翻譯 當x的類別為Comparable的實作時，返回x的類別；否則返回 null。\n  藉由這個函式實例的解讀，可以了解一下類別、泛型的相關概念。  Source Code static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) {  if (x instanceof Comparable) {  Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p;  if ((c = x.getClass()) == String.class) // bypass checks  return c;  if ((ts = c.getGenericInterfaces()) != null) {  for (Type t : ts) {  if ((t instanceof ParameterizedType) \u0026amp;\u0026amp;  ((p = (ParameterizedType) t).getRawType() ==  Comparable.class) \u0026amp;\u0026amp;  (as = p.getActualTypeArguments()) != null \u0026amp;\u0026amp;  as.length == 1 \u0026amp;\u0026amp; as[0] == c) // type arg is c  return c;  }  }  }  return null; } instanceof  insanceof 可理解成某類別的實作，無論是執行期時的類別，或是父類別，或是它實現的介面，或父類別實現的介面…，總之只要在繼承鏈上有這個類別就可以了。  getClass()  與instanceof相對應的是getClass()函式，無論該物件如果轉型，getClass()都會返回它執行時期的類別，可以簡單理解成實際類別\u0008，換言之也就是我們 new 出來物件時使用的類別。 有一種例外情形是匿名物件，當匿名物件調用getClass()時，返回的是依賴它的物件在執行期的類別，並以1,2,3\u0026hellip;的index區分。  getGenericInterfaces()  getGenericInterfaces()方法返回的是該物件在執行期時直接實作的介面。必然是該類別自己實作的介面，繼承的則不可。  getGenericSuperclass()和getSuperclass() 這兩個函式雖然沒有出現在 comparableClassFor(Object x)中，但也順帶一提。\n getSuperclass()返回的是直接父類的類別，不包括泛型參數。 \u0008getGenericSuperclass()返回的是包括泛型參數在內的直接父類別。 注意如果父類別聲明了泛型，但子類別繼承時沒有為父類別實作該泛型，這時候也是沒有泛型參數的  ParameterizedType  ParameterizedType 是 Type 介面的子介面，表示參數化的類別，亦即實作了泛型參數的類型。 注意如果直接用 bean 物件 instanceof ParameterizedType，结果都是 false。 Class 物件只能是 instanceof ParameterizedType，否則編譯會報錯。 只有用 Type 物件 instanceof ParameterizedType 才能得到想要的比較结果。可以這麼理解：一個 Bean 類別不會是 ParameterizedType，只有代表這個Bean類的類型（Type）才可能是ParameterizedType。 實現泛型參數，可以是給泛型傳入了一個真實的類別，或者傳入另一個新聲明的泛型參數，只聲明泛型而不實作，則 instanceof ParameterizedType 為 false。  getRawType()  getRawType()方法返回聲明了這個類別的類或介面，也就是去掉了泛型参数部分的類別物件。  getActualTypeArguments()  與getRawType()相對應，getActualTypeArguments()以數組的形式返回泛型參數列表。 當傳入的是真實類別時，印出來的是全類名 當傳入的是另一個聲明的泛型參數時滿印出來的是代表該泛型參數的符號。  getOwnerType()  ParameterizedType介面還有一個getOwnerType()函式，如果該類別是一个內部類別/介面，返回它的外部類別/介面。如果該類型不是內部類型不是内部類別/介面，返回null。  comparableClassFor(Object x) 總結 static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) {  if (x instanceof Comparable) { // 判斷是否實作了 Comparable 介面  Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p;  if ((c = x.getClass()) == String.class) // 如果是String類別，直接返回String.class  return c;  if ((ts = c.getGenericInterfaces()) != null) { // 檢查是否有直接實現的介面  for (Type t : ts) { // 遍歷介面  if ((t instanceof ParameterizedType) \u0026amp;\u0026amp; // 當介面實現了泛型  ((p = (ParameterizedType) t).getRawType() == // 取得介面不帶參數時的類別對象  Comparable.class) \u0026amp;\u0026amp; // 且為 Comparable  (as = p.getActualTypeArguments()) != null \u0026amp;\u0026amp; // 取得該介面的泛型參數  as.length == 1 \u0026amp;\u0026amp; as[0] == c) // type arg is c // 只帶有一種泛型且是實作類別為其本身  return c; // 返回該類別  }  }  }  return null; // 皆否則回傳 null } ","permalink":"http://intervalrain.github.io/posts/java/hashmap/hashmap/","summary":"HashMap.comparableClassFor(Object x) 的函式解讀  原文敘述\nReturns x\u0026rsquo;s Class if it is of the form \u0026ldquo;class C implements Comparable\u0026rdquo;, else null.\n  我的翻譯 當x的類別為Comparable的實作時，返回x的類別；否則返回 null。\n  藉由這個函式實例的解讀，可以了解一下類別、泛型的相關概念。  Source Code static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) {  if (x instanceof Comparable) {  Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p;  if ((c = x.getClass()) == String.class) // bypass checks  return c;  if ((ts = c.getGenericInterfaces()) != null) {  for (Type t : ts) {  if ((t instanceof ParameterizedType) \u0026amp;\u0026amp;  ((p = (ParameterizedType) t).","title":"[Java] Java 的中 HashMap.comparableClassFor(Object x) 的函式解讀"},{"content":"什麼是 Computer Science(CS)?  CS 意在解決問題，更精準地說，是將問題 (input) 轉換成答案 (output) 的過程。 在計算機的世界，為了表達 inputs 和 outputs，我們必須將資訊標準化來儲存與操作它們，因為計算機只讀得懂 0 與 1 (開路/通路)。  如何表達數字?  在人類的世界，人們使用十進制(Decimal)。 在計算機的世界，用的是二進制(Binary)，也就是 0 與 1。  \\(1+1=10\\) \\((1,2,3,4,5,6,7,\u0026hellip;)_{10}=(001,010,011,100,101,110,111,\u0026hellip;)_2\\)   每個二進制的位元(digit)稱為 bit。 在現代計算機結構中，是由數以億計的電晶體(transistors)所組成的。  電晶體是一種具有開關(switch)性質的邏輯元件。   大部分的計算機一次用 8 個 bits，或稱 1 bytes，來表達數字。  \\(8 \\text{bits}=1 \\text{bytes}\\)    如何表達文字?  要表達文字，只需將不同的字元定義到對應的數字即可。 ASCII，American Standard Code for Information Interchange，即是一種基於拉丁字母的編碼系統，可應用顯示現代英語。  A-\u0026gt;65, B-\u0026gt;66, \u0026hellip;etc a-\u0026gt;97, b-\u0026gt;98, \u0026hellip;etc H-\u0026gt;72, I-\u0026gt;73, !-\u0026gt;33, so HI!=72, 73, 33   在不同語言，有不同的字符，就必須定義新的編碼系統，來容納更多的字符。  如 Unicode。 如 emojo 顏文字也是一種字符。    如何表達顏色?  同理，可以把不同的數字定義給不同的顏色，其中最常見的就是 RGB 系統。  由紅綠藍色塊所組成。 紅、綠、藍又個別以 8 bits 儲存的 256 種不同層度的顏色強度表示。 一共由 24 bits 來表達，超過1百萬種顏色。    那圖案、影片、音樂呢?  圖案是由數以萬計的色塊(dots)所組成，在螢幕顯示器上我們稱作畫素(pixels)。 影片則是由連續的圖案經由連續播放所建構而成的。 音樂同樣可以用 bits 來表達，其中 MIDI 是一種用數字來表達音符的形式。   All are composed by 0 and 1 in the computer world.\n 演算法 (Algorithms)  我們現在可以表達 inputs 和 outputs 了，接下來要開始解決問題。 演算法就是將 inputs 經過一連串系統性、且有邏輯的指令(instructions)轉化成 outpus 的過程。 試想我們要從電話簿中查朋友的電話，電話簿是按照名字排序的。   我們可以從第一頁往後找到最後一頁，只有名字與電話是存在的，我們就會在電話簿中找到，所以這個方法是無誤的。 我們也可以兩頁兩頁找，但我們有可能因此錯失我們要查的號碼。 我們也可以一次翻到當前電話簿的一半，利用電話簿的排序規則，決定往左半邊找或右半邊找，並且持續這個步驟直到找到。    將上述的演算法效率視覺化如下：  從上圖可見，當我們處理的樣本數很大時(電話簿頁數很多)，那麼我們用方法1解決問題的時間(找到號碼的時間)就會大的很多。而利用方法3解決問題的時間則會呈對數成長。 因此，好的演算法設計，會大大的影響計算機的操作效率。  Pseudocode  我們可以用英文(或人類語言)來表達我們的演算法，這種寫作方式叫作 Pseudocode。  Pick up phone book Open to middle of phone book Look at page If person is on page Call person Else if person is earlier in book Open to middle of left half to book Go back to line 3 Else if person is later in book Open to middle of right half to book Go back to line 3 Else Quit  其中像Pick up、Open to、Look at、Quit這些動作，在計算機中我們稱作函式(functions)。 其中分枝的部分If、Else，稱作條件(conditions)。 而我們需要決定的判斷式如person is on page、person is earlier than book、person is later in book稱為布林邏輯值(Boolean expressions)，也就是Yes or No，是或否。 最後，不斷地重覆Go back to line 3的動作，稱作迴圈(loops)。 接下來我們會繼續遇到各種玩意：  function  引數 arguments, 傳回值 return values   conditionals Boolean expressions loops variables   和 David 的第一個程式：將 \u0026ldquo;hello, world\u0026rdquo; 印到螢幕上。  #include \u0026lt;stdio.h\u0026gt; int main(void) {  printf(\u0026#34;hello, world\\n\u0026#34;); } Scratch  試試看到 Scratch(https://scratch.mit.edu/) 這套圖像化軟體語言操作看看吧！  Reference: https://cs50.harvard.edu/college/2021/fall/notes/0/\n","permalink":"http://intervalrain.github.io/posts/cs50/lec0/","summary":"什麼是 Computer Science(CS)?  CS 意在解決問題，更精準地說，是將問題 (input) 轉換成答案 (output) 的過程。 在計算機的世界，為了表達 inputs 和 outputs，我們必須將資訊標準化來儲存與操作它們，因為計算機只讀得懂 0 與 1 (開路/通路)。  如何表達數字?  在人類的世界，人們使用十進制(Decimal)。 在計算機的世界，用的是二進制(Binary)，也就是 0 與 1。  \\(1+1=10\\) \\((1,2,3,4,5,6,7,\u0026hellip;)_{10}=(001,010,011,100,101,110,111,\u0026hellip;)_2\\)   每個二進制的位元(digit)稱為 bit。 在現代計算機結構中，是由數以億計的電晶體(transistors)所組成的。  電晶體是一種具有開關(switch)性質的邏輯元件。   大部分的計算機一次用 8 個 bits，或稱 1 bytes，來表達數字。  \\(8 \\text{bits}=1 \\text{bytes}\\)    如何表達文字?  要表達文字，只需將不同的字元定義到對應的數字即可。 ASCII，American Standard Code for Information Interchange，即是一種基於拉丁字母的編碼系統，可應用顯示現代英語。  A-\u0026gt;65, B-\u0026gt;66, \u0026hellip;etc a-\u0026gt;97, b-\u0026gt;98, \u0026hellip;etc H-\u0026gt;72, I-\u0026gt;73, !-\u0026gt;33, so HI!","title":"[CS50] Lec 0 - Introduction to Computer Science"},{"content":"0. 前言  以往寫筆記通常是使用 Notion，簡單的 Markdown 語法搭配支援 LaTex，使得在撰寫學習筆記時，可以達到快速且美觀的呈現。 雖說 GitHub Pages 支援了 Markdown 的語法，但卻不支援 LaTex，這使得想將筆記從 Notion 移轉到 GitHub Pages，成為一個小缺點。 而此處介紹的是在網頁上顯示較為輕便的 KaTex。  1. 解決方法  利用 KaTex，在靜態頁面掛載 JavaScript 程式碼。 其在官網的描述是：   Beautilful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works.\n Step 1. 創建一個可常駐的靜態頁面  在 \\layouts\\partials\\ 下創建一個叫作 math.html 的頁面。  注意是 global 的 layouts 文件夾中不是 hugo themes 中的文件夾   開啟頁面之後，在 \u0026lt;head\u0026gt; 與 \u0026lt;/head\u0026gt; 之間加入下一步驟內的 JavaScript 程式碼。  Step 2. 將 JavaScript 程式碼貼入 math.html \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;  onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  上面的程式碼是將 KaTex 的渲染程式碼寫到 math.html 中。  Step 3. 將 Hugo theme 中的 header.html 複製出來  同樣將 header.html 複製到 global 下的 \\layout\\partials，並貼入  {{- /* Head custom content area start */ -}} {{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} {{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} {{- /* Head custom content area end */ -}}  上面的程式碼的功能將 math.html 嵌進 header.html 中，並以 config.yml 中的 .param.math 指令來控制。  Step 4. 開始撰寫 KaTex  一開始先將標頭的定義區將 math: true，即可開啟該頁面的 KaTex 渲染功能。 在 \\\\( 符號與 \\\\) 符號間進行 inline equation 插入。 或在 $ $ 符號與 $ $ 間進行 block equation 的插入。 LaTex 的語法可以參考https://www.cs.pu.edu.tw/~wckuo/doc/latex123/node11.html  參考來源：\n https://bend1031.github.io/ https://teddygood.github.io/posts/blog/katex/  ","permalink":"http://intervalrain.github.io/posts/ghpage/latexrendering/","summary":"0. 前言  以往寫筆記通常是使用 Notion，簡單的 Markdown 語法搭配支援 LaTex，使得在撰寫學習筆記時，可以達到快速且美觀的呈現。 雖說 GitHub Pages 支援了 Markdown 的語法，但卻不支援 LaTex，這使得想將筆記從 Notion 移轉到 GitHub Pages，成為一個小缺點。 而此處介紹的是在網頁上顯示較為輕便的 KaTex。  1. 解決方法  利用 KaTex，在靜態頁面掛載 JavaScript 程式碼。 其在官網的描述是：   Beautilful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works.\n Step 1. 創建一個可常駐的靜態頁面  在 \\layouts\\partials\\ 下創建一個叫作 math.html 的頁面。  注意是 global 的 layouts 文件夾中不是 hugo themes 中的文件夾   開啟頁面之後，在 \u0026lt;head\u0026gt; 與 \u0026lt;/head\u0026gt; 之間加入下一步驟內的 JavaScript 程式碼。  Step 2.","title":"[ghpage] 在 GitHub Pages 中渲染 KaTex 公式"},{"content":"前言 2022/3/3 更新\n 此篇為筆者以工作經驗為背景寫下的筆記，如有錯誤煩請指教。點此聯絡我。  Ring Oscillator 環形振盪器(RO) 簡介  在 IC 電路設計中，除了 metal routing 會造成訊號的延遲，邏輯閘從高電位轉換到低電位、或從低電位轉換到高電位(switch)，也會造成相對應的 Gate Delay，然而 Gate Delay 非常小，很難以測量，故 RO 是一個便於測量 Gate Delay 的電路設計。 在 IC 電路設計中，除了考慮速度，還會考慮功耗，而邏輯閘開關所造成的動態功耗(dynamic power consumption)佔比非常大，故 Ring Oscillator 也可以用來計算閘開關的功耗。  1. Time Delay  為了方便測量 Time Delay，RO 是一種用奇數 n 個 inverter(NOT Gate) 串接成的電路。透過在輸入端振盪產生方波，經過奇數個 inverter 之後，在輸出端產生反向的方波訊號，其時間差為經過 n 個 inverter 的 time delay。利用 time delay 會透過串接 inverter 累加(或稱propagation)的性質，故可以算出單個閘極的 gate delay(\\(T_p\\), propagation time) \\(t_{HtoL}\\sim t_{LtoH}=t_p=\\Delta T/2n\\) [註] 圖為一個由3個反向器組成的環形振盪器，其輸出頻率為 \\(\\frac{1}{6}t_p\\)(Gate Delay)。 由偶數個 inverter 組成的環形電路無法構成環形振盪器，因為其輸入與輸出相同。然而這種配置可以被用作記憶體的基本單元，它是建構靜態隨機存取記憶體 SRAM (static random access memory)的基本組成。 環形振盪器通常全部由 inverter 所組成，較能抵抗環境影響。事實上也可以用 non-inverter 與 inverter 混合組成，前提是 inverter 的總數要是奇數。其振蕩器的週期等於兩倍的閘延遲(Gate delay)， 為了增加振盪頻率，通常有兩種方法  減少環形電路中的 inverter 數量。 提升電壓，但同時會有較大的電流與功耗。     2. Power consumption  分為 Dynamic Power Consumption 與 Static Power Consumption。 \\(P_{total}=a\\times f\\times(\\frac{1}{2}CV_{DD}^2+V_{DD}I_{SC})+V_{DD}I_{off}+V_{DD}I_{Diode}+V_{DD}I_{Gate}\\)  a 為 activity，每個 clock cycle 的平均開關切換數目。  故在電路設計上減少開關的次數也能有效降低功耗。   f 為頻率，代表一秒內可以完成幾次開關(switch)。     Dynamic Power(Switching Power)  為現今 CMOS 振盪器的主要功耗來源。 Dynamic Power 為 RO 在固定方波頻率為 \\(f\\) 時的平均功率(一組方波歷時為 \\(1/f\\))。 每一次開或關(switch)所耗的能為 \\(\\frac{1}{2}CV^2\\)  推導：  \\(C=\\frac{Q}{V}\\) \\(I=\\frac{dQ}{dt}=C\\frac{dV}{dt}\\) \\(W=IV=\\int_{0}^{t}CV\\frac{dV}{dt}=\\frac{1}{2}CV^2\\)     故功耗為\\(P_{dynamic}=I_{active}V=CV^2\\) 如何降低功耗?  降低 Activity  Clock Gating:  避免不必要的 flip-flop 避免 transition downstream logic 加入 enable 來控制邏輯複雜度    Data Gating:  利用 gating off inputs 來避免不必要的 toggling   Bus Encodings Freeze \u0026ldquo;Don\u0026rsquo;t cares\u0026rdquo; Remove Glitches   降低\\(C_{Load}\\) 降低\\(f\\) 降低\\(V_{DD}\\) 平行結構  可降低相同 Throughput 時的功耗   Trade off performance    Short-Circuit current  當 NMOS 與 PMOS 同時在切換開關時發生(NMOS尚未完全關閉，但PMOS已經部分啟動或是兩者相反)。  Kept to \u0026lt; 10% of capacitor charging current by making edges fast    Static Power  因為 subthreshold leakage，MOS並未完全關閉所造成的漏電流致使的功耗。 在小尺寸(\u0026lt;180nm)元件中，因為 short channel effect 的加劇，此功耗的比例會加劇，甚至達 10~40%。   Diode Leakage  Drain 端與 Source 端的 Diode junction 產生的 junction leakage。 通常很小可忽略。  Gate Leakage  因為電子穿隧穿過閘極氧化層(gate oxide)造成的漏電，通常在極薄的閘極氧化層發生，可忽略。  Reference reference1_Eletrical Engineering and Computer Science by MIT\n","permalink":"http://intervalrain.github.io/posts/device/ringoscillator/","summary":"前言 2022/3/3 更新\n 此篇為筆者以工作經驗為背景寫下的筆記，如有錯誤煩請指教。點此聯絡我。  Ring Oscillator 環形振盪器(RO) 簡介  在 IC 電路設計中，除了 metal routing 會造成訊號的延遲，邏輯閘從高電位轉換到低電位、或從低電位轉換到高電位(switch)，也會造成相對應的 Gate Delay，然而 Gate Delay 非常小，很難以測量，故 RO 是一個便於測量 Gate Delay 的電路設計。 在 IC 電路設計中，除了考慮速度，還會考慮功耗，而邏輯閘開關所造成的動態功耗(dynamic power consumption)佔比非常大，故 Ring Oscillator 也可以用來計算閘開關的功耗。  1. Time Delay  為了方便測量 Time Delay，RO 是一種用奇數 n 個 inverter(NOT Gate) 串接成的電路。透過在輸入端振盪產生方波，經過奇數個 inverter 之後，在輸出端產生反向的方波訊號，其時間差為經過 n 個 inverter 的 time delay。利用 time delay 會透過串接 inverter 累加(或稱propagation)的性質，故可以算出單個閘極的 gate delay(\\(T_p\\), propagation time) \\(t_{HtoL}\\sim t_{LtoH}=t_p=\\Delta T/2n\\) [註] 圖為一個由3個反向器組成的環形振盪器，其輸出頻率為 \\(\\frac{1}{6}t_p\\)(Gate Delay)。 由偶數個 inverter 組成的環形電路無法構成環形振盪器，因為其輸入與輸出相同。然而這種配置可以被用作記憶體的基本單元，它是建構靜態隨機存取記憶體 SRAM (static random access memory)的基本組成。 環形振盪器通常全部由 inverter 所組成，較能抵抗環境影響。事實上也可以用 non-inverter 與 inverter 混合組成，前提是 inverter 的總數要是奇數。其振蕩器的週期等於兩倍的閘延遲(Gate delay)， 為了增加振盪頻率，通常有兩種方法  減少環形電路中的 inverter 數量。 提升電壓，但同時會有較大的電流與功耗。     2.","title":"[Device] Ring Oscillator 環形振盪器"},{"content":"List of Generics equality Case In leetcode no. 39 Combination Sum gives\n Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nIt is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be use mutiple times. 7 is a candidate, and 7 = 7. These are the only two combinations.\n List Equality Consider the following case:\nList\u0026lt;Integer\u0026gt; a = Arrays.asList(1,2,3,4); List\u0026lt;Integer\u0026gt; b = Arrays.asList(4,3,2,1); List\u0026lt;Integer\u0026gt; c = Arrays.asList(4,4,3,2,1); If we apply containsAll methods to test List equality in any order, it might work. But it might not test size of List, so it might go wrong when there is repeated items.\nSystem.out.println(b.containsAll(a)) // true System.out.println(c.containsAll(a)) // true How about applying equals methods after sorting the List?\n// apply sort to all to-be-check items. Collections.sort(a); Collections.sort(b); Collections.sort(c);  System.out.println(a.equals(b)); // true System.out.println(a.equals(c)); // false Luckily, List can easily to test elements equality rathan than strict equality of the same object.\nSo, We can see if we want to test List Equality in any order, we can just simply sort List, and apply a.equals(b).\nList of List Equality But in case leetcode no. 39 Combination Sum, list of list of Integer in any order is considered acceptable answer. How do we test list of list of Integer equality?\nclass Solution{  public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target){..}   @Test  public void test(){  Solution sol = new Solution();  expected = List.of(List.of(2,2,3), List.of(7)) // [[2,2,3],[7]]  actual = sol.combinationSum(new int[]{2,3,6,7}  Collections.sort(expected); // fail  Collections.sort(actual); // fail  assertEquals(expected, acutal)  } } The code will fail, and the description shows below.\n The method sort(List) in the type Collections is not applicable for the arguments (List\u0026lt;List\u0026gt;)Java(67108979)\n Thus, we have to turns List of Integers in the List into some other type like String, by using toString(). So, we can do like this:\npublic boolean equalsAnyOrder(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; expected, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; actual){  // First we have to check size of list equaltiy  if (expected == null \u0026amp;\u0026amp; actual == null) return false;  if ((expected == null \u0026amp;\u0026amp; actual != null) || (expected != null \u0026amp;\u0026amp; actual == null) || expected.size() != actual.size()) return false;   // Create List of string to turn List of Integer into strings.  List\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;();  List\u0026lt;String\u0026gt; d = new ArrayList\u0026lt;\u0026gt;();  for (int i = 0; i \u0026lt; expected.size(); i++){  c.add(expected.get(i).toString());  d.add(actual.get(i).toString());  }   // Sort List of strings  Collections.sort(c);  Collections.sort(d);   // Apply simple list equaltiy (We have known List.equals() just test equality of elements in order.)  return c.equals(d); } More materials  Leetcode no.39 Solution Test List of List Equality Implementation Test cases for no.39 by Junit  ","permalink":"http://intervalrain.github.io/posts/java/listequal/","summary":"List of Generics equality Case In leetcode no. 39 Combination Sum gives\n Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.","title":"[Java] List of list of something equality"},{"content":"Rain Hu / intervalrain / \u0008陣雨  Music, coding, and life.\n陣雨 / 音樂使人快樂，也使人憂傷，如同陣雨。\nRain Hu / 寫程式充實生命，在生命的道路上，盲目的前行。\nintervalrain / 人生不過是一場電影或是一首歌，踟躕不如笑一個，然後繼續。\n About me  八年級，青年期的最後一個梯次。\n曾經有過音樂夢，當過吉他老師，組過樂團，當過鼓手，也曾在西餐廳駐唱表演。\n沒有隱疾，只有顯疾。人生周折而困頓，為了現實還是選擇當工程師賣肝。\n喜歡寫程式處理繁瑣重覆的事，然後拿空出來的時間作白日夢。\n喜歡唱歌、彈吉他、聽歌、看書，寫憤世嫉俗的歌，解Leetcode，吃。\n喜歡的食物有壽司、拉麵、鹹蛋苦瓜、菜脯蛋、魚香茄子、香菇雞湯。\n最喜歡的甜點有肉桂捲、可麗露、檸檬塔、藍莓塔、草莓蛋糕。\n最喜歡的水果是削好的蘋果跟切好的火龍果跟奇異果，芒果冰上面的芒果，還有所有莓果類，不能吃楊桃。\nCoffeholic，淺焙，上班日喜歡日曬，假日喜歡水洗，加班的話就蜜處理吧。\n討厭毛、討厭草、討厭昆蟲、討厭KMT、除了自己以外的機掰人。\n如果明天就要死亡的話，我會跟家人一起。\n More about me  Job  Resume   Music  Streetvoice Youtube   Coding  Leetcode Algorithm    Contact  Email Facebook Instagram Twitter LinkedIn  ","permalink":"http://intervalrain.github.io/posts/aboutme/","summary":"Rain Hu / intervalrain / \u0008陣雨  Music, coding, and life.\n陣雨 / 音樂使人快樂，也使人憂傷，如同陣雨。\nRain Hu / 寫程式充實生命，在生命的道路上，盲目的前行。\nintervalrain / 人生不過是一場電影或是一首歌，踟躕不如笑一個，然後繼續。\n About me  八年級，青年期的最後一個梯次。\n曾經有過音樂夢，當過吉他老師，組過樂團，當過鼓手，也曾在西餐廳駐唱表演。\n沒有隱疾，只有顯疾。人生周折而困頓，為了現實還是選擇當工程師賣肝。\n喜歡寫程式處理繁瑣重覆的事，然後拿空出來的時間作白日夢。\n喜歡唱歌、彈吉他、聽歌、看書，寫憤世嫉俗的歌，解Leetcode，吃。\n喜歡的食物有壽司、拉麵、鹹蛋苦瓜、菜脯蛋、魚香茄子、香菇雞湯。\n最喜歡的甜點有肉桂捲、可麗露、檸檬塔、藍莓塔、草莓蛋糕。\n最喜歡的水果是削好的蘋果跟切好的火龍果跟奇異果，芒果冰上面的芒果，還有所有莓果類，不能吃楊桃。\nCoffeholic，淺焙，上班日喜歡日曬，假日喜歡水洗，加班的話就蜜處理吧。\n討厭毛、討厭草、討厭昆蟲、討厭KMT、除了自己以外的機掰人。\n如果明天就要死亡的話，我會跟家人一起。\n More about me  Job  Resume   Music  Streetvoice Youtube   Coding  Leetcode Algorithm    Contact  Email Facebook Instagram Twitter LinkedIn  ","title":"About me"},{"content":"How to say hello to the world?\nJava class Hello{  public static void main(String[] args){  System.out.println(\u0026#34;Hello World!\u0026#34;);  } } C #include \u0026lt;stdio.h\u0026gt; int main(){  printf(\u0026#34;Hello World!\u0026#34;);  return 0; } C++ #include \u0026lt;iostream\u0026gt; int main(){  std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl;  return 0; } ###C#\nnamespace HelloWorld{  class Hello{  static void Main(String[] args){  System.Console.WriteLine(\u0026#34;Hello World!\u0026#34;);  }  } } Python print(\u0026#34;Hello World!\u0026#34;) Ruby puts \u0026#39;Hello World!\u0026#39; TCL Language puts \u0026#34;Hello World!\u0026#34; JavaScript console.log(\u0026#34;Hello World!\u0026#34;); TypeScript console.log \u0026#39;Hello World!\u0026#39; Perl print \u0026#34;Hello World!\u0026#34;; R cat(\u0026#39;Hello World!\u0026#39;); Swift println(\u0026#39;Hello World!\u0026#39;); Kotlin fun main(args: Array\u0026lt;String\u0026gt;){  println(\u0026#34;Hello World!\u0026#34;) } Go println(\u0026#39;Hello World!\u0026#39;); PHP echo \u0026#34;Hello World!\u0026#34;; VBA msgbox \u0026#34;Hello World\u0026#34; Assembly Language global _main extern _printf section .text _main: push message call _printf add esp, 4 message: db \u0026#39;Hello World!\u0026#39;, 11, 0 Me Hello the fucking world ","permalink":"http://intervalrain.github.io/posts/helloworld/","summary":"How to say hello to the world?\nJava class Hello{  public static void main(String[] args){  System.out.println(\u0026#34;Hello World!\u0026#34;);  } } C #include \u0026lt;stdio.h\u0026gt; int main(){  printf(\u0026#34;Hello World!\u0026#34;);  return 0; } C++ #include \u0026lt;iostream\u0026gt; int main(){  std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl;  return 0; } ###C#\nnamespace HelloWorld{  class Hello{  static void Main(String[] args){  System.Console.WriteLine(\u0026#34;Hello World!\u0026#34;);  }  } } Python print(\u0026#34;Hello World!","title":"Hello World"},{"content":"Review  組合電路設計  建構真值表將輸出表示成輸入的函式 \\(\\text{Inputs}\\rightarrow\\boxed{\\text{MUX}}\\rightarrow\\text{Outputs}\\) 用 K-map, Q-M method 等方法得到簡化的布林表達式   多層、多輸出的電路(Multi-level \u0026amp; Multi-outputs) Mininum SOP 起點  Minimum two-level \\(\\text{AND-OR, NAND-NAND, OR-NAND, NOR-OR}\\)   Minimum POS 起點  Minimum two-level \\(\\text{OR-AND, NOR-NOR, AND-NOR, NAND-AND}\\)    限制 fan-in 數的電路設計  Ex1  \\(\\text{用 3 pin 的 NOR Gate 實現}f(a,b,c,d)=\\sum m(0,3,4,5,8,9,10,14,15)\\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 01\u0026amp; 0\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 11\u0026amp; 1\u0026amp; 0\u0026amp; 1\u0026amp; 0\\\\\\hline 10\u0026amp; 0\u0026amp; 0\u0026amp; 1\u0026amp; 1\\\\\\hline \\end{array}\\) 從 POS 開始 \\(f\u0026rsquo;=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; d+ab\u0026rsquo; cd+abc\u0026rsquo; + a\u0026rsquo; bc+a\u0026rsquo; cd\u0026rsquo;\\\\ \\quad=b\u0026rsquo; d(a\u0026rsquo; c\u0026rsquo;+ac)+a\u0026rsquo; c(b+d\u0026rsquo;)+abc\u0026rsquo;\\)     Ex2 Multiple-Output  \\(\\text{用 2 pin 的 NAND 與 NOT 實現}\\) \\(f_1=\\sum m(0,2,3,4,5)=b\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; +a\u0026rsquo; b\\\\ f_2=\\sum m(0,2,3,4,7)=b\u0026rsquo; c\u0026rsquo;+bc+a\u0026rsquo; b\\\\ f_3=\\sum m(1,2,6,7)=a\u0026rsquo; b\u0026rsquo; c+ab+bc\u0026rsquo;\\) \\(\\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp;1\\\\\\hline 11\u0026amp;1\u0026amp; \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp;1 \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp; \u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp;1\\\\\\hline 10\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) \\(f_1=b\u0026rsquo;(a+c\u0026rsquo;)+a\u0026rsquo; b\\\\ f_2=(b\u0026rsquo;+c)(b+c\u0026rsquo;)+b\u0026rsquo; c\u0026rsquo;\\\\ f_3=b(a+c\u0026rsquo;)+a\u0026rsquo; b\u0026rsquo; c\\)     閘延遲與時序圖  邏輯閘必然存在延遲，固然小，但存在。  組合電路  延遲亦可能來自電線，電線愈長則延遲可能愈久。  Control value  \\(\\text{AND gate}\\) 的 control value 是 \\(0\\) \\(\\text{OR gate}\\) 的 control value 是 \\(1\\) \\(\\text{AND=2ns}\\\\ \\text{NOR=3ns}\\)   若 X 訊號相反時， Z 要到 5ns 訊號才有意義。  組合邏輯中的 Hazards 邏輯電路的模擬與測試 ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec7/","summary":"Review  組合電路設計  建構真值表將輸出表示成輸入的函式 \\(\\text{Inputs}\\rightarrow\\boxed{\\text{MUX}}\\rightarrow\\text{Outputs}\\) 用 K-map, Q-M method 等方法得到簡化的布林表達式   多層、多輸出的電路(Multi-level \u0026amp; Multi-outputs) Mininum SOP 起點  Minimum two-level \\(\\text{AND-OR, NAND-NAND, OR-NAND, NOR-OR}\\)   Minimum POS 起點  Minimum two-level \\(\\text{OR-AND, NOR-NOR, AND-NOR, NAND-AND}\\)    限制 fan-in 數的電路設計  Ex1  \\(\\text{用 3 pin 的 NOR Gate 實現}f(a,b,c,d)=\\sum m(0,3,4,5,8,9,10,14,15)\\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 01\u0026amp; 0\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 11\u0026amp; 1\u0026amp; 0\u0026amp; 1\u0026amp; 0\\\\\\hline 10\u0026amp; 0\u0026amp; 0\u0026amp; 1\u0026amp; 1\\\\\\hline \\end{array}\\) 從 POS 開始 \\(f\u0026rsquo;=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; d+ab\u0026rsquo; cd+abc\u0026rsquo; + a\u0026rsquo; bc+a\u0026rsquo; cd\u0026rsquo;\\\\ \\quad=b\u0026rsquo; d(a\u0026rsquo; c\u0026rsquo;+ac)+a\u0026rsquo; c(b+d\u0026rsquo;)+abc\u0026rsquo;\\)     Ex2 Multiple-Output  \\(\\text{用 2 pin 的 NAND 與 NOT 實現}\\) \\(f_1=\\sum m(0,2,3,4,5)=b\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; +a\u0026rsquo; b\\\\ f_2=\\sum m(0,2,3,4,7)=b\u0026rsquo; c\u0026rsquo;+bc+a\u0026rsquo; b\\\\ f_3=\\sum m(1,2,6,7)=a\u0026rsquo; b\u0026rsquo; c+ab+bc\u0026rsquo;\\) \\(\\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp;1\\\\\\hline 11\u0026amp;1\u0026amp; \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp;1 \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp; \u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp;1\\\\\\hline 10\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) \\(f_1=b\u0026rsquo;(a+c\u0026rsquo;)+a\u0026rsquo; b\\\\ f_2=(b\u0026rsquo;+c)(b+c\u0026rsquo;)+b\u0026rsquo; c\u0026rsquo;\\\\ f_3=b(a+c\u0026rsquo;)+a\u0026rsquo; b\u0026rsquo; c\\)     閘延遲與時序圖  邏輯閘必然存在延遲，固然小，但存在。  組合電路  延遲亦可能來自電線，電線愈長則延遲可能愈久。  Control value  \\(\\text{AND gate}\\) 的 control value 是 \\(0\\) \\(\\text{OR gate}\\) 的 control value 是 \\(1\\) \\(\\text{AND=2ns}\\\\ \\text{NOR=3ns}\\)   若 X 訊號相反時， Z 要到 5ns 訊號才有意義。  組合邏輯中的 Hazards 邏輯電路的模擬與測試 ","title":"[Logic Design] Lec 7 - 組合電路設計與閘模擬"},{"content":"Multi-level gate circuits  如何決定 level 數：  Gate input number \u0026amp; Delay determine level Factoring to accomplish different level   AND-OR: 2-level SOP OR-AND: 2-level POS OR-AND-OR: 3-level circuit of AND and OR → no particular ordering   4 level gates: \\(\\text{Z=(AB+C)(FG+D+E)+H}\\)  3 level gates: (case fan out) \\(\\text{AB(D+E)+C(D+E)+ABFG+CFG+H}\\)  Factoring 可變成 4-level \\(\\text{(AB+C)(D+E+FG)+H}\\)    level \u0026amp; gate \u0026amp; gate inputs 的關係會隨之變化，可根據電路設計的需求改變  範例：  \\( \\begin{array}{llll} f(a,b,c,d)=\\sum(1,5,6,10,13,14)\\\\ f=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]\u0026amp;\\text{4 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;)\u0026amp;\\text{3 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=c\u0026rsquo; d(a\u0026rsquo;+b)+cd\u0026rsquo;(a+b)\u0026amp;\\text{3 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{12 gate inputs} \\end{array} \\) \\( \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;m_0\u0026amp;m_4\u0026amp;m_{12}\u0026amp;m_{8}\\\\\\hline 01\u0026amp;m_1\u0026amp;m_5\u0026amp;m_{13}\u0026amp;m_{9}\\\\\\hline 11\u0026amp;m_3\u0026amp;m_7\u0026amp;m_{15}\u0026amp;m_{11}\\\\\\hline 10\u0026amp;m_2\u0026amp;m_6\u0026amp;m_{14}\u0026amp;m_{10} \\end{array}}\\rightarrow \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline 11\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 10\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\) \\(\\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo; d\u0026rsquo;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline c\u0026rsquo; d\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline cd\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline cd\u0026rsquo;\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\\\ =a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;=(a\u0026rsquo;+b)c\u0026rsquo; d+(a+b)cd\u0026rsquo;\\\\ =(c\u0026rsquo; d\u0026rsquo;+ab\u0026rsquo; c\u0026rsquo;+cd+a\u0026rsquo; b\u0026rsquo; c)\u0026rsquo;=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\\\\ =[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;) \\)    NAND and NOR gates NAND  符號  真值表\n\\(\\boxed{\\begin{array}{cc|cc} A\u0026amp;B\u0026amp;AB\u0026amp;\\overline{AB}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array}} \\) 布林表達式：\n\\(F=(ABC)\u0026rsquo;=A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;\\)  NOR  符號  真值表\n\\(\\boxed{\\begin{array}{cc|cc} A\u0026amp;B\u0026amp;AB\u0026amp;\\overline{AB}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array}} \\) 布林表達式：  \\(F=(A+B+C)\u0026rsquo;=A\u0026rsquo; B\u0026rsquo; C\u0026rsquo;\\)    Functionally Complete Sets of Gates  定義：當所有的布林式皆可以被這組邏輯閘組合而成，則這組邏輯閘為 Functionally Complete  \\(\\lbrace{\\text{AND, OR, NOT}}\\rbrace\\) \\(\\lbrace{\\text{AND, NOT}}\\rbrace\\rightarrow \\text{OR}=X+Y=(X\u0026rsquo; Y\u0026rsquo;)\u0026rsquo;\\) \\(\\lbrace{\\text{OR, NOT}}\\rbrace\\rightarrow \\text{AND}=XY=(X\u0026rsquo;+Y\u0026rsquo;)\u0026rsquo;\\) \\(\\lbrace{\\text{NAND}}\\rbrace\\) \\(\\lbrace{\\text{NOR}}\\rbrace\\) \\(\\lbrace{\\text{3-input Minority Gate}}\\rbrace\\)    Majority Gate and Minority Gate  真值表\n\\(\\boxed{\\begin{array}{ccc|cc} A\u0026amp;B\u0026amp;C\u0026amp;F_M\u0026amp;F_m\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array}}\\)  \\(\\text{(0, B, C)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{NAND}=\\text{(BC)\u0026rsquo;=\\text{B\u0026rsquo;+C\u0026rsquo;}}\\) \\(\\text{(1, B, C)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{NOR}=\\text{(B+C)\u0026rsquo;=\\text{B\u0026rsquo;C\u0026rsquo;}}\\) \\(\\text{(A, A, A)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{NOT}=\\text{A\u0026rsquo;}\\) \\(\\text{(0, B\u0026rsquo;, C\u0026rsquo;)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{AND}=\\text{BC}\\) \\(\\text{(1, B\u0026rsquo;, C\u0026rsquo;)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{OR}=\\text{B+C}\\)    2-level NAND and NOR gates DeMorgon\u0026rsquo;s Law  等效邏輯閘： \\((A+B)\u0026rsquo;=A\u0026rsquo; B\u0026rsquo;\\) \\((AB)\u0026rsquo;=A\u0026rsquo;+B\u0026rsquo;\\) \\(A+B=(A\u0026rsquo; B\u0026rsquo;)\u0026rsquo;\\) \\(AB=(A\u0026rsquo;+B\u0026rsquo;)\u0026rsquo;\\)   \\(\\text{Ex1: AND/OR}\\rightarrow\\text{NAND/NAND}\\)     \\(\\text{Ex2: AND/OR}\\rightarrow\\text{NOR/NOR}\\)      Multi-level NAND and NOR circuits  Multi-level NAND and NOR circuits  \\(\\text{to NAND gate}\\)\n \\(\\text{to NOR gate}\\)     Multi-output circuit realization  實際一個多工器(multiplexer)內的電路實現，可以用 fan out 的方式達到最佳化。 整體最佳不一定代表個別都為最佳。 實作1:  \\(F_1(A,B,C,D)=\\sum m(11,12,13,14,15) =AB+ACD \\\\ F_2(A,B,C,D)=\\sum m(3,7,11,12,13,15)=ABC\u0026rsquo;+CD\\\\ F_3(A,B,C,D)=\\sum m(3,7,12,13,14,15)=A\u0026rsquo; CD+AB\\\\ \\) \\( \\begin{array}{|c|c|c|c|c|}\\hline F_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; 1\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline F_2\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 11\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; 1\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline F_3\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;1 \u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp;1 \u0026amp; \\\\\\hline 11\u0026amp; 1\u0026amp;1 \u0026amp;1 \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; \u0026amp;1 \u0026amp; \\\\\\hline \\end{array} \\) \\(\\text{9 Gates, 21 Gate inputs}\\rightarrow\\text{7 Gates, 18 Gate inputs}\\) \\(\\text{Share AB(fan out)}\\) \\(\\text{A\u0026rsquo;CD+ACD=CD}\\)  \\(F_1(A,B,C,D)=AB+ACD \\\\ F_2(A,B,C,D)=ABC\u0026rsquo;+ACD+A\u0026rsquo; CD\\\\ F_3(A,B,C,D)=A\u0026rsquo; CD+AB\\\\ \\lbrace{AB,A\u0026rsquo; CD,ACD,ABC\u0026rsquo;}\\rbrace \\)      實作2:  \\(f_1=\\sum m(2,3,5,7,8,9,10,11,13,15)=bd+b\u0026rsquo; c+ab\u0026rsquo;\\\\ f_2=\\sum m(2,3,5,6,7,10,11,14,15)=a\u0026rsquo; bd+c\\\\ f_3=\\sum m(6,7,8,9,13,14,15)=bc+ab\u0026rsquo; c\u0026rsquo;+abd\\\\ \\rightarrow\\text{10 Gates, 25 Gate inputs} \\) \\( \\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp;1 \\\\\\hline 01\u0026amp; \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline 11\u0026amp;1 \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline 10\u0026amp;1 \u0026amp; \u0026amp; \u0026amp;1 \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_2\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 01\u0026amp; \u0026amp;1 \u0026amp; \u0026amp; \\\\\\hline 11\u0026amp;1 \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline 10\u0026amp;1 \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_3\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp;1 \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp;1 \u0026amp;1 \\\\\\hline 11\u0026amp; \u0026amp;1 \u0026amp;1 \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp;1 \u0026amp;1 \u0026amp; \\\\\\hline \\end{array} \\) \\( \\text{(1) } b\u0026rsquo; c+bc = c\\\\ \\text{(2) } a\u0026rsquo; bd+abd = bd\\\\ \\text{用}\\lbrace{b\u0026rsquo; c, bc, a\u0026rsquo;bd, abd, ab\u0026rsquo; c\u0026rsquo;}\\rbrace\\text{組合上例} \\) \\( f_1=b\u0026rsquo; c+(abd+a\u0026rsquo; bd)+ab\u0026rsquo; c\u0026rsquo;\\\\ f_2=(b\u0026rsquo; c+ bc)+a\u0026rsquo; bd\\\\ f_3=bc+abd+ab\u0026rsquo; c\u0026rsquo;\\\\ \\lbrace {b\u0026rsquo; c,bc,abd,a\u0026rsquo; bd,ab\u0026rsquo; c\u0026rsquo;}\\rbrace\\\\ \\rightarrow\\text{8 Gates, 23 Gate inputs} \\)   實作3:  \\( f_1=\\sum m(1,5,9,13,15)=c\u0026rsquo; d+abd\\\\ f_2=\\sum m(4,6,12,14,15)=bd\u0026rsquo;+abc\\\\ \\rightarrow\\text{6 Gates, 14 Gate inputs} \\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 01\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; 1\\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_2\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline \\end{array}\\) 使上面兩式共用 \\(abcd\\) \\( f_1=c\u0026rsquo; d+abcd\\\\ f_2=bd\u0026rsquo;+abcd\\\\ \\rightarrow\\text{5 Gates, 12 Gate inputs} \\)   實作4:  \\( f_1=\\sum m(0,3,4,5,6,14)=a\u0026rsquo; c\u0026rsquo; d\u0026rsquo;+a\u0026rsquo; bc\u0026rsquo;+a\u0026rsquo; cd\u0026rsquo;+bcd\u0026rsquo;\\\\ f_2=\\sum m(0,1,4,6,8,10)=a\u0026rsquo; c\u0026rsquo; d\u0026rsquo;+bc\u0026rsquo; d\u0026rsquo;+a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;+bcd\u0026rsquo;\\\\ \\rightarrow\\text{8 Gates, 26 Gate inputs} \\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; \u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; 1\u0026amp; \u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; 1\u0026amp; \u0026amp; \u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline \\end{array} \\) 不 combine 各自做最佳化 \\( f_1=a\u0026rsquo; d\u0026rsquo;+a\u0026rsquo; bc\u0026rsquo;+bcd\u0026rsquo;\\\\ f_2=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;+bd\u0026rsquo;\\\\ \\rightarrow\\text{7 Gates, 18 Gate Inputs} \\)    多輸出電路的基本質函項  參考實作3，若基本質函項可通過多工器中其他的輸入共用的話，則對多輸出電路而言並非基本質函項(Essential prime terms)。 參考實作4，\\(a\u0026rsquo; d\u0026rsquo;(m_2),a\u0026rsquo; bc\u0026rsquo;(m_5), a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;(m_1), bd\u0026rsquo;(m_{12})\\)皆為基本質函項。 一般而言，不會為了共享而把基本質函項拆開。  和項共用(Shared by sum terms)  真值表\n\\(\\begin{array}{|cccc|cccc:c|}\\hline a\u0026amp;b\u0026amp;c\u0026amp;d\u0026amp;w\u0026amp;x\u0026amp;y\u0026amp;z\u0026amp;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;2\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;3\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;4\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;5\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;6\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;7\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;8\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;9\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline \\end{array}\\) k-map\n\\(\\begin{array}{|c|c|c|c|c||}\\hline w\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; X\u0026amp; 1\\\\\\hline 01\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; 1\\\\\\hline 11\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline \\end{array} \\begin{array}{|c|c|c|c|c||}\\hline x\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; \\\\\\hline 01\u0026amp; 1\u0026amp; \u0026amp; X\u0026amp; 1\\\\\\hline 11\u0026amp; 1\u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; 1\u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline \\end{array} \\begin{array}{|c|c|c|c|c||}\\hline y\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; 1\\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; X\u0026amp; \\\\\\hline 11\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline \\end{array} \\begin{array}{|c|c|c|c|c|}\\hline z\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; 1\\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; X\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline \\end{array}\\) \\(w=a+bc+bd=a+b(c+d)\\\\ x=bc\u0026rsquo; d\u0026rsquo;+b\u0026rsquo; d+b\u0026rsquo; c=bc\u0026rsquo; d\u0026rsquo;+b\u0026rsquo;(c+d)\\\\ y=c\u0026rsquo; d\u0026rsquo;+cd\\\\ z=d' \\) Sum terms 也可以 share Multi-output circuits 也可以只用 \\(\\text{NAND/NOR}\\) 表示  Multi-Output NAND/NOR circuits  範例 \\(\\text{to NAND}\\)  \\(\\text{to NOR}\\)     ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec6/","summary":"Multi-level gate circuits  如何決定 level 數：  Gate input number \u0026amp; Delay determine level Factoring to accomplish different level   AND-OR: 2-level SOP OR-AND: 2-level POS OR-AND-OR: 3-level circuit of AND and OR → no particular ordering   4 level gates: \\(\\text{Z=(AB+C)(FG+D+E)+H}\\)  3 level gates: (case fan out) \\(\\text{AB(D+E)+C(D+E)+ABFG+CFG+H}\\)  Factoring 可變成 4-level \\(\\text{(AB+C)(D+E+FG)+H}\\)    level \u0026amp; gate \u0026amp; gate inputs 的關係會隨之變化，可根據電路設計的需求改變  範例：  \\( \\begin{array}{llll} f(a,b,c,d)=\\sum(1,5,6,10,13,14)\\\\ f=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]\u0026amp;\\text{4 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;)\u0026amp;\\text{3 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=c\u0026rsquo; d(a\u0026rsquo;+b)+cd\u0026rsquo;(a+b)\u0026amp;\\text{3 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{12 gate inputs} \\end{array} \\) \\( \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;m_0\u0026amp;m_4\u0026amp;m_{12}\u0026amp;m_{8}\\\\\\hline 01\u0026amp;m_1\u0026amp;m_5\u0026amp;m_{13}\u0026amp;m_{9}\\\\\\hline 11\u0026amp;m_3\u0026amp;m_7\u0026amp;m_{15}\u0026amp;m_{11}\\\\\\hline 10\u0026amp;m_2\u0026amp;m_6\u0026amp;m_{14}\u0026amp;m_{10} \\end{array}}\\rightarrow \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline 11\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 10\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\) \\(\\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo; d\u0026rsquo;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline c\u0026rsquo; d\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline cd\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline cd\u0026rsquo;\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\\\ =a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;=(a\u0026rsquo;+b)c\u0026rsquo; d+(a+b)cd\u0026rsquo;\\\\ =(c\u0026rsquo; d\u0026rsquo;+ab\u0026rsquo; c\u0026rsquo;+cd+a\u0026rsquo; b\u0026rsquo; c)\u0026rsquo;=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\\\\ =[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;) \\)    NAND and NOR gates NAND  符號  真值表","title":"[Logic Design] Lec 6 - Multi-Level Gate Circuits / NAND and NOR Gates"},{"content":"概要  當變數愈來愈多時，很難依靠人眼判斷，所以必須計設系統化的簡化過程讓電腦運行。 系統化的簡化過程  輸入：minterm expansion 輸出：minimum SOP 步驟：  找出所有質函項，並試著將和項消除到不能再消，利用\\(XY+XY\u0026rsquo;=X\\) \u0008利用質函項圖找出最小解        範例：\\(F(a,b,c)=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; + ab\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; c+ abc\\)  \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo;\u0026amp;1\u0026amp;\u0026amp;\u0026amp;1\\\\\\hline c\u0026amp;\u0026amp;\u0026amp;1\u0026amp;1 \\end{array} } \\) 所有蘊函項：\\(a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c, abc, ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 質函項：\\(ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 基本質函項：\\(b\u0026rsquo; c\u0026rsquo;, ac\\) Min SOP：\\(F(a,b,c)=b\u0026rsquo; c\u0026rsquo;+ac\\)    決定質函項(prime implicants)  找出所有質函項  將每個 minterm 以二進制表示。 統計每個項的1的數量作為 index 並分群。 將分完群的 minterm 以 index 排列。 從 index 最小開始，往 index + 1 的群，尋找可以用\\(XY+XY\u0026rsquo;=X\\)簡化的組合 檢查所有的項都合併成組合，留下來的項即為質函項。 重複步驟 4 到 步驟 5 直到沒有函項可以合併。\n被打勾表示不是質函項(prime implicants)   範例：\\(f(a,b,c,d)=\\sum m(0,1,2,5,6,7,8,9,10,14)\\)  \\(f(a,b,c,d)=P1+P2+P3+P4+P5+P6\\) \\(f(a,b,c,d)=a\u0026rsquo; c\u0026rsquo; d+a\u0026rsquo; bd+a\u0026rsquo; bc+cd\u0026rsquo;+b\u0026rsquo; d\u0026rsquo;+b\u0026rsquo; c\u0026rsquo;\\) \\(\\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|cc} \u0026amp;\\text{Column I}\\\\\\hline m_0\u0026amp;0000\u0026amp;\\checkmark\\\\\\hline m_1\u0026amp;0001\u0026amp;\\checkmark\\\\ m_2\u0026amp;0010\u0026amp;\\checkmark\\\\ m_8\u0026amp;1000\u0026amp;\\checkmark\\\\\\hline m_5\u0026amp;0101\u0026amp;\\checkmark\\\\ m_6\u0026amp;0110\u0026amp;\\checkmark\\\\ m_9\u0026amp;1001\u0026amp;\\checkmark\\\\ m_{10}\u0026amp;1010\u0026amp;\\checkmark\\\\\\hline m_7\u0026amp;0111\u0026amp;\\checkmark\\\\ m_{14}\u0026amp;1110\u0026amp;\\checkmark \\end{array} }\\) \\(\\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|cc} \u0026amp;\\text{Column II}\\\\\\hline m_0,m_1\u0026amp;000.\u0026amp;\\checkmark\\\\ m_0,m_2\u0026amp;00.0\u0026amp;\\checkmark\\\\ m_0,m_8\u0026amp;.000\u0026amp;\\checkmark\\\\\\hline m_1,m_5\u0026amp;0.01\u0026amp;\\text{P1}\\\\ m_1,m_9\u0026amp;.001\u0026amp;\\checkmark\\\\ m_2,m_6\u0026amp;0.10\u0026amp;\\checkmark\\\\ m_2,m_{10}\u0026amp;.010\u0026amp;\\checkmark\\\\ m_8,m_9\u0026amp;100.\u0026amp;\\checkmark\\\\ m_8,m_{10}\u0026amp;10.0\u0026amp;\\checkmark\\\\\\hline m_5,m_7\u0026amp;01.1\u0026amp;\\text{P2}\\\\ m_6,m_7\u0026amp;011.\u0026amp;\\text{P3}\\\\ m_6,m_{14}\u0026amp;.110\u0026amp;\\checkmark\\\\ m_{10},m_{14}\u0026amp;1.10\u0026amp;\\checkmark \\end{array} }\\) \\(\\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|cc} \u0026amp;\\text{Column III}\\\\\\hline m_0,m_1,m_8,m_9\u0026amp;.00.\u0026amp;\\text{P4}\\\\ m_0,m_2,m_8,m_{10}\u0026amp;.0.0\u0026amp;\\text{P5}\\\\ \\sout{m_0,m_8,m_1,m_9}\u0026amp;\\sout{.00.}\\\\ \\sout{m_0,m_8,m_2,m_{10}}\u0026amp;\\sout{.0.0}\\\\\\hline m_2,m_6,m_{10},m_{14}\u0026amp;..10\u0026amp;\\text{P6}\\\\ \\sout{m_2,m_{10},m_6,m_{14}}\u0026amp;\\sout{..10}\\\\ \\end{array} } \\)    質函項圖(表)  範例  \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{r|l|c|cccccccccc} \u0026amp; \u0026amp; \u0026amp;0\u0026amp;1\u0026amp;2\u0026amp;5\u0026amp;6\u0026amp;7\u0026amp;8\u0026amp;9\u0026amp;10\u0026amp;14\\\\\\hline 0, 1, 8, 9\u0026amp;b\u0026rsquo; c\u0026rsquo; \u0026amp;P6\u0026amp;\\checkmark\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\oplus\\\\ 0, 2, 8,10\u0026amp;b\u0026rsquo; d\u0026rsquo; \u0026amp;P5\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ 2, 6,10,14\u0026amp;c d\u0026rsquo; \u0026amp;P4\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\oplus\\\\ 1, 5\u0026amp;a\u0026rsquo; c\u0026rsquo; d\u0026amp;P1\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ 5, 7\u0026amp;a\u0026rsquo; bd \u0026amp;P2\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ 6, 7\u0026amp;a\u0026rsquo; bc \u0026amp;P3\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ \\end{array} } \\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{r|l|c|cccccccccc} \u0026amp;\u0026amp;\u0026amp;5\u0026amp;7\\\\\\hline 1,5\u0026amp;a\u0026rsquo; c\u0026rsquo;d\u0026amp;P1\u0026amp;\\checkmark\\\\ 5,7\u0026amp;a\u0026rsquo; bd \u0026amp;P2\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ 6,7\u0026amp;a\u0026rsquo; bc \u0026amp;P3\u0026amp;\u0026amp;\\checkmark\\\\ \\end{array} } \\) 優先選 \\(\\oplus\\)的質函項(只出現過一次，代表是基本質函項)，如範例\\(P6與P4\\)。 刪除選出的質函項後化簡成更簡化的質函項圖。 選可以同時照顧到最多函項的質函項。 \\(\\rightarrow f(a,b,c)=P2+P4+P6=a\u0026rsquo; bd+cd\u0026rsquo;+b\u0026rsquo; c\u0026rsquo;\\) (若沒有基本質函項時，有可以有多個最佳解)    Petrick\u0026rsquo;s method  用來解出質函項圖的所有 min SOP 解。 在使用 Petrick 法前，需將所有基本質函項與其函蓋的 minterms 從表上劃掉。 範例：\\(F=\\sum m(0,1,2,5,6,7)\\)\n\\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{r|l|c|cccccc} P1\u0026amp;0,1\u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ P2\u0026amp;0,2\u0026amp;a\u0026rsquo; c\u0026rsquo;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P3\u0026amp;1,5\u0026amp;b\u0026rsquo; c \u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P4\u0026amp;2,6\u0026amp;b c\u0026rsquo;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P5\u0026amp;5,7\u0026amp;a c \u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P6\u0026amp;6,7\u0026amp;a b \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ \\end{array} } \\)  \\(\\def\\arraystretch{1.4}\\begin{array}{l} 0\\rightarrow P1+P2\\\\ 1\\rightarrow P1+P3\\\\ 2\\rightarrow P2+P4\\\\ 5\\rightarrow P3+P5\\\\ 6\\rightarrow P4+P6\\\\ 7\\rightarrow P5+P6\\\\ \\end{array}\\) \\(P=(P1+P2)(P1+P3)(P2+P4)(P3+P5)(P4+P6)(P5+P6)=1\\) \\(P=(P1+P2P3)(P4+P2P6)(P5+P3P6)\\) \\(P=P1P4P5+P1P2P5P6+P2P3P4P5+P2P3P5P6+P1P3P4P6+P1P2P3P6+P2P3P4P6+P2P3P6\\) 刪掉含有\\(P2P3P6\\)的和項 \\(P=P1P4P5+P1P2P5P6+P2P3P4P5+P1P3P4P6+P2P3P6\\) \\(\\text{min Sol:}\\)  \\(F=P1+P4+P5=a\u0026rsquo; b\u0026rsquo;+bc\u0026rsquo;+ac\\) \\(F=P2+P3+P6=a\u0026rsquo; c\u0026rsquo;+b\u0026rsquo; c+ab\\)      考慮 Don\u0026rsquo;t Care 的情形  稍微修改一下 Quine-McClusky 方法  找出所有質函項：將DC視為minterms 建構出質函項表：DC不必列在表頭   範例：\\(F(A,B,C,D)=\\sum m(2,3,7,9,11,13)+\\sum d(1,10,15)\\)  \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{rrl} 1\u0026amp;0001\u0026amp;\\checkmark\\\\ 2\u0026amp;0010\u0026amp;\\checkmark\\\\\\hline 3\u0026amp;0011\u0026amp;\\checkmark\\\\ 9\u0026amp;1001\u0026amp;\\checkmark\\\\ 10\u0026amp;1010\u0026amp;\\checkmark\\\\\\hline 7\u0026amp;0111\u0026amp;\\checkmark\\\\ 11\u0026amp;1011\u0026amp;\\checkmark\\\\ 13\u0026amp;1101\u0026amp;\\checkmark\\\\\\hline 15\u0026amp;1111\u0026amp;\\checkmark \\end{array}}\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{rrl} 1,3\u0026amp;00.1\u0026amp;\\checkmark\\\\ 1,9\u0026amp;.001\u0026amp;\\checkmark\\\\ 2,3\u0026amp;001.\u0026amp;\\checkmark\\\\ 2,10\u0026amp;.01.\u0026amp;\\checkmark\\\\\\hline 3,7\u0026amp;0.11\u0026amp;\\checkmark\\\\ 3,11\u0026amp;.011\u0026amp;\\checkmark\\\\ 9,11\u0026amp;10.1\u0026amp;\\checkmark\\\\ 9,13\u0026amp;1.01\u0026amp;\\checkmark\\\\ 10,11\u0026amp;101.\u0026amp;\\checkmark\\\\\\hline 7,15\u0026amp;.111\u0026amp;\\checkmark\\\\ 11,15\u0026amp;1.11\u0026amp;\\checkmark\\\\ 13,15\u0026amp;11.1\u0026amp;\\checkmark\\\\ \\end{array}}\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{rrl} 1,3,9,11\u0026amp;.0.1\\\\ 2,3,10,11,\u0026amp;.01.\\\\ 3,7,11,15\u0026amp;..11\\\\ 9,11,13,15\u0026amp;1..1\\\\ \\end{array}}\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{r|cccccc} \u0026amp;2\u0026amp;3\u0026amp;7\u0026amp;9\u0026amp;11\u0026amp;13\\\\\\hline 1,3,9,11\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ *2,3,10,11\u0026amp;\\oplus\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\\checkmark\\\\ *3,7,11,15\u0026amp;\u0026amp;\\checkmark\u0026amp;\\oplus\u0026amp;\u0026amp;\\checkmark\\\\ *9,11,13,15\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\u0026amp;\\oplus\\\\ \\end{array}}\\) \\(F=B\u0026rsquo; C+CD+AD\\) 其中 1 被當作 0，10、15當作1。    ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec5/","summary":"概要  當變數愈來愈多時，很難依靠人眼判斷，所以必須計設系統化的簡化過程讓電腦運行。 系統化的簡化過程  輸入：minterm expansion 輸出：minimum SOP 步驟：  找出所有質函項，並試著將和項消除到不能再消，利用\\(XY+XY\u0026rsquo;=X\\) \u0008利用質函項圖找出最小解        範例：\\(F(a,b,c)=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; + ab\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; c+ abc\\)  \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo;\u0026amp;1\u0026amp;\u0026amp;\u0026amp;1\\\\\\hline c\u0026amp;\u0026amp;\u0026amp;1\u0026amp;1 \\end{array} } \\) 所有蘊函項：\\(a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c, abc, ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 質函項：\\(ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 基本質函項：\\(b\u0026rsquo; c\u0026rsquo;, ac\\) Min SOP：\\(F(a,b,c)=b\u0026rsquo; c\u0026rsquo;+ac\\)    決定質函項(prime implicants)  找出所有質函項  將每個 minterm 以二進制表示。 統計每個項的1的數量作為 index 並分群。 將分完群的 minterm 以 index 排列。 從 index 最小開始，往 index + 1 的群，尋找可以用\\(XY+XY\u0026rsquo;=X\\)簡化的組合 檢查所有的項都合併成組合，留下來的項即為質函項。 重複步驟 4 到 步驟 5 直到沒有函項可以合併。","title":"[Logic Design] Lec 5 - Quine-McClusky Method"},{"content":"布林邏輯式的簡化  卡諾圖(Karnaugh Maps, K-maps)是一種簡單、快速的簡化布林邏輯的方法。  SOP  將布林邏輯化簡成最簡SOP(Minimum Sum of products)  \\(F=A\u0026rsquo; B\u0026rsquo; C\u0026rsquo;+A\u0026rsquo; B\u0026rsquo; C+A\u0026rsquo; BC\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo; +ABC\\) \\(F=A\u0026rsquo; B\u0026rsquo;+B\u0026rsquo; C+BC\u0026rsquo;+AB\\) \\(F=A\u0026rsquo; B\u0026rsquo;+BC\u0026rsquo;+AC\\)    POS  將布林邏輯化簡成最簡POS(Minimum Product of Sums)  \\(F=(A+B\u0026rsquo;+C+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D)(A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;+D)(A+B+C\u0026rsquo;+D)(A\u0026rsquo;+B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;+D)(B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D)(A+B\u0026rsquo;+C\u0026rsquo;)(C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(C\u0026rsquo;+D)\\)    2或3個變數的卡諾圖 簡化2個變數的布林邏輯式  \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B\\)  布林代數：  \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B=A\u0026rsquo;(B\u0026rsquo;+B)=A\u0026rsquo;\\)   卡諾圖：  \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow B\\rightarrow A\u0026amp;0\u0026amp;1\u0026amp;\\\\\\hline 0\u0026amp;\\text{A=0,B=0}\u0026amp;\\text{A=1,B=0}\\\\\\hline 1\u0026amp;\\text{A=0,B=1}\u0026amp;\\text{A=1,B=1}\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\rightarrow A' \\)       簡化3個變數的布林邏輯式  \\(F=\\sum m(2,3,6)=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;\\)  布林代數：  \\(F=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;=A\u0026rsquo; B+BC\u0026rsquo;\\)   卡諾圖：*注意相鄰以grey code排列  \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow BC\\rightarrow A\u0026amp;0\u0026amp;1\u0026amp;\\\\\\hline 00\u0026amp;m_0(000)\u0026amp;m_4(100)\\\\\\hline 01\u0026amp;m_1(001)\u0026amp;m_5(101)\\\\\\hline 11\u0026amp;m_3(011)\u0026amp;m_7(111)\\\\\\hline 10\u0026amp;m_2(010)\u0026amp;m_6(110)\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;0\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;0\u0026amp;0\\\\\\hline B C \u0026amp;1\u0026amp;0\\\\\\hline B C\u0026rsquo; \u0026amp;1\u0026amp;1\\\\ \\end{array} } \\rightarrow A\u0026rsquo; B+BC' \\)       相鄰(Adjacency)的定義  最上面可以與最下面相接，視為相鄰 最左邊可以與最右邊相接，視為相鄰  \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;0\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;0\u0026amp;0\\\\\\hline B C \u0026amp;1\u0026amp;1\\\\\\hline B C\u0026rsquo; \u0026amp;0\u0026amp;0\\\\ \\end{array} } \\rightarrow BC \\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;0\u0026amp;0\\\\\\hline B C \u0026amp;0\u0026amp;0\\\\\\hline B C\u0026rsquo; \u0026amp;1\u0026amp;0\\\\ \\end{array} } \\rightarrow A\u0026rsquo; C' \\)    組合的規則  以組合相鄰且以2為倍數為規則 組合的元素愈多愈好 可以重複選(cover)  等效最簡式  \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;1\u0026amp;1\\\\\\hline B C \u0026amp;0\u0026amp;1\\\\\\hline B C\u0026rsquo; \u0026amp;1\u0026amp;1\\\\ \\end{array}} \\rightarrow F=A\u0026rsquo; B\u0026rsquo;+BC\u0026rsquo;+AC=A\u0026rsquo; C\u0026rsquo;+B\u0026rsquo;C+AB \\)  4個變數的卡諾圖  \\(F=ACD+A\u0026rsquo; B+D\u0026rsquo;\\) 以卡諾圖表示  \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;A\u0026rsquo; B\u0026rsquo;\u0026amp;A\u0026rsquo; B\u0026amp;AB\u0026amp;AB\u0026rsquo;\\\\\\hline C\u0026rsquo; D\u0026rsquo;\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline C\u0026rsquo; D \u0026amp; \u0026amp;1\u0026amp; \u0026amp; \\\\\\hline C D \u0026amp; \u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline C D\u0026rsquo; \u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array}} \\quad \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;m_0\u0026amp;m_4\u0026amp;m_{12}\u0026amp;m_8\\\\\\hline 01\u0026amp;m_1\u0026amp;m_5\u0026amp;m_{13}\u0026amp;m_9\\\\\\hline 11\u0026amp;m_3\u0026amp;m_7\u0026amp;m_{15}\u0026amp;m_{11}\\\\\\hline 10\u0026amp;m_2\u0026amp;m_6\u0026amp;m_{14}\u0026amp;m_{10}\\\\ \\end{array}} \\)     以 min-term expression 方式解題  解 \\(F(a,b,c,d)=\\sum m(1,3,4,5,10,12,13)\\)  \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp; \u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; \u0026amp;1\\\\ \\end{array}} \\rightarrow F=bc\u0026rsquo;+a\u0026rsquo; b\u0026rsquo; d+ab\u0026rsquo; c\u0026rsquo;d \\)     考慮 Don\u0026rsquo;t care 的情況  解 \\(F(a,b,c,d)=\\sum m(1,3,5,7,9)+\\sum d(6,12,13)\\)  \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;X\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;X\u0026amp;1\\\\\\hline 11\u0026amp;1\u0026amp;1\u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp;X\u0026amp; \u0026amp; \\\\ \\end{array}} \\rightarrow F=a\u0026rsquo;d+c\u0026rsquo;d \\)     以 max-term expression 方式解題  解 \\(F(a,b,c,d)=\\sum m(0,2,3,4,8,10,11,15)=\\prod M(1,5,6,7,9,12,13,14)\\)  \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;0\u0026amp; \\\\\\hline 01\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 11\u0026amp; \u0026amp;0\u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp;0\u0026amp;0\u0026amp; \\\\ \\end{array}} \\)\n\\(\\rightarrow F\u0026rsquo;=c\u0026rsquo; d+a\u0026rsquo; bc+abd\u0026rsquo;\\)\n\\(\\rightarrow F=(c+d)(a+b\u0026rsquo;+c\u0026rsquo;)(a\u0026rsquo;+b\u0026rsquo;+d)\\)    基本質函項(essential prime implicants) 名詞定義  蘊函項(Implicant)  任何可以被組合的單一或群元素(意指為 \\(F\\)的子集。)   質函項(Prime Implicant)  已不能再被組合更多的函項。(意指最大的、框選最多的子集)   基本質函項(Essential Prime Implicant)  一個帶有只能被單一質函項框選到的元素的質函項   \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;1\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline 10\u0026amp; \u0026amp;1\u0026amp; \u0026amp; \\\\ \\end{array}} \\)  蘊函項：\\(A\u0026rsquo; C\u0026rsquo; D, ABC\u0026rsquo;, ACD, A\u0026rsquo; BC, BD, m_1, m_5, m_6, m_7\u0026hellip;. \\) 質函項：\\(A\u0026rsquo; C\u0026rsquo; D, ABC\u0026rsquo;, ACD, A\u0026rsquo; BC, BD \\) 基本質函項：\\(A\u0026rsquo; C\u0026rsquo; D,ABC\u0026rsquo;,A\u0026rsquo; BC, ACD\\)    簡化原則  因為有可能存在多個等效的最簡式，所以：   盡可能將式子展開成質函項(Prime implicants)。 用盡可能最少的質函項來表式布林函式。    例題 \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp; \u0026amp;1\u0026amp;1\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp;1\u0026amp;1\\\\ \\end{array}} \\rightarrow F=A\u0026rsquo; B\u0026rsquo; D+BC\u0026rsquo;+AC \\)  5個變數的卡諾圖  表示法1  表示法2   ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec4/","summary":"布林邏輯式的簡化  卡諾圖(Karnaugh Maps, K-maps)是一種簡單、快速的簡化布林邏輯的方法。  SOP  將布林邏輯化簡成最簡SOP(Minimum Sum of products)  \\(F=A\u0026rsquo; B\u0026rsquo; C\u0026rsquo;+A\u0026rsquo; B\u0026rsquo; C+A\u0026rsquo; BC\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo; +ABC\\) \\(F=A\u0026rsquo; B\u0026rsquo;+B\u0026rsquo; C+BC\u0026rsquo;+AB\\) \\(F=A\u0026rsquo; B\u0026rsquo;+BC\u0026rsquo;+AC\\)    POS  將布林邏輯化簡成最簡POS(Minimum Product of Sums)  \\(F=(A+B\u0026rsquo;+C+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D)(A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;+D)(A+B+C\u0026rsquo;+D)(A\u0026rsquo;+B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;+D)(B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D)(A+B\u0026rsquo;+C\u0026rsquo;)(C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(C\u0026rsquo;+D)\\)    2或3個變數的卡諾圖 簡化2個變數的布林邏輯式  \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B\\)  布林代數：  \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B=A\u0026rsquo;(B\u0026rsquo;+B)=A\u0026rsquo;\\)   卡諾圖：  \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow B\\rightarrow A\u0026amp;0\u0026amp;1\u0026amp;\\\\\\hline 0\u0026amp;\\text{A=0,B=0}\u0026amp;\\text{A=1,B=0}\\\\\\hline 1\u0026amp;\\text{A=0,B=1}\u0026amp;\\text{A=1,B=1}\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.","title":"[Logic Design] Lec 4 - 卡諾圖 Karnaugh Maps"},{"content":"布林表達式的轉換  將文字敘述轉換成布林表達式：   \\( \\def\\arraystrecth{1.5}\\begin{array}{l} \\underbrace{\\text{The alarm will ring}}_ {Z} \\text{ iff } \\underbrace{\\text{the power of alarm is on}} _{A} \\text{ and } \\underbrace{\\text{the door is not closed}} _{B\u0026rsquo;} \\\\ \\text{ or } \\underbrace{\\text{it is after 6 p.m.}} _{C} \\text{ and } \\underbrace{\\text{the window is not closed}} _{D\u0026rsquo;} \\end{array} \\)\n  \\(Z=AB\u0026rsquo;+CD\u0026rsquo;\\)  由真值表開始建構邏輯電路  Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|c|c} A\u0026amp;B\u0026amp;C\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array} } \\) 利用 1\u0026rsquo;s 的函數\n\\(f=A\u0026rsquo; BC+AB\u0026rsquo; C\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo;+ABC\\)\n\\(=A\u0026rsquo; BC+AB\u0026rsquo;+AB\\)\n\\(=A\u0026rsquo; BC+A\\)\n\\(=A+BC\\) 利用 0\u0026rsquo;s 的函數\n\\(f=(A+B+C)(A+B+C\u0026rsquo;)(A+B\u0026rsquo;+C)\\)\n\\(=(A+B)(A+B\u0026rsquo;+C)\\)\n\\(=A+B(B\u0026rsquo;+C)\\)\n\\(=A+BC\\)  Minterm 與 maxterm 展開   以 \\(F=A\u0026rsquo; BC+A\\) 為範例 \\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{c|ccc|c|c|cc} \\text{Row No.}\u0026amp;A\u0026amp;B\u0026amp;C\u0026amp;\\text{Minterns}\u0026amp;\\text{Maxterms}\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;\\text{A\u0026rsquo;B\u0026rsquo;C\u0026rsquo;}=\\text{m}_0\u0026amp;\\text{A+B+C}=\\text{M}_0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;\\text{A\u0026rsquo;B\u0026rsquo;C}=\\text{m}_1\u0026amp;\\text{A+B+C\u0026rsquo;}=\\text{M}_1\u0026amp;0\u0026amp;1\\\\ 2\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;\\text{A\u0026rsquo;BC\u0026rsquo;}=\\text{m}_2\u0026amp;\\text{A+B\u0026rsquo;+C}=\\text{M}_2\u0026amp;0\u0026amp;1\\\\ 3\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;\\text{A\u0026rsquo;BC}=\\text{m}_3\u0026amp;\\text{A+B\u0026rsquo;+C\u0026rsquo;}=\\text{M}_3\u0026amp;1\u0026amp;0\\\\ 4\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;\\text{AB\u0026rsquo;C\u0026rsquo;}=\\text{m}_4\u0026amp;\\text{A\u0026rsquo;+B+C}=\\text{M}_4\u0026amp;1\u0026amp;0\\\\ 5\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;\\text{AB\u0026rsquo;C}=\\text{m}_5\u0026amp;\\text{A\u0026rsquo;+B+C\u0026rsquo;}=\\text{M}_5\u0026amp;1\u0026amp;0\\\\ 6\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;\\text{ABC\u0026rsquo;}=\\text{m}_6\u0026amp;\\text{A\u0026rsquo;+B\u0026rsquo;+C}=\\text{M}_6\u0026amp;1\u0026amp;0\\\\ 7\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\text{ABC}=\\text{m}_7\u0026amp;\\text{A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;}=\\text{M}_7\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\)\n  \\(m_i\u0026rsquo;=M_i\\)\n  \\(\\text{f=A\u0026rsquo;BC+A=1}\\)\n\\(\\text{=A\u0026rsquo;BC+AB\u0026rsquo;C\u0026rsquo;+AB\u0026rsquo;C+ABC\u0026rsquo;+ABC}\\)\n\\(=m_3+m_4+m_5+m_6+m_7\\)\n\\(=\\sum m(3,4,5,6,7)\\)\n  \\(\\text{f=(A+B+C)(A+B+C\u0026rsquo;)(A+B\u0026rsquo;+C)=0}\\)\n\\(=M_0M_1M_2\\)\n\\(=\\prod M(0,1,2)\\)\n  Maxterm 與 minterm 的轉換\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{rcl} g\u0026amp;=\u0026amp;\\sum m(2,3,4,6,7)\\\\ \u0026amp;=\u0026amp;\\prod M(0,1,5)\\\\ g\u0026rsquo;\u0026amp;=\u0026amp;\\sum m(0,1,5)\\\\ g\u0026amp;=\u0026amp;[\\sum m(0,1,5)]\u0026rsquo;\\\\ \u0026amp;=\u0026amp;\\prod m\u0026rsquo;(0,1,5)\\\\ \u0026amp;=\u0026amp;\\prod M(0,1,5) \\end{array} } \\)\n  性質：\n \\(\\boxed{\\text{m}_i\\text{m}_j=0\\text{ if i}\\neq j}\\)    未完整定義的函式(Don\u0026rsquo;t Care)  Truth table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{lll|l} A\u0026amp;B\u0026amp;C\u0026amp;F\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;X\\leftarrow \\text{Don\u0026rsquo;t care}\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;X\\leftarrow \\text{Don\u0026rsquo;t care}\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\) 表達式：  \\(F=\\sum m(0,3,7)+\\sum d(1,6)=\\prod M(2,4,5)\\cdot \\prod(1,6)\\)    Binary adders and subtracters Half Adder 半加器  \\(X,Y_{\\text{in}}\\rightarrow{\\boxed{\\text{Half Adder}}\\rightarrow \\text{Sum}}\\) Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{cc|c} X\u0026amp;Y\u0026amp;Sum\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\) 表達式： \\(\\text{Sum}=X\u0026rsquo; Y+XY\u0026rsquo;\\)  Full Adder 全加器  \\(X,Y,C_{\\text{in}}\\rightarrow{\\boxed{\\text{Full Adder}}\\rightarrow C_{out}, \\text{Sum}}\\) Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|cc} X\u0026amp;Y\u0026amp;C_{\\text{in}}\u0026amp;C_{\\text{out}}\u0026amp;\\text{Sum}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\) 表達式：  \\(\\text{Sum}=X\\oplus Y\\oplus C_{\\text{in}}\\) \\(C_\\text{out}=YC_{\\text{in}}+XC_{\\text{in}}+XY\\)   邏輯電路   4-Bit Parallel Adder (Ripple Carry Adder 漣波加法器)  四個平行串接的全加器 (Full Adder)   Binary Subtracter using Full Adders  用全加器來實現減法器  Full Subtracter   \\(x_i,y_i,b_i\\rightarrow\\boxed{\\text{Full Subtracter}}\\rightarrow b_{i+1},d_i\\)\n  Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|cc} x_i\u0026amp;y_i\u0026amp;b_i\u0026amp;b_{i+1}\u0026amp;d_i\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\)\n  示意\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{c|cc} \u0026amp;\\text{Column i Before Borrow}\u0026amp;\\text{Column i After Borrow}\\\\\\hline x_i\u0026amp;0\u0026amp;10\u0026amp;\\\\ -b_i\u0026amp;-1\u0026amp;-1\\\\ -y_i\u0026amp;-1\u0026amp;-1\\\\\\hline d_i\u0026amp;\u0026amp;0(b_{i+1}=1)\\\\ \\end{array} } \\)\n  Parallel Subtracter Speeding up integer additions Ripple Carry Adder  一般的漣波進位加法器  設計簡單、規律 有較大的 Time Delay  一個 Full Adder 為\\(C_\\text{out}=YC_{\\text{in}}+XC_{\\text{in}}+XY\\) 也就是先 AND 再 OR，兩個 gate delay 故 n-bit adder 的 time delay 是 2n      Carry Lockahead Adder(CLA)  \\(\\text{Sum}=A\\oplus B\\oplus C_{in}\\) \\(C_{out}=AB+(A+B)C_{in}\\) \\(C_{i+1}=A_iB_i+(A_i+B_i)C_i\\) \\(C_{i+1}=g_i+p_iC_i\\)  \\(g_i=A_iB_i\\) generate function \\(p_i=A_i+B_i\\) propagate function   \\(C_2=g_1+p_1C_1\\) \\(C_2=g_1+p_1p_0g_0+p_1p_0C_0\\) \\(C_n=g_{n-1}+p_{n-1}g_{n-2}+p_{n-1}p_{n-2}g_{n-3}+\u0026hellip;+p_{n-1}p_{n-2}\u0026hellip;p_1g_0+p_{n-1}p_{n-2}\u0026hellip;p_0C_0\\) 換句話說，\\(C_n\\)可以藉由 \\(C_0\\)運算出來，以 4-bit 為例，可以從漣波的 8 次降到 5 次的 Gate delay。   Carry Select Adder  將兩個加法作平行處理  預先假設 carry-in 的值，待前一級的 carry-in 算出後再用 selector 選擇正確的 carry-in，減去收到前級 carry-in 再開始運算的時間。     Binary multiplication  用邏輯閘模擬一般十進制進位法的乘法  示意\n\\( \\def\\arraystretch{1}\\begin{array}{rcccc} \\text{Multiplicand}\u0026amp;\u0026amp;\u0026amp;B_1\u0026amp;B_0\\\\ \\text{Multiplier}\u0026amp;\u0026amp;\u0026amp;A_1\u0026amp;A_0\\\\\\hline \\text{Partial products}\u0026amp;\u0026amp;\u0026amp;A_0B_1\u0026amp;A_0B_0\\\\ \\text{shift one bit left}\u0026amp;\u0026amp;A_1B_1\u0026amp;A_1B_0\\\\ \\text{Sum of partial products}\u0026amp;C1\u0026amp;C2\u0026amp;C3\u0026amp;C4\\\\ \\end{array} \\)     ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec3/","summary":"布林表達式的轉換  將文字敘述轉換成布林表達式：   \\( \\def\\arraystrecth{1.5}\\begin{array}{l} \\underbrace{\\text{The alarm will ring}}_ {Z} \\text{ iff } \\underbrace{\\text{the power of alarm is on}} _{A} \\text{ and } \\underbrace{\\text{the door is not closed}} _{B\u0026rsquo;} \\\\ \\text{ or } \\underbrace{\\text{it is after 6 p.m.}} _{C} \\text{ and } \\underbrace{\\text{the window is not closed}} _{D\u0026rsquo;} \\end{array} \\)\n  \\(Z=AB\u0026rsquo;+CD\u0026rsquo;\\)  由真值表開始建構邏輯電路  Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|c|c} A\u0026amp;B\u0026amp;C\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array} } \\) 利用 1\u0026rsquo;s 的函數","title":"[Logic Design] Lec 3 - Minterm 與 Maxterm 展開"},{"content":"基本邏輯運算 Logic Gates Not Gates  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|}\\hline \\text{X}\u0026amp;\\overline{\\text{X}}\\text{or}\\text{X\u0026rsquo;}\\\\\\hline 0\u0026amp;1\\\\\\hline 1\u0026amp;0\\\\\\hline \\end{array} \\)  And Gates  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\cdot\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\)  Or Gates  Symbol  Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X+Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\)  布林表達式與真值表(Boolean Expression and Truth Table)  Boolean expression  用 ' 代表 NOT 用 + 代表 OR 用 . 代表 AND 將輸入用上面的運算子表示成算式，如：\\((A+C)(B\u0026rsquo;+C)\\)   Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{ccc|cccccc} A\u0026amp;B\u0026amp;C\u0026amp;B\u0026rsquo;\u0026amp;AB\u0026rsquo;\u0026amp;AB\u0026rsquo;+C\u0026amp;A+C\u0026amp;B\u0026rsquo;+C\u0026amp;(A+C)(B\u0026rsquo;+C)\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} \\)  基本運算定理 NOT gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x\u0026rsquo;)\u0026rsquo;\u0026amp;=\u0026amp;x \\end{array} } \\)\nAND gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x+0\u0026amp;=\u0026amp;x\\\\ x+1\u0026amp;=\u0026amp;1\\\\ x+x\u0026amp;=\u0026amp;x\\\\ x+x\u0026rsquo;\u0026amp;=\u0026amp;1 \\end{array} } \\)\nOR gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\cdot 0\u0026amp;=\u0026amp;0\\\\ x\\cdot 1\u0026amp;=\u0026amp;x\\\\ x\\cdot x\u0026amp;=\u0026amp;x\\\\ x\\cdot x\u0026rsquo;\u0026amp;=\u0026amp;0 \\end{array} } \\)\n進階運算定理 交換律 Commutative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} xy\u0026amp;=\u0026amp;yx\\\\ x+y\u0026amp;=\u0026amp;y+x \\end{array} } \\)\n結合律 Associative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (xy)z\u0026amp;=\u0026amp;x(yz)\\\\ (x+y)+z\u0026amp;=\u0026amp;x+(y+z) \\end{array} } \\)\n分配律 Distributive Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026amp;=\u0026amp;xy+xz\\\\ x+yz\u0026amp;=\u0026amp;(x+y)(x+z) \\end{array} } \\)\nMultiplying out and factoring Sum of Product(SOP) form  將算式化整成各個輸入端先 AND 後再 OR 例： \\(ABC+AB\u0026rsquo;C+AB\u0026rsquo;C\u0026rsquo;\\)  Product of Sum(POS) form  將算式化整成各個輸入端先 OR 後再 AND 例： \\((A+B+C)(A+B\u0026rsquo;+C)(A+B\u0026rsquo;+C\u0026rsquo;)\\)  Multiplying out：  將算式化簡成 SOP form 善用\\(\\boxed{(A+B)(A+C)=A+BC}\\) 範例：\n\\((A+BC)(A+D+E)\\)\n\\(=(A+x)(A+y)\\)\n\\(=A+xy\\)\n\\(=A+BC(D+E)\\)\n\\(=A+BCD+BCE\\)  Factoring：  將算式化簡成 POS form 善用\\(\\boxed{A+BC=(A+B)(A+C)}\\) 範例：\n\\(AB\u0026rsquo;+C\u0026rsquo;D\\)\n\\(=(AB\u0026rsquo;+C\u0026rsquo;)(AB\u0026rsquo;+D)\\)\n\\(=(A+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;)(A+D)(B\u0026rsquo;+D))\\)  2-level realization  利用 Multiplying out 與 Factoring 可以將電路簡化成 2-level circuit 因為減少了 Delay propagation 可以減少 Total Time Delay  DeMorgan\u0026rsquo;s Laws and Duality DeMorgan\u0026rsquo;s Laws  方法：  \\(AND\\leftrightarrow OR\\) \\(A\\leftrightarrow A\u0026rsquo;\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x+y+z+\u0026hellip;)\u0026rsquo;\u0026amp;=\u0026amp;x\u0026rsquo; y\u0026rsquo; z\u0026rsquo;\u0026hellip;\\\\ (xyz\u0026hellip;)\u0026rsquo;\u0026amp;=\u0026amp;x\u0026rsquo;+y\u0026rsquo;+z\u0026rsquo;\u0026hellip; \\end{array} } \\)   Truth Table 證明\n\\( \\def\\arraystretch{1.5}\\begin{array}{ccc|ccc|c|c|c} x\u0026amp;y\u0026amp;z\u0026amp;x\u0026rsquo;\u0026amp;y\u0026rsquo;\u0026amp;z\u0026rsquo;\u0026amp;x+y+z\u0026amp;(x+y+z)\u0026rsquo;\u0026amp;x\u0026rsquo; y\u0026rsquo; z\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ \\end{array} \\) 範例\n\\([(A\u0026rsquo; B+C\u0026rsquo;)(D\u0026rsquo;+EF\u0026rsquo;)+GH+W]\u0026rsquo;\\)\n\\(=[(A+B\u0026rsquo;)C+D(E\u0026rsquo;+F)] (G\u0026rsquo;+H\u0026rsquo;)W\u0026rsquo;\\)  Duality   方法\n \\(AND\\leftrightarrow OR\\) \\(0\\leftrightarrow 1\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{cccccccccc} [f(\u0026amp;x_1,\u0026amp;x_2,\u0026amp;\u0026hellip;,\u0026amp;x_n,\u0026amp;0,\u0026amp;1,\u0026amp;+,\u0026amp;\\cdot\u0026amp;)]^D\\\\ =f(\u0026amp;x_1,\u0026amp;x_2,\u0026amp;\u0026hellip;,\u0026amp;x_n,\u0026amp;1,\u0026amp;0,\u0026amp;\\cdot,\u0026amp;+\u0026amp;) \\end{array} } \\)    性質\n \\(\\boxed{F=G\\rightarrow F^D=G^D}\\)    範例\n\\((x+y\u0026rsquo;)y=xy\\rightarrow x\\cdot y\u0026rsquo;+y=x+y\\)\n  回顧分配律 Distributive Law，即為 Duality 的表現。\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026amp;=\u0026amp;xy+xz\\\\ x+yz\u0026amp;=\u0026amp;(x+y)(x+z) \\end{array} } \\)\n  Exclusive-OR and equivalence operations Exlusive-OR(XOR,\\(\\oplus\\))  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\oplus\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;0\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\oplus 0\u0026amp;=\u0026amp;x\\\\ x\\oplus 1\u0026amp;=\u0026amp;x\u0026rsquo;\\\\ x\\oplus x\u0026amp;=\u0026amp;0\\\\ x\\oplus x\u0026rsquo;\u0026amp;=\u0026amp;1\\\\ x\\oplus y\u0026amp;=\u0026amp;y\\oplus x\\\\ (x\\oplus y)\\oplus z\u0026amp;=\u0026amp;x\\oplus (y\\oplus z)\\\\ x(y\\oplus z)\u0026amp;=\u0026amp;xy\\oplus xz\\\\ x\\oplus y\u0026amp;=\u0026amp;xy+x\u0026rsquo; y' \\end{array} } \\)  Equivalence(\\(\\equiv\\))  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\equiv{Y}\\\\\\hline 0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\equiv 0\u0026amp;=\u0026amp;x\u0026rsquo;\\\\ x\\equiv 1\u0026amp;=\u0026amp;x\\\\ x\\equiv x\u0026amp;=\u0026amp;1\\\\ x\\equiv x\u0026rsquo;\u0026amp;=\u0026amp;0\\\\ x\\equiv y\u0026amp;=\u0026amp;y\\equiv x\\\\ (x\\equiv y)\\equiv z\u0026amp;=\u0026amp;x\\equiv (y\\equiv z)\\\\ x(y\\equiv z)\u0026amp;=\u0026amp;xy\\equiv xz\\\\ x\\equiv y\u0026amp;=\u0026amp;xy\u0026rsquo;+x\u0026rsquo; y \\end{array} } \\)  連鎖律 The consensus thorem  公式：  \\(\\boxed{xy+x\u0026rsquo; z+yz=xy+x\u0026rsquo; z}\\) \\(\\boxed{(x+y)(x\u0026rsquo;+z)(y+z)=(x+y)(x\u0026rsquo;+z)}\\)   證明：\n\\(xy+x\u0026rsquo; z+yz\\)\n\\(=xy+x\u0026rsquo; z + (x+x\u0026rsquo;)yz\\)\n\\(=xy+xyz+x\u0026rsquo; z+x\u0026rsquo; yz\\)\n\\(=xy(1+z)+x\u0026rsquo; z(1+y)\\)\n\\(=xy+x\u0026rsquo; z\\)  簡化布林表達式的流程  利用 \\(\\boxed{xy+xy\u0026rsquo;=x(y+y\u0026rsquo;)=x}\\)(AND性質) 利用 \\(\\boxed{x+xy+\u0026hellip;=x(1+y+\u0026hellip;)=x}\\)(OR性質) 利用 \\(\\boxed{xy+x\u0026rsquo; z+yz=xy+x\u0026rsquo;z }\\)(連鎖律) 利用 \\(\\boxed{x+x\u0026rsquo;y=x(y+y\u0026rsquo;)+x\u0026rsquo;y=xy+xy\u0026rsquo;+x\u0026rsquo; y=x+y}\\) 必要時加入 redundant terms   Lec3會使用圖表法，較不容易出錯。  如何證明布林表達式的正確性?  建構 Truth Table 簡化 LHS 和 RHS  ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec2/","summary":"基本邏輯運算 Logic Gates Not Gates  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|}\\hline \\text{X}\u0026amp;\\overline{\\text{X}}\\text{or}\\text{X\u0026rsquo;}\\\\\\hline 0\u0026amp;1\\\\\\hline 1\u0026amp;0\\\\\\hline \\end{array} \\)  And Gates  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\cdot\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\)  Or Gates  Symbol  Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X+Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\)  布林表達式與真值表(Boolean Expression and Truth Table)  Boolean expression  用 ' 代表 NOT 用 + 代表 OR 用 .","title":"[Logic Design] Lec 2 - 布林代數"},{"content":"數位系統與開關電路  在現實世界中，資訊是以類比(Analog)的方式傳遞的，換言之，資訊是連續的 在電腦世界中，資訊是以數位(Digital)的方式傳遞的，也就是開與關或是0或1。 A/D \u0026lt;-\u0026gt; DSP(digital signal processor) \u0026lt;-\u0026gt; D/A   Switching Circuit  可分為三個層級：  System: 模組Modules、算術運算單元 ALU(Arithmetic logic unit)、記憶體 Memory Logic：邏輯閘(gates) Circuit：電晶體(transistors)   經由 switching network 的設計，可將輸入轉成合乎 spec 的輸出。其中 switching network 的種類包含：  Combinational network  輸出是輸入的函數，且表達當下的值。   Sequential network  輸出是輸入的函數，可以表達當下的值或是過去的值。 具有記憶體的行為   Switches  由電晶體來實現 transistor level, gate level, module level\u0026hellip;      數字系統與轉換  在現實世界中，最普遍使用的數字系統為十進制(Decimal) 然而在電腦世界中，因為只有代表開與關的 0 與 1，故使用的數字系統是以二進制(Binary)為基礎。  \\(N=(a_2a_1a_0)_R=a_2\\times R^2+a_1\\times R^1+a_0\\times R^0\\)    負數    N 正數表示 -N 正數加負號 1的補數 2的補數     +0 0000 -0 1000 1111 N/A   +1 0001 -1 1001 1110 1111   +2 0010 -2 1010 1101 1110   +3 0011 -3 1011 1100 1101   +4 0100 -4 1100 1011 1100   +5 0101 -5 1101 1010 1011   +6 0110 -6 1110 1001 1010   +7 0111 -7 1111 1000 1001   +8 N/A -8 N/A N/A 1000    二進制算數  當兩數相加或兩數相減時，超過可用bits數時會發生overflow，  例如-3+-4=-4是OK的 但-5+-6=-11會產生溢位    二進制的表達方式 Binary codes    Decimal Digit 8421 Code(BCD) 6311 Code Excess-3 Code 2-out-of-5 Code Gray Code     0 0000 0000 0011 00011 0000   1 0001 0001 0100 00101 0001   2 0010 0011 0101 00110 0011   3 0011 0100 0110 01001 0010   4 0100 0101 0111 01010 0110   5 0101 0111 1000 01100 1110   6 0110 1000 1001 10001 1010   7 0111 1001 1010 10010 1011   8 1000 1011 1011 10100 1001   9 1001 1100 1100 11000 1000    Weighted Codes  8421 Code 與 6311 都是 Weighted Code，代表每4個bit，各自代表的數字，  例：1011 for 8421 = 8 + 0 + 2 + 1 = 11 例：1011 for 6311 = 6 + 0 + 1 + 1 = 8    Excess-3 Codes  Excess-3 是以 8421 Code 為基礎下，額外加 3。 使得 i 與 10-i 互為 1 的補數，  0 與 9 為補數。(0011 與 1100) 1 與 8 為補數。(0100 與 1011) 2 與 7 為補數。(0101 與 1010) 3 與 6 為補數。(0110 與 1001) 4 與 5 為補數。(0111 與 1000)    Gray Codes  兩相鄰的數只會相差一個 bit 又名 Reflected Binary Codes(RBC)、Unit distance code、Minimum error code 可以減少 switching operation 如何轉換 Gray Code? 參考Leetcode no.89  ASCII table ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec1/","summary":"數位系統與開關電路  在現實世界中，資訊是以類比(Analog)的方式傳遞的，換言之，資訊是連續的 在電腦世界中，資訊是以數位(Digital)的方式傳遞的，也就是開與關或是0或1。 A/D \u0026lt;-\u0026gt; DSP(digital signal processor) \u0026lt;-\u0026gt; D/A   Switching Circuit  可分為三個層級：  System: 模組Modules、算術運算單元 ALU(Arithmetic logic unit)、記憶體 Memory Logic：邏輯閘(gates) Circuit：電晶體(transistors)   經由 switching network 的設計，可將輸入轉成合乎 spec 的輸出。其中 switching network 的種類包含：  Combinational network  輸出是輸入的函數，且表達當下的值。   Sequential network  輸出是輸入的函數，可以表達當下的值或是過去的值。 具有記憶體的行為   Switches  由電晶體來實現 transistor level, gate level, module level\u0026hellip;      數字系統與轉換  在現實世界中，最普遍使用的數字系統為十進制(Decimal) 然而在電腦世界中，因為只有代表開與關的 0 與 1，故使用的數字系統是以二進制(Binary)為基礎。  \\(N=(a_2a_1a_0)_R=a_2\\times R^2+a_1\\times R^1+a_0\\times R^0\\)    負數    N 正數表示 -N 正數加負號 1的補數 2的補數     +0 0000 -0 1000 1111 N/A   +1 0001 -1 1001 1110 1111   +2 0010 -2 1010 1101 1110   +3 0011 -3 1011 1100 1101   +4 0100 -4 1100 1011 1100   +5 0101 -5 1101 1010 1011   +6 0110 -6 1110 1001 1010   +7 0111 -7 1111 1000 1001   +8 N/A -8 N/A N/A 1000    二進制算數  當兩數相加或兩數相減時，超過可用bits數時會發生overflow，  例如-3+-4=-4是OK的 但-5+-6=-11會產生溢位    二進制的表達方式 Binary codes    Decimal Digit 8421 Code(BCD) 6311 Code Excess-3 Code 2-out-of-5 Code Gray Code     0 0000 0000 0011 00011 0000   1 0001 0001 0100 00101 0001   2 0010 0011 0101 00110 0011   3 0011 0100 0110 01001 0010   4 0100 0101 0111 01010 0110   5 0101 0111 1000 01100 1110   6 0110 1000 1001 10001 1010   7 0111 1001 1010 10010 1011   8 1000 1011 1011 10100 1001   9 1001 1100 1100 11000 1000    Weighted Codes  8421 Code 與 6311 都是 Weighted Code，代表每4個bit，各自代表的數字，  例：1011 for 8421 = 8 + 0 + 2 + 1 = 11 例：1011 for 6311 = 6 + 0 + 1 + 1 = 8    Excess-3 Codes  Excess-3 是以 8421 Code 為基礎下，額外加 3。 使得 i 與 10-i 互為 1 的補數，  0 與 9 為補數。(0011 與 1100) 1 與 8 為補數。(0100 與 1011) 2 與 7 為補數。(0101 與 1010) 3 與 6 為補數。(0110 與 1001) 4 與 5 為補數。(0111 與 1000)    Gray Codes  兩相鄰的數只會相差一個 bit 又名 Reflected Binary Codes(RBC)、Unit distance code、Minimum error code 可以減少 switching operation 如何轉換 Gray Code?","title":"[Logic Design] Lec 1 - 數字系統與轉換"},{"content":"Coding Interview University John Washam:\n I originally created this as a short to-do list of study topics for becoming a software engineer, but it grew to the large list you see today. After going through this study plan, I got hired as a Software Development Engineer at Amazon! You probably won\u0026rsquo;t have to study as much as I did. Anyway, everything you need is here.\nI studied about 8-12 hours a day, for several months. This is my story: Why I studied full-time for 8 months for a Google interview\nPlease Note: You won\u0026rsquo;t need to study as much as I did. I wasted a lot of time on things I didn\u0026rsquo;t need to know. More info about that below. I\u0026rsquo;ll help you get there without wasting your precious time.\nThe items listed here will prepare you well for a technical interview at just about any software company, including the giants: Amazon, Facebook, Google, and Microsoft.\nBest of luck to you!\n What is it? This is my multi-month study plan for becoming a software engineer for a large company.\nRequired:\n A little experience with coding (variables, loops, methods/functions, etc) Patience Time  Note this is a study plan for software engineering, not web development. Large software companies like Google, Amazon, Facebook and Microsoft view software engineering as different from web development. For example, Amazon has Frontend Engineers (FEE) and Software Development Engineers (SDE). These are 2 separate roles and the interviews for them will not be the same, as each has its own competencies. These companies require computer science knowledge for software development/engineering roles.\n Table of Contents The Study Plan  What is it? Why use it? How to use it Don\u0026rsquo;t feel you aren\u0026rsquo;t smart enough A Note About Video Resources Choose a Programming Language Books for Data Structures and Algorithms Interview Prep Books Don\u0026rsquo;t Make My Mistakes What you Won\u0026rsquo;t See Covered The Daily Plan Coding Question Practice Coding Problems  Topics of Study  Algorithmic complexity / Big-O / Asymptotic analysis Data Structures  Arrays Linked Lists Stack Queue Hash table   More Knowledge  Binary search Bitwise operations   Trees  Trees - Notes \u0026amp; Background Binary search trees: BSTs Heap / Priority Queue / Binary Heap balanced search trees (general concept, not details) traversals: preorder, inorder, postorder, BFS, DFS   Sorting  selection insertion heapsort quicksort merge sort   Graphs  directed undirected adjacency matrix adjacency list traversals: BFS, DFS   Even More Knowledge  Recursion Dynamic Programming Design Patterns Combinatorics (n choose k) \u0026amp; Probability NP, NP-Complete and Approximation Algorithms How computers process a program Caches Processes and Threads Testing String searching \u0026amp; manipulations Tries Floating Point Numbers Unicode Endianness Networking   Final Review  Getting the Job  Update Your Resume Find a Job Interview Process \u0026amp; General Interview Prep Be thinking of for when the interview comes Have questions for the interviewer Once You\u0026rsquo;ve Got The Job  \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- Everything below this point is optional \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\nOptional Extra Topics \u0026amp; Resources  Additional Books System Design, Scalability, Data Handling (if you have 4+ years experience) Additional Learning  Compilers Emacs and vi(m) Unix command line tools Information theory Parity \u0026amp; Hamming Code Entropy Cryptography Compression Computer Security Garbage collection Parallel Programming Messaging, Serialization, and Queueing Systems A* Fast Fourier Transform Bloom Filter HyperLogLog Locality-Sensitive Hashing van Emde Boas Trees Augmented Data Structures Balanced search trees  AVL trees Splay trees Red/black trees 2-3 search trees 2-3-4 Trees (aka 2-4 trees) N-ary (K-ary, M-ary) trees B-Trees   k-D Trees Skip lists Network Flows Disjoint Sets \u0026amp; Union Find Math for Fast Processing Treap Linear Programming Geometry, Convex hull Discrete math Machine Learning   Additional Detail on Some Subjects Video Series Computer Science Courses Papers   Why use it? If you want to work as a software engineer for a large company, these are the things you have to know.\nIf you missed out on getting a degree in computer science, like I did, this will catch you up and save four years of your life.\nWhen I started this project, I didn\u0026rsquo;t know a stack from a heap, didn\u0026rsquo;t know Big-O anything, or anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it would have been terrible. Every data structure I had ever used was built into the language, and I didn\u0026rsquo;t know how they worked under the hood at all. I never had to manage memory unless a process I was running would give an \u0026ldquo;out of memory\u0026rdquo; error, and then I\u0026rsquo;d have to find a workaround. I used a few multidimensional arrays in my life and thousands of associative arrays, but I never created data structures from scratch.\nIt\u0026rsquo;s a long plan. It may take you months. If you are familiar with a lot of this already it will take you a lot less time.\nHow to use it Everything below is an outline, and you should tackle the items in order from top to bottom.\nI\u0026rsquo;m using GitHub\u0026rsquo;s special markdown flavor, including tasks lists to track progress.\nCreate a new branch so you can check items like this, just put an x in the brackets: [x]\nFork a branch and follow the commands below  Fork the GitHub repo https://github.com/jwasham/coding-interview-university by clicking on the Fork button.\nClone to your local repo:\ngit clone git@github.com:\u0026lt;your_github_username\u0026gt;/coding-interview-university.git git checkout -b progress git remote add jwasham https://github.com/jwasham/coding-interview-university git fetch --all  Mark all boxes with X after you completed your changes:\ngit add . git commit -m \u0026quot;Marked x\u0026quot; git rebase jwasham/main git push --set-upstream origin progress git push --force  More about GitHub-flavored markdown\nDon\u0026rsquo;t feel you aren\u0026rsquo;t smart enough  Successful software engineers are smart, but many have an insecurity that they aren\u0026rsquo;t smart enough. The myth of the Genius Programmer It\u0026rsquo;s Dangerous to Go Alone: Battling the Invisible Monsters in Tech  A Note About Video Resources Some videos are available only by enrolling in a Coursera or EdX class. These are called MOOCs. Sometimes the classes are not in session so you have to wait a couple of months, so you have no access.\nIt would be great to replace the online course resources with free and always-available public sources, such as YouTube videos (preferably university lectures), so that you people can study these anytime, not just when a specific online course is in session.\nChoose a Programming Language You\u0026rsquo;ll need to choose a programming language for the coding interviews you do, but you\u0026rsquo;ll also need to find a language that you can use to study computer science concepts.\nPreferably the language would be the same, so that you only need to be proficient in one.\nFor this Study Plan When I did the study plan, I used 2 languages for most of it: C and Python\n C: Very low level. Allows you to deal with pointers and memory allocation/deallocation, so you feel the data structures and algorithms in your bones. In higher level languages like Python or Java, these are hidden from you. In day to day work, that\u0026rsquo;s terrific, but when you\u0026rsquo;re learning how these low-level data structures are built, it\u0026rsquo;s great to feel close to the metal.  C is everywhere. You\u0026rsquo;ll see examples in books, lectures, videos, everywhere while you\u0026rsquo;re studying. The C Programming Language, Vol 2  This is a short book, but it will give you a great handle on the C language and if you practice it a little you\u0026rsquo;ll quickly get proficient. Understanding C helps you understand how programs and memory work. You don\u0026rsquo;t need to go super deep in the book (or even finish it). Just get to where you\u0026rsquo;re comfortable reading and writing in C. Answers to questions in the book     Python: Modern and very expressive, I learned it because it\u0026rsquo;s just super useful and also allows me to write less code in an interview.  This is my preference. You do what you like, of course.\nYou may not need it, but here are some sites for learning a new language:\n Exercism Codewars Codility HackerEarth Sphere Online Judge (spoj) Codechef Codeforces  For your Coding Interview You can use a language you are comfortable in to do the coding part of the interview, but for large companies, these are solid choices:\n C++ Java Python  You could also use these, but read around first. There may be caveats:\n JavaScript Ruby  Here is an article I wrote about choosing a language for the interview: Pick One Language for the Coding Interview. This is the original article my post was based on: http://blog.codingforinterviews.com/best-programming-language-jobs/\nYou need to be very comfortable in the language and be knowledgeable.\nRead more about choices:\n Choose the Right Language for Your Coding Interview  See language-specific resources here\nBooks for Data Structures and Algorithms This book will form your foundation for computer science.\nJust choose one, in a language that you will be comfortable with. You\u0026rsquo;ll be doing a lot of reading and coding.\nC  Algorithms in C, Parts 1-5 (Bundle), 3rd Edition  Fundamentals, Data Structures, Sorting, Searching, and Graph Algorithms    Python  Data Structures and Algorithms in Python  by Goodrich, Tamassia, Goldwasser I loved this book. It covered everything and more. Pythonic code my glowing book report: https://startupnextdoor.com/book-report-data-structures-and-algorithms-in-python/    Java Your choice:\n Goodrich, Tamassia, Goldwasser  Data Structures and Algorithms in Java   Sedgewick and Wayne:  Algorithms Free Coursera course that covers the book (taught by the authors!):  Algorithms I Algorithms II      C++ Your choice:\n Goodrich, Tamassia, and Mount  Data Structures and Algorithms in C++, 2nd Edition   Sedgewick and Wayne  Algorithms in C++, Parts 1-4: Fundamentals, Data Structure, Sorting, Searching Algorithms in C++ Part 5: Graph Algorithms    Interview Prep Books You don\u0026rsquo;t need to buy a bunch of these. Honestly \u0026ldquo;Cracking the Coding Interview\u0026rdquo; is probably enough, but I bought more to give myself more practice. But I always do too much.\nI bought both of these. They gave me plenty of practice.\n Programming Interviews Exposed: Coding Your Way Through the Interview, 4th Edition  Answers in C++ and Java This is a good warm-up for Cracking the Coding Interview Not too difficult. Most problems may be easier than what you\u0026rsquo;ll see in an interview (from what I\u0026rsquo;ve read)   Cracking the Coding Interview, 6th Edition  answers in Java    If you have tons of extra time: Choose one:\n Elements of Programming Interviews (C++ version) Elements of Programming Interviews in Python Elements of Programming Interviews (Java version) - Companion Project - Method Stub and Test Cases for Every Problem in the Book  Don\u0026rsquo;t Make My Mistakes This list grew over many months, and yes, it got out of hand.\nHere are some mistakes I made so you\u0026rsquo;ll have a better experience. And you\u0026rsquo;ll save months of time.\n1. You Won\u0026rsquo;t Remember it All I watched hours of videos and took copious notes, and months later there was much I didn\u0026rsquo;t remember. I spent 3 days going through my notes and making flashcards, so I could review. I didn\u0026rsquo;t need all of that knowledge.\nPlease, read so you won\u0026rsquo;t make my mistakes:\nRetaining Computer Science Knowledge.\n2. Use Flashcards To solve the problem, I made a little flashcards site where I could add flashcards of 2 types: general and code. Each card has different formatting. I made a mobile-first website, so I could review on my phone or tablet, wherever I am.\nMake your own for free:\n Flashcards site repo  I DON\u0026rsquo;T RECOMMEND using my flashcards. There are too many and many of them are trivia that you don\u0026rsquo;t need.\nBut if you don\u0026rsquo;t want to listen to me, here you go:\n My flash cards database (1200 cards): My flash cards database (extreme - 1800 cards):  Keep in mind I went overboard and have cards covering everything from assembly language and Python trivia to machine learning and statistics. It\u0026rsquo;s way too much for what\u0026rsquo;s required.\nNote on flashcards: The first time you recognize you know the answer, don\u0026rsquo;t mark it as known. You have to see the same card and answer it several times correctly before you really know it. Repetition will put that knowledge deeper in your brain.\nAn alternative to using my flashcard site is Anki, which has been recommended to me numerous times. It uses a repetition system to help you remember. It\u0026rsquo;s user-friendly, available on all platforms and has a cloud sync system. It costs $25 on iOS but is free on other platforms.\nMy flashcard database in Anki format: https://ankiweb.net/shared/info/25173560 (thanks @xiewenya).\nSome students have mentioned formatting issues with white space that can be fixed by doing the following: open deck, edit card, click cards, select the \u0026ldquo;styling\u0026rdquo; radio button, add the member \u0026ldquo;white-space: pre;\u0026rdquo; to the card class.\n3. Do Coding Interview Questions While You\u0026rsquo;re Learning THIS IS VERY IMPORTANT.\nStart doing coding interview questions while you\u0026rsquo;re learning data structures and algorithms.\nYou need to apply what you\u0026rsquo;re learning to solving problems, or you\u0026rsquo;ll forget. I made this mistake.\nOnce you\u0026rsquo;ve learned a topic, and feel somewhat comfortable with it, for example, linked lists:\n Open one of the coding interview books (or coding problem websites, listed below) Do 2 or 3 questions regarding linked lists. Move on to the next learning topic. Later, go back and do another 2 or 3 linked list problems. Do this with each new topic you learn.  Keep doing problems while you\u0026rsquo;re learning all this stuff, not after.\nYou\u0026rsquo;re not being hired for knowledge, but how you apply the knowledge.\nThere are many resources for this, listed below. Keep going.\n4. Focus There are a lot of distractions that can take up valuable time. Focus and concentration are hard. Turn on some music without lyrics and you\u0026rsquo;ll be able to focus pretty well.\nWhat you won\u0026rsquo;t see covered These are prevalent technologies but not part of this study plan:\n SQL Javascript HTML, CSS, and other front-end technologies  The Daily Plan This course goes over a lot of subjects. Each will probably take you a few days, or maybe even a week or more. It depends on your schedule.\nEach day, take the next subject in the list, watch some videos about that subject, and then write an implementation of that data structure or algorithm in the language you chose for this course.\nYou can see my code here:\n C C++ Python  You don\u0026rsquo;t need to memorize every algorithm. You just need to be able to understand it enough to be able to write your own implementation.\nCoding Question Practice Why is this here? I'm not ready to interview.  Then go back and read this.\nWhy you need to practice doing programming problems:\n Problem recognition, and where the right data structures and algorithms fit in Gathering requirements for the problem Talking your way through the problem like you will in the interview Coding on a whiteboard or paper, not a computer Coming up with time and space complexity for your solutions (see Big-O below) Testing your solutions  There is a great intro for methodical, communicative problem solving in an interview. You\u0026rsquo;ll get this from the programming interview books, too, but I found this outstanding: Algorithm design canvas\nWrite code on a whiteboard or paper, not a computer. Test with some sample inputs. Then type it and test it out on a computer.\nIf you don\u0026rsquo;t have a whiteboard at home, pick up a large drawing pad from an art store. You can sit on the couch and practice. This is my \u0026ldquo;sofa whiteboard\u0026rdquo;. I added the pen in the photo just for scale. If you use a pen, you\u0026rsquo;ll wish you could erase. Gets messy quick. I use a pencil and eraser.\nCoding question practice is not about memorizing answers to programming problems.\nCoding Problems Don\u0026rsquo;t forget your key coding interview books here.\nSolving Problems:\n How to Find a Solution How to Dissect a Topcoder Problem Statement  Coding Interview Question Videos:\n IDeserve (88 videos) Tushar Roy (5 playlists)  Super for walkthroughs of problem solutions   Nick White - LeetCode Solutions (187 Videos)  Good explanations of solution and the code You can watch several in a short time   FisherCoder - LeetCode Solutions  Challenge sites:\n LeetCode  My favorite coding problem site. It\u0026rsquo;s worth the subscription money for the 1-2 months you\u0026rsquo;ll likely be preparing. See Nick White and FisherCoder Videos above for code walk-throughs.   HackerRank TopCoder Geeks for Geeks InterviewBit Project Euler  Let\u0026rsquo;s Get Started Alright, enough talk, let\u0026rsquo;s learn!\nBut don\u0026rsquo;t forget to do coding problems from above while you learn!\nAlgorithmic complexity / Big-O / Asymptotic analysis  Nothing to implement here, you\u0026rsquo;re just watching videos and taking notes! Yay! There are a lot of videos here. Just watch enough until you understand it. You can always come back and review. Don\u0026rsquo;t worry if you don\u0026rsquo;t understand all the math behind it. You just need to understand how to express the complexity of an algorithm in terms of Big-O. Harvard CS50 - Asymptotic Notation (video) Big O Notations (general quick tutorial) (video) Big O Notation (and Omega and Theta) - best mathematical explanation (video) Skiena:  video slides   UC Berkeley Big O (video) Amortized Analysis (video) TopCoder (includes recurrence relations and master theorem):  Computational Complexity: Section 1 Computational Complexity: Section 2   Cheat sheet  Well, that\u0026rsquo;s about enough of that.\nWhen you go through \u0026ldquo;Cracking the Coding Interview\u0026rdquo;, there is a chapter on this, and at the end there is a quiz to see if you can identify the runtime complexity of different algorithms. It\u0026rsquo;s a super review and test.\nData Structures   Arrays  About Arrays:  Arrays (video) UC Berkeley CS61B - Linear and Multi-Dim Arrays (video) (Start watching from 15m 32s) Dynamic Arrays (video) Jagged Arrays (video)   Implement a vector (mutable array with automatic resizing):  Practice coding using arrays and pointers, and pointer math to jump to an index instead of using indexing. New raw data array with allocated memory  can allocate int array under the hood, just not use its features start with 16, or if starting number is greater, use power of 2 - 16, 32, 64, 128   size() - number of items capacity() - number of items it can hold is_empty() at(index) - returns item at given index, blows up if index out of bounds push(item) insert(index, item) - inserts item at index, shifts that index\u0026rsquo;s value and trailing elements to the right prepend(item) - can use insert above at index 0 pop() - remove from end, return value delete(index) - delete item at index, shifting all trailing elements left remove(item) - looks for value and removes index holding it (even if in multiple places) find(item) - looks for value and returns first index with that value, -1 if not found resize(new_capacity) // private function  when you reach capacity, resize to double the size when popping an item, if size is 1/4 of capacity, resize to half     Time  O(1) to add/remove at end (amortized for allocations for more space), index, or update O(n) to insert/remove elsewhere   Space  contiguous in memory, so proximity helps performance space needed = (array capacity, which is \u0026gt;= n) * size of item, but even if 2n, still O(n)      Linked Lists  Description:  Singly Linked Lists (video) CS 61B - Linked Lists 1 (video) CS 61B - Linked Lists 2 (video)   C Code (video) - not the whole video, just portions about Node struct and memory allocation Linked List vs Arrays:  Core Linked Lists Vs Arrays (video) In The Real World Linked Lists Vs Arrays (video)   why you should avoid linked lists (video) Gotcha: you need pointer to pointer knowledge: (for when you pass a pointer to a function that may change the address where that pointer points) This page is just to get a grasp on ptr to ptr. I don\u0026rsquo;t recommend this list traversal style. Readability and maintainability suffer due to cleverness.  Pointers to Pointers   Implement (I did with tail pointer \u0026amp; without):  size() - returns number of data elements in list empty() - bool returns true if empty value_at(index) - returns the value of the nth item (starting at 0 for first) push_front(value) - adds an item to the front of the list pop_front() - remove front item and return its value push_back(value) - adds an item at the end pop_back() - removes end item and returns its value front() - get value of front item back() - get value of end item insert(index, value) - insert value at index, so current item at that index is pointed to by new item at index erase(index) - removes node at given index value_n_from_end(n) - returns the value of the node at nth position from the end of the list reverse() - reverses the list remove_value(value) - removes the first item in the list with this value   Doubly-linked List  Description (video) No need to implement      Stack  Stacks (video) Will not implement. Implementing with array is trivial    Queue  Queue (video) Circular buffer/FIFO Implement using linked-list, with tail pointer:  enqueue(value) - adds value at position at tail dequeue() - returns value and removes least recently added element (front) empty()   Implement using fixed-sized array:  enqueue(value) - adds item at end of available storage dequeue() - returns value and removes least recently added element empty() full()   Cost:  a bad implementation using linked list where you enqueue at head and dequeue at tail would be O(n) because you\u0026rsquo;d need the next to last element, causing a full traversal each dequeue enqueue: O(1) (amortized, linked list and array [probing]) dequeue: O(1) (linked list and array) empty: O(1) (linked list and array)      Hash table   Videos:\n Hashing with Chaining (video) Table Doubling, Karp-Rabin (video) Open Addressing, Cryptographic Hashing (video) PyCon 2010: The Mighty Dictionary (video) PyCon 2017: The Dictionary Even Mightier (video) (Advanced) Randomization: Universal \u0026amp; Perfect Hashing (video) (Advanced) Perfect hashing (video)    Online Courses:\n Core Hash Tables (video) Data Structures (video) Phone Book Problem (video) distributed hash tables:  Instant Uploads And Storage Optimization In Dropbox (video) Distributed Hash Tables (video)      Implement with array using linear probing\n hash(k, m) - m is size of hash table add(key, value) - if key already exists, update value exists(key) get(key) remove(key)      More Knowledge   Binary search  Binary Search (video) Binary Search (video) detail Implement:  binary search (on sorted array of integers) binary search using recursion      Bitwise operations  Bits cheat sheet - you should know many of the powers of 2 from (2^1 to 2^16 and 2^32) Get a really good understanding of manipulating bits with: \u0026amp;, |, ^, ~, \u0026raquo;, \u0026laquo;  words Good intro: Bit Manipulation (video) C Programming Tutorial 2-10: Bitwise Operators (video) Bit Manipulation Bitwise Operation Bithacks The Bit Twiddler The Bit Twiddler Interactive Bit Hacks (video) Practice Operations   2s and 1s complement  Binary: Plusses \u0026amp; Minuses (Why We Use Two\u0026rsquo;s Complement) (video) 1s Complement 2s Complement   Count set bits  4 ways to count bits in a byte (video) Count Bits How To Count The Number Of Set Bits In a 32 Bit Integer   Swap values:  Swap   Absolute value:  Absolute Integer      Trees   Trees - Notes \u0026amp; Background  Series: Trees (video) basic tree construction traversal manipulation algorithms BFS(breadth-first search) and DFS(depth-first search) (video)  BFS notes:  level order (BFS, using queue) time complexity: O(n) space complexity: best: O(1), worst: O(n/2)=O(n)   DFS notes:  time complexity: O(n) space complexity: best: O(log n) - avg. height of tree worst: O(n) inorder (DFS: left, self, right) postorder (DFS: left, right, self) preorder (DFS: self, left, right)        Binary search trees: BSTs  Binary Search Tree Review (video) Introduction (video) MIT (video) C/C++:  Binary search tree - Implementation in C/C++ (video) BST implementation - memory allocation in stack and heap (video) Find min and max element in a binary search tree (video) Find height of a binary tree (video) Binary tree traversal - breadth-first and depth-first strategies (video) Binary tree: Level Order Traversal (video) Binary tree traversal: Preorder, Inorder, Postorder (video) Check if a binary tree is binary search tree or not (video) Delete a node from Binary Search Tree (video) Inorder Successor in a binary search tree (video)   Implement:  insert // insert value into tree get_node_count // get count of values stored print_values // prints the values in the tree, from min to max delete_tree is_in_tree // returns true if given value exists in the tree get_height // returns the height in nodes (single node\u0026rsquo;s height is 1) get_min // returns the minimum value stored in the tree get_max // returns the maximum value stored in the tree is_binary_search_tree delete_value get_successor // returns next-highest value in tree after given value, -1 if none      Heap / Priority Queue / Binary Heap  visualized as a tree, but is usually linear in storage (array, linked list) Heap Introduction (video) Naive Implementations (video) Binary Trees (video) Tree Height Remark (video) Basic Operations (video) Complete Binary Trees (video) Pseudocode (video) Heap Sort - jumps to start (video) Heap Sort (video) Building a heap (video) MIT: Heaps and Heap Sort (video) CS 61B Lecture 24: Priority Queues (video) Linear Time BuildHeap (max-heap) Implement a max-heap:  insert sift_up - needed for insert get_max - returns the max item, without removing it get_size() - return number of elements stored is_empty() - returns true if heap contains no elements extract_max - returns the max item, removing it sift_down - needed for extract_max remove(x) - removes item at index x heapify - create a heap from an array of elements, needed for heap_sort heap_sort() - take an unsorted array and turn it into a sorted array in-place using a max heap or min heap      Sorting   Notes:\n Implement sorts \u0026amp; know best case/worst case, average complexity of each:  no bubble sort - it\u0026rsquo;s terrible - O(n^2), except when n \u0026lt;= 16   Stability in sorting algorithms (\u0026ldquo;Is Quicksort stable?\u0026rdquo;)  Sorting Algorithm Stability Stability In Sorting Algorithms Stability In Sorting Algorithms Sorting Algorithms - Stability   Which algorithms can be used on linked lists? Which on arrays? Which on both?  I wouldn\u0026rsquo;t recommend sorting a linked list, but merge sort is doable. Merge Sort For Linked List      For heapsort, see Heap data structure above. Heap sort is great, but not stable\n  Sedgewick - Mergesort (5 videos)\n 1. Mergesort 2. Bottom up Mergesort 3. Sorting Complexity 4. Comparators 5. Stability    Sedgewick - Quicksort (4 videos)\n 1. Quicksort 2. Selection 3. Duplicate Keys 4. System Sorts    UC Berkeley:\n CS 61B Lecture 29: Sorting I (video) CS 61B Lecture 30: Sorting II (video) CS 61B Lecture 32: Sorting III (video) CS 61B Lecture 33: Sorting V (video)    Bubble Sort (video)\n  Analyzing Bubble Sort (video)\n  Insertion Sort, Merge Sort (video)\n  Insertion Sort (video)\n  Merge Sort (video)\n  Quicksort (video)\n  Selection Sort (video)\n  Merge sort code:\n Using output array (C) Using output array (Python) In-place (C++)    Quick sort code:\n Implementation (C) Implementation (C) Implementation (Python)    Implement:\n Mergesort: O(n log n) average and worst case Quicksort O(n log n) average case Selection sort and insertion sort are both O(n^2) average and worst case For heapsort, see Heap data structure above    Not required, but I recommended them:\n Sedgewick - Radix Sorts (6 videos)  1. Strings in Java 2. Key Indexed Counting 3. Least Significant Digit First String Radix Sort 4. Most Significant Digit First String Radix Sort 5. 3 Way Radix Quicksort 6. Suffix Arrays   Radix Sort Radix Sort (video) Radix Sort, Counting Sort (linear time given constraints) (video) Randomization: Matrix Multiply, Quicksort, Freivalds\u0026rsquo; algorithm (video) Sorting in Linear Time (video)    As a summary, here is a visual representation of 15 sorting algorithms. If you need more detail on this subject, see \u0026ldquo;Sorting\u0026rdquo; section in Additional Detail on Some Subjects\nGraphs Graphs can be used to represent many problems in computer science, so this section is long, like trees and sorting were.\n  Notes:\n There are 4 basic ways to represent a graph in memory:  objects and pointers adjacency matrix adjacency list adjacency map   Familiarize yourself with each representation and its pros \u0026amp; cons BFS and DFS - know their computational complexity, their trade offs, and how to implement them in real code When asked a question, look for a graph-based solution first, then move on if none    MIT(videos):\n Breadth-First Search Depth-First Search    Skiena Lectures - great intro:\n CSE373 2012 - Lecture 11 - Graph Data Structures (video) CSE373 2012 - Lecture 12 - Breadth-First Search (video) CSE373 2012 - Lecture 13 - Graph Algorithms (video) CSE373 2012 - Lecture 14 - Graph Algorithms (con\u0026rsquo;t) (video) CSE373 2012 - Lecture 15 - Graph Algorithms (con\u0026rsquo;t 2) (video) CSE373 2012 - Lecture 16 - Graph Algorithms (con\u0026rsquo;t 3) (video)    Graphs (review and more):\n 6.006 Single-Source Shortest Paths Problem (video) 6.006 Dijkstra (video) 6.006 Bellman-Ford (video) 6.006 Speeding Up Dijkstra (video) Aduni: Graph Algorithms I - Topological Sorting, Minimum Spanning Trees, Prim\u0026rsquo;s Algorithm - Lecture 6 (video) Aduni: Graph Algorithms II - DFS, BFS, Kruskal\u0026rsquo;s Algorithm, Union Find Data Structure - Lecture 7 (video) Aduni: Graph Algorithms III: Shortest Path - Lecture 8 (video) Aduni: Graph Alg. IV: Intro to geometric algorithms - Lecture 9 (video) CS 61B 2014 (starting at 58:09) (video) CS 61B 2014: Weighted graphs (video) Greedy Algorithms: Minimum Spanning Tree (video) Strongly Connected Components Kosaraju\u0026rsquo;s Algorithm Graph Algorithm (video)    Full Coursera Course:\n Algorithms on Graphs (video)    I\u0026rsquo;ll implement:\n DFS with adjacency list (recursive) DFS with adjacency list (iterative with stack) DFS with adjacency matrix (recursive) DFS with adjacency matrix (iterative with stack) BFS with adjacency list BFS with adjacency matrix single-source shortest path (Dijkstra) minimum spanning tree DFS-based algorithms (see Aduni videos above):  check for cycle (needed for topological sort, since we\u0026rsquo;ll check for cycle before starting) topological sort count connected components in a graph list strongly connected components check for bipartite graph      Even More Knowledge   Recursion  Stanford lectures on recursion \u0026amp; backtracking:  Lecture 8 | Programming Abstractions (video) Lecture 9 | Programming Abstractions (video) Lecture 10 | Programming Abstractions (video) Lecture 11 | Programming Abstractions (video)   When it is appropriate to use it? How is tail recursion better than not?  What Is Tail Recursion Why Is It So Bad? Tail Recursion (video)      Dynamic Programming  You probably won\u0026rsquo;t see any dynamic programming problems in your interview, but it\u0026rsquo;s worth being able to recognize a problem as being a candidate for dynamic programming. This subject can be pretty difficult, as each DP soluble problem must be defined as a recursion relation, and coming up with it can be tricky. I suggest looking at many examples of DP problems until you have a solid understanding of the pattern involved. Videos:  the Skiena videos can be hard to follow since he sometimes uses the whiteboard, which is too small to see Skiena: CSE373 2012 - Lecture 19 - Introduction to Dynamic Programming (video) Skiena: CSE373 2012 - Lecture 20 - Edit Distance (video) Skiena: CSE373 2012 - Lecture 21 - Dynamic Programming Examples (video) Skiena: CSE373 2012 - Lecture 22 - Applications of Dynamic Programming (video) Simonson: Dynamic Programming 0 (starts at 59:18) (video) Simonson: Dynamic Programming I - Lecture 11 (video) Simonson: Dynamic programming II - Lecture 12 (video) List of individual DP problems (each is short): Dynamic Programming (video)   Yale Lecture notes:  Dynamic Programming   Coursera:  The RNA secondary structure problem (video) A dynamic programming algorithm (video) Illustrating the DP algorithm (video) Running time of the DP algorithm (video) DP vs. recursive implementation (video) Global pairwise sequence alignment (video) Local pairwise sequence alignment (video)      Design patterns  Quick UML review (video) Learn these patterns:  strategy singleton adapter prototype decorator visitor factory, abstract factory facade observer proxy delegate command state memento iterator composite flyweight   Series of videos (27 videos) Book: Head First Design Patterns  I know the canonical book is \u0026ldquo;Design Patterns: Elements of Reusable Object-Oriented Software\u0026rdquo;, but Head First is great for beginners to OO.   Handy reference: 101 Design Patterns \u0026amp; Tips for Developers    Combinatorics (n choose k) \u0026amp; Probability  Math Skills: How to find Factorial, Permutation and Combination (Choose) (video) Make School: Probability (video) Make School: More Probability and Markov Chains (video) Khan Academy:  Course layout:  Basic Theoretical Probability   Just the videos - 41 (each are simple and each are short):  Probability Explained (video)        NP, NP-Complete and Approximation Algorithms  Know about the most famous classes of NP-complete problems, such as traveling salesman and the knapsack problem, and be able to recognize them when an interviewer asks you them in disguise. Know what NP-complete means. Computational Complexity (video) Simonson:  Greedy Algs. II \u0026amp; Intro to NP Completeness (video) NP Completeness II \u0026amp; Reductions (video) NP Completeness III (Video) NP Completeness IV (video)   Skiena:  CSE373 2012 - Lecture 23 - Introduction to NP-Completeness (video) CSE373 2012 - Lecture 24 - NP-Completeness Proofs (video) CSE373 2012 - Lecture 25 - NP-Completeness Challenge (video)   Complexity: P, NP, NP-completeness, Reductions (video) Complexity: Approximation Algorithms (video) Complexity: Fixed-Parameter Algorithms (video) Peter Norvig discusses near-optimal solutions to traveling salesman problem:  Jupyter Notebook   Pages 1048 - 1140 in CLRS if you have it.    How computers process a program  How CPU executes a program (video) How computers calculate - ALU (video) Registers and RAM (video) The Central Processing Unit (CPU) (video) Instructions and Programs (video)    Caches  LRU cache:  The Magic of LRU Cache (100 Days of Google Dev) (video) Implementing LRU (video) LeetCode - 146 LRU Cache (C++) (video)   CPU cache:  MIT 6.004 L15: The Memory Hierarchy (video) MIT 6.004 L16: Cache Issues (video)      Processes and Threads  Computer Science 162 - Operating Systems (25 videos):  for processes and threads see videos 1-11 Operating Systems and System Programming (video)   What Is The Difference Between A Process And A Thread? Covers:  Processes, Threads, Concurrency issues  Difference between processes and threads Processes Threads Locks Mutexes Semaphores Monitors How they work? Deadlock Livelock   CPU activity, interrupts, context switching Modern concurrency constructs with multicore processors Paging, segmentation and virtual memory (video) Interrupts (video) Process resource needs (memory: code, static storage, stack, heap, and also file descriptors, i/o) Thread resource needs (shares above (minus stack) with other threads in the same process but each has its own pc, stack counter, registers, and stack) Forking is really copy on write (read-only) until the new process writes to memory, then it does a full copy. Context switching  How context switching is initiated by the operating system and underlying hardware?     threads in C++ (series - 10 videos) CS 377 Spring \u0026lsquo;14: Operating Systems from University of Massachusetts concurrency in Python (videos):  Short series on threads Python Threads Understanding the Python GIL (2010)  reference   David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015 Keynote David Beazley - Topics of Interest (Python Asyncio) Mutex in Python      Testing  To cover:  how unit testing works what are mock objects what is integration testing what is dependency injection   Agile Software Testing with James Bach (video) Open Lecture by James Bach on Software Testing (video) Steve Freeman - Test-Driven Development (that’s not what we meant) (video)  slides   Dependency injection:  video Tao Of Testing   How to write tests    String searching \u0026amp; manipulations  Sedgewick - Suffix Arrays (video) Sedgewick - Substring Search (videos)  1. Introduction to Substring Search 2. Brute-Force Substring Search 3. Knuth-Morris Pratt 4. Boyer-Moore 5. Rabin-Karp   Search pattern in text (video)  If you need more detail on this subject, see \u0026ldquo;String Matching\u0026rdquo; section in Additional Detail on Some Subjects.\n  Tries  Note there are different kinds of tries. Some have prefixes, some don\u0026rsquo;t, and some use string instead of bits to track the path I read through code, but will not implement Sedgewick - Tries (3 videos)  1. R Way Tries 2. Ternary Search Tries 3. Character Based Operations   Notes on Data Structures and Programming Techniques Short course videos:  Introduction To Tries (video) Performance Of Tries (video) Implementing A Trie (video)   The Trie: A Neglected Data Structure TopCoder - Using Tries Stanford Lecture (real world use case) (video) MIT, Advanced Data Structures, Strings (can get pretty obscure about halfway through) (video)    Floating Point Numbers  simple 8-bit: Representation of Floating Point Numbers - 1 (video - there is an error in calculations - see video description) 32 bit: IEEE754 32-bit floating point binary (video)    Unicode  The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text    Endianness  Big And Little Endian Big Endian Vs Little Endian (video) Big And Little Endian Inside/Out (video)  Very technical talk for kernel devs. Don\u0026rsquo;t worry if most is over your head. The first half is enough.      Networking  if you have networking experience or want to be a reliability engineer or operations engineer, expect questions Otherwise, this is just good to know Khan Academy UDP and TCP: Comparison of Transport Protocols (video) TCP/IP and the OSI Model Explained! (video) Packet Transmission across the Internet. Networking \u0026amp; TCP/IP tutorial. (video) HTTP (video) SSL and HTTPS (video) SSL/TLS (video) HTTP 2.0 (video) Video Series (21 videos) (video) Subnetting Demystified - Part 5 CIDR Notation (video) Sockets:  Java - Sockets - Introduction (video) Socket Programming (video)       Final Review This section will have shorter videos that you can watch pretty quickly to review most of the important concepts. It's nice if you want a refresher often.   Series of 2-3 minutes short subject videos (23 videos)  Videos   Series of 2-5 minutes short subject videos - Michael Sambol (18 videos):  Videos   Sedgewick Videos - Algorithms I Sedgewick Videos - Algorithms II   Update Your Resume  See Resume prep information in the books: \u0026ldquo;Cracking The Coding Interview\u0026rdquo; and \u0026ldquo;Programming Interviews Exposed\u0026rdquo; I don\u0026rsquo;t know how important this is (you can do your own research) but here is an article on making your resume ATS Compliant:  How to Create or Check if your Resume is ATS Compliant   \u0026ldquo;This Is What A GOOD Resume Should Look Like\u0026rdquo; by Gayle McDowell (author of Cracking the Coding Interview),  Note by the author: \u0026ldquo;This is for a US-focused resume. CVs for India and other countries have different expectations, although many of the points will be the same.\u0026rdquo;    Find a Job  Sites for Finding Jobs  Interview Process \u0026amp; General Interview Prep  How to Pass the Engineering Interview in 2021 Demystifying Tech Recruiting How to Get a Job at the Big 4:  How to Get a Job at the Big 4 - Amazon, Facebook, Google \u0026amp; Microsoft (video) How to Get a Job at the Big 4.1 (Follow-up video)   Cracking The Coding Interview Set 1:  Gayle L McDowell - Cracking The Coding Interview (video) Cracking the Coding Interview with Author Gayle Laakmann McDowell (video)   Cracking the Facebook Coding Interview:  The Approach Problem Walkthrough   Prep Courses:  Software Engineer Interview Unleashed (paid course):  Learn how to make yourself ready for software engineer interviews from a former Google interviewer.   Python for Data Structures, Algorithms, and Interviews (paid course):  A Python centric interview prep course which covers data structures, algorithms, mock interviews and much more.   Intro to Data Structures and Algorithms using Python (Udacity free course):  A free Python centric data structures and algorithms course.   Data Structures and Algorithms Nanodegree! (Udacity paid Nanodegree):  Get hands-on practice with over 100 data structures and algorithm exercises and guidance from a dedicated mentor to help prepare you for interviews and on-the-job scenarios.   Grokking the Behavioral Interview (Educative free course):  Many times, it’s not your technical competency that holds you back from landing your dream job, it’s how you perform on the behavioral interview.      Mock Interviews:\n Gainlo.co: Mock interviewers from big companies - I used this and it helped me relax for the phone screen and on-site interview Pramp: Mock interviews from/with peers - peer-to-peer model of practice interviews interviewing.io: Practice mock interview with senior engineers - anonymous algorithmic/systems design interviews with senior engineers from FAANG anonymously  Be thinking of for when the interview comes Think of about 20 interview questions you\u0026rsquo;ll get, along with the lines of the items below. Have at least one answer for each. Have a story, not just data, about something you accomplished.\n  Why do you want this job?\n  What\u0026rsquo;s a tough problem you\u0026rsquo;ve solved?\n  Biggest challenges faced?\n  Best/worst designs seen?\n  Ideas for improving an existing product\n  How do you work best, as an individual and as part of a team?\n  Which of your skills or experiences would be assets in the role and why?\n  What did you most enjoy at [job x / project y]?\n  What was the biggest challenge you faced at [job x / project y]?\n  What was the hardest bug you faced at [job x / project y]?\n  What did you learn at [job x / project y]?\n  What would you have done better at [job x / project y]?\n  If you find it hard to come up with good answers of these types of interview questions, here are some ideas:\n General Interview Questions and their Answers    Have questions for the interviewer Some of mine (I already may know the answers, but want their opinion or team perspective):\n How large is your team? What does your dev cycle look like? Do you do waterfall/sprints/agile? Are rushes to deadlines common? Or is there flexibility? How are decisions made in your team? How many meetings do you have per week? Do you feel your work environment helps you concentrate? What are you working on? What do you like about it? What is the work life like? How is the work/life balance?  Once You\u0026rsquo;ve Got The Job Congratulations!\nKeep learning.\nYou\u0026rsquo;re never really done.\n ***************************************************************************************************** ***************************************************************************************************** Everything below this point is optional. It is NOT needed for an entry-level interview. However, by studying these, you'll get greater exposure to more CS concepts, and will be better prepared for any software engineering job. You'll be a much more well-rounded software engineer. ***************************************************************************************************** *****************************************************************************************************   Additional Books These are here so you can dive into a topic you find interesting.   The Unix Programming Environment  An oldie but a goodie   The Linux Command Line: A Complete Introduction  A modern option   TCP/IP Illustrated Series Head First Design Patterns  A gentle introduction to design patterns   Design Patterns: Elements of Reusable Object-Oriente​d Software  AKA the \u0026ldquo;Gang Of Four\u0026rdquo; book, or GOF The canonical design patterns book   Algorithm Design Manual (Skiena)  As a review and problem recognition The algorithm catalog portion is well beyond the scope of difficulty you\u0026rsquo;ll get in an interview This book has 2 parts:  Class textbook on data structures and algorithms  Pros:  Is a good review as any algorithms textbook would be Nice stories from his experiences solving problems in industry and academia Code examples in C   Cons:  Can be as dense or impenetrable as CLRS, and in some cases, CLRS may be a better alternative for some subjects Chapters 7, 8, 9 can be painful to try to follow, as some items are not explained well or require more brain than I have Don\u0026rsquo;t get me wrong: I like Skiena, his teaching style, and mannerisms, but I may not be Stony Brook material     Algorithm catalog:  This is the real reason you buy this book. This book is better as an algorithm reference, and not something you read cover to cover.     Can rent it on Kindle Answers:  Solutions Solutions   Errata   Write Great Code: Volume 1: Understanding the Machine  The book was published in 2004, and is somewhat outdated, but it\u0026rsquo;s a terrific resource for understanding a computer in brief The author invented HLA, so take mentions and examples in HLA with a grain of salt. Not widely used, but decent examples of what assembly looks like These chapters are worth the read to give you a nice foundation:  Chapter 2 - Numeric Representation Chapter 3 - Binary Arithmetic and Bit Operations Chapter 4 - Floating-Point Representation Chapter 5 - Character Representation Chapter 6 - Memory Organization and Access Chapter 7 - Composite Data Types and Memory Objects Chapter 9 - CPU Architecture Chapter 10 - Instruction Set Architecture Chapter 11 - Memory Architecture and Organization     Introduction to Algorithms  Important: Reading this book will only have limited value. This book is a great review of algorithms and data structures, but won\u0026rsquo;t teach you how to write good code. You have to be able to code a decent solution efficiently AKA CLR, sometimes CLRS, because Stein was late to the game   Computer Architecture, Sixth Edition: A Quantitative Approach  For a richer, more up-to-date (2017), but longer treatment    System Design, Scalability, Data Handling You can expect system design questions if you have 4+ years of experience.\n Scalability and System Design are very large topics with many topics and resources, since there is a lot to consider when designing a software/hardware system that can scale. Expect to spend quite a bit of time on this Considerations:  Scalability  Distill large data sets to single values Transform one data set to another Handling obscenely large amounts of data   System design  features sets interfaces class hierarchies designing a system under certain constraints simplicity and robustness tradeoffs performance analysis and optimization     START HERE: The System Design Primer System Design from HiredInTech How Do I Prepare To Answer Design Questions In A Technical Interview? 8 Things You Need to Know Before a System Design Interview Database Normalization - 1NF, 2NF, 3NF and 4NF (video) System Design Interview - There are a lot of resources in this one. Look through the articles and examples. I put some of them below How to ace a systems design interview Numbers Everyone Should Know How long does it take to make a context switch? Transactions Across Datacenters (video) A plain English introduction to CAP Theorem MIT 6.824: Distributed Systems, Spring 2020 (20 videos) Consensus Algorithms:  Paxos - Paxos Agreement - Computerphile (video) Raft - An Introduction to the Raft Distributed Consensus Algorithm (video)  Easy-to-read paper Infographic     Consistent Hashing NoSQL Patterns Scalability:  You don\u0026rsquo;t need all of these. Just pick a few that interest you. Great overview (video) Short series:  Clones Database Cache Asynchronism   Scalable Web Architecture and Distributed Systems Fallacies of Distributed Computing Explained Jeff Dean - Building Software Systems At Google and Lessons Learned (video) Introduction to Architecting Systems for Scale Scaling mobile games to a global audience using App Engine and Cloud Datastore (video) How Google Does Planet-Scale Engineering for Planet-Scale Infra (video) The Importance of Algorithms Sharding Engineering for the Long Game - Astrid Atkinson Keynote(video) 7 Years Of YouTube Scalability Lessons In 30 Minutes  video   How PayPal Scaled To Billions Of Transactions Daily Using Just 8VMs How to Remove Duplicates in Large Datasets A look inside Etsy\u0026rsquo;s scale and engineering culture with Jon Cowie (video) What Led Amazon to its Own Microservices Architecture To Compress Or Not To Compress, That Was Uber\u0026rsquo;s Question When Should Approximate Query Processing Be Used? Google\u0026rsquo;s Transition From Single Datacenter, To Failover, To A Native Multihomed Architecture The Image Optimization Technology That Serves Millions Of Requests Per Day A Patreon Architecture Short Tinder: How Does One Of The Largest Recommendation Engines Decide Who You\u0026rsquo;ll See Next? Design Of A Modern Cache Live Video Streaming At Facebook Scale A Beginner\u0026rsquo;s Guide To Scaling To 11 Million+ Users On Amazon\u0026rsquo;s AWS A 360 Degree View Of The Entire Netflix Stack Latency Is Everywhere And It Costs You Sales - How To Crush It What Powers Instagram: Hundreds of Instances, Dozens of Technologies Salesforce Architecture - How They Handle 1.3 Billion Transactions A Day ESPN\u0026rsquo;s Architecture At Scale - Operating At 100,000 Duh Nuh Nuhs Per Second See \u0026ldquo;Messaging, Serialization, and Queueing Systems\u0026rdquo; way below for info on some of the technologies that can glue services together Twitter:  O\u0026rsquo;Reilly MySQL CE 2011: Jeremy Cole, \u0026ldquo;Big and Small Data at @Twitter\u0026rdquo; (video) Timelines at Scale   For even more, see \u0026ldquo;Mining Massive Datasets\u0026rdquo; video series in the Video Series section   Practicing the system design process: Here are some ideas to try working through on paper, each with some documentation on how it was handled in the real world:  review: The System Design Primer System Design from HiredInTech cheat sheet flow:  Understand the problem and scope:  Define the use cases, with interviewer\u0026rsquo;s help Suggest additional features Remove items that interviewer deems out of scope Assume high availability is required, add as a use case   Think about constraints:  Ask how many requests per month Ask how many requests per second (they may volunteer it or make you do the math) Estimate reads vs. writes percentage Keep 80/20 rule in mind when estimating How much data written per second Total storage required over 5 years How much data read per second   Abstract design:  Layers (service, data, caching) Infrastructure: load balancing, messaging Rough overview of any key algorithm that drives the service Consider bottlenecks and determine solutions     Exercises:  Design a random unique ID generation system Design a key-value database Design a picture sharing system Design a recommendation system Design a URL-shortener system: copied from above Design a cache system      Additional Learning I added them to help you become a well-rounded software engineer, and to be aware of certain technologies and algorithms, so you'll have a bigger toolbox.    Compilers  How a Compiler Works in ~1 minute (video) Harvard CS50 - Compilers (video) C++ (video) Understanding Compiler Optimization (C++) (video)    Emacs and vi(m)  Familiarize yourself with a unix-based code editor vi(m):  Editing With vim 01 - Installation, Setup, and The Modes (video) VIM Adventures set of 4 videos:  The vi/vim editor - Lesson 1 The vi/vim editor - Lesson 2 The vi/vim editor - Lesson 3 The vi/vim editor - Lesson 4   Using Vi Instead of Emacs   emacs:  Basics Emacs Tutorial (video) set of 3 (videos):  Emacs Tutorial (Beginners) -Part 1- File commands, cut/copy/paste, cursor commands Emacs Tutorial (Beginners) -Part 2- Buffer management, search, M-x grep and rgrep modes Emacs Tutorial (Beginners) -Part 3- Expressions, Statements, ~/.emacs file and packages   Evil Mode: Or, How I Learned to Stop Worrying and Love Emacs (video) Writing C Programs With Emacs (maybe) Org Mode In Depth: Managing Structure (video)      Unix command line tools  I filled in the list below from good tools. bash cat grep sed awk curl or wget sort tr uniq strace tcpdump    Information theory (videos)  Khan Academy More about Markov processes:  Core Markov Text Generation Core Implementing Markov Text Generation Project = Markov Text Generation Walk Through   See more in MIT 6.050J Information and Entropy series below    Parity \u0026amp; Hamming Code (videos)  Intro Parity Hamming Code:  Error detection Error correction   Error Checking    Entropy  Also see videos below Make sure to watch information theory videos first Information Theory, Claude Shannon, Entropy, Redundancy, Data Compression \u0026amp; Bits (video)    Cryptography  Also see videos below Make sure to watch information theory videos first Khan Academy Series Cryptography: Hash Functions Cryptography: Encryption    Compression  Make sure to watch information theory videos first Computerphile (videos):  Compression Entropy in Compression Upside Down Trees (Huffman Trees) EXTRA BITS/TRITS - Huffman Trees Elegant Compression in Text (The LZ 77 Method) Text Compression Meets Probabilities   Compressor Head videos (optional) Google Developers Live: GZIP is not enough!    Computer Security  MIT (23 videos)  Introduction, Threat Models Control Hijacking Attacks Buffer Overflow Exploits and Defenses Privilege Separation Capabilities Sandboxing Native Code Web Security Model Securing Web Applications Symbolic Execution Network Security Network Protocols Side-Channel Attacks      Garbage collection  GC in Python (video) Deep Dive Java: Garbage Collection is Good! Deep Dive Python: Garbage Collection in CPython (video)    Parallel Programming  Coursera (Scala) Efficient Python for High Performance Parallel Computing (video)    Messaging, Serialization, and Queueing Systems  Thrift  Tutorial   Protocol Buffers  Tutorials   gRPC  gRPC 101 for Java Developers (video)   Redis  Tutorial   Amazon SQS (queue) Amazon SNS (pub-sub) RabbitMQ  Get Started   Celery  First Steps With Celery   ZeroMQ  Intro - Read The Manual   ActiveMQ Kafka MessagePack Avro    A*  A Search Algorithm A* Pathfinding Tutorial (video) A* Pathfinding (E01: algorithm explanation) (video)    Fast Fourier Transform  An Interactive Guide To The Fourier Transform What is a Fourier transform? What is it used for? What is the Fourier Transform? (video) Divide \u0026amp; Conquer: FFT (video) Understanding The FFT    Bloom Filter  Given a Bloom filter with m bits and k hashing functions, both insertion and membership testing are O(k) Bloom Filters (video) Bloom Filters | Mining of Massive Datasets | Stanford University (video) Tutorial How To Write A Bloom Filter App    HyperLogLog  How To Count A Billion Distinct Objects Using Only 1.5KB Of Memory    Locality-Sensitive Hashing  Used to determine the similarity of documents The opposite of MD5 or SHA which are used to determine if 2 documents/strings are exactly the same Simhashing (hopefully) made simple    van Emde Boas Trees  Divide \u0026amp; Conquer: van Emde Boas Trees (video) MIT Lecture Notes    Augmented Data Structures  CS 61B Lecture 39: Augmenting Data Structures    Balanced search trees   Know at least one type of balanced binary tree (and know how it\u0026rsquo;s implemented):\n  \u0026ldquo;Among balanced search trees, AVL and 2/3 trees are now passé, and red-black trees seem to be more popular. A particularly interesting self-organizing data structure is the splay tree, which uses rotations to move any accessed key to the root.\u0026rdquo; - Skiena\n  Of these, I chose to implement a splay tree. From what I\u0026rsquo;ve read, you won\u0026rsquo;t implement a balanced search tree in your interview. But I wanted exposure to coding one up and let\u0026rsquo;s face it, splay trees are the bee\u0026rsquo;s knees. I did read a lot of red-black tree code\n Splay tree: insert, search, delete functions If you end up implementing red/black tree try just these: Search and insertion functions, skipping delete    I want to learn more about B-Tree since it\u0026rsquo;s used so widely with very large data sets\n  Self-balancing binary search tree\n  AVL trees\n In practice: From what I can tell, these aren\u0026rsquo;t used much in practice, but I could see where they would be: The AVL tree is another structure supporting O(log n) search, insertion, and removal. It is more rigidly balanced than red–black trees, leading to slower insertion and removal but faster retrieval. This makes it attractive for data structures that may be built once and loaded without reconstruction, such as language dictionaries (or program dictionaries, such as the opcodes of an assembler or interpreter) MIT AVL Trees / AVL Sort (video) AVL Trees (video) AVL Tree Implementation (video) Split And Merge    Splay trees\n In practice: Splay trees are typically used in the implementation of caches, memory allocators, routers, garbage collectors, data compression, ropes (replacement of string used for long text strings), in Windows NT (in the virtual memory, networking and file system code) etc CS 61B: Splay Trees (video) MIT Lecture: Splay Trees:  Gets very mathy, but watch the last 10 minutes for sure. Video      Red/black trees\n These are a translation of a 2-3 tree (see below). In practice: Red–black trees offer worst-case guarantees for insertion time, deletion time, and search time. Not only does this make them valuable in time-sensitive applications such as real-time applications, but it makes them valuable building blocks in other data structures which provide worst-case guarantees; for example, many data structures used in computational geometry can be based on red–black trees, and the Completely Fair Scheduler used in current Linux kernels uses red–black trees. In the version 8 of Java, the Collection HashMap has been modified such that instead of using a LinkedList to store identical elements with poor hashcodes, a Red-Black tree is used Aduni - Algorithms - Lecture 4 (link jumps to starting point) (video) Aduni - Algorithms - Lecture 5 (video) Red-Black Tree An Introduction To Binary Search And Red Black Tree    2-3 search trees\n In practice: 2-3 trees have faster inserts at the expense of slower searches (since height is more compared to AVL trees). You would use 2-3 tree very rarely because its implementation involves different types of nodes. Instead, people use Red Black trees. 23-Tree Intuition and Definition (video) Binary View of 23-Tree 2-3 Trees (student recitation) (video)    2-3-4 Trees (aka 2-4 trees)\n In practice: For every 2-4 tree, there are corresponding red–black trees with data elements in the same order. The insertion and deletion operations on 2-4 trees are also equivalent to color-flipping and rotations in red–black trees. This makes 2-4 trees an important tool for understanding the logic behind red–black trees, and this is why many introductory algorithm texts introduce 2-4 trees just before red–black trees, even though 2-4 trees are not often used in practice. CS 61B Lecture 26: Balanced Search Trees (video) Bottom Up 234-Trees (video) Top Down 234-Trees (video)    N-ary (K-ary, M-ary) trees\n note: the N or K is the branching factor (max branches) binary trees are a 2-ary tree, with branching factor = 2 2-3 trees are 3-ary K-Ary Tree    B-Trees\n Fun fact: it\u0026rsquo;s a mystery, but the B could stand for Boeing, Balanced, or Bayer (co-inventor). In Practice: B-Trees are widely used in databases. Most modern filesystems use B-trees (or Variants). In addition to its use in databases, the B-tree is also used in filesystems to allow quick random access to an arbitrary block in a particular file. The basic problem is turning the file block i address into a disk block (or perhaps to a cylinder-head-sector) address B-Tree B-Tree Datastructure Introduction to B-Trees (video) B-Tree Definition and Insertion (video) B-Tree Deletion (video) MIT 6.851 - Memory Hierarchy Models (video) - covers cache-oblivious B-Trees, very interesting data structures - the first 37 minutes are very technical, may be skipped (B is block size, cache line size)      k-D Trees  Great for finding number of points in a rectangle or higher dimension object A good fit for k-nearest neighbors Kd Trees (video) kNN K-d tree algorithm (video)    Skip lists  \u0026ldquo;These are somewhat of a cult data structure\u0026rdquo; - Skiena Randomization: Skip Lists (video) For animations and a little more detail    Network Flows  Ford-Fulkerson in 5 minutes — Step by step example (video) Ford-Fulkerson Algorithm (video) Network Flows (video)    Disjoint Sets \u0026amp; Union Find  UCB 61B - Disjoint Sets; Sorting \u0026amp; selection (video) Sedgewick Algorithms - Union-Find (6 videos)    Math for Fast Processing  Integer Arithmetic, Karatsuba Multiplication (video) The Chinese Remainder Theorem (used in cryptography) (video)    Treap  Combination of a binary search tree and a heap Treap Data Structures: Treaps explained (video) Applications in set operations    Linear Programming (videos)  Linear Programming Finding minimum cost Finding maximum value Solve Linear Equations with Python - Simplex Algorithm    Geometry, Convex hull (videos)  Graph Alg. IV: Intro to geometric algorithms - Lecture 9 Geometric Algorithms: Graham \u0026amp; Jarvis - Lecture 10 Divide \u0026amp; Conquer: Convex Hull, Median Finding    Discrete math  Computer Science 70, 001 - Spring 2015 - Discrete Mathematics and Probability Theory Discrete Mathematics by Shai Simonson (19 videos) Discrete Mathematics By IIT Ropar NPTEL    Machine Learning  Why ML?  How Google Is Remaking Itself As A Machine Learning First Company Large-Scale Deep Learning for Intelligent Computer Systems (video) Deep Learning and Understandability versus Software Engineering and Verification by Peter Norvig   Google\u0026rsquo;s Cloud Machine learning tools (video) Google Developers\u0026rsquo; Machine Learning Recipes (Scikit Learn \u0026amp; Tensorflow) (video) Tensorflow (video) Tensorflow Tutorials Practical Guide to implementing Neural Networks in Python (using Theano) Courses:  Great starter course: Machine Learning - videos only - see videos 12-18 for a review of linear algebra (14 and 15 are duplicates) Neural Networks for Machine Learning Google\u0026rsquo;s Deep Learning Nanodegree Google/Kaggle Machine Learning Engineer Nanodegree Self-Driving Car Engineer Nanodegree Metis Online Course ($99 for 2 months)   Resources:  Books:  Python Machine Learning Data Science from Scratch: First Principles with Python Introduction to Machine Learning with Python   Machine Learning for Software Engineers Data School: http://www.dataschool.io/       Additional Detail on Some Subjects I added these to reinforce some ideas already presented above, but didn't want to include them above because it's just too much. It's easy to overdo it on a subject. You want to get hired in this century, right?    SOLID\n Bob Martin SOLID Principles of Object Oriented and Agile Design (video) S - Single Responsibility Principle | Single responsibility to each Object  more flavor   O - Open/Closed Principle | On production level Objects are ready for extension but not for modification  more flavor   L - Liskov Substitution Principle | Base Class and Derived class follow ‘IS A’ Principle  more flavor   I - Interface segregation principle | clients should not be forced to implement interfaces they don\u0026rsquo;t use  Interface Segregation Principle in 5 minutes (video) more flavor   D -Dependency Inversion principle | Reduce the dependency In composition of objects.  Why Is The Dependency Inversion Principle And Why Is It Important more flavor      Union-Find\n Overview Naive Implementation Trees Union By Rank Path Compression Analysis Options    More Dynamic Programming (videos)\n 6.006: Dynamic Programming I: Fibonacci, Shortest Paths 6.006: Dynamic Programming II: Text Justification, Blackjack 6.006: DP III: Parenthesization, Edit Distance, Knapsack 6.006: DP IV: Guitar Fingering, Tetris, Super Mario Bros. 6.046: Dynamic Programming \u0026amp; Advanced DP 6.046: Dynamic Programming: All-Pairs Shortest Paths 6.046: Dynamic Programming (student recitation)    Advanced Graph Processing (videos)\n Synchronous Distributed Algorithms: Symmetry-Breaking. Shortest-Paths Spanning Trees Asynchronous Distributed Algorithms: Shortest-Paths Spanning Trees    MIT Probability (mathy, and go slowly, which is good for mathy things) (videos):\n MIT 6.042J - Probability Introduction MIT 6.042J - Conditional Probability MIT 6.042J - Independence MIT 6.042J - Random Variables MIT 6.042J - Expectation I MIT 6.042J - Expectation II MIT 6.042J - Large Deviations MIT 6.042J - Random Walks    Simonson: Approximation Algorithms (video)\n  String Matching\n Rabin-Karp (videos):  Rabin Karps Algorithm Precomputing Optimization: Implementation and Analysis Table Doubling, Karp-Rabin Rolling Hashes, Amortized Analysis   Knuth-Morris-Pratt (KMP):  TThe Knuth-Morris-Pratt (KMP) String Matching Algorithm   Boyer–Moore string search algorithm  Boyer-Moore String Search Algorithm Advanced String Searching Boyer-Moore-Horspool Algorithms (video)   Coursera: Algorithms on Strings  starts off great, but by the time it gets past KMP it gets more complicated than it needs to be nice explanation of tries can be skipped      Sorting\n Stanford lectures on sorting:  Lecture 15 | Programming Abstractions (video) Lecture 16 | Programming Abstractions (video)   Shai Simonson, Aduni.org:  Algorithms - Sorting - Lecture 2 (video) Algorithms - Sorting II - Lecture 3 (video)   Steven Skiena lectures on sorting:  lecture begins at 26:46 (video) lecture begins at 27:40 (video) lecture begins at 35:00 (video) lecture begins at 23:50 (video)      Video Series Sit back and enjoy.\n  List of individual Dynamic Programming problems (each is short)\n  x86 Architecture, Assembly, Applications (11 videos)\n  MIT 18.06 Linear Algebra, Spring 2005 (35 videos)\n  Excellent - MIT Calculus Revisited: Single Variable Calculus\n  CSE373 - Analysis of Algorithms (25 videos)\n Skiena lectures from Algorithm Design Manual    UC Berkeley 61B (Spring 2014): Data Structures (25 videos)\n  UC Berkeley 61B (Fall 2006): Data Structures (39 videos)\n  UC Berkeley 61C: Machine Structures (26 videos)\n  OOSE: Software Dev Using UML and Java (21 videos)\n  UC Berkeley CS 152: Computer Architecture and Engineering (20 videos)\n  MIT 6.004: Computation Structures (49 videos)\n  Carnegie Mellon - Computer Architecture Lectures (39 videos)\n  MIT 6.006: Intro to Algorithms (47 videos)\n  MIT 6.033: Computer System Engineering (22 videos)\n  MIT 6.034 Artificial Intelligence, Fall 2010 (30 videos)\n  MIT 6.042J: Mathematics for Computer Science, Fall 2010 (25 videos)\n  MIT 6.046: Design and Analysis of Algorithms (34 videos)\n  MIT 6.050J: Information and Entropy, Spring 2008 (19 videos)\n  MIT 6.824: Distributed Systems, Spring 2020 (20 videos)\n  MIT 6.851: Advanced Data Structures (22 videos)\n  MIT 6.854: Advanced Algorithms, Spring 2016 (24 videos)\n  Harvard COMPSCI 224: Advanced Algorithms (25 videos)\n  MIT 6.858 Computer Systems Security, Fall 2014\n  Stanford: Programming Paradigms (27 videos)\n  Introduction to Cryptography by Christof Paar\n Course Website along with Slides and Problem Sets    Mining Massive Datasets - Stanford University (94 videos)\n  Graph Theory by Sarada Herke (67 videos)\n  Computer Science Courses  Directory of Online CS Courses Directory of CS Courses (many with online lectures)  Algorithms implementation  Multiple Algorithms implementation by Princeton University  Papers  Love classic papers? 1978: Communicating Sequential Processes  implemented in Go   2003: The Google File System  replaced by Colossus in 2012   2004: MapReduce: Simplified Data Processing on Large Clusters  mostly replaced by Cloud Dataflow?   2006: Bigtable: A Distributed Storage System for Structured Data 2006: The Chubby Lock Service for Loosely-Coupled Distributed Systems 2007: Dynamo: Amazon’s Highly Available Key-value Store  The Dynamo paper kicked off the NoSQL revolution   2007: What Every Programmer Should Know About Memory (very long, and the author encourages skipping of some sections) 2012: AddressSanitizer: A Fast Address Sanity Checker:  paper video   2013: Spanner: Google’s Globally-Distributed Database:  paper video   2014: Machine Learning: The High-Interest Credit Card of Technical Debt 2015: Continuous Pipelines at Google 2015: High-Availability at Massive Scale: Building Google’s Data Infrastructure for Ads 2015: TensorFlow: Large-Scale Machine Learning on Heterogeneous Distributed Systems 2015: How Developers Search for Code: A Case Study More papers: 1,000 papers  LICENSE CC-BY-SA-4.0\n","permalink":"http://intervalrain.github.io/posts/washam/","summary":"Coding Interview University John Washam:\n I originally created this as a short to-do list of study topics for becoming a software engineer, but it grew to the large list you see today. After going through this study plan, I got hired as a Software Development Engineer at Amazon! You probably won\u0026rsquo;t have to study as much as I did. Anyway, everything you need is here.\nI studied about 8-12 hours a day, for several months.","title":"[Washam] Way to Software Engineer"}]