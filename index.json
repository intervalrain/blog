[{"content":"一、回溯法 二、回溯法的應用 三、例題 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 2-3. 分治法 接著閱讀：[Algo] 2-5. 動態規劃 ","permalink":"http://intervalrain.github.io/posts/cs/algo/backtracking/","summary":"一、回溯法 二、回溯法的應用 三、例題 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 2-3. 分治法 接著閱讀：[Algo] 2-5. 動態規劃 ","title":"[Algo] 2-4. 回溯法 Backtracking"},{"content":"一、分治法 分治法，簡而言之就是分而治之，把複雜的問題分成兩個或更多個相似或相似的子問題，直到子問題可以直接求解，最後再將子問題的解做合併。 三步驟：Divide、Conquer、Merge 以 pseudo code 來表示大概像： void func(collection set) { // 子問題求解 if (base_case) { // 根據要求將子問題解合併成母問題解 do_something return; } // 將母問題分解成子問題 for (collection subset : set) { func(subset); } } graph LR; 母問題--\u003e子問題1; 母問題--\u003e子問題2; subgraph Divide 子問題1--\u003e最小子問題1; 子問題1--\u003e最小子問題2; 子問題2--\u003e最小子問題3; 子問題2--\u003e最小子問題4; end subgraph Conquer 最小子問題1--\u003e最小子問題解1; 最小子問題2--\u003e最小子問題解2; 最小子問題3--\u003e最小子問題解3; 最小子問題4--\u003e最小子問題解4; end subgraph Merge 最小子問題解1--\u003e合併; 最小子問題解2--\u003e合併; 最小子問題解3--\u003e合併; 最小子問題解4--\u003e合併; end 合併--\u003e母問題解 舉例說明，河內塔遊戲： 河內塔是由三根桿子以大小不同碟片所組成的遊戲，僧人一次可以從一根桿子移動一個碟片到另一根桿子，但是小的碟片若放憂大的碟片下面會使得小的碟片裂開(也就是碟片只能由上而下從小排到大)，試問將一座塔從一根桿子完整的移動到另一根桿子需要移動多少次。 思考上面的情形，以三個碟片為例，若我們要從 A 到 C 移動一座塔，我們可以將之分解成「如何把上面兩個碟片移動到 B」，因為剩下的一個大碟片，可以很簡單的從 A 移動到 C。也就是說 f3(A-\u0026gt;C) = f2(A-\u0026gt;B) + f1(A-\u0026gt;C) + f2(B-\u0026gt;C)。 再更進一步，f2(A-\u0026gt;B) 和 f2(B-\u0026gt;C) 其實就是移動兩個碟片到另一座塔，所以可以分解成 f2(A-\u0026gt;C) = f1(A-\u0026gt;B) + f1(A-\u0026gt;C) + f1(B-\u0026gt;C)，至此，我們已經把 f3 都分解成可以代表一次移動的最小子問題的解 f1 了： graph TD; A[f3,A-\u003eC] B[f2,A-\u003eB] C[f1,A-\u003eC] D[f2,B-\u003eC] E[f1,A-\u003eC] F[f1,A-\u003eB] G[f1,C-\u003eB] H[f1,B-\u003eA] I[f1,B-\u003eC] J[f1,A-\u003eC] A--\u003eB A---\u003eC A--\u003eD B--\u003eE B--\u003eF B--\u003eG D--\u003eH D--\u003eI D--\u003eJ 故我們可以以數學方式證明：\n\\(\\begin{array}{l} T(n)=T(n-1)+T(1)+T(n-1)=2T(n-1)+T(1)\\\\ T(n-1)=T(n-2)+T(1)+T(n-2)=2T(n-2)+T(1)\\\\ T(n)=2[2T(n-2)+T(1)]+T(1)\\\\ T(n)=2\\times2T(n-2)+(1+2)T(1)\\\\ T(n)=2^k\\times T(n-k)+(1+2+\u0026hellip;+2^k)T(1)\\\\ 令k=n-1\\\\ T(n)=2^{n-1}\\times T(1)+(1+2+\u0026hellip;+2^{n-1})T(1)\\\\ T(n)=2^{n-1}\\times T(1)+\\frac{2^{n-1}-1}{2-1}T(1)\\\\ T(n)=(2^n-1)\\times T(1) \\end{array}\\) 得所需要的移動次數為 \\(2^n-1\\) 次 分治法的特色 要解決的問題有一定的規模 該問題可以分解成若干個規模較小的問題 可以找到一個 base case，可以直接求解(如上述數學證明的\\(T(1)\\)) 分解出來的子問題都是相互獨立的。(若有相依性，則無法使用分治法) 分治法的時間複雜度 將規模為 n 的問題分為 k個規模為 n/m 的子問題去解，那麼可以得到\n\\(T(n)=kT(n/m)+f(n)\\) 二、分治法的應用 1. 二元搜索法 Binary Search 令有一已排序的數列，欲查找該數列中是否有數值 x。 由於該數列已經過排序，所以我們無需遍歷整個數列，我們可以選擇每次挑選數列的中間值，若目標比中間值大，則選擇大的那側再繼續做篩選，此法稱為二元搜索法，其時間複雜度可以從線性搜索法的 \\(O(n)\\) 降低到 \\(O(n\\log n)\\)。 int binarySearch(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size()-1; while (left \u0026lt;= right) { int mid = left + (right-left)/2; if (nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid - 1; } return -1; } 2. Strassen 矩陣乘法 試做一個矩陣\\(A\\)與矩陣\\(B\\)內積。 \\( A=\\left[\\begin{matrix}A_{11}\u0026amp;A_{12}\\\\A_{21}\u0026amp;A_{22}\\end{matrix}\\right], B=\\left[\\begin{matrix}B_{11}\u0026amp;B_{12}\\\\B_{21}\u0026amp;B_{22}\\end{matrix}\\right], C=\\left[\\begin{matrix}C_{11}\u0026amp;C_{12}\\\\C_{21}\u0026amp;C_{22}\\end{matrix}\\right],其中\\\\ \\left[\\begin{matrix}C_{11}\u0026amp;C_{12}\\\\C_{21}\u0026amp;C_{22}\\end{matrix}\\right]=\\left[\\begin{matrix}A_{11}\u0026amp;A_{12}\\\\A_{21}\u0026amp;A_{22}\\end{matrix}\\right]\\cdot\\left[\\begin{matrix}B_{11}\u0026amp;B_{12}\\\\B_{21}\u0026amp;B_{22}\\end{matrix}\\right] \\) 若通過一般展開可得\n\\( C_{11}=A_{11}\\cdot B_{11}+A_{12}\\cdot B_{21}\\\\ C_{12}=A_{11}\\cdot B_{12}+A_{12}\\cdot B_{22}\\\\ C_{21}=A_{21}\\cdot B_{11}+A_{22}\\cdot B_{21}\\\\ C_{22}=A_{21}\\cdot B_{12}+A_{22}\\cdot B_{22} \\) 從上可得計算兩個 \\(n\\cdot n\\) 的矩陣內積需要 兩個 \\(\\frac{n}{2}\\cdot\\frac{n}{2}\\) 的矩陣做 8 次的乘法加上 4 次的加法，其時間複雜度可以表示成： \\( T(n)=8T(\\frac{n}{2})+\\Theta(n^2)\\\\ T(\\frac{n}{2})=8T(\\frac{n}{4})+\\Theta({\\frac{n}{2}}^2)\\\\ T(n)=8\\left[{8T(\\frac{n}{4})+\\Theta({{(\\frac{n}{2}})}^2)}\\right]+\\Theta(n^2)\\\\ T(n)=8^2T(\\frac{n}{4})+\\Theta(n^2)+8\\Theta(\\frac{n^2}{4})=8^2T(\\frac{n}{4})+(1+2)\\Theta(n^2)\\\\ T(n)=8^kT(\\frac{n}{2^k})+(1+2+\u0026hellip;+2^{k-1})\\Theta(n^2)\\\\ 令n=2^k\\\\ T(n)=n^3T(1)+(\\frac{n/2-1}{2-1})\\Theta(n^2)\\approx \\Theta(n^3) \\) 若使用 Strassen 演算法 同樣將矩陣\\(A,B,C\\)作分解，\\(時間\\Theta(1)\\) 創建 10 個 \\(\\frac{n}{2}\\cdot\\frac{n}{2}\\) 的矩陣 \\(S_1,S_2,\u0026hellip;,S_{10}\\)，時間\\(\\Theta(n^2)\\)\n\\( S_1=B_{12}-B_{22}\\\\ S_2=A_{11}+A_{12}\\\\ S_3=A_{21}+A_{22}\\\\ S_4=B_{21}-B_{11}\\\\ S_5=A_{11}+A_{22}\\\\ S_6=B_{11}+B_{22}\\\\ S_7=A_{12}-A_{22}\\\\ S_8=B_{21}+B_{22}\\\\ S_9=A_{11}-A_{21}\\\\ S_{10}=B_{11}+B_{12}\\\\ \\) 遞迴的計算 7 個矩陣積 \\(P_1,P_2,\u0026hellip;,P_7\\)，其中每個矩陣\\(P_i\\)都是\\(\\frac{n}{2}\\cdot\\frac{n}{2}\\)的。\n\\( P_1=A_{11}\\cdot S_1=A_{11}\\cdot B_{12}-A_{11}\\cdot B_{22}\\\\ P_2=S_2\\cdot B_{22}=A_{11}\\cdot B_{22}+A_{12}\\cdot B_{22}\\\\ P_3=S_3\\cdot B_{11}=A_{21}\\cdot B_{11}+A_{22}\\cdot B_{11}\\\\ P_4=A_{22}\\cdot S_4=A_{22}\\cdot B_{21}-A_{22}\\cdot B_{11}\\\\ P_5=S_5\\cdot S_6=A_{11}\\cdot B_{11}+A_{11}\\cdot B_{22}+A_{22}\\cdot B_{11}+A_{22}\\cdot B_{22}\\\\ P_6=S_7\\cdot S_8=A_{12}\\cdot B_{21}+A_{12}\\cdot B_{22}-A_{22}\\cdot B_{21}-A_{22}\\cdot B_{22}\\\\\\\\ P_7=S_9\\cdot S_{10}=A_{11}\\cdot B_{11}+A_{11}\\cdot B_{12}-A_{21}\\cdot B_{11}-A_{21}\\cdot B_{12}\\\\\\\\\\\\ \\) 藉由 \\(P_i\\) 來計算得到 矩陣 \\(C\\)：時間\\(\\Theta(n^2)\\)\n\\( C_{11}=P_5+P_4-P_2+P_6\\\\ C_{12}=P_1+P_2\\\\ C_{21}=P_3+P_4\\\\ C_{22}=P_5+P_1-P_3-P_7 \\) 綜合已上可得： \\( T(n)=\\bigg\\lbrace \\begin{array}{ll} \\Theta(1)\u0026amp;若n=1\\\\ 7T{\\frac{n}{2}}+\\Theta(n^2)\u0026amp;若n\u0026gt;1 \\end{array} \\) 故時間複雜度可推得 \\(T(n)=\\Theta(n^{\\log_27})\\approx \\Theta(n^{2.807})\\) 參考來源 Wikipedia 3. 合併排序 Merge Sort 在[Algo] 0-4. 二元樹(Binary Tree)中有介紹過，合併排序跟快速排序都有著類似前序、後序的結構， 步驟： 將數列拆成若干個只有 1 個元素的子數列(因為只有一個元素，所有可以視為已排序的數列)。 將已排序的數列兩兩合併，直到所有的數列都合併完成，即完成排序。 程式碼實作：mergeSort 4. 快速排序 Quick Sort 步驟： 選定一個數當作樞紐(pivot)，將小於此數的值都放到左邊，大於此數的都放到右邊。 反覆同樣動作，直到子數列只有一個數，即完成排序。 程式碼實作：quickSort 三、例題 1. 樹類問題 樹相關的問題很常有著類似的解題結構：\n在 base state 時，直接回傳答案(base result)。 對根的節點做遞迴的處理 將遞迴過後的回傳值做處理之後回傳。 T function(TreeNode* root) { if (BASE_STATE) return BASE_RESULT; T left = function(root-\u0026gt;left); T right = function(root-\u0026gt;right); T res = SOME_OPERATION(left, right, root); return res; } 1. Maxmium Binary Tree Leetcode 654. Maximum Binary Tree 給定一個數列，數列中的最大值為根，其索引值比根的索引值還小的子數列形成另一個子節，比根的索引值還大的子數列同樣形成另一個子節，以此類推。 以分治法的想法思考，我們會想得到一個函式 f(nums, s, e)，s 代表數列的最小索引值，e 代表數列的最大索引值，若 r 為該數列最大值的索引值，那麼我們應該會得到一個節點，其左子節點為 f(nums, s, r-1)，右子節點為 f(nums, r+1, e。 分治法的目標是要將問題由大化小，直到 base state 出現(即可以直接得到結果的一個狀態)，以此題而言就是當 s == e 或 s \u0026lt; e 時， s == e 時，應該要回傳 new TreeNode(s)。 s \u0026lt; e 時，應該要回傳 NULL。 根據上面的分析可以得到下面完整的程式碼： TreeNode* constructMaximumBinaryTree(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return build(nums, 0, nums.size()-1); } TreeNode* build(vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, int end) { if (start \u0026gt; end) return nullptr; if (start == end) return new TreeNode(nums[start]); int r = start; for (int i = start; i \u0026lt;= end; i++) { if (nums[i] \u0026gt; nums[r]) r = i; // 找尋最大值的索引值 } TreeNode* left = build(nums, start, r-1); TreeNode* right = build(nums, r+1, end); return new TreeNode(nums[r], left, right); } 2.Balance a Binary Search Tree Leetcode 1382. Balance a Binary Search Tree 這題若想要用 rotate 的方式去思考會很難解，但若把它想成是一個已排序的數列，要進行 BST 的建樹的話，就非常簡單了。 首先我們想得到一個已排序的數列，我們可以用 inorder traversal(中序遍歷) 去收集所有的節點。 剩下的部分就跟Leetcode 108. Convert Sorted Array to Binary Search Tree一樣了，當我們將數列索引值正中間的節點擺在根節點，那麼一定會滿足其兩邊的深度差不超過 1。 用分治法的思維，我們會想得到一個函式f(vec, s, e)，s 代表數列的最小索引值，e代表數列的最大索引值，若 mid 為該數列最中間的索引值，那麼我們會得到一個節點，其左子節點為 f(vec, s, mid-1，右子節點為 f(vec, mid-1, e)。 其 base state 為 s == e 或 s \u0026lt; e 時， s == e 時，回傳 vec[s]。 s \u0026gt; e 時，回傳 NULL。 根據上面的分析可得完整的程式碼： TreeNode* balanceBST(TreeNode* root) { vector\u0026lt;TreeNode*\u0026gt; vec; collect(root, vec); return build(vec, 0, vec.size()-1); } // 中序遍歷以收集到已排序的節點數列 void collect(TreeNode* root, vector\u0026lt;TreeNode*\u0026gt;\u0026amp; vec) { if (!root) return; collect(root-\u0026gt;left,vec); vec.push_back(root); collect(root-\u0026gt;right,vec); root-\u0026gt;left = nullptr; // 預先將節點之間的關係先清除 root-\u0026gt;right = nullptr; } TreeNode* build(vector\u0026lt;TreeNode*\u0026gt;\u0026amp; vec, int start, int end) { if (start \u0026gt; end) return nullptr; if (start == end) return vec[start]; int mid = start + (end-start)/2; // 求中間點 auto left = build(vec, start, mid-1); auto right = build(vec, mid+1, end); vec[mid]-\u0026gt;left = left; vec[mid]-\u0026gt;right = right; return vec[mid]; } 從上面兩個範例可以發現，樹類應用分治法於建樹問題上，基本上有著分常相似的框架，基本上都是想辦法把大問題拆成若干個同質的小問題，直到拆成 base state 之後再將答案組合起來。 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 2-2. 貪心演算法 接著閱讀：[Algo] 2-4. 回溯法 ","permalink":"http://intervalrain.github.io/posts/cs/algo/divide_and_conquer/","summary":"一、分治法 分治法，簡而言之就是分而治之，把複雜的問題分成兩個或更多個相似或相似的子問題，直到子問題可以直接求解，最後再將子問題的解做合併。 三步驟：Divide、Conquer、Merge 以 pseudo code 來表示大概像： void func(collection set) { // 子問題求解 if (base_case) { // 根據要求將子問題解合併成母問題解 do_something return; } // 將母問題分解成子問題 for (collection subset : set) { func(subset); } } graph LR; 母問題--\u003e子問題1; 母問題--\u003e子問題2; subgraph Divide 子問題1--\u003e最小子問題1; 子問題1--\u003e最小子問題2; 子問題2--\u003e最小子問題3; 子問題2--\u003e最小子問題4; end subgraph Conquer 最小子問題1--\u003e最小子問題解1; 最小子問題2--\u003e最小子問題解2; 最小子問題3--\u003e最小子問題解3; 最小子問題4--\u003e最小子問題解4; end subgraph Merge 最小子問題解1--\u003e合併; 最小子問題解2--\u003e合併; 最小子問題解3--\u003e合併; 最小子問題解4--\u003e合併; end 合併--\u003e母問題解 舉例說明，河內塔遊戲： 河內塔是由三根桿子以大小不同碟片所組成的遊戲，僧人一次可以從一根桿子移動一個碟片到另一根桿子，但是小的碟片若放憂大的碟片下面會使得小的碟片裂開(也就是碟片只能由上而下從小排到大)，試問將一座塔從一根桿子完整的移動到另一根桿子需要移動多少次。 思考上面的情形，以三個碟片為例，若我們要從 A 到 C 移動一座塔，我們可以將之分解成「如何把上面兩個碟片移動到 B」，因為剩下的一個大碟片，可以很簡單的從 A 移動到 C。也就是說 f3(A-\u0026gt;C) = f2(A-\u0026gt;B) + f1(A-\u0026gt;C) + f2(B-\u0026gt;C)。 再更進一步，f2(A-\u0026gt;B) 和 f2(B-\u0026gt;C) 其實就是移動兩個碟片到另一座塔，所以可以分解成 f2(A-\u0026gt;C) = f1(A-\u0026gt;B) + f1(A-\u0026gt;C) + f1(B-\u0026gt;C)，至此，我們已經把 f3 都分解成可以代表一次移動的最小子問題的解 f1 了： graph TD; A[f3,A-\u003eC] B[f2,A-\u003eB] C[f1,A-\u003eC] D[f2,B-\u003eC] E[f1,A-\u003eC] F[f1,A-\u003eB] G[f1,C-\u003eB] H[f1,B-\u003eA] I[f1,B-\u003eC] J[f1,A-\u003eC] A--\u003eB A---\u003eC A--\u003eD B--\u003eE B--\u003eF B--\u003eG D--\u003eH D--\u003eI D--\u003eJ 故我們可以以數學方式證明：","title":"[Algo] 2-3. 分治法 Divide and Conquer"},{"content":"一、貪心演算法 是一種在每一步都採前當下看起來最好的選擇的一種策略。 由於是當下看起來最好的選擇，故也有可能選到錯的路線，導致最終的答案不是最佳解。 先舉個生活中常見的例子： 今天小明的撲滿裡存滿了大大小小的1塊、5塊跟10塊，今天小明打算要要幫撲滿瘦身，令它的重量降低，那麼小明可以到銀行換鈔，將幣值小、重量重的硬幣集結起來換成幣值大、重量輕的紙鈔。 用貪心演算法的思維，我們一定是從幣值大的 1000 開始換起，再來 500、100、50、10，以此類推，有多少換多少。 // vector\u0026lt;int\u0026gt;\u0026amp; nums = {1000, 500, 100, 50, 10, 5, 1}; vector\u0026lt;int\u0026gt; coinChange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int money) { vector\u0026lt;int\u0026gt; res(nums.size(), 0); for (int i = 0; i \u0026lt; nums.size(); i++) { res[i] += (money / nums[i]); money %= nums[i]; } return res; } 但若我們新增了一個幣值是 23，那麼上面這個思路就有可能會導致錯誤。 貪心演算法的特點 直覺且快速 通常不是最佳的 需要會被要求證明 always stays ahead：跑者每個時間點都在第一名，最後結果會是第一名 用歸納法證明。 exchange argument 用反證法，找到原解的 inversions，並作交換，證明交換後並不影響最佳解。 二、貪心演算法的應用 0. 核心思維 貪心演算法是從某一個初始狀態出發，每次通過選取區域性最優解向目標前進，並最終期望取得整體最優解的一種演算法。由這個定義可知，貪心選擇標準就是選擇當前最好的決策，貪心演算法根據這個標準進行決策，將原問題變成一個相似但規模更小的子問題，而後每一步選出來的一定是原問題整體最優解的一部分。\n如果一個問題貪心後只剩下一個子問題且有最優子結構，那麼該問題就可以使用貪心演算法。當一個問題的整體最優解包含其子問題的最優解時，我們稱次問題具有最優子結構性質。 解題一般步驟 設計資料結構並找規律 進心貪心猜想 正確性證明(歸納法證明或是列舉反例進行反證) 實現程式碼 1. 找零錢問題(Coin Change) 先用剛剛提到的那一題來試做： 以貪心法的思維來做就是，幣值愈大先換，換到不能再換時再往次大的幣值換。 vector\u0026lt;int\u0026gt; coinChange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int money) { vector\u0026lt;int\u0026gt; res(nums.size(), 0); for (int i = 0; i \u0026lt; nums.size(); i++) { res[i] += (money / nums[i]); money %= nums[i]; } return res; } 以範例 nums = {1000, 500, 100, 50, 23, 10, 5, 1}，money = 1069 來測試看看，以上述得到的結果應該是：(參考例題Leetcode 322. Coin Change) {1000, 500, 100, 50, 23, 10, 5, 1} = {1, 0, 0, 1, 0, 1, 1, 4}，也就是說，得到的硬幣總數是 8(假設所有幣值都是硬幣)。 因為夾雜了 23，使得問題變得稍微有點不一樣，因為最佳解可以是：\n{1000, 500, 100, 50, 23, 10, 5, 1} = {1, 0, 0, 0, 3, 0, 0, 0}，總數 4。 從上面此例來觀察，貪心法是需要有適用時機的，當今天少掉 23 的時候，使用貪心法是可以得到最佳解的，因為所有數字互為因數、倍數關係，也就是說，當今天可以用 1 張 1000 解決的情況，必定可以用其它幣值用更多的代價來替換，如 2 張 500，或 10 張 100。但是 23 可以替換的是 2 個 10 塊加上 3 個 1 塊。用數字為例的話如下 \\(\\boxed{\\begin{array}{ll} 1069\u0026amp;=1\\times1000+1\\times50+1\\times10+1\\times5+4\\times1\\\\ \u0026amp;=1\\times(2\\times500)+1\\times50+1\\times10+1\\times5+4\\times1\\\\ \u0026amp;=1\\times(10\\times100)+1\\times50+1\\times10+1\\times5+4\\times1\\\\ \u0026amp;=1\\times(20\\times50)+1\\times50+1\\times10+1\\times5+4\\times1\\\\ \\end{array}} \\) 不管怎麼換，總數都是變大。 如果要解出上述的最佳解，需要做一點修正，或是使用暴力破解法，例如 bfs 來遍歷所有情形來獲得最小值。 試想要怎麼改寫可以使貪法仍然可以適用，「將23拿掉」那麼貪心法就仍可以適用，那要怎麼有技巧的將 23 拿掉呢。 23 能夠有效的替換表示我們一定會使用到 23，也就是說我們可以找到反例使 23 不能有效的替換就好了。 23 = 23*1(1) 換 10*2 + 1*3(5) 46 = 23*2(2) 換 10*4 + 5*1 + 1*1(6) 69 = 23*3(3) 換 50*1 + 10*1 + 1*4(6) 92 = 23*4(4) 換 50*1 + 10*4 + 1*2(7) 115 = 23*5(5) 換 100*1 + 10*1 + 5*1(3) 我們可以發現當 23 替換到第 5 個的時候已經不能有效的替換了，表示我們只有嘗試替換 0~4 個 23 硬幣，其餘剩下的錢用貪心法去計算，仍然可以得到有效的解。(在此只是為了展示失去「局部最佳性」的範例，不做嚴謹的數學證明) 即求 min(f(1069)+0, f(1046)+1, f(1023)+2, f(1000)+3, f(976)+4。 vector\u0026lt;int\u0026gt; coinChange(vector\u0026lt;int\u0026gt;\u0026amp;nums, int money) { ... } // implement by greedy vector\u0026lt;int\u0026gt; coinChangePlus(vector\u0026lt;int\u0026gt;\u0026amp;nums, int money) { vector\u0026lt;int\u0026gt; res; int coins = INT_MAX; for (int i = 0; i \u0026lt;= 4; i++) { vector\u0026lt;int\u0026gt; tmp = coinChange(nums, money-23*i); tmp[4]+=i; int cnt = accumulate(tmp.begin(), tmp.end(), 0); if (cnt \u0026lt; coins) { res = tmp; coins = cnt; } } return res; } 以上方法當遇到單一奇異數(無因倍數關係)的時候還可以用，但遇到多個奇異數的時候，複雜度就會明顯上升，到時後我們會遇用其它方法來解構。在後面的動態規劃篇，有深入的介紹，如何利用其它技巧達到剪枝得到最佳解。 由此可發現，貪心法不一定會得到最佳解，需要嚴格的驗證「局部最佳性」，才能保證最後的解是最佳解。 2. 背包問題(Knapsack Problem) 常見的背包問題分為分數背包問題與0-1背包問題。 今天在某個場合，你有一個載重5kg的背包，面前有3kg的金沙、3kg的銀沙與2kg的銅沙，已知金的價格比銀高，銀的價格比銅高。你可以任意決定怎麼將它們裝進背包，最後換取對應價值的獎金，試問怎麼裝可以得到最高的獎金？ 同樣的場合，金沙、銀沙、銅沙換成了金塊、銀塊、銅塊，分別也是 3kg、3kg、2kg，且不可切割，試問要怎麼裝可以得到最高的獎金？ 第1題(分數背包)，顯而易見，用貪心法來做一定是盡可能先裝滿價值高的金沙，再用剩餘的空間以此類推裝填其它的。(3kg金沙+2kg銀沙) 第2題(0-1背包)，由於拿完金塊，無法再拿銀塊，所以最佳解變成了拿金塊與銅塊。(3kg金塊+2kg銅塊) 三、例題 1. 餅乾分配問題 Leetcode 455. Assign Cookies 有若干個不同份量的餅乾，與若干個需要不同份量才能滿足的小孩，試問餅乾最多可以讓幾個小孩滿意。 把餅乾的份量從小排到大，把小孩從需求小排到需求大。 盡可能的滿足需求小的小孩。(若需求小的都滿足不了，那麼需求大的就不可能滿足了) int findContentChildren(vector\u0026lt;int\u0026gt;\u0026amp; children, vector\u0026lt;int\u0026gt;\u0026amp; cookies) { sort(children.begin(), children.end()); sort(cookies.begin(), cookies.end()); int child = 0, cookie = 0; while (child \u0026lt; children.size() \u0026amp;\u0026amp; cookie \u0026lt; cookies.size()) { if (children[child] \u0026lt;= cookies[cookie]) child++; cookie++; } return child; } 2. 股票買賣問題 Leetcode 122. Best Timer to Buy and Sell Stock II 有一數列為某上市公司每日的股價，若手上最多只能有一張股票，要怎麼樣買賣可以得到最高獲利。 最高獲利代表所有上升波段的總和，忽略所有下降波段。 int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int sum = 0; int last = prices[0]; for (const auto\u0026amp; price : prices) { sum += (price \u0026gt; last) ? price - last : 0; last = price } return sum; } 3. 跳躍遊戲 55. Jump Game 有一數列表示，在該 i 索引位置起，最多可以跳幾個索引長度，試問從索引值為 0 開始，可否到達索引值為 n-1。 盡可能的往前跳，不斷的更新最遠可以到達的位置。 bool canJump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int reach = nums[0]; for (int i = 0; i \u0026lt; nums.size() \u0026amp;\u0026amp; i \u0026lt;= reach; i++) { if (i == nums.size()-1) return true; reach = max(reach, nums[i]+i); } return false; } 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 2-1. 暴力演算法 接著閱讀：[Algo] 2-3. 分治法 ","permalink":"http://intervalrain.github.io/posts/cs/algo/greedy/","summary":"一、貪心演算法 是一種在每一步都採前當下看起來最好的選擇的一種策略。 由於是當下看起來最好的選擇，故也有可能選到錯的路線，導致最終的答案不是最佳解。 先舉個生活中常見的例子： 今天小明的撲滿裡存滿了大大小小的1塊、5塊跟10塊，今天小明打算要要幫撲滿瘦身，令它的重量降低，那麼小明可以到銀行換鈔，將幣值小、重量重的硬幣集結起來換成幣值大、重量輕的紙鈔。 用貪心演算法的思維，我們一定是從幣值大的 1000 開始換起，再來 500、100、50、10，以此類推，有多少換多少。 // vector\u0026lt;int\u0026gt;\u0026amp; nums = {1000, 500, 100, 50, 10, 5, 1}; vector\u0026lt;int\u0026gt; coinChange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int money) { vector\u0026lt;int\u0026gt; res(nums.size(), 0); for (int i = 0; i \u0026lt; nums.size(); i++) { res[i] += (money / nums[i]); money %= nums[i]; } return res; } 但若我們新增了一個幣值是 23，那麼上面這個思路就有可能會導致錯誤。 貪心演算法的特點 直覺且快速 通常不是最佳的 需要會被要求證明 always stays ahead：跑者每個時間點都在第一名，最後結果會是第一名 用歸納法證明。 exchange argument 用反證法，找到原解的 inversions，並作交換，證明交換後並不影響最佳解。 二、貪心演算法的應用 0. 核心思維 貪心演算法是從某一個初始狀態出發，每次通過選取區域性最優解向目標前進，並最終期望取得整體最優解的一種演算法。由這個定義可知，貪心選擇標準就是選擇當前最好的決策，貪心演算法根據這個標準進行決策，將原問題變成一個相似但規模更小的子問題，而後每一步選出來的一定是原問題整體最優解的一部分。\n如果一個問題貪心後只剩下一個子問題且有最優子結構，那麼該問題就可以使用貪心演算法。當一個問題的整體最優解包含其子問題的最優解時，我們稱次問題具有最優子結構性質。 解題一般步驟 設計資料結構並找規律 進心貪心猜想 正確性證明(歸納法證明或是列舉反例進行反證) 實現程式碼 1.","title":"[Algo] 2-2. 貪心演算法 Greedy"},{"content":"一、暴力演算法 暴力演算法就是枚舉法，試想今天有一個行李箱的密碼鎖為四個一組，但你又忘記密碼，那要怎麼辦？你會試著從 0000 轉到 9999 共 10000 種組合都試過，必定會找出密碼，把所有可能都枚舉過一遍，遍是暴力演算法。\n暴力演算法可以應用於很多問題，包含數論、樹、圖論等等，而暴力演算法的重點在於枚舉所有可能，以樹來說就是樹的遍歷。\n舉例來說：\nLeetcode 1. Two Sum\n給定一個數列，找數列中任兩個數的和為 target，回傳兩個數的索引值。 在還沒有認識任何資料結構之前，我們能想到最簡單的方法就是遍歷整個數列，用兩個指標 i 與 j，各指向一個數，將所有可能檢查過一遍，直到找到目標。 vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { for (int i = 0; i \u0026lt; nums.size() - 1; i++) for (int j = i + 1; j \u0026lt; nums.size(); j++) if (nums[i] + nums[j] == target) return {i, j}; return {-1, -1}; } 以上例來說，用暴力破解法求解時，求兩數和的時候，我們需進行兩個維度的 for-loop 迴圈來求解。若進一步到三數和、四數和、五數和時，我們會發現，維度會隨著多少個數字和增加。也就是三數和為 3 個迴圈，四數和為 4 個迴圈，以此類推。 以 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis來分析，也就相當於 k 數和的時間複雜度為 \\(O(n^k)\\)，這個增長是相當恐怖的。 暴力演算法的特點\n簡單粗暴 將所有可能枚舉出來，藉由電腦的運算力高於人腦的特性。 執行效率低 由於所有的情形都需列舉出來，所以執行效率低。 只適用於規模小的問題。 可作用衡量效率問題的基礎算法 暴力法可以看成是某問題時間效能的底限，所以可以用來衡量其它演算法的效率。 二、暴力演算法應用 1. 數組 線性搜索法(Linear Search) 將一個資料集合的所有元素遍歷一次，找到所需的目標。 例：有一個數列共有 n 個元素，找數列中是否含有某數 target，若有則回傳其索引值，若無則回傳 -1。 int findTarget(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] == target) return i; } return -1; } 2. 樹 深度優先搜索法(Depth-First Search, DFS) 一直往樹的子節點搜索，直到子葉再退回。 相關的遍歷法有：pre-ordered traversal(前序遍歷)、post-ordered traversal(後序遍歷)、in-ordered traversal(中序遍歷)。 bool find(TreeNode* root, int target) { if (!root) return false; if (root-\u0026gt;val == target) return true; return find(root-\u0026gt;left, target) || find(root-\u0026gt;right, target); } 廣度優先搜索法(Breadth-First Search, BFS) 從樹的一根點出發，將此根節點所有的子節點都遍歷完在進行下一次的搜索。 相關的遍歷法有：level-ordered traversal(層序遍歷)。 bool find(TreeNode* root, int target) { queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while (!q.empty()) { int sz = q.size(); while (sz--) { TreeNode* curr = q.front(); q.pop(); if (curr-\u0026gt;val == target) return true; if (curr-\u0026gt;left) q.push(curr-\u0026gt;left); if (curr-\u0026gt;right) q.push(curr-\u0026gt;right); } } return false; } 3. 圖論 圖跟樹的差別在於 圖可能有多個子節點。 圖可能是單向或雙向的。 以 DFS, BFS 處理圖論，需要額外處理已經遍歷過的節點。 深度優先搜索法(Depth-First Search, DFS) unordered_set\u0026lt;Node*\u0026gt; visited; bool find(Node* root, int target) { if (!root) return false; if (visited.count(root)) return false; visited.insert(root); if (root-\u0026gt;val == target) return true; for (TreeNode* child : root-\u0026gt;children) { if (find(child, target)) return true; } return false; } 廣度優先搜索法(Breadth-First Search, BFS) unordered_set\u0026lt;Node*\u0026gt; visited bool find(Node* root, int target) { queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); visited.insert(root); while (!q.empty()) { int sz = q.size(); while (sz--) { TreeNode* curr = q.front(); q.pop(); if (curr-\u0026gt;val == target) return true; for (TreeNode* child : root-\u0026gt;children) { if (visited.count(child)) continue; q.push(child); visited.insert(child); } } } return false; } 三、例題 最後用一題 Leetcode 的密碼鎖問題來作結。 Leetcode 752. Open the Lock 這題密碼鎖多加了一些條件，當轉到某些暗鎖時，會鎖死，所以必須要避開這些數字組合。 這題可以套用圖論的 bfs，把暗鎖放入到已經遍歷過的組合 visited，接著就是模擬轉動密碼的動作，即可解題。 string plus(string s, int i) { if (s[i] == \u0026#39;9\u0026#39;) { s[i] = \u0026#39;0\u0026#39;; } else { s[i]++; } return s; } string minus(string s, int i) { if (s[i] == \u0026#39;0\u0026#39;) { s[i] = \u0026#39;9\u0026#39;; } else { s[i]--; } return s; } int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) { unordered_set\u0026lt;string\u0026gt; set(deadends.begin(), deadends.end()); string start = \u0026#34;0000\u0026#34;; if (set.count(start)) return -1; queue\u0026lt;string\u0026gt; q; q.push(start); int step = 0; while (!q.empty()) { int sz = q.size(); while (sz--) { string curr = q.front(); q.pop(); if (curr == target) return step; for (int i = 0; i \u0026lt; 4; i++) { string next; next = plus(curr, i); if (!set.count(next)) q.push(next); set.insert(next); next = minus(curr, i); if (!set.count(next)) q.push(next); set.insert(next); } } step++; } return -1; } 回到目錄：[Algo] 演算法筆記 接著閱讀：[Algo] 2-2. 貪心演算法 ","permalink":"http://intervalrain.github.io/posts/cs/algo/brute_force/","summary":"一、暴力演算法 暴力演算法就是枚舉法，試想今天有一個行李箱的密碼鎖為四個一組，但你又忘記密碼，那要怎麼辦？你會試著從 0000 轉到 9999 共 10000 種組合都試過，必定會找出密碼，把所有可能都枚舉過一遍，遍是暴力演算法。\n暴力演算法可以應用於很多問題，包含數論、樹、圖論等等，而暴力演算法的重點在於枚舉所有可能，以樹來說就是樹的遍歷。\n舉例來說：\nLeetcode 1. Two Sum\n給定一個數列，找數列中任兩個數的和為 target，回傳兩個數的索引值。 在還沒有認識任何資料結構之前，我們能想到最簡單的方法就是遍歷整個數列，用兩個指標 i 與 j，各指向一個數，將所有可能檢查過一遍，直到找到目標。 vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { for (int i = 0; i \u0026lt; nums.size() - 1; i++) for (int j = i + 1; j \u0026lt; nums.size(); j++) if (nums[i] + nums[j] == target) return {i, j}; return {-1, -1}; } 以上例來說，用暴力破解法求解時，求兩數和的時候，我們需進行兩個維度的 for-loop 迴圈來求解。若進一步到三數和、四數和、五數和時，我們會發現，維度會隨著多少個數字和增加。也就是三數和為 3 個迴圈，四數和為 4 個迴圈，以此類推。 以 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis來分析，也就相當於 k 數和的時間複雜度為 \\(O(n^k)\\)，這個增長是相當恐怖的。 暴力演算法的特點","title":"[Algo] 2-1. 暴力演算法 Brute Force"},{"content":"491. Non-decreasing Subsequences\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Backtracking、Bit Manipulation 一、題目 Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.\nExample 1:\nInput: nums = [4,6,7,7] Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] Explanation: Example 2:\nInput: nums = [4,4,3,2,1] Output: [[4,4]] Constraints:\n\u0026lt;= nums.length \u0026lt;= 15 -100 \u0026lt;= nums[i] \u0026lt;= 100 二、分析 這一很典型的是一個 backtrack 的問題，只要熟悉回溯法的框架並注意終止條件與處理重覆子序列即可。 終止條件為 i == nums.size()，此時將遍歷過的 path 加入 res，但要注意題目有規定至少要 2 個元素的子序列，故需要再加入前做確認。 注意題目傳回的子序列不可重覆，故需要額外做處理。 三、解題 1. Backtracking Time complexity: \\(O(2^n)\\) Space complexity: \\(O(n)\\) vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findSubsequences(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; path; dfs(nums, 0, path, res); sort(res.begin(), res.end()); // 先做排序後 for (int i = res.size()-1; i \u0026gt;= 1; i--) { // 從後面往前迭代 if (res[i] == res[i-1]) { res.erase(res.begin()+i); // 刪除重覆的序列 } } return res; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, int i, vector\u0026lt;int\u0026gt;\u0026amp; path, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; res) { if (i == nums.size()) { // 終止條件 if (path.size() \u0026gt; 1) { // 滿足子序列元素大於等於2個，則加入答案 res.push_back(path); } return; } if (path.size() == 0 || nums[i] \u0026gt;= path.back()) { // 注意需滿足題意為上升序列 path.push_back(nums[i]); // 加入子序列 dfs(nums, i+1, path, res); path.pop_back(); // 回溯法需將元素 pop 掉 } dfs(nums, i+1, path, res); // 跳過不取 } 2. Backtracking(optimized) Time complexity: \\(O(2^n)\\) Space complexity: \\(O(n)\\) vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findSubsequences(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; path; dfs(nums, 0, path, res); return res; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, int i, vector\u0026lt;int\u0026gt;\u0026amp; path, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; res) { if (i == nums.size()) { if (path.size() \u0026gt; 1) { res.push_back(path); } return; } if (path.size() == 0 || nums[i] \u0026gt;= path.back()) { path.push_back(nums[i]); dfs(nums, i+1, path, res); path.pop_back(); } if (path.size() == 0 || nums[i] != path.back()) { // 處理重覆子序列 dfs(nums, i+1, path, res); } } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/491/","summary":"491. Non-decreasing Subsequences\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Backtracking、Bit Manipulation 一、題目 Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.\nExample 1:\nInput: nums = [4,6,7,7] Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] Explanation: Example 2:\nInput: nums = [4,4,3,2,1] Output: [[4,4]] Constraints:\n\u0026lt;= nums.length \u0026lt;= 15 -100 \u0026lt;= nums[i] \u0026lt;= 100 二、分析 這一很典型的是一個 backtrack 的問題，只要熟悉回溯法的框架並注意終止條件與處理重覆子序列即可。 終止條件為 i == nums.","title":"[LeetCode] 491. Non-decreasing Subsequences"},{"content":"C# 2 一、泛型 使用泛型(generic type)可以在編寫在編譯時類型安全的通用程式碼，無須事先知道要使用的具體類型。 示例1: array類型: 大小需預先設定，若要添加需要重新分配 public static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(string[] names) { foreach (string name in names) { Console.WriteLine(name); } } public static string[] GenerateNames() { string[] names = new string[4]; names[0] = \u0026#34;Mike\u0026#34;; names[1] = \u0026#34;Rain\u0026#34;; names[2] = \u0026#34;Jessica\u0026#34;; names[3] = \u0026#34;Billy\u0026#34;; return names; } 示例2: ArrayList類型: ArrayList.Add是Object的方法，但如果塞入不適合的參數類型，可能會引發InvalidCastException\npublic static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(ArrayList names) { foreach (object name in names) { Console.WriteLine(name); } } public static ArrayList GenerateNames() { ArrayList names = new ArrayList(); names.Add(\u0026#34;Mike\u0026#34;); names.Add(\u0026#34;Rain\u0026#34;); names.Add(\u0026#34;Jessica\u0026#34;); names.Add(\u0026#34;Billy\u0026#34;); return names; } 示例3: StringCollection專用類型: 解決前述兩個問題，但也限制了返回值。\npublic static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(StringCollection names) { foreach (string name in names) { Console.WriteLine(name); } } public static StringCollection GenerateNames() { StringCollection names = new StringCollection(); names.Add(\u0026#34;Mike\u0026#34;); names.Add(\u0026#34;Rain\u0026#34;); names.Add(\u0026#34;Jessica\u0026#34;); names.Add(\u0026#34;Billy\u0026#34;); return names; } 示例4: List泛型\npublic static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(List\u0026lt;string\u0026gt; names) { foreach (string name in names) { Console.WriteLine(name); } } public static List\u0026lt;string\u0026gt; GenerateNames() { var names = new List\u0026lt;string\u0026gt; { \u0026#34;Mike\u0026#34;, \u0026#34;Rain\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Billy\u0026#34; }; return names; } 泛型可以解決： 與 Array 不同，不需在創建前先知道集合的大小。 與 ArrayList 不同，在對外提供的 API 中，一切表示元素類型之處皆用 T 來代指。如果向集合添加了錯的元素，在編譯即會報錯。 與 StringCollection 不同，List\u0026lt;T\u0026gt; 可兼容所有類型，省去了實現其它類型的程式碼與處理返回值等的問題。 1. 形參與實參 Parameter and Argument 宣告函數時用於描述函數輸入類別的參數稱為形參(parameter)。 函數調用時實際傳遞給函數的參數稱為實參(argument)。 泛型及兩個參數概念：類型形參(Type parameter)和類型實參(type argument)，相當於把形參和實參的思想套用在表示類型訊息上。 // Type parameter public class List\u0026lt;T\u0026gt; ... { } // Type argument List\u0026lt;string\u0026gt; list = new List\u0026lt;string\u0026gt;(); 同樣，當宣告有繼承母類別或是介面時，泛型形參也可以作為母類別或介面的泛型實參。 public class List\u0026lt;T\u0026gt; : IEnumerable\u0026lt;T\u0026gt; 2. 泛型類型與泛型方法的度(arity) 泛型類型或泛型方法可以宣告多個類型形參。 public class Dictionary\u0026lt;TKey, TValue\u0026gt; 泛型度(arity)是泛型宣告中類型形參的數量，非泛型的宣告可視為泛型度為 0。 泛型度不同的同名接口，就屬於不同的類型。如IEnumerable\u0026lt;T\u0026gt; 與 IEnumerable，但不能僅透過類型形參名稱重載方法。 也不能出現重複的類型形參名稱；但同名類型實參是許可的。 public void Method() {} // arity = 0 public void Method\u0026lt;T\u0026gt;()) {} // arity = 1 public void Method\u0026lt;T1,T2\u0026gt;() {} // arity = 2 public void Method\u0026lt;Tone, Ttwo\u0026gt;() {} // 編譯錯誤, 不能僅透過類型形參名稱重載方法 public void Method\u0026lt;T,T,T\u0026gt;(){} // 編譯錯誤, 重複的類型形參名稱 var dict = new Dictoinary\u0026lt;string,string\u0026gt;(); // 同名類型實參是允許的 3. 泛型的適用範圍 enum 不能宣告為泛型 class, struct, interface, delegate 都可以被宣告成泛型類型。 但 class member 中，有些看似是泛型其實不然，原則是：判斷一個宣告是否為泛型宣告取決於它是否引入新的類型形參。 public class ValidatingList\u0026lt;TItem\u0026gt; { // 實際上 TItem 用作 List\u0026lt;T\u0026gt; 的類型實參，TItem 由 Validating 的宣告來引入類型形參。 private readonly List\u0026lt;TItem\u0026gt; items = new LIst\u0026lt;TItem\u0026gt;(); } 4. 方法類型實參的類型推斷 方法類型在以下情境時，可以省略類型實參，編譯器可以自動推斷實際的類型： public static List\u0026lt;T\u0026gt; CopyList\u0026lt;T\u0026gt;(List\u0026lt;T\u0026gt; input) { ... } public static void Main() { List\u0026lt;int\u0026gt; nums = new List\u0026lt;int\u0026gt;{ 1,2,3,5,8,13 }; List\u0026lt;int\u0026gt; copyList1 = CopyList\u0026lt;int\u0026gt;(nums); List\u0026lt;int\u0026gt; copyList2 = CopyList(nums); // 省略類型實參 } 利用方法類型實參的自動推斷，我們可以靜用靜態方法重載建構式，以簡化建構式。 public static void Main() { var tuple1 = new Tuple\u0026lt;int,int\u0026gt;(3,7); var tuple2 = CreateTuple(4,2); } public static Tuple\u0026lt;T1,T2\u0026gt; CreateTuple\u0026lt;T1,T2\u0026gt;(T1 x, T2 y) { return new Tuple\u0026lt;T1,T2\u0026gt;(x, y); } 5. 類型約束 6. default 與 typeof 7. 泛型類型初始化與狀態 二、可空值類型 三、委托 四、迭代器 五、其它的小特性 ","permalink":"http://intervalrain.github.io/posts/it/csharp_depth_ch2/","summary":"C# 2 一、泛型 使用泛型(generic type)可以在編寫在編譯時類型安全的通用程式碼，無須事先知道要使用的具體類型。 示例1: array類型: 大小需預先設定，若要添加需要重新分配 public static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(string[] names) { foreach (string name in names) { Console.WriteLine(name); } } public static string[] GenerateNames() { string[] names = new string[4]; names[0] = \u0026#34;Mike\u0026#34;; names[1] = \u0026#34;Rain\u0026#34;; names[2] = \u0026#34;Jessica\u0026#34;; names[3] = \u0026#34;Billy\u0026#34;; return names; } 示例2: ArrayList類型: ArrayList.Add是Object的方法，但如果塞入不適合的參數類型，可能會引發InvalidCastException\npublic static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(ArrayList names) { foreach (object name in names) { Console.","title":"[IT] C# Depth Ch.2 C# 2"},{"content":"974. Subarray Sums Divisible by K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Prefix Sum 一、題目 Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [4,5,0,-2,-3,1], k = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by k = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Example 2:\nInput: nums = [5], k = 9 Output: 0 Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 3 * 10^4 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 2 \u0026lt;= k \u0026lt;= 10^4 二、分析 觀察此題，要求子序列的和可以被 k 整除，我們可以用 prefix sum 來做這一題，那麼就可以利用 prefix[j] - prefix[j] 來檢查是否被 k 整除，若可以整除代表從 i+1 到 j 的子序列，為符合題意的子序列。 為了方便起見，要檢查 0 到 j 是否滿足，那麼 i 需要為 -1，故我們可以預先將 0 加入 prefix array 中，代表，到 j 為止沒有跳過任一元素。 由於我們要查找兩數相減可以被 k整除，我們可以預先將 prefix sum 處理成範為在 0~k 之間的數，那麼我們需要查找的，便是 prefix[i] == prefix[j]，證明： \\(0\u0026lt;a\u0026lt;k,0\u0026lt;b\u0026lt;k\\) \\(-k\u0026lt;b-a\u0026lt;k\\) \\(在 -k與 k之間，只有 0 滿足 k 的倍數，也就是a=b\\) 根據上述關係，我們可以利用 Hash Table，更高效的查找我們需要的找的對象，而不必真的存一個 prefix array。 三、解題 1. prefix sum Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int subarraysDivByK(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // vector\u0026lt;int\u0026gt; prefix = {0}; int sum = 0; int res = 0; unordered_map\u0026lt;int,int\u0026gt; map; map[0] = 1; for (const auto\u0026amp; x : nums) { sum += x; int val = sum % k; if (val \u0026lt; 0) val += k; // prefix.push_back(val); if (map.count(val)) res += map[val]; map[val]++; } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/974/","summary":"974. Subarray Sums Divisible by K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Prefix Sum 一、題目 Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [4,5,0,-2,-3,1], k = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by k = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Example 2:","title":"[LeetCode] 974. Subarray Sums Divisible by K"},{"content":"53. Maxmimum Subarray\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Divide and Conquer、Dynamic Programming 一、題目 Given an integer array num, find the subarray with the largest sum, and return its sum.\nExample 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: The subarray [4,-1,2,1] has the largest sum 6. Example 2:\nInput: nums = [1] Output: 1 Explanation: The subarray [1] has the largest sum 1. Example 3:\nInput: [5,4,-1,7,8] Output: 23 Explanation: The subarray [5,4,-1,7,8] has the largest sum 23. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n二、分析 這題可以用動態規劃的思維下去解題，將 dp[i] 定為，到第 i 個數為止，最大子序列的總和。 以上述的定義可以得到狀態轉移方程式：dp[i] = max(nums[i], nums[i] + dp[i-1]，對 i 元素來說，只需考慮兩種狀況： 前面的元素都不拿 拿包含前一個元素，且包含最大子序列的其它元素。 三、解題 1. DP Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = nums[0]; // int curr = INT_MIN; vector\u0026lt;int\u0026gt; dp(nums.size(), 0); dp[0] = nums[0]; for (int i = 1; i \u0026lt; nums.size(); i++) { dp[i] = max(nums[i], nums[i] + dp[i-1]); res = max(dp[i], res); } return res; } 2. DP(space optimized) Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int curr = INT_MIN, res = INT_MIN; for (const auto\u0026amp; x : nums) { curr = curr \u0026lt; 0 ? x : curr + x; res = max(res, curr); } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/53/","summary":"53. Maxmimum Subarray\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Divide and Conquer、Dynamic Programming 一、題目 Given an integer array num, find the subarray with the largest sum, and return its sum.\nExample 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: The subarray [4,-1,2,1] has the largest sum 6. Example 2:\nInput: nums = [1] Output: 1 Explanation: The subarray [1] has the largest sum 1. Example 3:\nInput: [5,4,-1,7,8] Output: 23 Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.","title":"[LeetCode] 53. Maximum Subarray"},{"content":"918. Maximum Sum Circular Subarray\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Divide and Conquer、Dynamic Programming、Queue、Monotonic Queue 一、題目 Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i \u0026lt;= k1, k2 \u0026lt;= j with k1 % n == k2 % n.\nExample 1:\nInput: nums = [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3. Example 2:\nInput: nums = [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10. Example 3:\nInput: nums = [-3,-2,-3] Output: -2 Explanation: Subarray [-2] has maximum sum -2. Constraints:\nn == nums.length 1 \u0026lt;= n \u0026lt;= 3 * 10^4 -3 * 10^4 \u0026lt;= nums[i] \u0026lt;= 3 * 10^4 二、分析 這一題是 [53. MaximumSubArray] 的進階題，如果沒有解題方向的話可以先解看看這題。 可以取 circular 代表，可以取頭尾合併，去掉中間的子序列，換個方式思考就是求「總和-最小子序列」。 注意子序列至少要有一個元素，故當最小子序列等於總和是，要特別處理 三、解題 1. DP Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int maxSubarraySumCircular(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int neg_cur = INT_MAX; int pos_cur = INT_MIN; int total = 0; int neg_max = INT_MAX; int pos_max = INT_MIN; for (int i = 0; i \u0026lt; nums.size(); i++) { neg_cur = neg_cur \u0026gt; 0 ? nums[i] : (neg_cur + nums[i]); pos_cur = pos_cur \u0026lt; 0 ? nums[i] : (pos_cur + nums[i]); neg_max = min(neg_cur, neg_max); // 記錄最小子序列 pos_max = max(pos_cur, pos_max); // 記錄最大子序列 total += nums[i]; // 記錄總和 } if (total == neg_max) return pos_max; // 當總和等於最小子序列時，因為至少需拿一個元素，特例處理 return max(pos_max, total - neg_max); // 解為最大子序列或總和-最小子序列(環狀) } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/918/","summary":"918. Maximum Sum Circular Subarray\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Divide and Conquer、Dynamic Programming、Queue、Monotonic Queue 一、題目 Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].","title":"[LeetCode] 918. Maximum Sum Circular Subarray"},{"content":"與時俱進的語言 一、System Class 1. 泛型(genric) 可更清楚的描述序列中每個元素的類型。 C#1 示例\npublic class Bookshelf { public IEnumerable Books { get { ... } } } C#2 示例：泛型\npublic class Bookshelf { public IEnumerable\u0026lt;Book\u0026gt; Books { get { ... } } } 2. 可空值類型(nullable value type) 可有效的表示未定的變量值，以擺脫魔數(用-1當集合索引，用 MinValue 或 MaxValue 做為初始值)。 示例\nstring? a = null; Console.WriteLine(a ?? \u0026#34;null\u0026#34;);\t// null a = \u0026#34;abc\u0026#34;; Console.WriteLine(a ?? \u0026#34;null\u0026#34;);\t// abc 3. 匿名類型(anonymous type)、隱式局部變數(var) 兩者皆可解決靜態類型語言的缺陷：程式碼冗長。 示例1: 匿名類型(anonymous type)\nvar book = new { Title = \u0026#34;Harry Potter\u0026#34;, Author = \u0026#34;J.K. Rowling\u0026#34; } string title = book.Title; string author = book.Author; 若已經調用了建構式的話，就無需顯式的宣該告變數的類型了。 示例2: 隱式類型(implicit typing)\nDictionary\u0026lt;string, string\u0026gt; map1 = new Dictionary\u0026lt;string, string\u0026gt;(); var map2 = new Dictionary\u0026lt;string, string\u0026gt;(); 4. 簡潔化 示例1:委托\nbutton.Click += new EventHandler(HandleButtonClick);\t// C#1 button.Click += HandleButtonClick;\t// C#2 方法組轉換+匿名方法 button.Click += delegate { MessageBox.Show(\u0026#34;Clicked!\u0026#34;) };\t// C#2 委托 button.Click += (sender, args) =\u0026gt; MessageBox.Show(\u0026#34;Clicked!\u0026#34;);\t// C#3 lamnda 表達式 void HandleButtonClick(object sender, EventArgs args) { MessageBox.Show(\u0026#34;Clicked!\u0026#34;); } 示例2:自動實現\n下面兩段 code 可以經由自動實現視為相同\nprivate string name; public string Name { get { return name; } set { name = value; } } public string Name { get; set; } 示例3:表達式主體成員\n下面兩段 code 可以經由表達式主體成員(expression-bodied member)視為相同\npublic int Count { get { return list.Count; } } public IEnumerator\u0026lt;string\u0026gt; GetEnumerator() { return list.GetEnumerator(); } public int Count =\u0026gt; list.Count; public IEnumerator GetEnumerator =\u0026gt; list.GetEnumerator(); 示例4:字串處理:內插內串字面量(interpolated string literal)\nthrow new KeyNotFoundException(\u0026#34;No calendar system for Id \u0026#34; + id + \u0026#34; exists\u0026#34;);\t// 字串拼接 throw new KeyNotFoundException(string.Format(\u0026#34;No calendar system for Id {0} exists\u0026#34;, id));\t// 字串格式化 throw new KeyNotFoundException($\u0026#34;No calendar system for Id {id} exists\u0026#34;);\t// 內插字串字面量 示例5: 利用LINQ進行數據訪問\nvar offers = from product in db.Products where product.SalePrice \u0026lt;= product.Price / 2 orderby product.SalePrice select new { producdt.Id, product.Description, product.SalePrice, priduct.Price }; 示例6: 非同步\nprivate async Task UpdateStatus() { Task\u0026lt;Weather\u0026gt; weatherTask = GetWeatherAsync(); Task\u0026lt;EmailStatus\u0026gt; emailTask = GetEmailStatusAsync(); Weather weather = await weatherTask; EmailStatus emai = await emailTask; weatherLabel.Text = weather.Description; inboxLabel.Text = email.InboxCount.ToString(); } ","permalink":"http://intervalrain.github.io/posts/it/csharp_depth_ch1/","summary":"與時俱進的語言 一、System Class 1. 泛型(genric) 可更清楚的描述序列中每個元素的類型。 C#1 示例\npublic class Bookshelf { public IEnumerable Books { get { ... } } } C#2 示例：泛型\npublic class Bookshelf { public IEnumerable\u0026lt;Book\u0026gt; Books { get { ... } } } 2. 可空值類型(nullable value type) 可有效的表示未定的變量值，以擺脫魔數(用-1當集合索引，用 MinValue 或 MaxValue 做為初始值)。 示例\nstring? a = null; Console.WriteLine(a ?? \u0026#34;null\u0026#34;);\t// null a = \u0026#34;abc\u0026#34;; Console.WriteLine(a ?? \u0026#34;null\u0026#34;);\t// abc 3. 匿名類型(anonymous type)、隱式局部變數(var) 兩者皆可解決靜態類型語言的缺陷：程式碼冗長。 示例1: 匿名類型(anonymous type)","title":"[IT] C# Depth Ch.1 與時俱進的語言"},{"content":"926. Flip String to Monotone Increasing\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String、Dynamic Programming 一、題目 A binary string is monotone increasing if it consists of some number of 0\u0026rsquo;s (possibly none), followed by some number of 1\u0026rsquo;s (also possibly none).\nYou are given a binary string s. You can flip s[i] changing 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.\nExample 1:\nInput: s = \u0026ldquo;00110\u0026rdquo; Output: 1 Explanation: We flip the last digit to get 00111. Example 2:\nInput: s = \u0026ldquo;010110\u0026rdquo; Output: 2 Explanation: We flip to get 011111, or alternatively 000111. Example 3:\nInput: s = \u0026ldquo;00011000\u0026rdquo; Output: 2 Explanation: We flip to get 00000000. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 10^5 s[i] is either '0' or '1'. 二、分析 這題可以使用動態規劃來解題，將 dp[0][i] 訂為將 s[i] 翻成 0 可以符合題目需求的最少次數，dp[1][i] 為將 s[i] 翻成 1 可以符合題目需求的最少次數。 當 s[i] == 0 時，前者一定要是 0；當 s[i] == 1 時，前者可以為 0 或 1。 根據上述可以得到狀態轉移方程式為： if (s[i] == \u0026#39;1\u0026#39;) { dp[0][i] = dp[0][i-1] + 1; dp[1][i] = min(dp[0][i-1], dp[1][i-1]); } else { dp[0][i] = dp[0][i-1]; dp[1][i] = min(dp[0][i-1], dp[1][i-1]) + 1; } 三、解題 1. DP Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int minFlipsMonoIncr(string s) { int n = s.length(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(2, vector\u0026lt;int\u0026gt;(n, 0)); if (s[0] == \u0026#39;0\u0026#39;) dp[1][0] = 1; else dp[0][0] = 1; for (int i = 1; i \u0026lt; n; i++) { if (s[i] == \u0026#39;1\u0026#39;) { dp[0][i] = dp[0][i-1] + 1; // 將 1 翻成 0 dp[1][i] = min(dp[0][i-1], dp[1][i-1]); } else { dp[0][i] = dp[0][i-1]; dp[1][i] = min(dp[0][i-1], dp[1][i-1]) + 1; // 將 0 翻成 1 } } return min(dp[0][n-1], dp[1][n-1]); } 1. DP(space optimized) 從狀態轉移方程式觀察，可發現只與「前一狀態」相關，故可以進行狀態壓縮 Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int minFlipsMonoIncr(string s) { int n = s.length(); int zero = 0; int one = 0; if (s[0] == \u0026#39;0\u0026#39;) one = 1; else zero = 1; for (int i = 1; i \u0026lt; n; i++) { if (s[i] == \u0026#39;1\u0026#39;) { one = min(zero, one); zero++; } else { one = min(zero, one) + 1; } } return min(zero, one); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/926/","summary":"926. Flip String to Monotone Increasing\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String、Dynamic Programming 一、題目 A binary string is monotone increasing if it consists of some number of 0\u0026rsquo;s (possibly none), followed by some number of 1\u0026rsquo;s (also possibly none).\nYou are given a binary string s. You can flip s[i] changing 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.\nExample 1:","title":"[LeetCode] 926. Flip String to Monotone Increasing"},{"content":" Reference\nhttps://blog.csdn.net/w918589859/article/details/108752592\nhttps://www.w3cschool.cn/linux/linux-Shell.html\n一、Shell 簡介 什麼是 Shell?\nShell 是一個用 C 語言編寫的程式，它是使用者使用 Linux 的橋樑。Shell 既是一種命令語言，又是一種程式設計語言。\nShell 是指一種應用程式，這個應用程式提供了一個界面，使用者通過這個界面訪問作業系統核心(kernel)的服務。 為什麼要學習和使用 Shell?\nShell 屬於內建的腳本，程序開發的效率非常高，依賴於功能強大的命令可以迅速的完成開發任務(批次處理)。 Shell 腳本(Shell script)\n是一種為 Shell 編寫的腳本程式。業界所說的 Shell 通常都是指 Shell 腳本。 二、 Shell 入門 1. Shell 環境 Shell 編程需要能編寫程式碼的文本編輯器和一個能解釋執行的腳本解釋器。 在 linux 中有很多類型的 Shell，不同的 Shell 具備不同的功能，Shell 還決定了腳本中函數的語法。 Bash 是 Linux 中默認的 Shell。一般情況下，人們不區分 Bourne Shell 和 Bourne Again Shell，所以 #!/bin/sh 也可以被替換成 #!/bin/bash Linux 的 Shell 種類眾多，不同的 Shell 都有自己的特點以及用途，常見的有： Bourne Shell (/usr/bin/sh 或 /bin/sh) Bourne Again Shell (/bin/bash) C Shell (/usr/bin/csh) K Shell (/usr/bin/ksh) Shell for Root(sbin/sh) \u0026hellip;\u0026hellip; 2. Bash 常用快捷鏈 快捷鏈 功能 Ctrl+A 把游標移動到命令行開頭。 Ctrl+E 把游標移動到命令行結尾。 Ctrl+C 強制終止當前的命令。 Ctrl+L 清除螢幕，等於 clear 指令。 Ctrl+U 清除並剪下當前命令。 Ctrl+K 刪除並剪下游標以後的命令。 Ctrl+Y 貼上。 Ctrl+R 在歷史命令中搜索，按下 Ctrl+R 之後，就會出現搜索界面，只要輸入搜索內容，就會從歷史命令中搜索。 Ctrl+D 退出當前終端機。 Ctrl+Z 暫停，並放入後台。 Ctrl+S 暫停螢幕輸出。 Ctrl+Q 恢復螢幕輸出。 3. 輸入與輸出 I/O linux 的標準輸入與輸出\n設備 設備名 文件描述符 類型 鍵盤 /dev/stdin 0 標準輸入 顯示器 /dev/stdout 1 標準輸出 顯示器 /dev/stderr 2 標準錯誤輸出 輸入重定向\n輸入重定向：是指不使用系統提供的標準輸入界面，而進行重新的指定。換言之，輸入重定向就是不使用標準輸入界面輸入文件，而是使用指定的文件作為標準輸入設備。\n(簡言之就是用 \u0026lt; 來修改標準輸入設備)\n類型 語法 功能 標準輸入 command \u0026lt; file 命令把文件中的內容作為標準輸入設備。 標識限定輸入 command \u0026lt;\u0026lt; tag 命令讀取標準輸入中的內容，直到遇到標識符號為止。 輸入輸出重定向(同時使用) command \u0026lt; file1 \u0026gt; file2 命令把文件1中的內容作為標準輸入，把文件2作為標準輸出。 輸出重定向\n輸出重定向：將輸出的文件訊息寫入到指定文件。\n\u0026amp;表示全部文件，文件不管對錯，1表示標準輸出文件、2表示標準錯誤輸出。\n類型 語法 功能 標註輸出重定向 command \u0026gt; file 以覆蓋方式，把命令的正確輸出內容輸出到指定的文件或設備中 標註輸出重定向 command \u0026gt;\u0026gt; file 以追加方式，把命令的正確輸出內容輸出到指定的文件或設備中 標準錯誤輸出重重定向 err_command 2\u0026gt; file 以覆蓋方式，把命令的錯誤輸出輸出到指定的文件或設備當中 標準錯誤輸出重重定向 err_command 2\u0026gt;\u0026gt; file 以追加方式，把令命的錯誤輸出輸出到指定的文件或設備中 正確輸出和錯誤輸出同時保存 command \u0026gt; file \u0026gt; 2\u0026gt;\u0026amp;1 以覆蓋的方式，把正確輸出和錯誤輸出都保存到同一個文件 正確輸出和錯誤輸出同時保存 command \u0026gt;\u0026gt; file 2\u0026gt;\u0026amp;1 以追加方式，把正確輸出和錯誤輸出都保存到同一個文件 正確輸出和錯誤輸出同時保存 command \u0026amp;\u0026gt; file 以覆蓋的方式，把正確輸出和錯誤輸出都保存到同一個文件 正確輸出和錯誤輸出同時保存 command \u0026amp;\u0026gt;\u0026gt; file 以追加方式，把正確輸出和錯誤輸出都保存到同一個文件 正確輸出和錯誤輸出同時保存 command \u0026gt;\u0026gt; file1 2\u0026gt;\u0026gt; file2 把正確的輸出追加到文件1，把錯誤的輸出追加到文件2中。 /dev/null\n若希望執行某個命令，但又不希望在螢幕上顯示輸出結果，那麼可以將輸出重定向到 /dev/null 中。\n[root@localhost ~]$ command \u0026gt; dev/null 4. 多命令順序執行 多命令執行符 作用 格式 ; 命令1;命令2 多個命令順序執行，命令之間沒有任何邏輯關係。 \u0026amp;\u0026amp; 命令1\u0026amp;\u0026amp;命令2 當命令1正確執行，命令2才會執行；當命令1執行不正確，則命令2不會執行。 || 命令1||命令2 當命令1正確執行，命令2不執行；當命令1執行不正確，則命令2才會執行。 5. Shell 腳本(Shell script) 撰寫腳本\n[root@localhost ~]$ vim test.sh #!/bin/bash echo \u0026#34;hello world\u0026#34; #! 是一個約定的標記，它告訴系統這個腳本需要什麼解釋器來執行，即使用哪一種 Shell。 echo 命令用於向 Console 輸出文本。 file.sh .sh是linux下 bash Shell 的預設副檔名 執行方法\n增加執行權限 [root@localhost ~]$ chmod u+x test.sh // 對所有user增加對當前目錄下的test.sh文件的執行權限 [root@localhost ~]$ ./test.sh chmod: change the permissions mode of a file u: user +x: 增加執行權限 通過 bash 調用執行腳本 [root@localhost ~]$ bash test.sh 三、 Shell 變數 1. 變數的命名規則 首個字元必須為英文字母 (a-z，A-Z) 中間不能有空格，可以用底線(_)取代。 不能使用標點符號。 不能使用關鍵字(可用 help 查看保留關鍵字)。 環境變數習慣大寫，便於區分。 調用變數示例\n[root@localhost ~]$ test=123 [root@localhost ~]$ test=\u0026#34;$test\u0026#34;456 [root@localhost ~]$ echo $test 123456 [root@localhost ~]$ test=${test}789 [root@localhost ~]$ echo $test 123456789 Shell 中的特殊符號\n符號 作用 '' 在單引號中所有字元都是普通字元，照原樣輸出。 \u0026quot;\u0026quot; 在雙引號中只有 $ 與 ` 和 \\ 是有特殊含義，分別是調用變數、引用命令和轉義。 `` 在反引號中的內容是系統命令，在 Bash 中會先執行，與 () 作用一樣，但不推薦使用。 $() 和反引號作用相同，用來引用系統命令。 () 用於一串命令執行時，() 中的命令會在子 Shell 中運行。 {} 用於一串命令執行時，{} 中的命令會在當前 Shell 中執行。也可以用於變數變形與替換。 [] 用於變數的測試。 # 用於注釋。 $ 用於調用變數的值。 \\ 用於轉義。 單引號與雙引號示例\n[root@localhost ~]$ name=rain [root@localhost ~]$ echo \u0026#39;$name\u0026#39; $name [root@localhost ~]$ echo \u0026#34;$name\u0026#34; rain [root@localhost ~]$ echo `date` 2023年 1月17日 週二 21時23分45秒 CST [root@localhost ~]$ echo \u0026#39;`date`\u0026#39; `date` [root@localhost ~]$ echo \u0026#34;`date`\u0026#34; 2023年 1月17日 週二 21時24分00秒 CST 反引號示例\n[root@localhost ~]$ echo ls ls [root@localhost ~]$ echo `ls` words.txt [root@localhost ~]$ echo $(date) 2023年 1月17日 週二 21時28分42秒 CST 2. 變數的分類 變數分類 名稱 作用 內容 自定義變數 自定義 自定義 自定義 使用自定義環境變數 自定義 自定義 自定義 系統環境變數 預定 預定 自定義 位置參數變數 預定 自定義 自定義 預定義變數 預定 自定義 自定義 2.1. 自定義變數： 最常見的變數，由使用者自由定義變數名稱與值。 使用 $ 調用變數。 使用 set [選項] 設定 -u：調用未宣告變數時會報錯(預設未無提示) -x：在命令執行之前，會把命令先輸出一次 +\u0026lt;參數\u0026gt;：取消某個曾啟動過的參數 set：查詢系統中所有的變量，包含自定義變數與環境變數 unset 變數名稱：刪除變數 2.2. 環境變數： 主要保存和系統操作環境相關的數據，比如當前登錄的使用者名稱，使用者的根目錄、命令的提示符等。一般對系統起作用的環境變數名稱是系統預定好的。 使用 export 宣告的變數即是環境變數 使用 env 查看環境變數 2.3. 位置參數變數： 用來向腳本當中傳遞參數或數據的，變數名稱不能自定義，變數作用是固定的。 $n：n 為數字，$0表示當前 Shell 腳本程式的名稱，10以上需加大括號。 $*：代表命令行中所有參數，$把所有參數看成一個整體。 $@：代表命令行中所有參數，不過$把每個參數區分對待。 $#：代表命令行中所有參數的個數 腳本示例1\n#!/bin/sh echo \u0026#34;shell\u0026#39;s name: $0\u0026#34; echo \u0026#34;shell\u0026#39;s first argument: $1\u0026#34; echo \u0026#34;shell\u0026#39;s second argument: $2\u0026#34; [root@localhost ~]$ bash test.sh 1 2 shell\u0026#39;s name: test.sh shell\u0026#39;s first argument: 1 shell\u0026#39;s second arguemnt: 2 腳本示例2\n#!/bin/sh for i in \u0026#34;$*\u0026#34; do echo \u0026#34;The parameter is: $i\u0026#34; done x=1 for y in \u0026#34;$@\u0026#34; do echo \u0026#34;The parameter$x is: $y\u0026#34; x=$(( $x +1 )) done [root@localhost ~]$ bash par.sh 1 2 3 4 5 6 The parameter is: 1 2 3 4 5 6 The parameter1 is: 1 The parameter2 is: 2 The parameter3 is: 3 The parameter4 is: 4 The parameter5 is: 5 The parameter6 is: 6 2.4. 預定義變數： 是Bash中已經定義好的變數，變數名稱不能自定義，變數作用也是固定的。 預定義變數 作用 $? 最後一次執行的命令的返回狀態。如果這個變數的值為 0，表示上一個命令正確執行；如果這個變數的值非 0(具體為哪個數，由命令自己決定)，則表示上一個命令執行不正確。 $$ 當前程式的程式號(PID) $! 後台運行的最後一個程式的程式號(PID) 腳本示例1\n[root@localhost ~]$ ls count.sh hello.sh parameter.sh [root@localhost ~]$ echo $? 0 [root@localhost ~]$ ls install.log ls: install.log: No such file or directory [root@localhost ~]$ echo $? 1 ","permalink":"http://intervalrain.github.io/posts/it/shell/","summary":"Reference\nhttps://blog.csdn.net/w918589859/article/details/108752592\nhttps://www.w3cschool.cn/linux/linux-Shell.html\n一、Shell 簡介 什麼是 Shell?\nShell 是一個用 C 語言編寫的程式，它是使用者使用 Linux 的橋樑。Shell 既是一種命令語言，又是一種程式設計語言。\nShell 是指一種應用程式，這個應用程式提供了一個界面，使用者通過這個界面訪問作業系統核心(kernel)的服務。 為什麼要學習和使用 Shell?\nShell 屬於內建的腳本，程序開發的效率非常高，依賴於功能強大的命令可以迅速的完成開發任務(批次處理)。 Shell 腳本(Shell script)\n是一種為 Shell 編寫的腳本程式。業界所說的 Shell 通常都是指 Shell 腳本。 二、 Shell 入門 1. Shell 環境 Shell 編程需要能編寫程式碼的文本編輯器和一個能解釋執行的腳本解釋器。 在 linux 中有很多類型的 Shell，不同的 Shell 具備不同的功能，Shell 還決定了腳本中函數的語法。 Bash 是 Linux 中默認的 Shell。一般情況下，人們不區分 Bourne Shell 和 Bourne Again Shell，所以 #!/bin/sh 也可以被替換成 #!/bin/bash Linux 的 Shell 種類眾多，不同的 Shell 都有自己的特點以及用途，常見的有： Bourne Shell (/usr/bin/sh 或 /bin/sh) Bourne Again Shell (/bin/bash) C Shell (/usr/bin/csh) K Shell (/usr/bin/ksh) Shell for Root(sbin/sh) \u0026hellip;\u0026hellip; 2.","title":"[IT] Shell 筆記"},{"content":"1519. Number of Nodes in the Sub-Tree With the Same Level\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table、Tree、Depth-First Search、Breadth-First Search、Counting 一、題目 You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]).\nThe edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.\nReturn an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i.\nA subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes.\nExample 1:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \u0026ldquo;abaedcd\u0026rdquo; Output: [2,1,1,1,1,1,1] Explanation: Node 0 has label \u0026lsquo;a\u0026rsquo; and its sub-tree has node 2 with label \u0026lsquo;a\u0026rsquo; as well, thus the answer is 2. Notice that any node is part of its sub-tree.\nNode 1 has a label \u0026lsquo;b\u0026rsquo;. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself). Example 2: Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = \u0026ldquo;bbbb\u0026rdquo; Output: [4,2,1,1] Explanation: The sub-tree of node 2 contains only node 2, so the answer is 1.\nThe sub-tree of node 3 contains only node 3, so the answer is 1.\nThe sub-tree of node 1 contains nodes 1 and 2, both have label \u0026lsquo;b\u0026rsquo;, thus the answer is 2.\nThe sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label \u0026lsquo;b\u0026rsquo;, thus the answer is 4. Example 3: Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \u0026ldquo;aabab\u0026rdquo; Output: [3,2,1,1,1] Constraints:\n1 \u0026lt;= n \u0026lt;= 10^5 edges.length == n - 1 edges[i].length == 2 0 \u0026lt;= ai, bi \u0026lt; n ai != bi labels.length == n labels is consisting of only of lowercase English letters. 二、分析 這一題是後序遍歷，利用後序遍歷可以得到遍歷過後的訊息來解題。 我們要的訊息是：當遍歷完子節點之後，每個字元已出現了幾遍，而根節點以下的所有節點出現過的字元次數，就是所有子節點統計數字的相加再加上根節點自己。 這邊要注意的是，因為每次深入子節點，都需要新增一組陣列，會大量使用到記憶體，所以在處理上要小心空間複雜度的處理。技巧是，能用參考就用參考。 由於這題的 n 的限制較大，只能運用陣列的加法，時間複雜度為\\(O(26)\\)，若場景有確認過，每個字符出現的次數限定在 10 以內，可以改用 int 來記錄，其加法的時間複雜度可以大大的下降。 三、解題 1. DFS Time complexity: \\(O(26\\times n)\\) Space complexity: \\(O(26\\times k), k 為深度\\) vector\u0026lt;int\u0026gt; res; vector\u0026lt;int\u0026gt; countSubTrees(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, string labels) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 先將 undirected graph 轉成每個節點有哪些鄰居 for (const auto\u0026amp; e : edges) { graph[e[0]].push_back(e[1]); graph[e[1]].push_back(e[0]); } res.assign(n, 0); dfs(graph, labels, -1, 0); // 起點為 0，而節點不為負，過 last 可假定為任意負數 return res; } vector\u0026lt;int\u0026gt; dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, string\u0026amp; labels, int last, int curr) { vector\u0026lt;int\u0026gt; path(26, 0); // 用一陣列記錄字符出現的次數 path[labels[curr]-\u0026#39;a\u0026#39;]++; for (const auto\u0026amp; next : graph[curr]) { if (last == next) continue; // 進到上一輪的數字則跳過 vector\u0026lt;int\u0026gt; tmp = dfs(graph, labels, curr, next); add(path, tmp); // 將遍歷完的結果加起來 } res[curr] = path[labels[curr]-\u0026#39;a\u0026#39;]; // 在後序的時間點，把統計完的結果記錄下來 return path; } void add(vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b) { // 用參考的方法做陣列的加法，也不回傳，可以省下空間 for (int i = 0; i \u0026lt; 26; i++) a[i] += b[i]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1519/","summary":"1519. Number of Nodes in the Sub-Tree With the Same Level\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table、Tree、Depth-First Search、Breadth-First Search、Counting 一、題目 You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.","title":"[LeetCode] 1519. Number of Nodes in the Sub-Tree With the Same Level"},{"content":"100. Same Tree\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Tree、Depth-First Search、Breadth-First Search、Binary Tree 一、題目 Given the roots of two binary tree p and q, write a function to check if they are the same or not.\nTwo binary tree are considered the same if they are structurally iedntical, and the nodes have the same value.\nExample 1:\nInput: p = [1,2,3], q = [1,2,3] Output: true Example 2:\nInput: p = [1,2], q = [1,null,2] Output: false Example 3: Input: p = [1,2,1], q = [1,1,2] Output: false Constraints:\nThe number of nodes in both trees is in the range [0, 100]. -10^4 \u0026lt;= Node.val \u0026lt;= 10^4 二、分析 典型樹的遍歷問題，兩棵樹一起遍歷，注意要處理當 node == null 的情形便可。 兩棵樹相同的條件為：root 的值相同，且左右兩個 leaf 也相同。 三、解題 1. Recursion Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) bool isSameTree(TreeNode* p, TreeNode* q) { if (p == NULL \u0026amp;\u0026amp; q == NULL) return true; if (p == NULL || q == NULL) return false; if (p-\u0026gt;val != q-\u0026gt;val) return false; return isSameTree(p-\u0026gt;left, q-\u0026gt;left) \u0026amp;\u0026amp; isSameTree(p-\u0026gt;right, q-\u0026gt;right); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/100/","summary":"100. Same Tree\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Tree、Depth-First Search、Breadth-First Search、Binary Tree 一、題目 Given the roots of two binary tree p and q, write a function to check if they are the same or not.\nTwo binary tree are considered the same if they are structurally iedntical, and the nodes have the same value.\nExample 1:\nInput: p = [1,2,3], q = [1,2,3] Output: true Example 2:\nInput: p = [1,2], q = [1,null,2] Output: false Example 3: Input: p = [1,2,1], q = [1,1,2] Output: false Constraints:","title":"[LeetCode] 100. Same Tree"},{"content":"149. Max Points on a Line\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Hash Table、Math、Geometry 一、題目 Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\nExample 1:\nInput: points = [[1,1],[2,2],[3,3]] Output: 3 Example 2: Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Constraints:\n1 \u0026lt;= points.length \u0026lt;= 300 points[i].length == 2 -10^4 \u0026lt;= xi, yi \u0026lt;= 10^4 All the points are unique. 二、分析 若干點在同一條線上，表示這些點的斜率都相同，注意題目有提示不會有相同的點，故兩點間必定有斜率。 特別注意當分母為 0 時要特別處理。 題目有限制 -10^4 \u0026lt;= xi, yi \u0026lt;= 10^4，故斜率最大 10^8，所以我們可以將分母為零的斜率暫定為 INT_MAX(2147483647)。 遍歷每個點，並統計該點與其它點之間的斜率，將斜率用 unordered_map 記錄下來，其每個斜率的直線上總共會有 m+1 (加上自己)。 三、解題 1. Time complexity: \\(O(n^2)\\) Space complexity: \\(O(n)\\) int maxPoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points) { int n = points.size(); int res = 0; for (int i = 0; i \u0026lt; n; i++) { int\u0026amp; x0 = points[i][0]; int\u0026amp; y0 = points[i][1]; unordered_map\u0026lt;double,int\u0026gt; map; for (int j = 0; j \u0026lt; n; j++) { if (i == j) continue; // 若等於自己則跳過 int\u0026amp; x1 = points[j][0]; int\u0026amp; y1 = points[j][1]; if (x0 == x1) { // 當分母為 0 時特別處理 int\u0026amp; cnt = ++map[INT_MAX]; res = max(res, cnt); } else { double m = (y1-y0)/(1.0*(x1-x0)); // 注意將斜率轉成 double int\u0026amp; cnt = ++map[m]; res = max(res, cnt); } } } return res + 1; // 答案記得加 1，加上自己 } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/149/","summary":"149. Max Points on a Line\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Hash Table、Math、Geometry 一、題目 Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\nExample 1:\nInput: points = [[1,1],[2,2],[3,3]] Output: 3 Example 2: Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 Constraints:\n1 \u0026lt;= points.length \u0026lt;= 300 points[i].length == 2 -10^4 \u0026lt;= xi, yi \u0026lt;= 10^4 All the points are unique.","title":"[LeetCode] 149. Max Points on a Line"},{"content":"452. Minimum Number of Arrows to Burst Balloons\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array,Greedy,Sorting 一、題目 There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [x_start, x_end] denotes a balloon whose horizontal diameter stretches between x_start and x_end. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with x_start and x_end is burst by an arrow shot at x if x_start \u0026lt;= x \u0026lt;= x_end. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\nExample 1:\nInput: points = [[10,16],[2,8],[1,6],[7,12]] Output: 2 Explanation: The balloons can be burst by 2 arrows:\nShoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\nShoot an arrow at x = 11, bursting the balloons [10,16] and [7,12]. Example 2:\nInput: points = [[1,2],[3,4],[5,6],[7,8]] Output: 4 Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows. Example 3:\nInput: points = [[1,2],[2,3],[3,4],[4,5]] Output: 2 Explanation: The balloons can be burst by 2 arrows:\nShoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\nShoot an arrow at x = 4, bursting the balloons [3,4] and [4,5]. Constraints:\n1 \u0026lt;= points.length \u0026lt;= 10^5 points[i].length == 2 -2^31 \u0026lt;= x_start \u0026lt; x_end \u0026lt;= 2^31 - 1 二、分析 這題是經典的區間問題，可以用 Greedy 的思維解，若要使一個集合的汽球用同一隻箭射破，它們必須要有一段重疊的區間， 必須從左至右，或從右至左開始射箭，以避免兩端的留下汽球的情況發生。 故我們使用 Sort 後，盡可能令愈多汽球與最左邊的汽球有重疊，方法是： 由於 x_start 已經過排序，故只要後一顆汽球的比前一顆汽球的 x_end 還小，就表示有重疊。 但要注意如果後一顆汽球的 x_end 比前一顆還小，那麼表示重疊的範圍需要縮小，故必須更新。 三、解題 1. Greedy Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(1)\\) int findMinArrowShots(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points) { sort(points.begin(), points.end()); int last = points[0][1]; // 右端點 int cnt = 1; for (int i = 1; i \u0026lt; points.size(); i++) { if (points[i][0] \u0026lt;= last) { // 只需比較右端點 last = min(last, points[i][1]); // 重疊的範圍縮小，只需更新右端點 } else { last = points[i][1]; // 若不重疊，則需再加另一隻箭，同時定義另一個重疊的區間 cnt++; } } return cnt; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/452/","summary":"452. Minimum Number of Arrows to Burst Balloons\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array,Greedy,Sorting 一、題目 There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [x_start, x_end] denotes a balloon whose horizontal diameter stretches between x_start and x_end. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis.","title":"[LeetCode] 452. Minimum Number of Arrows to Burst Balloons"},{"content":"algorithm \u0026lt;algorithm\u0026gt; 定義了專為元素集合設計的函式。\n元素集合包含可以被迭代器或指標存取的一系列元素，例如陣列或 STL container。但且注意，演算法只會透過迭代器去操作容器中的值，並不會更改其結構或是大小。\n一、函式 1. 無修改值的操作 all_of bool all_of(Iterator first, Iterator last, UnaryPredicate pred)\n檢查是否全部的元素都符合判斷式。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; arr1 = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; arr2 = {1,3,5,7,9}; vector\u0026lt;int\u0026gt; arr3 = {2,4,6,8,10}; auto isodd = [](int x)-\u0026gt;bool{ return x%2; }; cout \u0026lt;\u0026lt; all_of(arr1.begin(), arr1.end(), isodd) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; all_of(arr2.begin(), arr2.end(), isodd) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; all_of(arr3.begin(), arr3.end(), isodd) \u0026lt;\u0026lt; endl; // 0 return 0; } any_of bool any_of(Iterator first, Iterator last, Predicate pred)\n檢查是否有任一元素符合判斷式。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; arr1 = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; arr2 = {1,3,5,7,9}; vector\u0026lt;int\u0026gt; arr3 = {2,4,6,8,10}; auto isodd = [](int x)-\u0026gt;bool{ return x%2; }; cout \u0026lt;\u0026lt; any_of(arr1.begin(), arr1.end(), isodd) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; any_of(arr2.begin(), arr2.end(), isodd) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; any_of(arr3.begin(), arr3.end(), isodd) \u0026lt;\u0026lt; endl; // 0 return 0; } none_of bool none_of(Iterator first, Iterator last, Predicate pred)\n檢查是否沒有任何元素符合判斷式 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; arr1 = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; arr2 = {1,3,5,7,9}; vector\u0026lt;int\u0026gt; arr3 = {2,4,6,8,10}; auto isodd = [](int x)-\u0026gt;bool{ return x%2; }; cout \u0026lt;\u0026lt; none_of(arr1.begin(), arr1.end(), isodd) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; none_of(arr2.begin(), arr2.end(), isodd) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; none_of(arr3.begin(), arr3.end(), isodd) \u0026lt;\u0026lt; endl; // 1 return 0; } for_each void for_each(Iterator first, Iterator last, Function fn)\n用 function fn 遍歷範圍 [first,last) 中的元素。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; arr = {1,2,3,5,8,13,21}; for_each(arr.begin(), arr.end(), [](int x){ cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); // 1 2 3 5 8 13 21 return 0; } find Iterator find(Iterator first, Iterator last, const T\u0026amp; val)\n在範圍中找與指定元素相等的元素，若沒有與之相符的元素則回傳 last。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; arr = {1,3,7,4,9,12,5}; vector\u0026lt;int\u0026gt;::iterator it1 = find(arr.begin(), arr.end(), 12); auto it2 = find(arr.begin(), arr.end(), 8); cout \u0026lt;\u0026lt; distance(arr.begin(), it1) \u0026lt;\u0026lt; endl; // 5 cout \u0026lt;\u0026lt; distance(arr.begin(), it2) \u0026lt;\u0026lt; endl; // 7 return 0; } find_if Iterator find_if(Iterator first, Iterator last, UnaryPredicate pred)\n在範圍中找第一個符合條件的元素，若沒有與之相符的元素則回傳 last。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ auto isOdd = [](int x)-\u0026gt;bool{ return x%2; }; vector\u0026lt;int\u0026gt; arr = {2,3,7,4,9,12,5}; auto it = find_if(arr.begin(), arr.end(), isOdd); cout \u0026lt;\u0026lt; distance(arr.begin(), it) \u0026lt;\u0026lt; endl; // 1 return 0; } find_if_not Iterator find_if_not(Iterator first, Iterator last, UnaryPredicate pred)\n在範圍中找第一個不符合條件的元素，若沒有與之不符的元素則回傳 last。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; arr = {1,3,7,4,9,12,5}; auto it1 = find_if_not(arr.begin(), arr.end(), [](int x)-\u0026gt;bool{ return x \u0026lt; 8; }); // 4 auto it2 = find_if_not(arr.begin(), arr.end(), [](int x)-\u0026gt;bool{ return x \u0026lt; 13; }); // 7 auto it3 = find_if_not(arr.begin(), arr.end(), [](int x)-\u0026gt;bool{ return x == 1; }); // 1 cout \u0026lt;\u0026lt; distance(arr.begin(), it1) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; distance(arr.begin(), it2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; distance(arr.begin(), it3) \u0026lt;\u0026lt; endl; return 0; } find_end Iterator find_end(Iterator first1, Iterator last1, Iterator first2, Iterator last2) Iterator find_end(Iterator first1, Iterator last1, Iterator first2, Iterator last2, BinaryPredicate pred)\n在範圍中找出最後一次符合條件的子序列中的第一個元素。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #define all(x) x.begin(),x.end() using namespace std; int main(){ vector\u0026lt;int\u0026gt; arr1 = {1,2,3,4,5,1,2,3,4,5}; vector\u0026lt;int\u0026gt; arr2 = {1,2,3}; vector\u0026lt;int\u0026gt; arr3 = {2,3,4}; vector\u0026lt;int\u0026gt; arr4 = {4,5,6,4,5,6}; vector\u0026lt;int\u0026gt; arr5 = {1,3,5}; auto pred = [](int x, int y)-\u0026gt;bool{ return x == y; }; auto pred2 = [](int x, int y)-\u0026gt;bool{ return x == y+3; }; auto it1 = find_end(all(arr1), all(arr2)); auto it2 = find_end(all(arr1), all(arr2), pred); auto it3 = find_end(all(arr1), all(arr3)); auto it4 = find_end(all(arr1), all(arr4)); auto it5 = find_end(all(arr4), all(arr2), pred2); auto it6 = find_end(all(arr1), all(arr5)); cout \u0026lt;\u0026lt; distance(arr1.begin(), it1) \u0026lt;\u0026lt; endl; // 5 cout \u0026lt;\u0026lt; distance(arr1.begin(), it2) \u0026lt;\u0026lt; endl; // 5 cout \u0026lt;\u0026lt; distance(arr1.begin(), it3) \u0026lt;\u0026lt; endl; // 6 cout \u0026lt;\u0026lt; distance(arr1.begin(), it4) \u0026lt;\u0026lt; endl; // 10 cout \u0026lt;\u0026lt; distance(arr4.begin(), it5) \u0026lt;\u0026lt; endl; // 3 cout \u0026lt;\u0026lt; distance(arr1.begin(), it6) \u0026lt;\u0026lt; endl; // 10 return 0; } find_first_of Find element from set in range adjacent_find Find equal adjacent elements in range count Count appearances of value in range count_if Return number of elements in range satisfying conditon mismatch Return first position where two ranges differ equal Test whether the elements in two ranges are equal is_permutation Test whether range is permutation of another search Search range for subsequence search_n Search range for elements 2. 有修改值的操作 3. 分割(partition) 4. 排序(sort) 5. 二分法(binary search) 6. 合併(merge) 7. 堆(heap) 8. 極值(min/max) 9. 其它 回到目錄：[Algo] 演算法筆記 ","permalink":"http://intervalrain.github.io/posts/cs/algo/algorithm/","summary":"algorithm \u0026lt;algorithm\u0026gt; 定義了專為元素集合設計的函式。\n元素集合包含可以被迭代器或指標存取的一系列元素，例如陣列或 STL container。但且注意，演算法只會透過迭代器去操作容器中的值，並不會更改其結構或是大小。\n一、函式 1. 無修改值的操作 all_of bool all_of(Iterator first, Iterator last, UnaryPredicate pred)\n檢查是否全部的元素都符合判斷式。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; arr1 = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; arr2 = {1,3,5,7,9}; vector\u0026lt;int\u0026gt; arr3 = {2,4,6,8,10}; auto isodd = [](int x)-\u0026gt;bool{ return x%2; }; cout \u0026lt;\u0026lt; all_of(arr1.begin(), arr1.end(), isodd) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; all_of(arr2.begin(), arr2.end(), isodd) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; all_of(arr3.begin(), arr3.","title":"[Algo] 1-9. Algorithm"},{"content":"944. Delete Columns to Make Sorted\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、String 一、題目 You are given an array of n string strs, all of the same length.\nThe string s can be arranged such that there is one on each line, making a grid. For example, strs = [\u0026quot;abc\u0026quot;, \u0026quot;bce\u0026quot;, \u0026quot;cae\u0026quot; can be arranged as :\nabc bce cae You want to delete the columns that are not sorted lexicographically. In the aove example (0-indexed), columns 0('a','b','c') and 2('c','e','e') are sorted while column 1('b','c','a') is not, so you would delete column 1.\nReturn the number of columns that you will delete.\nExample 1:\nInput: strs = [\u0026ldquo;cba\u0026rdquo;,\u0026ldquo;daf\u0026rdquo;,\u0026ldquo;ghi\u0026rdquo;] Output: 1 Explanation: The grid looks as follows:\ncba\ndaf\nghi\nColumns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column. Example 2:\nInput: strs = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;] Output: 0 Explanation: The grid looks as follows:\na\nb\nColumn 0 is the only column and is sorted, so you will not delete any columns. Example 3:\nInput: strs = [\u0026ldquo;zyx\u0026rdquo;,\u0026ldquo;wvu\u0026rdquo;,\u0026ldquo;tsr\u0026rdquo;] Output: 3 Explanation: The grid looks as follows:\nzyx\nwvu\ntsr\nAll 3 columns are not sorted, so you will delete 3. Constraints:\nn == strs.length 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= strs[i].length \u0026lt;= 1000 二、分析 根據題意，逐個檢查是否字元有隨著列增加而呈 lexicographically sorted。 注意迴圈的走法，若是外圈為欄，內圈為列的話，在發現沒有排序時，可以提早跳出，加快速度。 三、解題 1. String Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(1)\\) int minDeletionSize(vector\u0026lt;string\u0026gt;\u0026amp; strs) { int m = strs.size(), n = strs[0].size(); int cnt = 0; for (int col = 0; col \u0026lt; n; ++col) { for (int row = 1; row \u0026lt; m; ++row) { if (strs[row-1][col] \u0026gt; strs[row][col]) { cnt++; break; } } } return cnt; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/944/","summary":"944. Delete Columns to Make Sorted\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、String 一、題目 You are given an array of n string strs, all of the same length.\nThe string s can be arranged such that there is one on each line, making a grid. For example, strs = [\u0026quot;abc\u0026quot;, \u0026quot;bce\u0026quot;, \u0026quot;cae\u0026quot; can be arranged as :\nabc bce cae You want to delete the columns that are not sorted lexicographically. In the aove example (0-indexed), columns 0('a','b','c') and 2('c','e','e') are sorted while column 1('b','c','a') is not, so you would delete column 1.","title":"[LeetCode] 944. Delete Columns to Make Sorted"},{"content":"2522. Partition String Into Substrings With Values at Most K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\nEach digit of s is part of exactly one substring. The value of each substring is less than or equal to k. Return the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that: The value of a string is its result when interpreted as an integer. For example, the value of \u0026quot;123\u0026quot; is 123 and the value of \u0026quot;1\u0026quot; is 1. A substring is a contiguous sequence of characters within a string. Example 1:\nInput: s = \u0026ldquo;165462\u0026rdquo;, k = 60 Output: 4 Explanation: We can partition the string into substrings \u0026ldquo;16\u0026rdquo;, \u0026ldquo;54\u0026rdquo;, \u0026ldquo;6\u0026rdquo;, and \u0026ldquo;2\u0026rdquo;. Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings. Example 2:\nInput: s = \u0026ldquo;238182\u0026rdquo;, k = 60 Output: -1 Explanation: There is no good partition for this string. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 105 s[i] is a digit from '1' to '9'. 1 \u0026lt;= k \u0026lt;= 10^9 二、分析 用動態規劃的方式解題，將 dp[i] 定義為前 i 個字元的最小 minimumPartition。 動態轉移方程式是，當 s[i:j] 滿足 \u0026lt;= k 的條件時， dp[j] = min(dp[j], dp[i]+1)。 要注意如果直接將字串轉為數字(stoi)比較，可能會有超出整數範圍而報錯。在此我們可能用字串比較，先比較長度，再比較值。 if (s.length() \u0026gt; to_string(k).length()) return false; else if (s.length() \u0026lt; to_string(k).length()) return true; else return s \u0026lt;= to_string(k); 三、解題 1. DP Time complexity: \\(O(n^2)\\) Space complexity: \\(O(n)\\) int minimumPartition(string s, int k) { int n = s.length(); vector\u0026lt;int\u0026gt; dp(n+1, 100001); // 因為 s 長度最大為 100000，故我們假定 dp 初始值為 100001 dp[0] = 0; for (int right = 1; right \u0026lt;= n; right++) { for (int left = right-1; left \u0026gt;= 0; left--) { if (helper(s, left, right, k)) { dp[right] = min(dp[right], dp[left] + 1); // 動態轉移 } else { break; // pruning，如果當下不滿足 k，那麼再加字元也不會滿足，故可以直接 break } } } return dp[n] \u0026gt;= 100001 ? -1 : dp[n]; // 注意最後的回傳值， } bool helper(string\u0026amp; s, int left, int right, int k) { int len = right - left; string subseq = s.substr(left, len); if (subseq.length() \u0026gt; to_string(k).length()) return false; else if (subseq.length() \u0026lt; to_string(k).length()) return true; return subseq \u0026lt;= to_string(k); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2522/","summary":"2522. Partition String Into Substrings With Values at Most K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\nEach digit of s is part of exactly one substring. The value of each substring is less than or equal to k. Return the minimum number of substrings in a good partition of s.","title":"[LeetCode] 2522. Partition String Into Substrings With Values at Most K"},{"content":"2523. Closest Prime Numbers in Range\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 Given two positive integers left and right, find the two integers num1 and num2 such that:\nleft \u0026lt;= nums1 \u0026lt; nums2 \u0026lt;= right. nums1 and nums2 are both prime numbers. nums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.\nReturn the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.\nA number greater than 1 is called prime if it is only divisible by 1 and itself. Example 1:\nInput: left = 10, right = 19 Output: [11,13] Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.\nThe closest gap between any pair is 2, which can be achieved by [11,13] or [17,19].\nSince 11 is smaller than 17, we return the first pair. Example 2:\nInput: left = 4, right = 6 Output: [-1,-1] Explanation: There exists only one prime number in the given range, so the conditions cannot be satisfied. Constraints:\n1 \u0026lt;= left \u0026lt;= right \u0026lt;= 10^6 二、分析 這題基本上也是在實作 prime 的 pre-built table，所以我們就大方的借用 [2521. Distinct Prime Factors of Product of Array] 的 prime table 吧。 再來就是依序求質數中符合範圍且距離最小的兩個質數。 三、解題 1. Sieve of Eratosthenes Time complexity: \\(O((R-L)\\sqrt{R}/\\log R)\\) Space complexity: \\(O((R-L)/\\log R)\\) vector\u0026lt;int\u0026gt; closestPrimes(int left, int right) { // create pre-built table vector\u0026lt;int\u0026gt; table(right+1, 0); iota(table.begin(), table.end(), 0); table[1] = 0; for (int i = 2; i \u0026lt;= right; i++) { if (table[i] != i) continue; for (int j = 2*i; j \u0026lt;= right; j += i) { table[j] = i; } } // 遍歷完所有符圍中的質數，回傳距離最小的兩個質數 stack\u0026lt;int\u0026gt; st; int diff = INT_MAX; vector\u0026lt;int\u0026gt; res = {-1,-1}; for (int i = left; i \u0026lt;= right; i++) { if (table[i] != i) continue; if (!st.empty()) { if (i - st.top() \u0026lt; diff) { diff = i - st.top(); res[0] = st.top(); res[1] = i; } } st.push(i); } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2523/","summary":"2523. Closest Prime Numbers in Range\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 Given two positive integers left and right, find the two integers num1 and num2 such that:\nleft \u0026lt;= nums1 \u0026lt; nums2 \u0026lt;= right. nums1 and nums2 are both prime numbers. nums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.\nReturn the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.","title":"[LeetCode] 2523. Closest Prime Numbers in Range"},{"content":"520. Detect Capital\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String 一、題目 We define the usage of capitals in a word to be right when one of the following cases holds:\nAll letters in this word are capitals, like \u0026quot;USA\u0026quot;. All letters in this word are not capitals, like \u0026quot;leetcode\u0026quot;. Only the first letter in this word is capital, like \u0026quot;Google\u0026quot;.\nGiven a string word, return true if the usage of capitals in it is right. Example 1:\nInput: word = \u0026ldquo;USA\u0026rdquo; Output: true Example 2:\nInput: word = FlaG\u0026quot; Output: false Constraints:\n1 \u0026lt;= word.length \u0026lt;= 100 word consists of lowercase and uppercase English letters. 二、分析 這題只需要判斷簡單的 if-else 即可解題。 根據題意，要馬全是大寫，要馬全是小寫，不然就是只有首字大寫。 三、解題 1. String Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) bool detectCapitalUse(string word) { if (word.length() == 1) return true; if (word[0] \u0026gt;= \u0026#39;a\u0026#39;) { // 小寫 for (int i = 1; i \u0026lt; word.length(); i++){ char\u0026amp; c = word[i]; if (c \u0026lt; \u0026#39;a\u0026#39;) return false; } } else { // 大寫 if (word[1] \u0026lt; \u0026#39;a\u0026#39;) { // 大寫+大寫 for (int i = 2; i \u0026lt; word.length(); i++) { char\u0026amp; c = word[i]; if (c \u0026gt;= \u0026#39;a\u0026#39;) return false; } } else { // 大寫+小寫 for (int i = 2; i \u0026lt; word.length(); i++) { char\u0026amp; c = word[i]; if (c \u0026lt; \u0026#39;a\u0026#39;) return false; } } } return true; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/520/","summary":"520. Detect Capital\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String 一、題目 We define the usage of capitals in a word to be right when one of the following cases holds:\nAll letters in this word are capitals, like \u0026quot;USA\u0026quot;. All letters in this word are not capitals, like \u0026quot;leetcode\u0026quot;. Only the first letter in this word is capital, like \u0026quot;Google\u0026quot;.\nGiven a string word, return true if the usage of capitals in it is right.","title":"[LeetCode] 520. Detect Capital"},{"content":"2521. Distinct Prime Factors of Product of Array\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.\nNote that:\nA number greater than 1 is called prime if it is divisible by only 1 and itself. An integer val1 is a factor of another integer val2 if val2 / val1 is an integer. Example 1:\nInput: nums = [2,4,3,7,10,6] Output: 4 Explanation: The product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 2^5 * 3^2 * 5 * 7.\nThere are 4 distinct prime factors so we return 4. Example 2:\nInput: nums = [2,4,8,16] Output: 1 Explanation: The product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210.\nThere is 1 distinct prime factor so we return 1. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 10^4 2 \u0026lt;= nums[i] \u0026lt;= 1000 二、分析 這一題是要求所有數字相乘的質因數分解，並求質因數的個數。 我們並不需要真的將所有數字相乘，因為我們的目的是要將之作因數分解，而分解的過程中，可能會重複檢查到每個數字是否為質因數，為了避免重複檢查，可以將檢查過的數，用 dp 的方式記錄起來。或者是用 pre-built table 的方式，將是否為質數先計算出來。 此題我用的方法是數論中，從 2 開始依序由小到大將倍數篩掉，此法有個很長的名子叫作 Sieve of Eratosthenes。 我們只需把 pre-built table 做到數列的最大值。 在此我做了一個改版，我們將這個 table 記錄下最小的因數，方便做因數分解，這個 table 的特性是： 當 table[i] == i 時，i 為質數。 當 table[i] != i 時，table[i] 為 i 最小的質因數。 以下是原始的 table：\n\\(\\begin{array}{|c|c|c|c|c|c|c|c|c|c|}\\hline \u0026amp;2\u0026amp;3\u0026amp;4\u0026amp;5\u0026amp;6\u0026amp;7\u0026amp;8\u0026amp;9\u0026amp;10\\\\\\hline 11\u0026amp;12\u0026amp;13\u0026amp;14\u0026amp;15\u0026amp;16\u0026amp;17\u0026amp;18\u0026amp;19\u0026amp;20\\\\\\hline 21\u0026amp;22\u0026amp;23\u0026amp;24\u0026amp;25\u0026amp;26\u0026amp;27\u0026amp;28\u0026amp;29\u0026amp;30\\\\\\hline 31\u0026amp;32\u0026amp;33\u0026amp;34\u0026amp;35\u0026amp;36\u0026amp;37\u0026amp;38\u0026amp;39\u0026amp;40\\\\\\hline 41\u0026amp;42\u0026amp;43\u0026amp;44\u0026amp;45\u0026amp;46\u0026amp;47\u0026amp;48\u0026amp;49\u0026amp;50\\\\\\hline \\end{array}\\) 改良後的 table：\n\\(\\begin{array}{|c|c|c|c|c|c|c|c|c|c|}\\hline \u0026amp;2\u0026amp;3\u0026amp;2\u0026amp;5\u0026amp;2\u0026amp;7\u0026amp;2\u0026amp;3\u0026amp;2\\\\\\hline 11\u0026amp;2\u0026amp;13\u0026amp;2\u0026amp;3\u0026amp;2\u0026amp;17\u0026amp;2\u0026amp;19\u0026amp;2\\\\\\hline 3\u0026amp;2\u0026amp;23\u0026amp;2\u0026amp;5\u0026amp;2\u0026amp;3\u0026amp;2\u0026amp;29\u0026amp;2\\\\\\hline 31\u0026amp;2\u0026amp;3\u0026amp;2\u0026amp;5\u0026amp;2\u0026amp;37\u0026amp;2\u0026amp;3\u0026amp;2\\\\\\hline 41\u0026amp;2\u0026amp;43\u0026amp;2\u0026amp;3\u0026amp;2\u0026amp;47\u0026amp;2\u0026amp;7\u0026amp;2\\\\\\hline \\end{array}\\) 有了上面這張改良後的表，因式分解就可以簡化成： 當 table[num] == num 時，num 是質數 否則 num = table[num] * num/table[num]，由於 table[num] 是最大因數，所以可以繼續分解直到變成質數。 三、解題 1. Sieve of Eratosthenes Time complexity: \\(O(n\\sqrt{n}/\\log n)\\) Space complexity: \\(O(n/\\log n)\\) vector\u0026lt;int\u0026gt; table; // 在全域建一個 pre-built table int distinctPrimeFactors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int upbound = *max_element(nums.begin(), nums.end()); // 求整個數列的最大值 table.assign(upbound+1, 0); // table 只需求到最大值即可 iota(table.begin(), table.end(), 0); // 依序將 table[i] = i 填入 table for (int i = 2; i \u0026lt;= upbound; i++) { if (!table[i]) continue; // 當該數為合數時，跳過 for (int j = 2*i; j \u0026lt;= upbound; j += i) { table[j] = i; // 將所有質數的倍數記錄下他 } } unordered_set\u0026lt;int\u0026gt; set; for (const auto\u0026amp; num : nums) { find(num, set); // 質因數分解 } return set.size(); // 求質因數的個數 } void find(int num, unordered_set\u0026lt;int\u0026gt;\u0026amp; set) { if (table[num] == num) { set.insert(num); // 當是質數就用 set 記錄下來 } else { find(num/table[num], set); // 不是質數就繼續分解 find(table[num], set); } } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2521/","summary":"2521. Distinct Prime Factors of Product of Array\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.\nNote that:\nA number greater than 1 is called prime if it is divisible by only 1 and itself. An integer val1 is a factor of another integer val2 if val2 / val1 is an integer.","title":"[LeetCode] 2521. Distinct Prime Factors of Product of Array"},{"content":"2520. Count the Digits That Divide a Number\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 Given an integer num, return the number of digits in num that divide num. An integer val divides nums if nums % val == 0.\nExample 1:\nInput: num = 7 Output: 1 Explanation: 7 divides itself, hence the answer is 1. Example 2:\nInput: num = 121 Output: 2 Explanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2. Example 3:\nInput: num = 1248 Output: 4 Explanation: 1248 is divisible by all of its digits, hence answer is 4. Constraints:\n1 \u0026lt;= num \u0026lt;= 10^9 num does not contain 0 as one of its digits. 二、分析 此題會用到遍歷所有 digit 的方法： while (num \u0026gt; 0){ int digit = num % 10; num /= 10; } + 利用上面的方法，再針對題目做相應的統計即可。 三、解題 1. Math Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int countDigits(int num) { int res = 0; int x = num; while (x \u0026gt; 0) { int tmp = x % 10; if (num % tmp == 0) res++; x /= 10; } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2520/","summary":"2520. Count the Digits That Divide a Number\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 Given an integer num, return the number of digits in num that divide num. An integer val divides nums if nums % val == 0.\nExample 1:\nInput: num = 7 Output: 1 Explanation: 7 divides itself, hence the answer is 1. Example 2:\nInput: num = 121 Output: 2 Explanation: 121 is divisible by 1, but not 2.","title":"[LeetCode] 2520. Count the Digits That Divide a Number"},{"content":"290. Word Pattern\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Hash Table、String 一、題目 Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and non-empty word in s.\nExample 1:\nInput: pattern = \u0026ldquo;abba\u0026rdquo;, s = \u0026ldquo;dog cat cat dog\u0026rdquo; Output: true Example 2:\nInput: pattern = \u0026ldquo;abba\u0026rdquo;, s = \u0026ldquo;dog cat cat fish\u0026rdquo; Output: false Example 3:\n**Input:**pattern = \u0026ldquo;aaaa\u0026rdquo;, s = \u0026ldquo;dog cat cat dog\u0026rdquo; Output: false Constraints:\n1 \u0026lt;= pattern.length \u0026lt;= 300 pattern contains only lower-case English letters. 1 \u0026lt;= s.length \u0026lt;= 3000 s contains only lowercase English letters and spaces ' '. s does not contain any leading or trailing spaces. All the words in s are separated by a single space. 二、分析 三、解題 1. Hash Table Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) vector\u0026lt;string\u0026gt; split(string\u0026amp; str, char del){ stringstream ss(str); string item; vector\u0026lt;string\u0026gt; res; while (getline(ss, item, del)){ if (!item.empty()){ res.push_back(item); } } return res; } bool wordPattern(string pattern, string s) { unordered_map\u0026lt;char, string\u0026gt; map; unordered_set\u0026lt;string\u0026gt; st; vector\u0026lt;string\u0026gt; svec = split(s, \u0026#39; \u0026#39;); // 將 s 以空白拆開成陣列 if (pattern.length() != svec.size()) return false; // 檢查陣列的個數是否與 pattern 的長度相符 for (int i = 0; i \u0026lt; svec.size(); i++) { char\u0026amp; c = pattern[i]; if (!map.count(c)) { // 定義第一次出現的 pattern if (st.count(svec[i])) return false; // 如果該字串已經被定義過 pattern 則為 false map[c] = svec[i]; // 定義 pattern st.insert(svec[i]); // 將定義過的字串記錄下來 } else { if (map[c] != svec[i]) return false; // 定義的 pattern 不符 } } return true; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/290/","summary":"290. Word Pattern\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Hash Table、String 一、題目 Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and non-empty word in s.\nExample 1:\nInput: pattern = \u0026ldquo;abba\u0026rdquo;, s = \u0026ldquo;dog cat cat dog\u0026rdquo; Output: true Example 2:\nInput: pattern = \u0026ldquo;abba\u0026rdquo;, s = \u0026ldquo;dog cat cat fish\u0026rdquo; Output: false Example 3:","title":"[LeetCode] 290. Word Pattern"},{"content":"C# 中的 Yield Return 與 IEnumerable\u0026lt;T\u0026gt; 在使用過 C# 與 Java 兩種語言之後會發現，Java 為了跨平台的特性，鮮少修改 VM 規格，相較 .NET 為了語法簡潔，編譯器往往會做出讓步，也因此 C# 比起 Java 多了許多語法糖。如 delegate 等，在這邊預留一些內容到下一次寫，今天專注於 yield return 與 IEnumerable。\n起源 為何需要 IEnumerable? 1. 目標：依序印出 1 ~ 100 的數字\n一般來說，若要做到以上的目標，只需要用到簡單的 for_loop 即可。\nstatic void Main(string[] args) { for (int i = 1; i \u0026lt;= 100; i++) { Console.Write(\u0026#34;{0} \u0026#34;, i); } } IEnumerable 是什麼？要做什麼用？ IEnumerator 是一種列舉器，它是特化用來專門處理 iteration 的工具。 在 Design Patterns 中有一種設計模式叫作 Iterator，它的目的就是要在：\n不需要知道物件的內部細節，即可依序存取內含的每一個元素。 IEnumerator 物件的實作： public class Enumerator1 : IEnumerator\u0026lt;int\u0026gt; { private int _start; private int _end; private int _curr; public Enumerator1(int start, int end) { _start = start; _end = end; this.Reset(); } public int Current { get { return this._curr; } } public void Dispose() { } object System.Collections.IEnumerator.Current { get { return this._curr; } } public bool MoveNext() { this._curr++; return !(this._curr \u0026gt; this._end); } public void Reset() { this._curr = this._start; } } 於是，我們若要遍歷這個物件的內容，只需要： static void Main(string[] args) { Enumerator1 e = new Enumerator1(1, 100); do { Console.Write(\u0026#34;{0} \u0026#34;, e.Current); } while (e.MoveNext()); } Ieration/Process 分離 當我們今天不想管 collection 裡每一個物件是怎麼擺的，用什麼結構裝、用什麼邏輯或演算法處理的，只想要依序將安排好的元素拿出來。也就是說，我們想把物件遍歷的(iteration) 與拿到它後要做什麼事(process) 分開，那麼就可以用到 Iterator Pattern。 2. 目標：依序印出 1 ~ 100 中的質數\n使用一般的 for_loop 來實現的話會是：\nstatic void Main(string[] args) { for (int i = 1; i \u0026lt;= 100; i++) { if (isPrime(i)) Console.Write(\u0026#34;{0} \u0026#34;, i); } } static bool isPrime(int num) { if (num \u0026lt;= 1) return false; for (int i = 2; i \u0026lt;= Math.Sqrt(num); i++) { if (num % i == 0) return false; } return true; } 會發現，Iteration 與 Process 已經混在一起。\n那用 IEnumerator 來實作呢?\nclass Test { public class PrimeEnumerator : IEnumerator\u0026lt;int\u0026gt; { private int _start; private int _end; private int _curr; private List\u0026lt;int\u0026gt; list; public PrimeEnumerator(int start, int end) { _start = start; _end = end; this.init(); this.Reset(); } private void init() { list = new List\u0026lt;int\u0026gt;(); bool[] arr = new bool[_end+1]; for (int i = 2; i \u0026lt;= _end; i++) { arr[i] = true; } for (int i = 2; i \u0026lt;= _end; i++) { if (!arr[i]) continue; for (int j = 2*i; j \u0026lt;= _end; j += i) { arr[j] = false; } } for (int i = _start; i \u0026lt;= _end; i++) { if (arr[i]) { list.Add(i); } } } public int Current { get { return this.list[this._curr]; } } public void Dispose() { } object System.Collections.IEnumerator.Current { get { return this.list[this._curr]; } } public bool MoveNext() { this._curr++; return !(this._curr+1 \u0026gt; this.list.Count); } public void Reset() { this._curr = 0; } } } 則要遍歷這個物件，跟原本的程式完全一樣：\nstatic void Main(string[] args) { PrimeEnumerator e = new PrimeEnumerator(1, 100); do { Console.Write(\u0026#34;{0} \u0026#34;, e.Current); } while (e.MoveNext()); } IEnumerable 實作 但是若要作到 Process 與 Iteration 分離，每次都要 Implement IEnumerator，那也太累了吧，於是就有了 IEnumerable 這個語法糖： class PrimeArray { static bool isPrime(int num) { if (num \u0026lt;= 1) return false; for (int i = 2; i \u0026lt;= Math.Sqrt(num); i++) { if (num % i == 0) return false; } return true; } static IEnumerable\u0026lt;int\u0026gt; PrimeEnumerable(int _start, int _end) { for (int i = _start; i \u0026lt;= _end; i++) { if (!isPrime(i)) continue; yield return i; } } static void Main(string[] args) { foreach (int i in PrimeEnumerable(1, 100)) { Console.Write(\u0026#34;{0} \u0026#34;, i); } } } 用以上的寫法，Iterator Patterns 變得非常的精簡，但是使用 yeild 使得違背了原本 function call/return 的概念。但其實如果反組譯其程式碼可以發現，yield return的寫法，其實就是編譯器在編譯的時候，電腦幫你實作了一個 IEnumerator，故事實上就是 C# 送你的一個語法糖。\n","permalink":"http://intervalrain.github.io/posts/it/csharp_yield/","summary":"C# 中的 Yield Return 與 IEnumerable\u0026lt;T\u0026gt; 在使用過 C# 與 Java 兩種語言之後會發現，Java 為了跨平台的特性，鮮少修改 VM 規格，相較 .NET 為了語法簡潔，編譯器往往會做出讓步，也因此 C# 比起 Java 多了許多語法糖。如 delegate 等，在這邊預留一些內容到下一次寫，今天專注於 yield return 與 IEnumerable。\n起源 為何需要 IEnumerable? 1. 目標：依序印出 1 ~ 100 的數字\n一般來說，若要做到以上的目標，只需要用到簡單的 for_loop 即可。\nstatic void Main(string[] args) { for (int i = 1; i \u0026lt;= 100; i++) { Console.Write(\u0026#34;{0} \u0026#34;, i); } } IEnumerable 是什麼？要做什麼用？ IEnumerator 是一種列舉器，它是特化用來專門處理 iteration 的工具。 在 Design Patterns 中有一種設計模式叫作 Iterator，它的目的就是要在：\n不需要知道物件的內部細節，即可依序存取內含的每一個元素。 IEnumerator 物件的實作： public class Enumerator1 : IEnumerator\u0026lt;int\u0026gt; { private int _start; private int _end; private int _curr; public Enumerator1(int start, int end) { _start = start; _end = end; this.","title":"[IT] C# Yield Return"},{"content":"1834. Single-Threaded CPU\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Sorting、Heap (Priority Queue\u0026gt; 一、題目 You are given n​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.\nYou have a single-threaded CPU that can process at most one task at a time and will act in the following way:\nIf the CPU is idle and there are no available tasks to process, the CPU remains idle. If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index. Once a task is started, the CPU will process the entire task without stopping. The CPU can finish a task then start a new one instantly. Return the order in which the CPU will process the tasks. Example 1:\nInput: tasks = [[1,2],[2,4],[3,2],[4,1]] Output: [0,2,3,1] Explanation: The events go as follows: At time = 1, task 0 is available to process. Available tasks = {0}. Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}. At time = 2, task 1 is available to process. Available tasks = {1}. At time = 3, task 2 is available to process. Available tasks = {1, 2}. Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}. At time = 4, task 3 is available to process. Available tasks = {1, 3}. At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}. At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}. At time = 10, the CPU finishes task 1 and becomes idle. Example 2:\nInput: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]] Output: [4,3,2,0,1] Explanation: The events go as follows: At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}. Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}. At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}. At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}. At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}. At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}. At time = 40, the CPU finishes task 1 and becomes idle. Constraints:\ntasks.length == n 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= enqueueTimei, processingTimei \u0026lt;= 10^9 二、分析 執行緒排程問題，直覺會將所有的 task 排序後，依據時間從 0 走到最後來處理這個問題，但是當秒數很大時，就會浪費很多時間，所以我們應該注意的時每個 trigger point，也就是新的 task 任務加入與結束的時候。 討論兩個情況， 當 Thread 是閒置時，直接跳到最前面的 task(即 trigger point 是任務加入時)。 當 Thread 不是閒置時，會將當下的 task 執行完後，所以得到結束的時間後，一次將符合 enqueueTime 的 task 加入佇列(即 trigger point 是任務結束時)。 由於這裡會優先處理 processingTime 較短的，所以在這裡可以用 min heap 來處理。 需注意，在排序前需先標記索引值。 需注意，timestamp 可能是大數。 三、解題 1. Heap (Priority Queue) Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) vector\u0026lt;int\u0026gt; getOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; tasks) { auto comp = [](const auto\u0026amp; a, const auto\u0026amp; b){return a.first == b.first ? a.second \u0026gt; b.second : a.first \u0026gt; b.first;}; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;, vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, decltype(comp)\u0026gt; pq(comp); // min heap long long int timestamp = 0; int n = tasks.size(); vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt; tasks.size(); i++) { tasks[i].push_back(i); // 標記索引值 } sort(tasks.begin(), tasks.end()); // 排序 int i = 0; while (res.size() \u0026lt; n) { if (pq.empty()) { // 閒置時，時間標籤移動到佇列最前面的任務 timestamp = tasks[i][0]; } else { // 非閒置時，將時間標籤移動到任務結束時 auto top = pq.top(); timestamp += top.first; res.push_back(top.second); pq.pop(); } while (i \u0026lt; n \u0026amp;\u0026amp; tasks[i][0] \u0026lt;= timestamp) { // 加入所有比時間標籤早的任務 pq.push({tasks[i][1], tasks[i][2]}); // 以 {processingTime, index} 的方式加入 min heap i++; } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1834/","summary":"1834. Single-Threaded CPU\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Sorting、Heap (Priority Queue\u0026gt; 一、題目 You are given n​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.\nYou have a single-threaded CPU that can process at most one task at a time and will act in the following way:","title":"[LeetCode] 1834. Single-Threaded CPU"},{"content":"1962. Remove Stones to Minimize the Total\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Heap (Priority Queue) 一、題目 You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:\nChoose any piles[i] and remove floor(piles[i] / 2) stones from it. Notice that you can apply the operation on the same pile more than once.\nReturn the minimum possible total number of stones remaining after applying the k operations.\nfloor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\nExample 1:\nInput: piles = [5,4,9], k = 2 Output: 12 Explanation: Steps of a possible scenario are: Apply the operation on pile 2. The resulting piles are [5,4,5]. Apply the operation on pile 0. The resulting piles are [3,4,5].\nThe total number of stones in [3,4,5] is 12. Example 2:\nInput: piles = [4,3,6,7], k = 3 Output: 12 Explanation: Steps of a possible scenario are: Apply the operation on pile 2. The resulting piles are [4,3,3,7]. Apply the operation on pile 3. The resulting piles are [4,3,3,4]. Apply the operation on pile 0. The resulting piles are [2,3,3,4].\nThe total number of stones in [2,3,3,4] is 12. Constraints:\n1 \u0026lt;= piles.length \u0026lt;= 10^5 1 \u0026lt;= piles[i] \u0026lt;= 10^4 1 \u0026lt;= k \u0026lt;= 10^5 二、分析 用 greedy 的思維來思考這一題，每次動作會減去 piles[i] 一半的石頭，要使 k 次後石頭總數最小，那必定是每次都要選在石頭最多的堆來動作。 由於石頭最多的堆是動態更新的，也就是說不能單純用 sort 來解決。舉例來說，每堆的石頭有非常多，那它執行許多次動作仍可能是最多的。 利用 max heap 將最多石頭的堆重覆推到 top，反覆動作 k 次即可解。 三、解題 1. Heap (Priority Queue) Time complexity: \\(O(k\\log n+n)\\) Space complexity: \\(O(n)\\) int minStoneSum(vector\u0026lt;int\u0026gt;\u0026amp; piles, int k) { priority_queue\u0026lt;int\u0026gt; pq; int res = 0; for (const auto\u0026amp; pile : piles) { pq.push(pile); // 先將所有堆都推到 priority queue 上 res += pile; // 順便將原本的石頭總數算出來 } while (k--) { int curr = pq.top(); pq.pop(); int loss = curr \u0026gt;\u0026gt; 1; // 當下的 max heap 的堆頂除於 2 即為當下可以一次取到最多的石頭 pq.push(curr - loss); // 將取完的堆放回 priority queue 上 res -= loss; // 將總數減掉拿掉的石頭 } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1962/","summary":"1962. Remove Stones to Minimize the Total\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Heap (Priority Queue) 一、題目 You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:\nChoose any piles[i] and remove floor(piles[i] / 2) stones from it. Notice that you can apply the operation on the same pile more than once.","title":"[LeetCode] 1962. Remove Stones to Minimize the Total"},{"content":"2279. Maximum Bags With Full Capacity of Rocks\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Greedy、Sorting 一、題目 You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.\nReturn the maximum number of bags that could have full capacity after placing the additional rocks in some bags.\nExample 1:\nInput: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2 Output: 3 Explanation: Place 1 rock in bag 0 and 1 rock in bag 1.\nThe number of rocks in each bag are now [2,3,4,4].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that there may be other ways of placing the rocks that result in an answer of 3. Example 2:\nInput: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100 Output: 3 Explanation: Place 8 rocks in bag 0 and 2 rocks in bag 2.\nThe number of rocks in each bag are now [10,2,2].\nBags 0, 1, and 2 have full capacity.\nThere are 3 bags at full capacity, so we return 3.\nIt can be shown that it is not possible to have more than 3 bags at full capacity.\nNote that we did not use all of the additional rocks. Constraints:\nn == capacity.length == rocks.length 1 \u0026lt;= n \u0026lt;= 5 * 10^4 1 \u0026lt;= capacity[i] \u0026lt;= 10^9 0 \u0026lt;= rocks[i] \u0026lt;= capacity[i] 1 \u0026lt;= additionalRocks \u0026lt;= 10^9 二、分析 思考如何用現有的 additionalRocks 填滿最多個已裝了 rocks[i] 個石頭且原本容量為 capacity[i] 的背包。 用 greedy 的思維來思考，首先先填滿需要最少額外石頭的背包，依序填到沒有額外的石頭，那麼便可以得到最多個已裝滿的背包。 也就是說先求 capacity[i] - rocks[i]，再將之排序後，逐一累加，直到超過 additionalRocks。 三、解題 1. Greedy Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int maximumBags(vector\u0026lt;int\u0026gt;\u0026amp; capacity, vector\u0026lt;int\u0026gt;\u0026amp; rocks, int additionalRocks) { vector\u0026lt;int\u0026gt;\u0026amp; need = capacity; // 借用 capacity 的空間，減少額外空間使用 for (int i = 0; i \u0026lt; capacity.size(); i++) { need[i] -= rocks[i]; // 算出每個背包還需多少個石頭才裝滿 } sort(need.begin(), need.end()); // 裝背包依所需石頭數從小到大排序 int cnt = 0; int used = 0; while (cnt \u0026lt; capacity.size()) { used += need[cnt]; // 算出累加所需的石頭數 if (used \u0026gt; additionalRocks) break; // 超出 additionalRocks 則跳出 cnt++; // 沒超出則滿足的背包數加 1 } return cnt; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2279/","summary":"2279. Maximum Bags With Full Capacity of Rocks\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Greedy、Sorting 一、題目 You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.","title":"[LeetCode] 2279. Maximum Bags With Full Capacity of Rocks"},{"content":"2389. Longest Subsequence With Limited Sum\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Binary Search、Greedy、Sorting、Prefix Sum 一、題目 You are given an integer array nums of length n, and an integer array queries of length m.\nReturn an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nInput: nums = [4,5,2,1], queries = [3,10,21] Output: [2,3,4] Explanation: We answer the queries as follows: The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2. The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3. The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4. Example 2:\nInput: nums = [2,3,4,5], queries = [1] Output: [0] Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0. Constraints:\nn == nums.length m == queries.length 1 \u0026lt;= n, m \u0026lt;= 1000 1 \u0026lt;= nums[i], queries[i] \u0026lt;= 10^6 二、分析 根據 greedy 的思維出發，子序列中的數字愈小，組成目標數字的數值個數愈多的可能性愈大，換句話說，當我們將陣列 sort 過後，前 n 個數字所組成的數字，即代表組成該數字最多的個數為 n。 由於我們要求的是前 n 個數字的和，故我們可以算出 prefix sum，再利用 binary search 去找到 target 所落在的位置。 舉例來說，nums = [4,5,2,1]，經排序後為 nums = [1,2,4,5]，求得 prefixSum = [1,3,7,12]，再利用 upper_bound 可求得解。 prefixSum = [1,3,7,12] target = [0,1,2,3,4,5,6,7,8,9,10,11,12] ^ ^ ^ ^ answer = [0,1,1,2,2,2,2,3,3,3,3, 3, 4 ] 三、解題 1. Binary Search Time complexity: \\(O((m+n)\\log n)\\)\n排序：\\(O(n\\log n)\\)\nm 次 Binary Search：\\(O(m\\times\\log n)\\) Space complexity: \\(O(n)\\) vector\u0026lt;int\u0026gt; answerQueries(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; queries) { sort(nums.begin(), nums.end()); // 排序 vector\u0026lt;int\u0026gt; acc; vector\u0026lt;int\u0026gt; res; for (int x : nums) { // 求 prefix sum if (acc.empty()) acc.push_back(x); else acc.push_back(acc.back() + x); } for (const auto\u0026amp; q : queries) { // 用 binary search 求解 res.push_back(distance(acc.begin(), upper_bound(acc.begin(), acc.end(), q))); } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2389/","summary":"2389. Longest Subsequence With Limited Sum\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Binary Search、Greedy、Sorting、Prefix Sum 一、題目 You are given an integer array nums of length n, and an integer array queries of length m.\nReturn an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.","title":"[LeetCode] 2389. Longest Subsequence With Limited Sum"},{"content":"790. Domino and Tromino Tiling\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Dynamic Programming 一、題目 You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 10^9 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\nExample 1:\nInput: n = 3 Output: 5 Explanation: The five different ways are show above. Example 2:\nInput: n = 1 Output: 1 Constraints:\n1 \u0026lt;= n \u0026lt;= 1000 二、分析 直覺上列出前 5 個解為：1,2,5,11,24，若用觀察法猜公式可以猜到dp[n] = 2*dp[n-1] + dp[n-3]，便可以快速解出答案。 以下為網友的分析\n也就是說，\n\\( \\text{dp[n] = dp[n-1]+dp[n-2]+2(dp[n-3]+\u0026hellip;+dp[0])}\\\\ \\text{dp[n-1] = dp[n-2]+dp[n-3]+2(dp[n-4]+\u0026hellip;+dp[0])}\\\\ \\text{dp[n]=2}\\times\\text{dp[n-1]+dp[n-3]} \\) 三、解題 1. DP Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int numTilings(int n) { int MOD = (int)1e9+7; if (n \u0026lt;= 2) return n; if (n == 3) return 5; vector\u0026lt;long long int\u0026gt; dp(n+1); dp[1] = 1; dp[2] = 2; dp[3] = 5; for (int i = 4; i \u0026lt;= n; i++) { dp[i] = (dp[i-1]*2 + dp[i-3]) % MOD; } return (int)dp[n]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/790/","summary":"790. Domino and Tromino Tiling\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Dynamic Programming 一、題目 You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 10^9 + 7.\nIn a tiling, every square must be covered by a tile.","title":"[LeetCode] 790. Domino and Tromino Tiling"},{"content":"841. Keys and Rooms\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Depth-First Search、Breadth-First Search、Graph 一、題目 There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\nExample 1:\nInput: rooms = [[1],[2],[3]] Output: true Explanation: We visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true. Example 2:\nInput: rooms = [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can not enter room number 2 since the only key that unlocks it is in that room. Constraints:\nn == rooms.length 2 \u0026lt;= n \u0026lt;= 1000 0 \u0026lt;= rooms[i].length \u0026lt;= 1000 1 \u0026lt;= sum(rooms[i].length) \u0026lt;= 3000 0 \u0026lt;= rooms[i][j] \u0026lt; n All the values of rooms[i] are unique. 二、分析 典型的 Graph 問題，利用 visited 來記錄拜訪過了沒，並用 BFS 來遍歷整個 Graph，每次拜訪一間新的 room 時，將 key 加入到新的佇列中，看是否能能遍歷整個 graph。 三、解題 1. BFS Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) bool canVisitAllRooms(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rooms) { queue\u0026lt;int\u0026gt; q; q.push(0); int cnt = rooms.size(); vector\u0026lt;bool\u0026gt; used(rooms.size(), false); while (!q.empty()){ int key = q.front(); q.pop(); if (used[key]) continue; cnt--; if (cnt == 0) break; used[key] = true; for (int next : rooms[key]){ if (used[next]) continue; q.push(next); } } return cnt == 0; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/841/","summary":"841. Keys and Rooms\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Depth-First Search、Breadth-First Search、Graph 一、題目 There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.","title":"[LeetCode] 841. Keys and Rooms"},{"content":"25. Reverse Nodes in k-Group\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Linked List、Recursion 一、題目 Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list\u0026rsquo;s nodes, only nodes themselves may be changed.\nExample 1:\nInput: head = [1,2,3,4,5], k = 2 Output: [2,1,4,3,5] Example 2: Input: head = [1,2,3,4,5], k = 3 Output: [3,2,1,4,5] Constraints:\nThe number of nodes in the list is n. 1 \u0026lt;= k \u0026lt;= n \u0026lt;= 5000 0 \u0026lt;= Node.val \u0026lt;= 1000 二、分析 經典的 ListNode 問題，鏈表的後序遍歷，利用後序遍歷回傳值的特性並用 recursion 來完成這一題。 三、解題 1. Recursion Time complexity: \\(O()\\) Space complexity: \\(O()\\) ListNode* reverseKGroup(ListNode* head, int k) { int cnt = k; ListNode* last = head; while (cnt \u0026amp;\u0026amp; last) { last = last-\u0026gt;next; cnt--; } if (cnt == 0) { last = reverseKGroup(last, k); ListNode* prev = nullptr; ListNode* curr = head; ListNode* next = nullptr; cnt = k; while (cnt--) { next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr; curr = next; } head-\u0026gt;next = last; head = prev; } return head; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/25/","summary":"25. Reverse Nodes in k-Group\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Linked List、Recursion 一、題目 Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.","title":"[LeetCode] 25. Reverse Nodes in k-Group"},{"content":"24. Swap Nodes in Pairs\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List、Recursion 一、題目 Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list\u0026rsquo;s nodes (i.e., only nodes themselves may be changed.)\nExample 1:\nInput: head = [1,2,3,4] Output: [2,1,4,3] Example 2:\nInput: head = [] Output: [] Example 3:\nInput: head = [1] Output: [1] Constraints:\nThe number of nodes in the list in the range [0, 100]. 0 \u0026lt;= Node.val \u0026lt;= 100 二、分析 經典的 ListNode 問題，鏈表的後序遍歷，利用後序遍歷回傳值的特性並用 recursion 來完成這一題。 三、解題 1. Recursion Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) ListNode* swapPairs(ListNode* head) { if (!head || !head-\u0026gt;next) return head; // 先確定終止條件 ListNode* next = head-\u0026gt;next; // 兩個節點為單位，所以在每一個遞迴內控制兩個節點 head-\u0026gt;next = swapPairs(next-\u0026gt;next); // 每個單位的尾巴接回傳值的頭部 next-\u0026gt;next = head; // 實做每個單位裡面的反轉 return next; // 因為單位的尾巴要接到下一個單位的頭部，故這裡要回傳單位的頭位 } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/24/","summary":"24. Swap Nodes in Pairs\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List、Recursion 一、題目 Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list\u0026rsquo;s nodes (i.e., only nodes themselves may be changed.)\nExample 1:\nInput: head = [1,2,3,4] Output: [2,1,4,3] Example 2:\nInput: head = [] Output: [] Example 3:\nInput: head = [1] Output: [1] Constraints:","title":"[LeetCode] 24. Swap Nodes in Pairs"},{"content":"931. Minimum Falling Path Sum\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming、Matrix 一、題目 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).\nExample 1:\nInput: matrix = [[2,1,3],[6,5,4],[7,8,9]] Output: 13 Explanation: There are two falling paths with a minimum sum as shown. Example 2:\nInput: matrix = [[-19,57],[-40,-5]] Output: -59 Explanation: The falling path with a minimum sum is shown. Constraints:\nn == matrix.length == matrix[i].length 1 \u0026lt;= n \u0026lt;= 100 -100 \u0026lt;= matrix[i][j] \u0026lt;= 100 二、分析 這題也是典型的動態規劃問題，每一層可能的最小值，會影響到下一層的最小值，所以我們只需記錄每一層的狀態再將狀態往下一層推移即可。 定義 dp[m][n] 為第 m 層，第 n 欄的累計最小值。 轉移方程式為 dp[m][n] = min({dp[m-1][n-1], dp[m-1][n], dp[m-1][n+1]}) + row[m][n]。 但要注意最左邊跟最右邊要另外處理以避免出界。 從轉移方程式可以注意到，狀態的轉移只跟上一層有關係，故可以做空間壓縮，就空間複雜度壓到 \\(O(n)\\) 三、解題 1. DP Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(m\\times n)\\) int minFallingPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int m = matrix.size(), n = matrix[0].size(); if (m == 1) return matrix[0][0]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m+1, vector\u0026lt;int\u0026gt;(n)); for (int i = 0; i \u0026lt; m; i++) { vector\u0026lt;int\u0026gt;\u0026amp; row = matrix[i]; dp[i+1][0] = min(dp[i][0], dp[i][1]) + row[0]; dp[i+1][n-1] = min(dp[i][n-1], dp[i][n-2]) + row[n-1]; for (int j = 1; j \u0026lt; n-1; j++) { dp[i+1][j] = min({dp[i][j-1], dp[i][j], dp[i][j+1]}) + row[j]; } } int res = INT_MAX; for (int j = 0; j \u0026lt; n; j++) { res = min(res, dp[m][j]); } return res; } 2. DP space-optimized Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(n)\\) int minFallingPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int m = matrix.size(), n = matrix[0].size(); if (m == 1) return matrix[0][0]; // 利用奇數層跟偶數層做切換 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(2, vector\u0026lt;int\u0026gt;(n)); for (int i = 0; i \u0026lt; m-1; i++) { vector\u0026lt;int\u0026gt;\u0026amp; row = matrix[i]; dp[i%2][0] = min(dp[(i+1)%2][0], dp[(i+1)%2][1]) + row[0]; dp[i%2][n-1] = min(dp[(i+1)%2][n-1], dp[(i+1)%2][n-2]) + row[n-1]; for (int j = 1; j \u0026lt; matrix[0].size()-1; j++) { dp[i%2][j] = min({dp[(i+1)%2][j-1], dp[(i+1)%2][j], dp[(i+1)%2][j+1]}) + row[j]; } } int res = INT_MAX; dp[(m-1)%2][0] = min(dp[m%2][0], dp[m%2][1]) + matrix[m-1][0]; dp[(m-1)%2][n-1] = min(dp[m%2][n-1], dp[m%2][n-2]) + matrix[m-1][n-1]; res = min({res, dp[(m-1)%2][0], dp[(m-1)%2][n-1]}); for (int j = 1; j \u0026lt; matrix[0].size()-1; j++) { dp[(m-1)%2][j] = min({dp[m%2][j-1], dp[m%2][j], dp[m%2][j+1]}) + matrix[m-1][j]; res = min(res, dp[(m-1)%2][j]); } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/931/","summary":"931. Minimum Falling Path Sum\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming、Matrix 一、題目 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).","title":"[LeetCode] 931. Minimum Falling Path Sum"},{"content":"70. Climbing Stairs\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math、Dynamic Programming、Memoization 一、題目 You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nExample 1:\nInput: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps Example 2:\nInput: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step Constraints:\n1 \u0026lt;= n \u0026lt;= 45 二、分析 經典的動態規劃問題，因為只有 1-step 與 2-steps 兩個選擇，所以 n 階的樓梯的走法會是 n-1 階與 n-2 階走法的總和。 令 n 階走法的數目為 dp[n]，dp[n] = dp[n-1] + dp[n-2]。 注意初始條件 dp[0] = 1，dp[1] = 1。 可以發現此為費式數列，即 1,1,2,3,5,8,13,21...。 三、解題 1. DP Time complexity: \\(O()\\) Space complexity: \\(O()\\) int climbStairs(int n) { int dp[n+1]; dp[0] = 1, dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/70/","summary":"70. Climbing Stairs\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math、Dynamic Programming、Memoization 一、題目 You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nExample 1:\nInput: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps Example 2:","title":"[LeetCode] 70. Climbing Stairs"},{"content":"2501. Longest Square Streak in an Array\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Binary Search、Dynamic Programming、Sorting \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 You are given an integer array nums. A subsequence of nums is called a square streak if:\nThe length of the subsequence is at least 2, and after sorting the subsequence, each element (except the first element) is the square of the previous number.\nReturn the length of the longest square streak in nums, or return -1 if there is no square streak.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. Example 1:\nInput: nums = [4,3,6,16,8,2] Output: 3 Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16]. 4 = 2 * 2. 16 = 4 * 4.\nTherefore, [4,16,2] is a square streak.\nIt can be shown that every subsequence of length 4 is not a square streak. Example 2:\nInput: nums = [2,3,5,6,7] Output: -1 Explanation: There is no square streak in nums so return -1. Constraints:\n2 \u0026lt;= nums.length \u0026lt;= 10^5 2 \u0026lt;= nums[i] \u0026lt;= 10^5 二、分析 先將 num 排序過後，遍歷所有的數字，並在遍歷的當下將數值存進 map 中，再找尋有沒有符合題意條件的數值在 map 中。 令一個 dp(n)，代別 nums[n] 所具有的 longestSquareStreak，其中 if (map.count(sqrt(nums[i]))) dp[i] = dp[map[sqrt(nums[i])]] + 1 需注意檢查 sqrt(nums[i]) * sqrt(nums[i] == nums[i] 三、解題 1. DP Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) int longestSquareStreak(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; dp(nums.size(), 1); unordered_map\u0026lt;int,int\u0026gt; map; sort(nums.begin(), nums.end()); int res = -1; for (int i = 0; i \u0026lt; nums.size(); i++) { int target = sqrt(nums[i]); if (target * target == nums[i]) { if (map.count(target)) { dp[i] = dp[map[target]] + 1; res = max(dp[i], res); } } map[nums[i]] = i; } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2501/","summary":"2501. Longest Square Streak in an Array\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Binary Search、Dynamic Programming、Sorting \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 You are given an integer array nums. A subsequence of nums is called a square streak if:\nThe length of the subsequence is at least 2, and after sorting the subsequence, each element (except the first element) is the square of the previous number.\nReturn the length of the longest square streak in nums, or return -1 if there is no square streak.","title":"[LeetCode] 2501. Longest Square Streak in an Array"},{"content":"2500. Delete Greatest Value in Each Row\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Hash Table、Binary Search、Dynamic Programming、Sorting \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them. Add the maximum of deleted elements to the answer.\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above. Example 1:\nInput: grid = [[1,2,4],[3,3,1]] Output: 8 Explanation: The diagram above shows the removed values in each step. In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer. In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer. In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8. Example 2:\nInput: grid = [[10]] Output: 10 Explanation: The diagram above shows the removed values in each step. In the first operation, we remove 10 from the first row. We add 10 to the answer. The final answer = 10. Constraints:\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 50 1 \u0026lt;= grid[i][j] \u0026lt;= 100 二、分析 將每一列的 vector 都各自排序後，依題意將每一欄取最大值並累加起來。 三、解題 1. Sort Time complexity: \\(O(m\\times n\\log n)\\) Space complexity: \\(O(1)\\) int deleteGreatestValue(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { for (int i = 0; i \u0026lt; grid.size(); i++) { auto\u0026amp; row = grid[i]; sort(row.begin(), row.end()); } int res = 0; for (int j = 0; j \u0026lt; grid[0].size(); j++) { int tmp = 0; for (int i = 0; i \u0026lt; grid.size(); i++) { tmp = max(tmp, grid[i][j]); } res += tmp; } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2500/","summary":"2500. Delete Greatest Value in Each Row\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Hash Table、Binary Search、Dynamic Programming、Sorting \\(\\color{blue}\\textsf{Weekly Contest 323}\\) 一、題目 You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them. Add the maximum of deleted elements to the answer.\nNote that the number of columns decreases by one after each operation.","title":"[LeetCode] 2500. Delete Greatest Value in Each Row"},{"content":"124. Binary Tree Maximum Path Sum\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Dynamic Programming、Tree、Depth-First Search、Binary Tree 一、題目 A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node\u0026rsquo;s values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path. Example 1:\nInput: root = [1,2,3] Output: 6 Explanation: The optimal path is 2 -\u0026gt; 1 -\u0026gt; 3 with a path sum of 2 + 1 + 3 = 6 Example 2: Input: root = [-10,9,20,null,null,15,7] Output: 42 Explanation: The optimal path is 15 -\u0026gt; 20 -\u0026gt; 7 with a path sum of 15 + 20 + 7 = 42. Constraints:\nThe number of nodes in the tree is in the range [1, 3*10^4]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 二、分析 此題的解題關鍵在於求單邊子葉的最大 pathSum。 注意 pathSum 只需要是路徑上的任一總和，無需一定要包含子葉節點。 對一個節點而言，可能的路徑包含： 節點本身 節點本身 + 左邊的 pathSum 節點本身 + 右邊的 pathSum 節點本身 + 兩邊的 pathSum 以上可以簡化成 root-\u0026gt;val + max(leftPathSum, 0) + max(rightPathSum, 0) 故我們可以遍歷整棵樹，並同時更新可能的 三、解題 1. DFS Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int res = INT_MIN; int maxPathSum(TreeNode* root) { dfs(root); return res; } int dfs(TreeNode* root) { if (!root) return 0; int left = dfs(root-\u0026gt;left); int right = dfs(root-\u0026gt;right); int sum = root-\u0026gt;val + max(left, 0) + max(right, 0); res = max(res, sum); return root-\u0026gt;val + max(max(left, 0) + max(right, 0)); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/124/","summary":"124. Binary Tree Maximum Path Sum\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Dynamic Programming、Tree、Depth-First Search、Binary Tree 一、題目 A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node\u0026rsquo;s values in the path.","title":"[LeetCode] 124. Binary Tree Maximum Path Sum"},{"content":"初級日語第 3 課 1. ここ/そこ/あそこ は[名詞] です 這裡、那裡(近的)、那裡(遠的)\nここは食堂です。 あそこは図書館です。 ここは入り口[いりくち]ですか。\nはい、そうです。ここは入り口です。 こちら/そちら/あちら/どちら 為較有禮貌的說法\n2. [名詞] は [名詞(場所)] です \u0026hellip;在\u0026hellip;\n図書館はあそこです。 入り口はここです。 出口[でくち]はここです。 お手洗い[おてあらい]は一階です。 森さんは会議室です。 3. [名詞] はどこですか \u0026hellip;在哪裡?\n出口はどこですか。\n出口は一階です。 お手洗いはどこですか。\nお手洗いはあそこです。 受付[うけつけ]はどちらですか。 4. [名詞] も [名詞] \u0026hellip;也\u0026hellip;\nここは会議室です。\nあそこも会議室です。 図書館は一階です。\nお手洗いも一階です。 私は日本人です。\n田中さんも日本人です。 森さんは会社員です。\n王さんも会社員です。 ","permalink":"http://intervalrain.github.io/posts/jp/jp03/","summary":"初級日語第 3 課 1. ここ/そこ/あそこ は[名詞] です 這裡、那裡(近的)、那裡(遠的)\nここは食堂です。 あそこは図書館です。 ここは入り口[いりくち]ですか。\nはい、そうです。ここは入り口です。 こちら/そちら/あちら/どちら 為較有禮貌的說法\n2. [名詞] は [名詞(場所)] です \u0026hellip;在\u0026hellip;\n図書館はあそこです。 入り口はここです。 出口[でくち]はここです。 お手洗い[おてあらい]は一階です。 森さんは会議室です。 3. [名詞] はどこですか \u0026hellip;在哪裡?\n出口はどこですか。\n出口は一階です。 お手洗いはどこですか。\nお手洗いはあそこです。 受付[うけつけ]はどちらですか。 4. [名詞] も [名詞] \u0026hellip;也\u0026hellip;\nここは会議室です。\nあそこも会議室です。 図書館は一階です。\nお手洗いも一階です。 私は日本人です。\n田中さんも日本人です。 森さんは会社員です。\n王さんも会社員です。 ","title":"[JP] 初級日語#3"},{"content":"初級日語第 2 課 1. これ、それ、あれ 這個、那個(近的)、那個(遠的)\nこれは、私のパソコン[電腦]です。 あれは、日本の漫画です。 2. 〜はどれですか 哪個\n日本の漫画はどれですか。 すみません。アイスコーヒー[冰咖啡]はどれですか。\nこれです。 おすすめ[推薦]はどれですか。 3. 〜は何[なん]ですか \u0026hellip;是什麼\nこれは何ですか。 それは何ですか。 あれは何ですか。 4. 〜は誰[だれ]ですか＝どなたですか 誰\n彼は誰ですか。 これは誰ですか。 これは私の先生位です。 ","permalink":"http://intervalrain.github.io/posts/jp/jp02/","summary":"初級日語第 2 課 1. これ、それ、あれ 這個、那個(近的)、那個(遠的)\nこれは、私のパソコン[電腦]です。 あれは、日本の漫画です。 2. 〜はどれですか 哪個\n日本の漫画はどれですか。 すみません。アイスコーヒー[冰咖啡]はどれですか。\nこれです。 おすすめ[推薦]はどれですか。 3. 〜は何[なん]ですか \u0026hellip;是什麼\nこれは何ですか。 それは何ですか。 あれは何ですか。 4. 〜は誰[だれ]ですか＝どなたですか 誰\n彼は誰ですか。 これは誰ですか。 これは私の先生位です。 ","title":"[JP] 初級日語#2"},{"content":"初級日語第 1 課 1. [名詞]は[名詞]です \u0026hellip;是\u0026hellip;\n私は日本人です。 私は先生です。 彼は学生です。 彼女は留学生[りゅうがくせい]です。 森さんは先生です。 2. [名詞]は[名詞]ではありません＝[名詞]は[名詞]じゃありません \u0026hellip;不是\u0026hellip;\n私は中国人ではありません。 彼は学生ではありません。 王さんは会社員[かいしゃいん]ではありません。 私は王ではありません、田中です。 3. [名詞]は[名詞]ですか \u0026hellip;是\u0026hellip;嗎?\n彼は学生ですか。 田中さんは会社員ですか。 王さんは留学生ですか。\nはい、そうです。\nいいえ、違います。 4. [名詞]の[名詞] \u0026hellip;的\u0026hellip;\n日本の大学 海外の企業[きぎょう] 東京大学は日本の大学ですか。 北京大学は中国の大学ですか。 ","permalink":"http://intervalrain.github.io/posts/jp/jp01/","summary":"初級日語第 1 課 1. [名詞]は[名詞]です \u0026hellip;是\u0026hellip;\n私は日本人です。 私は先生です。 彼は学生です。 彼女は留学生[りゅうがくせい]です。 森さんは先生です。 2. [名詞]は[名詞]ではありません＝[名詞]は[名詞]じゃありません \u0026hellip;不是\u0026hellip;\n私は中国人ではありません。 彼は学生ではありません。 王さんは会社員[かいしゃいん]ではありません。 私は王ではありません、田中です。 3. [名詞]は[名詞]ですか \u0026hellip;是\u0026hellip;嗎?\n彼は学生ですか。 田中さんは会社員ですか。 王さんは留学生ですか。\nはい、そうです。\nいいえ、違います。 4. [名詞]の[名詞] \u0026hellip;的\u0026hellip;\n日本の大学 海外の企業[きぎょう] 東京大学は日本の大学ですか。 北京大学は中国の大学ですか。 ","title":"[JP] 初級日語#1"},{"content":"1339. Maximum Product of Splitted Binary Tree\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.\nNote that you need to maximize the answer before taking the mod and not after taking it.\nExample 1:\nInput: root = [1,2,3,4,5,6] Output: 110 Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (10*10) Example 2: Input: root = [1,null,2,3,4,null,null,5,6] Output: 90 Explanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6) Constraints:\nThe number of nodes in the tree is in the range [2, 5 * 10^4]. 1 \u0026lt;= Node.val \u0026lt;= 10^4 二、分析 這一題的關鍵在於，求切斷的 edge 兩邊的乘積為最大值。而一但我們知道整棵樹的總和之後，我們便只要知道切斷的其中一邊的和為多少，便可以知道另一邊的和為多少。 one = total - another 經觀察我們可以發現，節點與其所有子葉的和，代表了切斷的 edge 的其中一邊。 故我們只需遍歷整個樹，並把當下節點與所有子葉的和，記錄到 vector 中，再利用 one = total - another 的關係，求得最大乘積。 需要注意此題為大數問題，要注意返回的值要先比較之後才取餘數。 三、解題 1. DFS Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) #define ll long long int #define MOD 1000000007 int maxProduct(TreeNode* root) { vector\u0026lt;ll\u0026gt; vec; int total = dfs(root, vec); // 遍歷樹，並算出整棵樹的和 ll res = 0; for (ll\u0026amp; x : vec) { res = max(res, x * (total-x)); // 截斷邊的兩側樹的和分別為 x 與 total - x } return res % MOD; } int dfs(TreeNode* root, vector\u0026lt;ll\u0026gt; vec) { if (!root) return 0; int left = dfs(root-\u0026gt;left, vec); int right = dfs(root-\u0026gt;right, vec); vec.push_back(root-\u0026gt;val + left + right); // 將子樹的總和記到 vector 中 return vec.back(); // 返回子樹的總和，讓父節點可以使用 } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1339/","summary":"1339. Maximum Product of Splitted Binary Tree\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.\nNote that you need to maximize the answer before taking the mod and not after taking it.","title":"[LeetCode] 1339. Maximum Product of Splitted Binary Tree"},{"content":"1026. Maximum Difference Between Node and Ancestor\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\nA node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.\nExample 1:\nInput: root = [8,3,10,1,6,null,14,null,null,4,7,13] Output: 7 Explanation: We have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7. Example 2: Input: root = [1,null,2,null,0,3] Output: 3 Constraints:\nThe number of nodes in the tree is in the range [2, 5000]. 0 \u0026lt;= Node.val \u0026lt;= 10^5 二、分析 借用一個 helper 函式，將父節點的值往子葉節點傳，並且記錄過程中的最大值與最小值，並定義一個全域變數記錄其差值。 三、解題 1. DFS Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int res = 0; int maxAncestorDiff(TreeNode* root) { helper(root, root-\u0026gt;val, root-\u0026gt;val); return res; } void helper(TreeNode* root, int maxv, int minv) { if (!root) return; maxv = max(maxv, root-\u0026gt;val); minv = min(minv, root-\u0026gt;val); helper(root-\u0026gt;left, maxv, minv); helper(root-\u0026gt;right, maxv, minv); res = max(res, maxv-minv); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1026/","summary":"1026. Maximum Difference Between Node and Ancestor\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\nA node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.","title":"[LeetCode] 1026. Maximum Difference Between Node and Ancestor"},{"content":"872. Leaf-Similar Trees\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\nTwo binary trees are considered leaf-similar if their leaf value sequence is the same.\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.\nExample 1:\nInput: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8] Output: true Example 2: Input: root1 = [1,2,3], root2 = [1,3,2] Output: false Constraints:\nThe number of nodes in each tree will be in the range [1, 200]. Both of the given trees will have values in the range [0, 200]. 二、分析 將所有的節點遍歷過一遍，並將所有的子葉節點記錄在 vector 中，再逐一比較即可。 三、解題 1. DFS Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) bool leafSimilar(TreeNode* root1, TreeNode* root2) { vector\u0026lt;int\u0026gt; vec1, vec2; dfs(root1, vec1); dfs(root2, vec2); return isSame(vec1, vec2); } void dfs(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; vec) { if (!root) return; if (!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right) vec.push_back(root-\u0026gt;val); dfs(root-\u0026gt;left, vec); dfs(root-\u0026gt;right, vec); } bool isSame(vector\u0026lt;int\u0026gt;\u0026amp; vec1, vector\u0026lt;int\u0026gt;\u0026amp; vec2) { if (vec1.size() != vec2.size()) return false; for (int i = 0; i \u0026lt; vec1.size(); i++) { if (vec1[i] != vec2[i]) return false; } return true; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/872/","summary":"872. Leaf-Similar Trees\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\nTwo binary trees are considered leaf-similar if their leaf value sequence is the same.\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.","title":"[LeetCode] 872. Leaf-Similar Trees"},{"content":"938. Range Sum of BST\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Tree、Depth-First Search、Binary Search Tree、Binary Tree 一、題目 Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\nExample 1:\nInput: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32. Example 2: Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 Output: 23 Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23. Constraints:\nThe number of nodes in the tree is in the range [1, 2 * 104]. 1 \u0026lt;= Node.val \u0026lt;= 105 1 \u0026lt;= low \u0026lt;= high \u0026lt;= 105 All Node.val are unique. 二、分析 最簡單的方法可以遍歷過一次，將符合條件的數值加起來，可得到解。 進一步可以思考，可以怎麼樣做到剪枝(pruning)。 當 num \u0026lt; low 時，只有其右子葉有可能有符合條件的子葉。 當 num \u0026gt; high 時，只有其左子葉有可能有符合條件的子葉。 三、解題 1. DFS Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int rangeSumBST(TreeNode* root, int low, int high) { if (!root) return 0; int sum = root-\u0026gt;val \u0026lt;= high \u0026amp;\u0026amp; root-\u0026gt;val \u0026gt;= low ? root-\u0026gt;val : 0; return sum + rangeSumBST(root-\u0026gt;left, low, high) + rangeSumBST(root-\u0026gt;right, low, high); } 2. Binary Search Tree Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int rangeSumBST(TreeNode* root, int low, int high) { if (!root) return 0; int val = root-\u0026gt;val \u0026gt;= low \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= high ? root-\u0026gt;val : 0; int left = root-\u0026gt;val \u0026lt; low ? 0 : rangeSumBST(root-\u0026gt;left, low, high); int right = root-\u0026gt;val \u0026gt; high ? 0 : rangeSumBST(root-\u0026gt;right, low, high); return left + right + val; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/938/","summary":"938. Range Sum of BST\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Tree、Depth-First Search、Binary Search Tree、Binary Tree 一、題目 Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].\nExample 1:\nInput: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15].","title":"[LeetCode] 938. Range Sum of BST"},{"content":"328. Odd Even Linked List\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List 一、題目 Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\nThe first node is considered odd, and the second node is even, and so on.\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\nYou must solve the problem in O(1) extra space complexity and O(n) time complexity.\nExample 1:\nInput: head = [1,2,3,4,5] Output: [1,3,5,2,4] Example 2: Input: head = [2,1,3,5,6,4,7] Output: [2,3,6,7,1,5,4] Constraints:\nThe number of nodes in the linked list is in the range [0, 10^4]. -10^6 \u0026lt;= Node.val \u0026lt;= 10^6 二、分析 分別將奇偶位置的鏈表分開相接之後再將其頭尾串連。 注意因為我們要拿奇數的尾接偶數的頭，故要注意 iterate 的終止條件是 !even || !even-\u0026gt;next 三、解題 1. Linked List Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) ListNode* oddEvenList(ListNode* head) { if (!head) return NULL; ListNode* head2 = head-\u0026gt;next; ListNode* odd = head; ListNode* even = head2; while (even \u0026amp;\u0026amp; even-\u0026gt;next) { odd-\u0026gt;next = odd-\u0026gt;next-\u0026gt;next; even-\u0026gt;next = even-\u0026gt;next-\u0026gt;next; odd = odd-\u0026gt;next; even = even-\u0026gt;next; } odd-\u0026gt;next = head2; return head; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/328/","summary":"328. Odd Even Linked List\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List 一、題目 Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\nThe first node is considered odd, and the second node is even, and so on.\nNote that the relative order inside both the even and odd groups should remain as it was in the input.","title":"[LeetCode] 328. Odd Even Linked List"},{"content":"2472. Maximum Number of Non-overlapping Palindrome Substrings\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: String、Dynamic Programming \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 You are given a string s and a positive integer k. Select a set of non-overlapping substrings from the string s that satisfy the following conditions:\nThe length of each substring is at least k. Each substring is a palindrome. Return the maximum number of substrings in an optimal selection. A substring is a contiguous sequence of characters within a string. Example 1:\nInput: s = \u0026ldquo;abaccdbbd\u0026rdquo;, k = 3 Output: 2 Explanation: We can select the substrings underlined in s = \u0026ldquo;abaccdbbd\u0026rdquo;. Both \u0026ldquo;aba\u0026rdquo; and \u0026ldquo;dbbd\u0026rdquo; are palindromes and have a length of at least k = 3.\nIt can be shown that we cannot find a selection with more than two valid substrings. Example 2:\nInput: s = \u0026ldquo;adbcda\u0026rdquo;, k = 2 Output: 0 Explanation: There is no palindrome substring of length at least 2 in the string. Constraints:\n1 \u0026lt;= k \u0026lt;= s.length \u0026lt;= 2000 s consists of lowercase English letters. 二、分析 動態規劃，定義 dp[i][j] 為索引 i 到索引 j之間的子序列，是否為 palindrome。 當只有兩個字元時，s[i] == s[j] 時為回文。 當大於兩個字元時，除了要滿足 s[i] == s[j] 之外，i+1 到 j-1 的子序列也需為回文，故 dp[i+1][j-1] 需為 true。 注意題目有規定當子序列長度要大於 k 時才可計作解，所以可以設一個值記錄當前最短長度時，滿足題目要求的索引值 pos。 三、解題 1. DP Time complexity: \\(O(n^2)\\) Space complexity: \\(O(n^2)\\) int maxPalindromes(string s, int k) { int n = s.length(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n, vector\u0026lt;bool\u0026gt;(n, false)); int left, right; int len = 0; int res = 0; int pos = 0; for (int j = 0; j \u0026lt; n; j++){ for (int i = 0; i \u0026lt;= j; i++){ if (i == j){ dp[i][j] = true; } else if (j - i == 1){ dp[i][j] = s[i] == s[j]; } else { dp[i][j] = (s[i] == s[j] \u0026amp;\u0026amp; dp[i+1][j-1]); } if (dp[i][j] \u0026amp;\u0026amp; j - i + 1 \u0026gt;= k \u0026amp;\u0026amp; i \u0026gt;= pos) { pos = j+1; res++; } } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2472/","summary":"2472. Maximum Number of Non-overlapping Palindrome Substrings\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: String、Dynamic Programming \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 You are given a string s and a positive integer k. Select a set of non-overlapping substrings from the string s that satisfy the following conditions:\nThe length of each substring is at least k. Each substring is a palindrome. Return the maximum number of substrings in an optimal selection. A substring is a contiguous sequence of characters within a string.","title":"[LeetCode] 2472. Maximum Number of Non-overlapping Palindrome Substrings"},{"content":"2471. Minimum Number of Operations to Sort a Binary Tree by Level\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Breadth-First Search、Binary Tree \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order. The level of a node is the number of edges along the path between it and the root node.\nExample 1:\nInput: root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10] Output: 3 Explanation: Swap 4 and 3. The 2nd level becomes [3,4]. Swap 7 and 5. The 3rd level becomes [5,6,8,7]. Swap 8 and 7. The 3rd level becomes [5,6,7,8].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed. Example 2: Input: root = [1,3,2,7,6,5,4] Output: 3 Explanation: Swap 3 and 2. The 2nd level becomes [2,3]. Swap 7 and 4. The 3rd level becomes [4,6,5,7]. Swap 6 and 5. The 3rd level becomes [4,5,6,7].\nWe used 3 operations so return 3.\nIt can be proven that 3 is the minimum number of operations needed. Example 3: Input: root = [1,2,3,4,5,6] Output: 0 Explanation: Each level is already sorted in increasing order so return 0. Constraints:\nThe number of nodes in the tree is in the range [1, 10^5]. 1 \u0026lt;= Node.val \u0026lt;= 10^5 All the values of the tree are unique. 二、分析 這一題最直觀的想法就是先將所有節點用 vector 記錄下來之後，分層去做 minSwaps。 注意到 minSwaps 的實現：想法是，n 個節點 swap 形成一個 cycle，代表進行了 n-1 次 swap，故我們可以觀察得：minSwaps 的次數會等於 n - cycles。 三、解題 1. DFS Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) int minimumOperations(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec; dfs(root, vec, 0); int res = 0; for (auto v : vec) { res += minSwaps(v); } return res; } void dfs(TreeNode* root, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; vec, int depth) { if (!root) return; if (depth == vec.size()) { vec.push_back({}); } vec[depth].push_back(root-\u0026gt;val); dfs(root-\u0026gt;left, vec, depth+1); dfs(root-\u0026gt;right, vec, depth+1); } int minSwaps(vector\u0026lt;int\u0026gt;\u0026amp; arr){ int n = arr.size(); map\u0026lt;int,int\u0026gt; map; for (int i = 0; i \u0026lt; n; i++) { map[arr[i]] = i; } vector\u0026lt;bool\u0026gt; vis(n, false); sort(arr.begin(), arr.end()); int ans = 0; for (int i = 0; i \u0026lt; n; i++) { if (vis[i] || map[arr[i]] == i) continue; int j = i, cycle = 0; while (!vis[j]) { vis[j] = true; j = map[arr[j]]; cycle++; } if (cycle \u0026gt; 0) { ans += (cycle-1); } } return ans; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2471/","summary":"2471. Minimum Number of Operations to Sort a Binary Tree by Level\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Tree、Breadth-First Search、Binary Tree \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.","title":"[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level"},{"content":"2470. Number of Subarrays With LCM Equal to K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Math、Number Theory \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray\u0026rsquo;s elements is k. A subarray is a contiguous non-empty sequence of elements within an array. The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.\nExample 1:\nInput: nums = [3,6,2,7,1], k = 6 Output: 4 Explanation: The subarrays of nums where 6 is the least common multiple of all the subarray\u0026rsquo;s elements are: [3,6,2,7,1] [3,6,2,7,1] [3,6,2,7,1] [3,6,2,7,1] Example 2:\nInput: nums = [3], k = 2 Output: 0 Explanation: There are no subarrays of nums where 2 is the least common multiple of all the subarray\u0026rsquo;s elements. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i], k \u0026lt;= 1000 二、分析 1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i], k \u0026lt;= 1000 三、解題 1. Brute Method Time complexity: \\(O(n^2)\\) Space complexity: \\(O(1)\\) int subarrayLCM(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int res = 0; int n = nums.size(); int left = 0; while (left \u0026lt; n) { int right = left; int tmp = 1; // 從 left 到 right 的公倍數 while (right \u0026lt; n) { if (k % nums[right] == 0) { // 可被 k 整除才可能公倍數為 k tmp = lcm(tmp, nums[right]); if (tmp == k) res++; } else { break; } right++; } left++; } return res; } 2. Hash Table Time complexity: \\(O(n^2)\\) Space complexity: \\(O(n)\\) int subarrayLCM(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int res = 0; int n = nums.size(); unordered_map\u0026lt;int,int\u0026gt; u; for (int i = 0; i \u0026lt; n; i++) { u[nums[i]]++; unordered_map\u0026lt;int,int\u0026gt; v; // 到 i 為止可以被 k 整除的個數 for (auto [d, cnt] : u) { int tmp = lcm(nums[i], d); if (tmp == k) res += cnt; // 若公倍數等於 k 則加入答案 if (k % tmp == 0) v[tmp] += cnt; } swap(u, v); // 將可能的候選再加入下一輪繼續 } return res; 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2470/","summary":"2470. Number of Subarrays With LCM Equal to K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Math、Number Theory \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray\u0026rsquo;s elements is k. A subarray is a contiguous non-empty sequence of elements within an array. The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.","title":"[LeetCode] 2470. Number of Subarrays With LCM Equal to K"},{"content":"2469. Convert the Temperature\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius. You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit]. Return the array ans. Answers within 10^-5 of the actual answer will be accepted. Note that:\nKelvin = Celsius + 273.15 Fahrenheit = Celsius * 1.80 + 32.00 Example 1:\nInput: celsius = 36.50 Output: [309.65000,97.70000] Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70. Example 2:\nInput: celsius = 122.11 Output: [395.26000,251.79800] Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798. Constraints:\n0 \u0026lt;= celsius \u0026lt;= 1000 二、分析 略。 三、解題 1. Math Time complexity: \\(O(1)\\) Space complexity: \\(O(1)\\) vector\u0026lt;double\u0026gt; convertTemperature(double celsius) { return {celsius+273.15, 1.8*celsius+32}; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2469/","summary":"2469. Convert the Temperature\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math \\(\\color{blue}\\textsf{weekly Contest 319}\\) 一、題目 You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius. You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit]. Return the array ans. Answers within 10^-5 of the actual answer will be accepted. Note that:\nKelvin = Celsius + 273.","title":"[LeetCode] 2469. Convert the Temperature"},{"content":"446. Arithmetic Slices II - Subsequence\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Dynamic Programming 一、題目 Given an integer array nums, return the number of all the arithmetic subsequences of nums. A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences. For example, [1, 1, 2, 5, 7] is not an arithmetic sequence. A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array. For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10]. The test cases are generated so that the answer fits in 32-bit integer. Example 1:\nInput: [2,4,6,8,10] Output: 7 Explanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10] Example 2:\nInput: [7,7,7,7,7] Output: 16 Explanation: Any subsequence of this array is arithmetic. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 -2^31 \u0026lt;= nums[i] \u0026lt;= 2^31 - 1 二、分析 定義 dp[i][j] 為索引為 i ，且間隔為 j 時的子序列個數。 由於間隔可能或大或小，故改用 Hash Map 記錄，故我們使用 vector\u0026lt;unordered_map\u0026lt;int,int\u0026gt;\u0026gt; dp(n) 注意數值的範圍，故 target = nums[j] - diff 若超出範圍，需要剔除。 三、解題 1. DP Time complexity: \\(O(n^2)\\) Space complexity: \\(O(n)\\) int numberOfArithmeticSlices(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int res = 0; vector\u0026lt;unordered_map\u0026lt;int,long long\u0026gt;\u0026gt; dp(n); // dp[index][diff] for (int i = 2; i \u0026lt; n; i++) { unordered_map\u0026lt;int,int\u0026gt; map; for (int j = 0; j \u0026lt; i; j++) { long long diff = (long long)nums[i] - (long long)nums[j]; long long target = nums[j] - diff; // check target is in the range if (target \u0026gt;= INT_MIN \u0026amp;\u0026amp; target \u0026lt;= INT_MAX){ if (map.count(target)) dp[i][diff] += map[target]; // 三個一組的子序列 if (dp[j].count(diff)) dp[i][diff] += dp[j][diff]; // 三個以上的子序列 } map[nums[j]]++; } } for (int i = 0; i \u0026lt; n; i++) { for (auto m : dp[i]) { res += m.second; } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/446/","summary":"446. Arithmetic Slices II - Subsequence\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Dynamic Programming 一、題目 Given an integer array nums, return the number of all the arithmetic subsequences of nums. A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.","title":"[LeetCode] 446. Arithmetic Slices II - Subsequence"},{"content":"2488. Count Subarrays With Median K\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Hash Table、Prefix Sum \\(\\color{blue}\\textsf{Weekly Contest 321}\\) 一、題目 You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.\nReturn the number of non-empty subarrays in nums that have a median equal to k. Note:\nThe median of an array is the middle element after sorting the array in ascending order. If the array is of even length, the median is the left middle element. For example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1] is 4. A subarray is a contiguous part of an array. Example 1:\nInput: nums = [3,2,1,4,5], k = 4 Output: 3 Explanation: The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5]. Example 2:\nInput: nums = [2,3,1], k = 3 Output: 1 Explanation: [3] is the only subarray that has a median equal to 3. Constraints:\nn == nums.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= nums[i], k \u0026lt;= n The integers in nums are distinct. 二、分析 注意這一題的 median 不是統計上的 median。 median 必定是含有 k 的子序列。 我的作法是，找到 k 的位置定為 pivot，其餘的若小於 k，定為 -1，大於 k，定為 +1，並將其用 presum 的方式記錄下來。 根據題目的定義，median == k 只會發生在當 presum[i:j] == 0 或 1 時。又子序列一定要包含 k，所以我們會增加一個條件就是，i \u0026gt;= pivot，j \u0026lt; pivot。其中我們可以事先將 presum[0:pivot] 放入 Hash Map 以供後續使用。 三、解題 1. Hash Map Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int countSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { vector\u0026lt;int\u0026gt; presum = {0}; int pivot; for (int i = 0; i \u0026lt; nums.size(); i++) { int back = presum.back(); if (nums[i] \u0026gt; k) { back += 1; } else if (nums[i] \u0026lt; k){ back -= 1; } else { pivot = i+1; } presum.push_back(back); } int res = 0; unordered_map\u0026lt;int,int\u0026gt; map; for (int i = 0; i \u0026lt; pivot; i++) map[presum[i]]++; for (int i = pivot; i \u0026lt; presum.size(); i++) { res += (map[presum[i]] + map[presum[i]-1]); } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2488/","summary":"2488. Count Subarrays With Median K\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Hash Table、Prefix Sum \\(\\color{blue}\\textsf{Weekly Contest 321}\\) 一、題目 You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.\nReturn the number of non-empty subarrays in nums that have a median equal to k. Note:\nThe median of an array is the middle element after sorting the array in ascending order.","title":"[LeetCode] 2488. Count Subarrays With Median K"},{"content":"2487. Remove Nodes From Linked List\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List、Stack、Recursion、Monotonic Stack \\(\\color{blue}\\textsf{Weekly Contest 321}\\) 一、題目 You are given the head of a linked list.\nRemove every node which has a node with strictly greater value anywhere to the right side of it.\nReturn the head of the modified linked list.\nExample 1:\nInput: head = [5,2,13,3,8] Output: [13,8] Explanation: The nodes that should be removed are 5, 2 and 3. Node 13 is to the right of node 5. Node 13 is to the right of node 2. Node 8 is to the right of node 3. Example 2:\nInput: head = [1,1,1,1] Output: [1,1,1,1] Explanation: Every node has value 1, so no nodes are removed. Constraints:\nThe number of the nodes in the given list is in the range [1, 10^5]. 1 \u0026lt;= Node.val \u0026lt;= 10^5 二、分析 這一題可以用 Monotonic Stack，將鏈表遍歷一次，遇到更大的數，就被堆上的值拿掉。 不過因為題目最後要回傳一個 Linked List，所以我會使用 Deque 來實作，遍歷完一次之後再把堆剩下的值，依序連接。 三、解題 1. Monotonic Stack Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) ListNode* removeNodes(ListNode* head) { deque\u0026lt;ListNode*\u0026gt; dq; dq.push_back(new ListNode(INT_MAX, head)); // 省去處理 deque 為空的狀況 ListNode* curr = head; while (curr) { while (curr-\u0026gt;val \u0026gt; dq.back()-\u0026gt;val) { dq.pop_back(); } dq.push_back(curr); curr = curr-\u0026gt;next; } ListNode* dummy = new ListNode(dq.front()-\u0026gt;val); curr = dummy; dq.pop_front(); while (!dq.empty() \u0026amp;\u0026amp; curr) { curr-\u0026gt;next = dq.front(); dq.pop_front(); curr = curr-\u0026gt;next; } return dummy-\u0026gt;next; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2487/","summary":"2487. Remove Nodes From Linked List\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List、Stack、Recursion、Monotonic Stack \\(\\color{blue}\\textsf{Weekly Contest 321}\\) 一、題目 You are given the head of a linked list.\nRemove every node which has a node with strictly greater value anywhere to the right side of it.\nReturn the head of the modified linked list.\nExample 1:\nInput: head = [5,2,13,3,8] Output: [13,8] Explanation: The nodes that should be removed are 5, 2 and 3.","title":"[LeetCode] 2487. Remove Nodes From Linked List"},{"content":"2486. Accept Characters to String to Make Subsequence\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Two Pointer、String、Greedy \\(\\color{blue}\\textsf{Weekly Contest 321}\\) 一、題目 You are given two strings s and t consisting of only lowercase English letters. Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nExample 1:\nInput: s = \u0026ldquo;coaching\u0026rdquo;, t = \u0026ldquo;coding\u0026rdquo; Output: 4 Explanation: Append the characters \u0026ldquo;ding\u0026rdquo; to the end of s so that s = \u0026ldquo;coachingding\u0026rdquo;.\nNow, t is a subsequence of s (\u0026ldquo;coachingding\u0026rdquo;).\nIt can be shown that appending any 3 characters to the end of s will never make t a subsequence. Example 2:\nInput: s = \u0026ldquo;abcde\u0026rdquo;, t = \u0026ldquo;a\u0026rdquo; Output: 0 Explanation: t is already a subsequence of s (\u0026ldquo;abcde\u0026rdquo;). Example 3:\nInput: s = \u0026ldquo;z\u0026rdquo;, t = \u0026ldquo;abcde\u0026rdquo; Output: 5 Explanation: Append the characters \u0026ldquo;abcde\u0026rdquo; to the end of s so that s = \u0026ldquo;zabcde\u0026rdquo;. Now, t is a subsequence of s (\u0026ldquo;zabcde\u0026rdquo;). It can be shown that appending any 4 characters to the end of s will never make t a subsequence. Constraints:\n1 \u0026lt;= s.length, t.length \u0026lt;= 10^5 s and t consist only of lowercase English letters. 二、分析 這一題是簡單的 Two Pointer，當 s[i] == t[j] 時，j++。i 指標走到盡頭時，t 剩餘多少字元即為 s 需要增加的字元。 三、解題 1. Two Pointer Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int appendCharacters(string s, string t) { int i = 0, j = 0; for (; i \u0026lt; s.length(); i++) { if (s[i] == t[j]) j++; if (j == t.length()) return 0; } return t.length()-j; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2486/","summary":"2486. Accept Characters to String to Make Subsequence\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Two Pointer、String、Greedy \\(\\color{blue}\\textsf{Weekly Contest 321}\\) 一、題目 You are given two strings s and t consisting of only lowercase English letters. Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.","title":"[LeetCode] 2486. Accept Characters to String to Make Subsequence"},{"content":"2485. Find the Pivot Integer\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math、Prefix Sum \\(\\color{blue}\\textsf{Weekly Contest 321}\\) 一、題目 Given a positive integer n, find the pivot integer x such that:\nThe sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively. Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input. Example 1:\nInput: n = 8 Output: 6 Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21 Example 2:\nInput: n = 1 Output: 1 Explanation: 1 is the pivot integer since: 1 = 1. Example 3:\nInput: n = 4 Output: -1 Explanation: It can be proved that no such integer exists. Constraints:\n1 \u0026lt;= n \u0026lt;= 1000 二、分析 此題要找 sum([1:x]) == sum([x:n]) 當 x=1 開始，即 left = sum([1:1]) 與 right = sum([1:n])。 當指標向右移動，left += (x+1)，而 right -= x。 若指標從 x=1 到 x=n 遍歷過一次都無解，即傳回 -1，若有解則立即傳回 x。 另外也可以也可以用 Prefix Sum 的概念，同樣從 x=1 到 x=n，找 presum[n] - presum[i] == presum[i+1]。 三、解題 1. Array Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int pivotInteger(int n) { if (n == 1) return 1; int right = (1 + n) * n/2; int left = 1; for (int i = 1; i \u0026lt; n; i++) { if (left == right) return i; left += (i+1); right -= i; } return -1; } 2. Prefix Sum Time Complexity int pivotInteger(int n) { if (n == 1) return 1; vector\u0026lt;int\u0026gt; presum; presum.push_back(0); for (int i = 1; i \u0026lt;= n; i++) { presum.push_back(presum.back() + i); } for (int i = 1; i \u0026lt; n; i++) { if (presum[n] - presum[i] == presum[i+1]) return i+1; } return -1; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2485/","summary":"2485. Find the Pivot Integer\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math、Prefix Sum \\(\\color{blue}\\textsf{Weekly Contest 321}\\) 一、題目 Given a positive integer n, find the pivot integer x such that:\nThe sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively. Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.","title":"[LeetCode] 2485. Find the Pivot Integer"},{"content":"1235. Maximum Profit in Job Scheduling\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Binary Search、Dynamic Programming、Sorting 一、題目 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou\u0026rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\nExample 1:\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70] Output: 120 Explanation: The subset chosen is the first and fourth job.\nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70. Example 2: Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60] Output: 150 Explanation: The subset chosen is the first, fourth and fifth job.\nProfit obtained 150 = 20 + 70 + 60. Example 3: Input: The subset chosen is the first, fourth and fifth job. Profit obtained 150 = 20 + 70 + 60. Output: 6 Constraints:\n1 \u0026lt;= startTime.length == endTime.length == profit.length \u0026lt;= 5 * 10^4 1 \u0026lt;= startTime[i] \u0026lt; endTime[i] \u0026lt;= 10^9 1 \u0026lt;= profit[i] \u0026lt;= 10^4 二、分析 在思考這一題，首先要先有 coin change 的思維，也就是動態規劃： 我們將 dp[n] 定義為在時間 n 時的最大利益。 所以當時間點 i 的最大利益會等於 max(dp[i-1], dp[i - time_cost] + profit 以範例 1 為例即： dp[0] = 0 dp[1] = 0 dp[2] = 0 dp[3] = 50 = max(dp[1]+50, dp[2]) dp[4] = 50 = dp[3] dp[5] = 90 = max(dp[3]+40, dp[4]) \u0026hellip; 其中我們可以發現，有可能發生改變的時間點都是在每一個工作的 endTime，也就是說我們只要針對每個 endTime 去記錄即可，其中我們可將 dp[i - time_cost] 改為搜尋小於 startTime 的最大值，即： dp[0] = 0 dp[3] = 50 = max(dp[0], dp[3]) dp[4] = 10 = max(dp[0]+10, dp[4]) 我們只記錄當下最大利益，故不記錄 dp[5] = 90 = max(dp[3]+40, dp[5]) dp[6] = 120 = max(dp[3]+70, dp[6] 我們可以使用 map 這個資料結構，將所有 trigger point 依 endTime 排序後，逐步更新。 其中注意 upper_bound(x) 這個函式，會找大於 x 的位子，而且我們要找的是比小於等於當前 startTime 的資料，故我們找的是 upper_bound(x)-1。 由於時間 t = 0 時不會有收益，我們可以加入 {0,0}，這樣可以省去解決 iterator out of range(it 指向 -1) 的情形。 三、解題 1. DP + Binary Search Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) int jobScheduling(vector\u0026lt;int\u0026gt;\u0026amp; startTime, vector\u0026lt;int\u0026gt;\u0026amp; endTime, vector\u0026lt;int\u0026gt;\u0026amp; profit) { map\u0026lt;int,int\u0026gt; dp; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; job; int n = startTime.size(); for (int i = 0; i \u0026lt; n; i++) { job.push_back({endTime[i], startTime[i], profit[i]}); } sort(job.begin(), job.end()); // sort by endTime dp.insert({0,0}); // 省去處理 out of range int res = 0; for (int i = 0; i \u0026lt; n; i++) { auto it = dp.upper_bound(job[i][1]); // \u0026gt; startTime it--; // \u0026lt;= startTime int last = it-\u0026gt;second; int val = last + job[i][2]; // 由當前最大收益往上累積 int pos = job[i][0]; if (val \u0026lt; res) continue; // 若當前最大收益比歷史最大收益還小，則跳過不記錄 dp[pos] = max(dp[pos], val); // 更新當前最大收益 res = max(dp[pos], res); // 更新歷史最大收益 } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1235/","summary":"1235. Maximum Profit in Job Scheduling\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Binary Search、Dynamic Programming、Sorting 一、題目 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou\u0026rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.","title":"[LeetCode] 1235. Maximum Profit in Job Scheduling"},{"content":"1143. Longest Common Subsequence\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String、Dynamic Programming 一、題目 Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nFor example, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot;. A common subsequence of two strings is a subsequence that is common to both strings. Example 1:\nInput: text1 = \u0026ldquo;abcde\u0026rdquo;, text2 = \u0026ldquo;ace\u0026rdquo; Output: 3 Explanation: The longest common subsequence is \u0026ldquo;ace\u0026rdquo; and its length is 3. Example 2:\nInput: text1 = \u0026ldquo;abc\u0026rdquo;, text2 = \u0026ldquo;abc\u0026rdquo; Output: 3 Explanation: The longest common subsequence is \u0026ldquo;abc\u0026rdquo; and its length is 3. Example 3:\nInput: text1 = \u0026ldquo;abc\u0026rdquo;, text2 = \u0026ldquo;def\u0026rdquo; Output: 0 Explanation: There is no such common subsequence, so the result is 0. Constraints:\n1 \u0026lt;= text1.length, text2.length \u0026lt;= 1000 text1 and text2 consist of only lowercase English characters. 二、分析 雙序列型的動態規劃問題。或我習慣稱作 LCS 型。 定義 dp[i][j] 為 s[1:i] 與 t[1:j] 的 LCS 長度。 利用s[i]與t[j]，使dp[i][j]與dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1] 產生關聯。 遍歷兩層迴圈，核心以從 s[i] 和 t[j] 的關係作破口，對 dp[i][j] 作轉移。 s[i] == t[j] 時，dp[i][j] = dp[i-1][j-1]。 相反則，dp[i][j] = max(dp[i-1], dp[j-1]。 最後解為 dp[m][n]，m 為 s 的長度，n 為 t 的長度。 三、解題 1. DP Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(m\\times n)\\) int longestCommonSubsequence(string text1, string text2) { int m = text1.length(), n = text2.length(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m+1, vector\u0026lt;int\u0026gt;(n+1, 0)); for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } return dp[m][n]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1143/","summary":"1143. Longest Common Subsequence\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String、Dynamic Programming 一、題目 Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nFor example, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot;.","title":"[LeetCode] 1143. Longest Common Subsequence"},{"content":"300. Longest Increasing Subsequence\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Binary Search、Dynamic Programming 一、題目 Given an integer array nums, return the length of the longest strictly increasing subsequence\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Example 2:\nInput: nums = [0,1,0,3,2,3] Output: 4 Example 3:\nInput: nums = [7,7,7,7,7,7,7] Output: 1 Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 2500 -104 \u0026lt;= nums[i] \u0026lt;= 104 Follow up: Can you come up with an algorithm that runs in O(n log n) time complexity\n二、分析 不定序列型的動態規劃問題。或我習慣稱作 LIS 型或俄羅斯娃娃型 定義 dp[i]：第 i 個元素的最長遞增子序列為多少。 故只要從第 i 個元素往前找到比 nums[i] 還大，同時又擁有最長遞增子序列的元素，再加 1 即可。 dp[i] = max(dp[i], dp[j] + 1) 最終的結果是 max({dp[i]})。 三、解題 1. DP Time complexity: \\(O(n^2)\\) Space complexity: \\(O(n)\\) int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; dp(n, 1); int res = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { if (nums[i] \u0026gt; nums[j]) { dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); } } } return res; } 2. DP + Binary Search Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; dp(n, INT_MAX); // dp[n] 裝的是實際排出來的數字，沒排到的位置以 INT_MAX 填滿，以使用 binary search int res = 0; for (int i = 0; i \u0026lt; n; i++) { auto it = lower_bound(dp.begin(), dp.end(), nums[i]); *it = min(*it, nums[i]); // 用 greedy 的想法，同樣位子上，數字愈小，愈有可能形成最長遞增子序列 res = max(res, (int)(it - dp.begin())+1); } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/300/","summary":"300. Longest Increasing Subsequence\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Binary Search、Dynamic Programming 一、題目 Given an integer array nums, return the length of the longest strictly increasing subsequence\nExample 1:\nInput: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Example 2:\nInput: nums = [0,1,0,3,2,3] Output: 4 Example 3:\nInput: nums = [7,7,7,7,7,7,7] Output: 1 Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 2500 -104 \u0026lt;= nums[i] \u0026lt;= 104 Follow up: Can you come up with an algorithm that runs in O(n log n) time complexity","title":"[LeetCode] 300. Longest Increasing Subsequence"},{"content":"2468. Split Message Based on Limit\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: String、Binary Search \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 You are given a string, message, and a positive integer, limit.\nYou must split message into one or more parts based on limit. Each resulting part should have the suffix \u0026quot;\u0026lt;a/b\u0026gt;\u0026quot;, where \u0026quot;b\u0026quot; is to be replaced with the total number of parts and \u0026quot;a\u0026quot; is to be replaced with the index of the part, starting from 1 and going up to b. Additionally, the length of each resulting part (including its suffix) should be equal to limit, except for the last part whose length can be at most limit.\nThe resulting parts should be formed such that when their suffixes are removed and they are all concatenated in order, they should be equal to message. Also, the result should contain as few parts as possible.\nReturn the parts message would be split into as an array of strings. If it is impossible to split message as required, return an empty array.\nExample 1:\ninput: message = \u0026ldquo;this is really a very awesome message\u0026rdquo;, limit = 9 Output: [\u0026ldquo;thi\u0026lt;1/14\u0026gt;\u0026rdquo;,\u0026ldquo;s i\u0026lt;2/14\u0026gt;\u0026rdquo;,\u0026ldquo;s r\u0026lt;3/14\u0026gt;\u0026rdquo;,\u0026ldquo;eal\u0026lt;4/14\u0026gt;\u0026rdquo;,\u0026ldquo;ly \u0026lt;5/14\u0026gt;\u0026rdquo;,\u0026ldquo;a v\u0026lt;6/14\u0026gt;\u0026rdquo;,\u0026ldquo;ery\u0026lt;7/14\u0026gt;\u0026rdquo;,\u0026quot; aw\u0026lt;8/14\u0026gt;\u0026quot;,\u0026ldquo;eso\u0026lt;9/14\u0026gt;\u0026rdquo;,\u0026ldquo;me\u0026lt;10/14\u0026gt;\u0026rdquo;,\u0026quot; m\u0026lt;11/14\u0026gt;\u0026quot;,\u0026ldquo;es\u0026lt;12/14\u0026gt;\u0026rdquo;,\u0026ldquo;sa\u0026lt;13/14\u0026gt;\u0026rdquo;,\u0026ldquo;ge\u0026lt;14/14\u0026gt;\u0026rdquo;] Explanation:\nThe first 9 parts take 3 characters each from the beginning of message.\nThe next 5 parts take 2 characters each to finish splitting message.\nIn this example, each part, including the last, has length 9.\nIt can be shown it is not possible to split message into less than 14 parts. Example 2:\nInput: message = \u0026ldquo;short message\u0026rdquo;, limit = 15 Output: [\u0026ldquo;short mess\u0026lt;1/2\u0026gt;\u0026rdquo;,\u0026ldquo;age\u0026lt;2/2\u0026gt;\u0026rdquo;] Explanation:\nUnder the given constraints, the string can be split into two parts: The first part comprises of the first 10 characters, and has a length 15. The next part comprises of the last 3 characters, and has a length 8. Constraints:\n1 \u0026lt;= message.length \u0026lt;= 10^4 message consists only of lowercase English letters and ' '. 1 \u0026lt;= limit \u0026lt;= 10^4 二、分析 令 n 為最後答案 vector 的總數，注意並非 n 愈大，能裝載的 string 就愈多。 limit * n \u0026gt;= f(n) + len 時，message 可以被裝載，其中 len 為其長度，f(n)為 n 時所需額外的字元長度。 觀察可得 f(n) 為： n \u0026lt; 10 時，5*n。 n \u0026lt; 100 時，7*n - 9。 n \u0026lt; 1000 時，9*n - 9 - 99。 n \u0026lt; 10000 時，11*n - 9 - 99 - 999。 \u0026hellip; 三、解題 1. Math Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) vector\u0026lt;string\u0026gt; splitMessage(string message, int limit) { if (limit \u0026lt;= 5) return {}; int len = message.length(); int left = 1; for ( ;left \u0026lt; len; left++) { if (limit * left \u0026gt;= f(left) + len) break; } if (limit * left \u0026lt; f(left) + len) return {}; vector\u0026lt;string\u0026gt; res(left); int strlen = to_string(left).length() + 3; int acc = 0; for (int i = 1; i \u0026lt;= left; i++) { len = strlen + to_string(i).length(); res[i-1] = message.substr(acc, limit-len) + \u0026#34;\u0026lt;\u0026#34; + to_string(i) + \u0026#34;/\u0026#34; + to_string(left) + \u0026#34;\u0026gt;\u0026#34;; acc += limit-len; } return res; } int f(int n) { if (n \u0026lt; 10) { return n*5; } else if (n \u0026lt; 100) { return n*7-9; } else if (n \u0026lt; 1000) { return n*9-108; } else if (n \u0026lt; 10000) { return n*11-1107; } return n*13-11106; } 2. Binary Search Time complexity: \\(O(\\log n)\\) Space complexity: \\(O(n)\\) vector\u0026lt;string\u0026gt; splitMessage(string message, int limit) { int b = 0 , cnt = 0 , sm = 0; vector\u0026lt;string\u0026gt; ans; for(int i=1; i\u0026lt;=10000; i++) { sm+=Size(i); // sum of length of (\u0026#39;1\u0026#39;) + (\u0026#39;2\u0026#39;)... (\u0026#39;i\u0026#39;) , we are calculating sum of length of all a\u0026#39;s. int cnt = ((3 + Size(i)) * i) + message.size() + sm; // sum of (3 is \u0026#34;\u0026lt;/\u0026gt;\u0026#34; + i\u0026#39;s size ) * i times , message , sm int len = (i-1) * limit; // till second last if(cnt - len \u0026lt;= limit) { // if last is bigger than limit , its invalid! b = i; break; } } string s = \u0026#34;\u0026#34;; cnt = 1; for(int i=0; i\u0026lt;message.size(); i++) { if(limit - (3 + Size(cnt) + Size(b) + (int)s.size())\u0026gt;0) { s+=message[i]; }else { string word = s + \u0026#34;\u0026lt;\u0026#34; + to_string(cnt) + \u0026#34;/\u0026#34; + to_string(b) + \u0026#34;\u0026gt;\u0026#34;; ans.push_back(word); s = message[i]; cnt++; } } string word = s + \u0026#34;\u0026lt;\u0026#34; + to_string(cnt) + \u0026#34;/\u0026#34; + to_string(b) + \u0026#34;\u0026gt;\u0026#34;; ans.push_back(word); if(cnt\u0026gt;b || word.size()\u0026gt;limit) return {}; // cnt is last value of a which should never be \u0026gt; than b , also last word size should be \u0026lt;= limit! return ans; } int Size(int n) { return to_string(n).size(); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2468/","summary":"2468. Split Message Based on Limit\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: String、Binary Search \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 You are given a string, message, and a positive integer, limit.\nYou must split message into one or more parts based on limit. Each resulting part should have the suffix \u0026quot;\u0026lt;a/b\u0026gt;\u0026quot;, where \u0026quot;b\u0026quot; is to be replaced with the total number of parts and \u0026quot;a\u0026quot; is to be replaced with the index of the part, starting from 1 and going up to b.","title":"[LeetCode] 2468. Split Message Based on Limit"},{"content":"2467. Most Profitable Path in a Tree\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Tree、Depth-First Search、Breadth-First Search、Graph \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:\nthe price needed to open the gate at node i, if amount[i] is negative, or, the cash reward obtained on opening the gate at node i, otherwise. The game goes on as follows: Initially, Alice is at node 0 and Bob is at node bob. At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0. For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that: If the gate is already open, no price will be required, nor will there be any cash reward. If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each. If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other. Return the maximum net income Alice can have if she travels towards the optimal leaf node. Example 1:\nInput: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6] Output: 6 Explanation:\nThe above diagram represents the given tree. The game goes as follows: Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\nAlice\u0026rsquo;s net income is now -2. Both Alice and Bob move to node 1.\nSince they reach here simultaneously, they open the gate together and share the reward.\nAlice\u0026rsquo;s net income becomes -2 + (4 / 2) = 0. Alice moves on to node 3. Since Bob already opened its gate, Alice\u0026rsquo;s income remains unchanged.\nBob moves on to node 0, and stops moving. Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\nNow, neither Alice nor Bob can make any further moves, and the game ends.\nIt is not possible for Alice to get a higher net income. Example 2:\nInput: edges = [[0,1]], bob = 1, amount = [-7280,2350] Output: -7280 Explanation:\nAlice follows the path 0-\u0026gt;1 whereas Bob follows the path 1-\u0026gt;0.\nThus, Alice opens the gate at node 0 only. Hence, her net income is -7280. Constraints:\n2 \u0026lt;= n \u0026lt;= 10^5 edges.length == n - 1 edges[i].length == 2 0 \u0026lt;= ai, bi \u0026lt; n ai != bi edges represents a valid tree. 1 \u0026lt;= bob \u0026lt; n amount.length == n amount[i] is an even integer in the range [-10^4, 10^4]. 二、分析 先將 graph 建起來。 用 dfs 遍歷所有節點，並回傳 {gain, collide}。 三、解題 1. DFS Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int mostProfitablePath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int bob, vector\u0026lt;int\u0026gt;\u0026amp; amount) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(amount.size()); for (const auto\u0026amp; edge : edges) { graph[edge[0]].push_back(edge[1]); graph[edge[1]].push_back(edge[0]); } vector\u0026lt;bool\u0026gt; vis(amount.size(), false); return dfs(graph, 0, bob, amount, vis, 1)[0]; } vector\u0026lt;int\u0026gt; dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; graph, int alice, int bob, vector\u0026lt;int\u0026gt;\u0026amp; amount, vector\u0026lt;bool\u0026gt;\u0026amp; vis, int round) { int res = INT_MIN; vis[alice] = true; int collide = alice == bob ? 1 : 0; for (int\u0026amp; next : graph[alice]) { if (vis[next]) continue; vector\u0026lt;int\u0026gt; tmp = dfs(graph, next, bob, amount, vis, round+1); if (tmp[1] \u0026gt; 0) collide = tmp[1] + 1; res = max(res, tmp[0]); } if (collide \u0026gt; 0 \u0026amp;\u0026amp; collide \u0026lt;= round) { if (collide == round) amount[alice] \u0026gt;\u0026gt;= 1; else amount[alice] = 0; } return {res == INT_MIN ? amount[alice] : amount[alice] + res, collide}; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2467/","summary":"2467. Most Profitable Path in a Tree\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Tree、Depth-First Search、Breadth-First Search、Graph \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. At every node i, there is a gate.","title":"[LeetCode] 2467. Most Profitable Path in a Tree"},{"content":"1926. Nearest Exit from Entrance in Maze\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.\nIn one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.\nReturn the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.\nExample 1:\nInput: maze = [[\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;+\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;+\u0026quot;],[\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;.\u0026quot;]], entrance = [1,2] Output: 1 Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].\nInitially, you are at the entrance cell [1,2]. You can reach [1,0] by moving 2 steps left. You can reach [0,2] by moving 1 step up.\nIt is impossible to reach [2,3] from the entrance.\nThus, the nearest exit is [0,2], which is 1 step away. Example 2:\nInput: maze = [[\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;],[\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;]], entrance = [1,0] Output: 2 Explanation: There is 1 exit in this maze at [1,2].\n[1,0] does not count as an exit since it is the entrance cell.\nInitially, you are at the entrance cell [1,0]. You can reach [1,2] by moving 2 steps right.\nThus, the nearest exit is [1,2], which is 2 steps away. Example 3:\nInput: maze = [[\u0026quot;.\u0026quot;,\u0026quot;+\u0026quot;]], entrance = [0,0] Output: -1 Explanation: There are no exits in this maze. Constraints:\nmaze.length == m maze[i].length == n 1 \u0026lt;= m, n \u0026lt;= 100 maze[i][j] is either '.' or '+'. entrance.length == 2 0 \u0026lt;= entrancerow \u0026lt; m 0 \u0026lt;= entrancecol \u0026lt; n entrance will always be an empty cell. 二、分析 經典的 bfs 題型，套用框架： queue\u0026lt;Point\u0026gt; q; int step = 0; while (!q.empty()) { int sz = q.size() while (sz--) { auto curr = q.front(); q.pop(); if (isEnd) return step; for (options) { if (!excludedOptions) continue; q.push(option); visited.insert(option); } } cnt++; } 注意記錄拜訪的時間點，若是在 q.pop() 時才記錄拜訪，有可以造成大量重複的點進入到佇列中，故必須在 q.push() 時就記錄拜訪。 需要排除起始點，故需要排除 cnt == 1。 三、解題 1. BFS Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(1)\\) int dirc[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; int nearestExit(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; maze, vector\u0026lt;int\u0026gt;\u0026amp; e) { int m = maze.size(), n = maze[0].size(); queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; q; q.push({e[0], e[1]}); maze[e[0]][e[1]] = \u0026#39;+\u0026#39;; int cnt = 0; while (!q.empty()) { int sz = q.size(); while (sz--){ auto curr = q.front(); q.pop(); if (cnt \u0026gt; 0 \u0026amp;\u0026amp; (curr.first == 0 || curr.first == m-1 || curr.second == 0 || curr.second == n-1)) return cnt; for (auto d : dirc) { int row = curr.first + d[0]; int col = curr.second + d[1]; if (row \u0026lt; 0 || row \u0026gt;= m || col \u0026lt; 0 || col \u0026gt;= n || maze[row][col] != \u0026#39;.\u0026#39;) continue; q.push({row, col}); maze[row][col] = \u0026#39;+\u0026#39;; } } cnt++; } return -1; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1926/","summary":"1926. Nearest Exit from Entrance in Maze\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.\nIn one step, you can move one cell up, down, left, or right.","title":"[LeetCode] 1926. Nearest Exit from Entrance in Maze"},{"content":"279. Perfect Squares\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Math、Dynamic Programming、Breadth-First Search 一、題目 Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\nExample 1:\nInput: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4 Example 2:\nInput: n = 13 Output: 2 Explanation: 13 = 4 + 9 Constraints:\n1 \u0026lt;= n \u0026lt;= 10^4 二、分析 動態規劃，令 dp[i] 為 n = i 時，由最少個 perfect squares 所組合成和為 i 的個數。 當 n 為平方數時，dp[n] = 1。 其餘則 `dp[n] = min(dp[n-i]+1, dp[i]); dp[1] = 1，因為 1 為平方數 dp[2] = 2 dp[3] = 3 dp[4] = 1，因為 4 為平方數 dp[5] = 2，min(dp[4]+1, dp[1]+1) dp[6] = 3，min(dp[5]+1, dp[2]+1) dp[7] = 4，min(dp[6]+1, dp[3]+1) dp[8] = 2，min(dp[7]+1, dp[4]+1) dp[12] = 3, min(dp[12-1]+1, dp[12-4]+1, dp[12-9]+1) 三、解題 1. DP Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int numSquares(int n) { vector\u0026lt;int\u0026gt; dp(n+1, INT_MAX); vector\u0026lt;int\u0026gt; sel; for (int i = 1; i \u0026lt;= n; i++) { int x = sqrt(i); if (x*x == i) { // 平方數時，增加選擇 dp[i] = 1; sel.push_back(i); } else { for (int s : sel) { // 動態規劃轉移方程 dp[i] = min(dp[i-s]+1, dp[i]); } } } return dp[n]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/279/","summary":"279. Perfect Squares\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Math、Dynamic Programming、Breadth-First Search 一、題目 Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\nExample 1:","title":"[LeetCode] 279. Perfect Squares"},{"content":"337. House Robber III\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Dynamic Programming、Tree、Depth-First Search、Binary Tree 一、題目 The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\nExample 1:\nInput: root = [3,2,3,null,3,null,1] Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2:\nInput: root = [3,4,5,1,3,null,1] Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Constraints:\nThe number of nodes in the tree is in the range [1, 10^4]. 0 \u0026lt;= Node.val \u0026lt;= 10^4 二、分析 遵循第 i 間房若搶，則前一間房必定不能搶；第 i 間房若不搶，前一間房可搶可不搶： 用一個 pair 來記錄每個節點搶與不搶的結果，最後再將兩者做比較。 dp[i][0] = max(dp[i-1][1], dp[i-1][0]) dp[i][1] = dp[i-1][0] + val[i] 改寫成： int pass = max(left.first, left.second) + max(right.first, right.second) int rob = root-\u0026gt;val + left.second + right.second 三、解題 1. DP Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int rob(TreeNode* root) { pair\u0026lt;int,int\u0026gt; res = helper(root); // {搶, 不搶} return max(res.first); } pair\u0026lt;int,int\u0026gt; helper(TreeNode* root) { if (!root) return {0, 0}; pair\u0026lt;int,int\u0026gt; left = helper(root-\u0026gt;left); pair\u0026lt;int,int\u0026gt; right = helper(root-right); return {root-\u0026gt;val + left.second + right.second, max(left.first, left.second) + max(right.first, right.second)}; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/337/","summary":"337. House Robber III\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Dynamic Programming、Tree、Depth-First Search、Binary Tree 一、題目 The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.","title":"[LeetCode] 337. House Robber III"},{"content":"587. Erect the Rence\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Math、Geometry 一、題目 You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden. You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Return the coordinates of trees that are exactly located on the fence perimeter.\nExample 1:\nInput: points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]] Output: [[1,1],[2,0],[3,3],[2,4],[4,2]] Example 2:\nInput: [[1,2],[2,2],[4,2]] Output: [[4,2],[2,2],[1,2]] Constraints:\n1 \u0026lt;= points.length \u0026lt;= 3000 points[i].length == 2 0 \u0026lt;= xi, yi \u0026lt;= 100 All the given points are unique. 二、分析 這題的關鍵在於當一個點已經是最外圍的點時，其相鄰的 fence 會是與之斜率最大與最小的兩點。 可將數組排序後利於解題。 由左到右找斜率大的，可得到上半部的外圍線；由右到左可得到下半部的外圍線。 三、解題 1. Math Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) bool biggerSlope(vector\u0026lt;int\u0026gt;\u0026amp; a, vector\u0026lt;int\u0026gt;\u0026amp; b, vector\u0026lt;int\u0026gt;\u0026amp; c) { // slope of ab compares with slope of ac return (b[1]-a[1])*(c[0]-a[0]) \u0026lt; (b[0]-a[0])*(c[1]-a[1]); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; outerTrees(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; trees) { int n = trees.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(trees.begin(), trees.end()); for (int i = 0; i \u0026lt; n; i++) { while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; biggerSlope(res[res.size()-2], res.back(), trees[i])) res.pop_back(); res.push_back(trees[i]); } if (res.size() == n) return res; for (int i = n-2; i \u0026gt;= 0; i--) { while (res.size() \u0026gt; 1 \u0026amp;\u0026amp; biggerSlope(res[res.size()-2], res.back(), trees[i])) res.pop_back(); res.push_back(trees[i]); } res.pop_back(); return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/587/","summary":"587. Erect the Rence\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Math、Geometry 一、題目 You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden. You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Return the coordinates of trees that are exactly located on the fence perimeter.","title":"[LeetCode] 587. Erect the Fence"},{"content":"322. Coin Change\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming、Breadth-First Search 一、題目 You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.\nExample 1:\nInput: coins = [1,2,5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2:\nInput: coins = [2], amount = 3 Output: -1 Example 3:\nInput: coins = [1], amount = 0 Output: 0 Constraints:\n1 \u0026lt;= coins \u0026lt;= 12 1 \u0026lt;= coins[i] \u0026lt;= 2^31 - 1 0 \u0026lt;= amount \u0026lt;= 10^4 二、分析 這一題動態規劃是不定序列型框架的題型： 令 dp[n] 為組成 n 有幾種可能性。 dp[n] = sum(dp[n-nums[i]]) 以題目 coins = [1,2,5] 為例， dp[11] 可以為 dp[11-1] + dp[11-2] + dp[11-5]。 三、解題 1. Dynamic Programming Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int coinChange(vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { vector\u0026lt;int\u0026gt; dp(amount+1, 20000); dp[0] = 0; for (int i = 0; i \u0026lt; coins.size(); i++){ for (int j = coins[i]; j \u0026lt;= amount; j++){ dp[j] = min(dp[j], dp[j-coins[i]] + 1); } } return dp[amount] \u0026gt;= 20000 ? -1 : dp[amount]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/322/","summary":"322. Coin Change\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming、Breadth-First Search 一、題目 You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.","title":"[LeetCode] 322. Coin Change"},{"content":"2466. Count Ways To Build Good Strings\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Dynamic Programming \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\nAppend the character '0' zero times. Append the character '1' one times. This can be performed any number of times. A good string is a string constructed by the above process having a length between low and high (inclusive). Return the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 10^9 + 7. Example 1:\nInput: low = 3, high = 3, zero = 1, one = 1 Output: 8 Explanation: One possible valid good string is \u0026ldquo;011\u0026rdquo;.\nIt can be constructed as follows: \u0026quot;\u0026quot; -\u0026gt; \u0026ldquo;0\u0026rdquo; -\u0026gt; \u0026ldquo;01\u0026rdquo; -\u0026gt; \u0026ldquo;011\u0026rdquo;.\nAll binary strings from \u0026ldquo;000\u0026rdquo; to \u0026ldquo;111\u0026rdquo; are good strings in this example. Example 2:\nInput: low = 2, high = 3, zero = 1, one = 2 Output: 5 Explanation: The good strings are \u0026ldquo;00\u0026rdquo;, \u0026ldquo;11\u0026rdquo;, \u0026ldquo;000\u0026rdquo;, \u0026ldquo;110\u0026rdquo;, and \u0026ldquo;011\u0026rdquo;. Constraints:\n1 \u0026lt;= low \u0026lt;= high \u0026lt;= 10^5 1 \u0026lt;= zero, one \u0026lt;= low 二、分析 這一題與 322. Coin Change 有異曲同工之妙。 這一題動態規劃是不定序列型框架的題型： dp[n] 設為組成長度為 n 的 string 的可能性，最後再將符合題目需求的 dp[low] 到 dp[high] 加起來。 dp[n] = sum(dp[n-nums[i]])。 三、解題 1. DP Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int countGoodStrings(int low, int high, int zero, int one) { vector\u0026lt;int\u0026gt; dp(high+1, 0); int res = 0; dp[0] = 1; int start = min(zero, one); for (int i = start; i \u0026lt;= high; i++) { if (i-zero \u0026gt;= 0) dp[i] = (dp[i] + dp[i-zero]) % modulo; if (i-one \u0026gt;= 0) dp[i] = (dp[i] + dp[i-one]) % modulo; if (i \u0026gt;= low) res = (res + dp[i]) % modulo; } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2466/","summary":"2466. Count Ways To Build Good Strings\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Dynamic Programming \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\nAppend the character '0' zero times. Append the character '1' one times. This can be performed any number of times. A good string is a string constructed by the above process having a length between low and high (inclusive).","title":"[LeetCode] 2466. Count Ways To Build Good Strings"},{"content":"2465. Number of Distinct Averages\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Hash Table、Two Pointers、Sorting \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 You are given a 0-indexed integer array nums of even length. As long as nums is not empty, you must repetitively:\nFind the minimum number in nums and remove it. Find the maximum number in nums and remove it. Calculate the average of the two removed numbers. The average of two numbers a and b is (a + b) / 2. For example, the average of 2 and 3 is (2 + 3) / 2 = 2.5. Return the number of distinct averages calculated using the above process. Note that when there is a tie for a minimum or maximum number, any can be removed. Example 1:\nInput: nums = [4,1,4,0,3,5] Output: 2 Explanation: Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3]. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3]. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.\nSince there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2. Example 2:\nInput: nums = [1,100] Output: 1 Explanation: There is only one average to be calculated after removing 1 and 100, so we return 1. Constraints:\n2 \u0026lt;= nums.length \u0026lt;= 100 nums.length is even. 0 \u0026lt;= nums[i] \u0026lt;= 100 二、分析 每次取陣列中的最大值與最小值平均，再求有多少個相異的平均值。 可以先用 sort 將陣列排序後，每次取頭尾做平均，再用 unordered_set 記錄。 三、解題 1. sort Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) int distinctAverages(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()); unordered_set\u0026lt;double\u0026gt; set; int n = nums.size(); for (int i = 0; i \u0026lt; n/2; i++) { set.insert((nums[i] + nums[n-1-i])/2.0); } return set.size(); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2465/","summary":"2465. Number of Distinct Averages\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Hash Table、Two Pointers、Sorting \\(\\color{blue}\\textsf{Biweekly Contest 91}\\) 一、題目 You are given a 0-indexed integer array nums of even length. As long as nums is not empty, you must repetitively:\nFind the minimum number in nums and remove it. Find the maximum number in nums and remove it. Calculate the average of the two removed numbers. The average of two numbers a and b is (a + b) / 2.","title":"[LeetCode] 2465. Number of Distinct Averages"},{"content":"223. Rectangle Area\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Math、Geometry 一、題目 Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles. The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2). The second rectangle is defined by its bottom-left corner (bx1, by1) and tis top-right corner (bx2, by2).\nExample 1:\nInput: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2 Output: 45 Example 2:\nInput: ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2 Output: 16 Constraints:\n-10^4 \u0026lt;= ax1 \u0026lt;= ax2 \u0026lt;= 10^4 -10^4 \u0026lt;= ay1 \u0026lt;= ay2 \u0026lt;= 10^4 -10^4 \u0026lt;= bx1 \u0026lt;= bx2 \u0026lt;= 10^4 -10^4 \u0026lt;= by1 \u0026lt;= by2 \u0026lt;= 10^4 二、分析 矩形的面積為長寬相加，所以以題目所示，單個矩形的面積為 (x2-x1)*(y2-y1)，但此題需考慮到重疊的情形發生，需將重疊的部分額外扣掉。 兩個矩形重疊的小矩形的 bottom-left corner 為 (max(ax1,bx1),max(ay1,by1))，top-right corner 為 (min(ax2,bx2),min(ay2,by2))。 但注意到當下列情形發生的時候，兩個矩形不發生重疊：cx1 \u0026gt;= cx2 || cy1 \u0026gt;= cy2。 為方便計算，將矩形寫成一個物件。 struct Rect { int x1,x2,y1,y2; }; 三、解題 1. Math Time complexity: \\(O(1)\\) Space complexity: \\(O(1)\\) struct Rect { int x1,y1,x2,y2; Rect(int x1_, int y1_, int x2_, int y2_):x1(x1_),y1(y1_),x2(x2_),y2(y2_) {} int area() { return (x1 \u0026gt;= x2 || y1 \u0026gt;= y2) ? 0 : (x2 - x1) * (y2 - y1); // 不重疊則回傳面積 0 } }; class Solution { public: int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) { Rect a(ax1,ay1,ax2,ay2); Rect b(bx1,by1,bx2,by2); Rect c(max(ax1,bx1), max(ay1,by1), min(ax2,bx2), min(ay2,by2)); return a.area() + b.area() - c.area(); } }; 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/223/","summary":"223. Rectangle Area\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Math、Geometry 一、題目 Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles. The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2). The second rectangle is defined by its bottom-left corner (bx1, by1) and tis top-right corner (bx2, by2).\nExample 1:\nInput: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2 Output: 45 Example 2:","title":"[LeetCode] 223. Rectangle Area"},{"content":"374. Guess Number Higher or Lower\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Binary Search、Interactive 一、題目 We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results:\n-1: Your guess is higher than the number I picked (i.e. num \u0026gt; pick). 1: Your guess is lower than the number I picked (i.e. num \u0026lt; pick). 0: your guess is equal to the number I picked (i.e. num == pick). Return the number that I picked. Example 1:\nInput: n = 10, pick = 6 Output: 6 Example 2:\nInput: n = 1, pick = 1 Output: 1 Example 3:\nInput: n = 2, pick 1 Output: 1 Constraints:\n1 \u0026lt;= n \u0026lt;= 23^1 - 1 1 \u0026lt;= pick \u0026lt;= n 二、分析 簡單的 Binary Search 問題，題目有提供 API，所以我們只需針對 API 傳回的結果就相對應的事情。 Binary Search 的框架 bool BinarySearch(int x, int lo, int hi) { while (lo \u0026lt;= hi) { int mid = lo + (hi - lo)/2; if (API(mid) == 0) { return true; } else if (API(mid) \u0026gt; 0) { // 往左收斂 right = mid-1; } else if (API(mid) \u0026lt; 0) { // 往右收斂 left = mid+1; } return false } } 三、解題 1. Binary Search Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(`)\\) int guessNumber(int n) { int left = 1, right = n; while(left \u0026lt;= right) { int mid = left + (right - left)/2; if (guess(mid) == 0) { return mid; } else if (guess(mid) \u0026lt; 0) { right = mid-1; } else { left = mid + 1; } } return -1; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/374/","summary":"374. Guess Number Higher or Lower\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Binary Search、Interactive 一、題目 We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results:","title":"[LeetCode] 374. Guess Number Higher or Lower"},{"content":"213. House Robber II\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming 一、題目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2:\nInput: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4. Example 3:\nInput: nums = [1,2,3] Output: 3 Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 1000 二、分析 時間序列型的動態規劃問題。 定義 dp[i][j]：第 i 間房子，j == 0 代表不搶，j == 1 代表搶。 第 i 間房若搶，則前一間房必定不能搶；第 i 間房若不搶，前一間房可搶可不搶： dp[i][0] = max(dp[i-1][1], dp[i-1][0]) dp[i][1] = dp[i-1][0] + val[i] 最終的結果是 max(dp[n-1][0], dp[n-1][1])。 多了一個條件是，房子的首尾相連。所以額外增加的條件多了一個限制為： 第一間若搶了，則最後一間必不能搶。 第一間若沒搶，則最後一間可搶可不搶。 故相當於比較 第1間到第n-1間的最大值或第2間到第n間的最大值。 max(rob(nums, 0, n-1), rob(nums, 1, n)) 三、解題 1. Dynamic Programming Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums, int lo, int hi) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(hi, vector\u0026lt;int\u0026gt;(2, 0)); dp[lo][1] = nums[lo]; for (int i = lo+1; i \u0026lt; hi; i++) { dp[i][0] = max(dp[i-1][1], dp[i-1][0]); dp[i][1] = dp[i-1][0] + nums[i]; } return max(dp[hi-1][0], dp[hi-1][1]); } int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n \u0026lt;= 3) return *max_element(nums.begin(), nums.end()); return max(rob(nums, 0, n-1), rob(nums, 1, n)); } 2. Dynamic Programming(SC optimized) Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums, int lo, int hi) { int robbed = nums[lo]; int passed = 0; for (int i = lo+1; i \u0026lt; hi; i++) { int tmp = robbed; robbed = passed + nums[i]; passed = max(tmp, passed); } return max(robbed, passed); } int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n \u0026lt;= 3) return *max_element(nums.begin(), nums.end()); return max(rob(nums, 0, n-1), rob(nums, 1, n)); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/213/","summary":"213. House Robber II\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming 一、題目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.","title":"[LeetCode] 213. House Robber II"},{"content":"198. House Robber\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming 一、題目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nInput: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2:\nInput: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 400 二、分析 時間序列型的動態規劃問題。 定義 dp[i][j]：第 i 間房子，j == 0 代表不搶，j == 1 代表搶。 第 i 間房若搶，則前一間房必定不能搶；第 i 間房若不搶，前一間房可搶可不搶： dp[i][0] = max(dp[i-1][1], dp[i-1][0]) dp[i][1] = dp[i-1][0] + val[i] 最終的結果是 max(dp[n-1][0], dp[n-1][1])。 三、解題 1. Dynamic Programming Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(2, 0)); dp[0][1] = nums[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = max(dp[i-1][1], dp[i-1][0]); dp[i][1] = dp[i-1][0] + nums[i]; } return max(dp[n-1][0], dp[n-1][1]); } 2. Dynamic Programming(SC optimized) Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int robbed = nums[0]; int passed = 0; for (int i = 1; i \u0026lt; n; i++) { int tmp = robbed; robbed = passed + nums[i]; passed = max(tmp, passed); } return max(robbed, passed); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/198/","summary":"198. House Robber\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming 一、題目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.","title":"[LeetCode] 198. House Robber"},{"content":"一、動態規劃的思考藝術 動態規劃其實就是一種暴力枚舉的優化，在暴力枚舉的過程中有著大量的重複，藉由「備忘錄(memoization)」的方式做到剪枝(pruning)來達到優化的一種演算法。 舉例來說： Leetcode 62. Unique Paths\n機器人由左上走到右下角星星有幾種走法，其中機器人只能選擇往右走或往下走。 試想機器人從 (1,1) 走到 (m,n) 的不同路徑中，可見有大量的重複，比如過程中有一點 (i,j)，其 (1,1) 走到 (i,j) 有 k 條不同路徑，麼那對於任何一條固定 (i,j) 到 (m,n) 的路徑，都需走 k 遍來模擬。 但其實我們不必關心具體的走法，我們只關心狀態，也就是走法的數目。 同理，我們若知道 (i,j) 到 (m,n) 共有 t 條不同的路徑，那麼 (1,1) -\u0026gt; (i,j) -\u0026gt; (m,n) 的不同路徑總數就是 k*s。 我們知道最左邊那欄與最上面那列都只有可能有一種路徑可以走，又每一格的路徑來自於上方與左方的和： sum of (i,j) = sum of (i-1,j) + sum of (i,j-1) \\(\\begin{array}{|c|c|c|c|c|c|c|}\\hline \\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\\\\\\hline \\text{1}\u0026amp;\\text{2}\u0026amp;\\text{3}\u0026amp;\\text{4}\u0026amp;\\text{5}\u0026amp;\\text{6}\u0026amp;\\text{7}\\\\\\hline \\text{1}\u0026amp;\\text{3}\u0026amp;\\text{6}\u0026amp;\\text{10}\u0026amp;\\text{15}\u0026amp;\\text{21}\u0026amp;\\text{28}\\\\\\hline \\end{array}\\) 寫成程式碼就是 int uniquePaths(int m, int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m+1, vector\u0026lt;int\u0026gt;(n+1,0)); for (int i = 1; i \u0026lt;= m; i++) // 將第一列填成 1 dp[i][1] = 1; for (int j = 1; j \u0026lt;= n; j++) // 將第一欄填成 1 dp[1][j] = 1; for (int i = 2; i \u0026lt;= m; i++) { // 將剩下的格子填完 for (int j = 2; j \u0026lt;= n; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m][n]; } 注意填格子的順序是有一定的限制的，必須要確保相關聯的子問題已經處理過。 動態規劃 由上例我們可以發現，原本的問題可以拆解成更小的問題(從 (1,1)-\u0026gt;(m,n) 變成從 (1,1)-\u0026gt;(i,j) 和從 (i,j)-\u0026gt;(m,n))。 我們令 f(i,j) 表示從 (1,1)-\u0026gt;(i,j) 的不同路徑數，則我們可以得到轉移方程式 f(i,j)=f(i-1,j)+f(i,j-1)。 我們發現，想求出 f(i,j) 只需要知道幾個更小的 f(i',j')。我們將 f(i',j') 稱為子問題。 我們捨棄冗餘的訊息(具體的走法)，只記錄對解決問題有幫助的結果。 動態規劃的兩大特點(適用前提) 無後效性 一旦 f(i,j) 確定，就不用關心我們如何計算出 f(i,j) 想要確定 f(i,j)，只需要知道 f(i-1,j) 和 f(i,j-1) 的值，而至於它們是如何算出來的，對當前或之後的任何子問題都沒有影響。 過去不依賴未來，未來不影響過去。 最優子結構 f(i,j) 的定義就已經蘊含了最優。 大問題的最優解可以由若干個小問題的最優解推出。(max, min, sum\u0026hellip;) DP 能適用於：能將大問題拆成若干小問題，滿足無後效性、最優子結構性質。 以下介紹幾種刷題會遇到的動態規劃套路： 二、動態規劃框架 1. 定序列型 給定一個陣列，其中一個元素可以認為一天，並且今天的狀態只取決於昨天的狀態。 框架： 定義 dp[i][j]：表示第 ith 輪的第 j 種狀態。 將 dp[i][j] 與前一輪的狀態 dp[i-1][j] 產生關聯。 最終的結果是 dp[n][j] 中的某種 aggression (sum, max, min, \u0026hellip;) 範例：[LeetCode] 198. House Robber 定義 dp[i][j]：第 i 間房子，j == 0 代表不搶，j == 1 代表搶。 第 i 間房若搶，則前一間房必定不能搶；第 i 間房若不搶，前一間房可搶可不搶： dp[i][0] = max(dp[i-1][1], dp[i-1][0]) dp[i][1] = dp[i-1][0] + val[i] 最終的結果是 max(dp[n-1][0], dp[n-1][1])。 例題： [LeetCode] 198. House Robber [LeetCode] 213. House Robber II [LeetCode] 337. House Robber III [LeetCode] 121. Best Time to Buy and Sell Stock [LeetCode] 122. Best Time to Buy and Sell Stock II [LeetCode] 123. Best Time to Buy and Sell Stock III [LeetCode] 188. Best Time to Buy and Sell Stock IV [LeetCode] 309. Best Time to Buy and Sell Stock with Cooldown [LeetCode] 714. Best Time to Buy and Sell Stock with Transcation Fee 2. 不定序列型(LIS) 給定一個陣列，其中一個元素可以認為一天，並且今天的狀態取決於過去某一天的狀態。 框架： 定義 dp[i]：表示第 ith 輪的狀態，一般這個狀態要求和元素 i 直接相關。 將 dp[i] 與之前的某一狀態 dp[i] 產生關聯。 最終的結果為 dp[i] 中的某一個。 範例：[LeetCode] 300. Longest Increasing Subsequence 定義 dp[i] 為 s[1:i] 中以 s[i] 為結尾的最長遞增子序列長度。 尋找最優的前驅狀態 j，將 dp[i] 與 dp[j] 產生關聯。 dp[i] = max(dp[i], dp[j] + 1) 尋找 dp[i] 中的最佳解。 res = max {dp[i]} 3. 雙序列型(LCS) 給定兩組序列，求兩組序列的某些特性。 框架： 定義 dp[i][j]：表示針對 s[1:i] 和 t[1:j] 的子問題求解。 將 dp[i][j] 與之前的某一狀態做關聯，如 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 最終的結果是 dp[m][n]。 範例：[LeetCode] 1143. Longest Common Subsequence 定義 dp[i][j] 為 s[1:i] 與 t[1:j] 的 LCS 長度。 利用s[i]與t[j]，使dp[i][j]與dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1] 產生關聯。 遍歷兩層迴圈，核心以從 s[i] 和 t[j] 的關係作破口，對 dp[i][j] 作轉移。 s[i] == t[j] 時，dp[i][j] = dp[i-1][j-1]。 相反則，dp[i][j] = max(dp[i-1], dp[j-1]。 最後解為 dp[m][n]，m 為 s 的長度，n 為 t 的長度。 4. 區間型 給定一個序列，明確要求分割成 K 個連續區間，要求計算這些區間的某個最優性質。 框架： 定義 dp[i][k] 表示針對 s[1:i] 分為 k 個區間，此時能夠得到最佳解。 搜尋最後一個區間的起始位置 j，將 dp[i][k] 分割成 dp[j-1][k-1] 和 s[j:i] 兩部分。 最終的結果是 dp[n][k]。 範例：[LeetCode] 1278. Palindrome Partitioning 定義 dp[i][j]：s[1:i] 和 t[1:j] 的最長相同子序列(LCS)。 5. 回文型(LPS) 給定一個序列，求一個針對這個序列的最佳解。 框架： 定義 dp[i][j]：表示針對 s[i:j] 的子問題求解。 將大區間的 dp[i][j] 往小區間的 dp[i'][j'] 轉移。 第一層循環是區間大小，第二層循環是起始點。 最終的結果是 dp[1][n]。 範例：[LeetCode] 516. Longest Palindrome Subsequence 6. 背包型 給定 n 件物品，每個物品可用可不用(或若干不同用法)，要求以某個有上限 C 的代價來實現最大收益。(或下限收益達成最小代價)。 框架： 定義 dp[i][c]：表示只從前 i 件物品的子集裡選擇、代價為 c 的最大收益。 將 dp[i][c] 往 dp[i-1][c'] 轉移，即考慮如何使用物品 i 對代價/收益的影響。 第一層循環是物品編號 i。 第二層循環是遍歷代價的所有可能值。 最終的結果是 max{dp[n][c_i]} 範例：[LeetCode] 494. Target Sum 三、狀態壓縮 方法1 如果轉移方程式很明顯可以省去使用空間，可利用將不需要的空間重複利用來達到狀態壓縮的效果。 如第 n 天的狀態只與前 1 天與前 2 天的狀態有關。那麼就可以將空間限縮到這三天的關係中。 例 dp[n] = dp[n-1] + dp[n-2]。 限縮成 day3 = day1 + day2 + day1 = day2, day2 = day3。 其中在二維動態規劃常用一個手法即是奇偶數交換的手法： 同樣以 Leetcode 62. Unique Paths為例：\n\\(\\begin{array}{|c|c|c|c|c|c|c|}\\hline \\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\\\\\\hline \\text{1}\u0026amp;\\text{2}\u0026amp;\\text{3}\u0026amp;\\text{4}\u0026amp;\\text{5}\u0026amp;\\text{6}\u0026amp;\\text{7}\\\\\\hline \\text{1}\u0026amp;\\text{3}\u0026amp;\\text{6}\u0026amp;\\text{10}\u0026amp;\\text{15}\u0026amp;\\text{21}\u0026amp;\\text{28}\\\\\\hline \\end{array}\\) 原先需要用到 m x n 即 21 個整數空間來實現動態規劃。 但事實上可以利用由上而下，由左而右的方向來填格子，來實現壓縮，最終到到 \\(O(\\text{min}(m,n))\\) 的效果。\n\\(\\begin{array}{|c|c|}\\hline \\text{1}\u0026amp;\\text{1}\\\\\\hline \\text{1}\u0026amp;\\text{2}\\\\\\hline \\text{1}\u0026amp;\\text{3}\\\\\\hline \\end{array}\\rightarrow\\begin{array}{|c|c|}\\hline \\text{1}\u0026amp;\\text{1}\\\\\\hline \\text{3}\u0026amp;\\text{2}\\\\\\hline \\text{6}\u0026amp;\\text{3}\\\\\\hline \\end{array}\\rightarrow\\begin{array}{|c|c|}\\hline \\text{1}\u0026amp;\\text{1}\\\\\\hline \\text{3}\u0026amp;\\text{4}\\\\\\hline \\text{6}\u0026amp;\\text{10}\\\\\\hline \\end{array}\\rightarrow\\begin{array}{|c|c|}\\hline \\text{1}\u0026amp;\\text{1}\\\\\\hline \\text{5}\u0026amp;\\text{4}\\\\\\hline \\text{15}\u0026amp;\\text{10}\\\\\\hline \\end{array}\\rightarrow\\begin{array}{|c|c|}\\hline \\text{1}\u0026amp;\\text{1}\\\\\\hline \\text{5}\u0026amp;\\text{6}\\\\\\hline \\text{15}\u0026amp;\\text{21}\\\\\\hline \\end{array}\\rightarrow\\begin{array}{|c|c|}\\hline \\text{1}\u0026amp;\\text{1}\\\\\\hline \\text{7}\u0026amp;\\text{6}\\\\\\hline \\text{28}\u0026amp;\\text{21}\\\\\\hline \\end{array}\\) 原本的狀態轉移方程式為：dp[m][n] = dp[m-1][n] + dp[m][n-1] 壓縮後的狀態轉移方程式寫成：dp[m%2][n] = dp[(m-1)%2][n] + dp[m%2][n-1] 方法2 如果所需的空間有限制，如在 30 個以內的 bool 值，可以將之轉換成 bit，利用位元運算來達到空間壓縮。 回到目錄：[Algo] 演算法筆記 ","permalink":"http://intervalrain.github.io/posts/cs/algo/dp/","summary":"一、動態規劃的思考藝術 動態規劃其實就是一種暴力枚舉的優化，在暴力枚舉的過程中有著大量的重複，藉由「備忘錄(memoization)」的方式做到剪枝(pruning)來達到優化的一種演算法。 舉例來說： Leetcode 62. Unique Paths\n機器人由左上走到右下角星星有幾種走法，其中機器人只能選擇往右走或往下走。 試想機器人從 (1,1) 走到 (m,n) 的不同路徑中，可見有大量的重複，比如過程中有一點 (i,j)，其 (1,1) 走到 (i,j) 有 k 條不同路徑，麼那對於任何一條固定 (i,j) 到 (m,n) 的路徑，都需走 k 遍來模擬。 但其實我們不必關心具體的走法，我們只關心狀態，也就是走法的數目。 同理，我們若知道 (i,j) 到 (m,n) 共有 t 條不同的路徑，那麼 (1,1) -\u0026gt; (i,j) -\u0026gt; (m,n) 的不同路徑總數就是 k*s。 我們知道最左邊那欄與最上面那列都只有可能有一種路徑可以走，又每一格的路徑來自於上方與左方的和： sum of (i,j) = sum of (i-1,j) + sum of (i,j-1) \\(\\begin{array}{|c|c|c|c|c|c|c|}\\hline \\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{1}\\\\\\hline \\text{1}\u0026amp;\\text{2}\u0026amp;\\text{3}\u0026amp;\\text{4}\u0026amp;\\text{5}\u0026amp;\\text{6}\u0026amp;\\text{7}\\\\\\hline \\text{1}\u0026amp;\\text{3}\u0026amp;\\text{6}\u0026amp;\\text{10}\u0026amp;\\text{15}\u0026amp;\\text{21}\u0026amp;\\text{28}\\\\\\hline \\end{array}\\) 寫成程式碼就是 int uniquePaths(int m, int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m+1, vector\u0026lt;int\u0026gt;(n+1,0)); for (int i = 1; i \u0026lt;= m; i++) // 將第一列填成 1 dp[i][1] = 1; for (int j = 1; j \u0026lt;= n; j++) // 將第一欄填成 1 dp[1][j] = 1; for (int i = 2; i \u0026lt;= m; i++) { // 將剩下的格子填完 for (int j = 2; j \u0026lt;= n; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m][n]; } 注意填格子的順序是有一定的限制的，必須要確保相關聯的子問題已經處理過。 動態規劃 由上例我們可以發現，原本的問題可以拆解成更小的問題(從 (1,1)-\u0026gt;(m,n) 變成從 (1,1)-\u0026gt;(i,j) 和從 (i,j)-\u0026gt;(m,n))。 我們令 f(i,j) 表示從 (1,1)-\u0026gt;(i,j) 的不同路徑數，則我們可以得到轉移方程式 f(i,j)=f(i-1,j)+f(i,j-1)。 我們發現，想求出 f(i,j) 只需要知道幾個更小的 f(i',j')。我們將 f(i',j') 稱為子問題。 我們捨棄冗餘的訊息(具體的走法)，只記錄對解決問題有幫助的結果。 動態規劃的兩大特點(適用前提) 無後效性 一旦 f(i,j) 確定，就不用關心我們如何計算出 f(i,j) 想要確定 f(i,j)，只需要知道 f(i-1,j) 和 f(i,j-1) 的值，而至於它們是如何算出來的，對當前或之後的任何子問題都沒有影響。 過去不依賴未來，未來不影響過去。 最優子結構 f(i,j) 的定義就已經蘊含了最優。 大問題的最優解可以由若干個小問題的最優解推出。(max, min, sum\u0026hellip;) DP 能適用於：能將大問題拆成若干小問題，滿足無後效性、最優子結構性質。 以下介紹幾種刷題會遇到的動態規劃套路： 二、動態規劃框架 1.","title":"[Algo] 2-5. 動態規劃 Dynamic Programming"},{"content":"947. Most Stones Removed with Same Row or Column\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Depth-First Search、Union Find、Graph 一、題目 On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.\nExample 1:\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Explanation: One way to remove 5 stones is as follows: Remove stone [2,2] because it shares the same row as [2,1]. Remove stone [2,1] because it shares the same column as [0,1]. Remove stone [1,2] because it shares the same row as [1,0]. Remove stone [1,0] because it shares the same column as [0,0]. Remove stone [0,1] because it shares the same row as [0,0].\nStone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane. Example 2:\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3 Explanation: One way to make 3 moves is as follows: Remove stone [2,2] because it shares the same row as [2,0]. Remove stone [2,0] because it shares the same column as [0,0]. Remove stone [0,2] because it shares the same row as [0,0].\nStones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane. Example 3:\nInput: stones = [[0,0]] Output: 0 Explanation: [0,0] is the only stone on the plane, so you cannot remove it. Constraints:\n1 \u0026lt;= stones.length \u0026lt;= 1000 0 \u0026lt;= xi, yi \u0026lt;= 10^4 No two stones are at the same coordinate point. 二、分析 典型的圖論問題，若兩個 stone 的 x 座標與 y 座標有一者相等，則可以看作它們之間有一條邊。 所有以邊相連的 stone，最後可以移除到剩下最後一個 stone。 可以移除的 stone 的最大值為所有 stone 數量減去留下的 stone 的數量。 三、解題 1. DFS Time complexity: \\(O(n^2)\\) Space complexity: \\(O(n)\\) void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stones, vector\u0026lt;bool\u0026gt;\u0026amp; vis, int i) { vis[i] = true; // 記錄拜訪 int r1 = stones[i][0], c1 = stones[i][1]; for (int j = 0; j \u0026lt; stones.size(); j++) { if (vis[j]) continue; int r2 = stones[j][0], c2 = stones[j][1]; if (r1 == r2 || c1 == c2) { // 有 x 軸或 y 軸相同 dfs(stones, vis, j); } } } int removeStones(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stones) { vector\u0026lt;bool\u0026gt; vis(stones.size(), false); // 用來記錄拜訪過了沒 int cnt = 0; // 可以留下來的石頭個數 for (int i = 0; i \u0026lt; stones.size(); i++) { if (vis[i]) continue; // 拜訪過則跳過 cnt++; dfs(stones, vis, i); // 將相連的石頭都拜訪過一遍 } return stones.size() - cnt; } 2. Union Find Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) class UF { private: unordered_map\u0026lt;int,int\u0026gt; parent; int cnt = 0; public: UF () {} int size() { return cnt; } int find(int x) { if (!parent.count(x)) { parent[x] = x; cnt++; } if (x != parent[x]) { parent[x] = find(parent[x]); } return parent[x]; } void connect(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX == rootY) return; parent[rootX] = rootY; cnt--; } }; class Solution { public: int removeStones(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stones) { int n = stones.size(); UF uf; for (auto stone : stones) { uf.connect(stone[0] + 10001, stone[1]); } return n - uf.size(); } }; 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/947/","summary":"947. Most Stones Removed with Same Row or Column\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Depth-First Search、Union Find、Graph 一、題目 On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.","title":"[LeetCode] 947. Most Stones Removed with Same Row or Column"},{"content":"151. Reverse Words in a String\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Two Pointers、String 一、題目 Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\nExample 1:\nInput: s = \u0026ldquo;the sky is blue\u0026rdquo; Output: \u0026ldquo;blue is sky the\u0026rdquo; Example 2:\nInput: \u0026quot; hello world \u0026quot; Output: \u0026ldquo;world hello\u0026rdquo; Explanation: Your reversed string should not contain leading or trailing spaces. Example 3:\nInput: \u0026ldquo;a good example\u0026rdquo; Output: \u0026ldquo;example good a\u0026rdquo; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 10^4 s contain English letters (upper-case and lower-case), digits, and spaces ' '. There is at least one word in s. Follow-up: If the string data is mutable in your language, can you solve it int-place with O(1) extra space?\n二、分析 此題如果搭配 string 常用的函式(在 hackerrank 有提供)，可以很簡單的解題： split function vector\u0026lt;string\u0026gt; split(string\u0026amp; s, char del) { stringstream ss(s); vector\u0026lt;string\u0026gt; res; string item; while (getline(ss, item, del)) { if (!item.empty()) res.push_back(item) // 注意，空白不加到陣列中 } return res; } 若要做到 O(1) 的 space complexity 的話，只能用 two pointer 了。 三、解題 1. split function Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) string reverseWords(string s) { vector\u0026lt;string\u0026gt; svec = split(s, \u0026#39; \u0026#39;); // 以空白字元作為分隔 string res; for (int i = svec.size()-1; i \u0026gt;= 0; i--) { res = res + \u0026#34; \u0026#34; + svec[i]; // 將陣列反過來組合成字串 } res = res.substr(1); // 移除多出來的空白字元 return res; } vector\u0026lt;string\u0026gt; split(string\u0026amp; s, char del) { stringstream ss(s); vector\u0026lt;string\u0026gt; res; string item; while (getline(ss, item, del)) { if (!item.empty()) res.push_back(item); // 注意，空白不加到陣列中 } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/151/","summary":"151. Reverse Words in a String\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Two Pointers、String 一、題目 Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words.","title":"[LeetCode] 151. Reverse Words in a String"},{"content":"23. Merge k Sorted Lists\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Linked List、Divide and Conquer、Heap (Priority Queue)、Merge Sort 一、題目 You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.\nExample 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are:\n[\n1-\u0026gt;4-\u0026gt;5,\n1-\u0026gt;3-\u0026gt;4,\n2-\u0026gt;6\n]\nmerging them into one sorted list:\n1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6 Example 2:\nInput: lists = [] Output: [] Example 3:\nInput: lists = [[]] Output: [] Constraints:\nk == lists.length 0 \u0026lt;= k \u0026lt;= 10^4 0 \u0026lt;= lists[i].length \u0026lt;= 500 -10^4 \u0026lt;= lists[i][j] \u0026lt;= 10^4 lists[i] is sorted in ascending order. The sum of lists[i].length will not exceed 10^4. 二、分析 由於所有鏈表都是排序好的，故我們可以同時比較所有鏈表 head 的值，來依序把鏈表建起來。 這裡可以用到 priority_queue，以下是 custom comparator 的寫法： auto comp = [](const auto\u0026amp; a, const auto\u0026amp; b) { return condition; } ; 1. priority_queue\u0026lt;element, container, decltype(comp)\u0026gt; pq(iterator::start, iterator::end, comp); 2. priority_queue\u0026lt;element, container, decltype(comp)\u0026gt; pq(comp); 需要特別 [] 與 [[]] 的差異，都可以藉由加入 heap 時先檢查鏈表來避免， 注意! 直接用 priority_queue 的 initializer 去加入整個 vector 會把 null 加進優先佇列中而導致報錯。 三、解題 1. Heap (Priority Queue) Time complexity: \\(O(k\\times n\\log k)\\) Space complexity: \\(O(k\\times n)\\) ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { auto comp = [](const auto\u0026amp; a, const auto\u0026amp; b) {return a-\u0026gt;val \u0026gt; b-\u0026gt;val;}; // min heap 的寫法跟 sort 相反 priority_queue\u0026lt;ListNode*, vector\u0026lt;ListNode*\u0026gt;, decltype(comp)\u0026gt; pq(comp); ListNode* dummy = new ListNode(-1); // 建立 dummy head ListNode* curr = dummy; for (const auto\u0026amp; list : lists) { if (list) pq.push(list); // 排除空鏈表 } while (!pq.empty()) { curr-\u0026gt;next = pq.top(); pq.pop(); if (curr-\u0026gt;next-\u0026gt;next) pq.push(curr-\u0026gt;next-\u0026gt;next); // 若鏈表還有 next，繼續加入 min heap curr = curr-\u0026gt;next; } return dummy-\u0026gt;next; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/23/","summary":"23. Merge k Sorted Lists\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Linked List、Divide and Conquer、Heap (Priority Queue)、Merge Sort 一、題目 You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.\nExample 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are:\n[\n1-\u0026gt;4-\u0026gt;5,\n1-\u0026gt;3-\u0026gt;4,\n2-\u0026gt;6\n]\nmerging them into one sorted list:\n1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6 Example 2:","title":"[LeetCode] 23. Merge k Sorted Lists"},{"content":"22. Generate Parentheses\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String、Dynamic Programming、Backtracking 一、題目 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nExample 1:\nInput: n = 3 Output: [\u0026quot;((()))\u0026quot;,\u0026quot;(()())\u0026quot;,\u0026quot;(())()\u0026quot;,\u0026quot;()(())\u0026quot;,\u0026quot;()()()\u0026quot;] Example 2:\nInput: n = 1 Output: [\u0026quot;()\u0026quot;] Constraints:\n1 \u0026lt;= n \u0026lt;= 8 二、分析 DFS 演算法是在遍歷「節點」，而回溯法是在遍歷「樹枝」。站在一個節點上，需思考三個問題： 路徑(PATH)：已做出的選擇。 選項(OPTION)：當前可以做的選擇。 終止條件(TERMINATE)：到達決策樹的底層，無法再做其它選擇。 以下為回溯法的框架： vector\u0026lt;PATH\u0026gt; res; void backtrack(PATH, OPTION) { if (TERMINATE) { res.push_back(PATH); return; } for (CHOICE : OPTION) { DO OPTION; backtrack(PATH, OPTION); CANCEL OPTION; } } 本題的終止條件是當 path 的長度為 2n 的時候。 而選項是增加左括號 ( 與增加右括號 )。 加上兩個子節點的條件便完成， 左節點需滿足 left \u0026lt; n。 右節點需滿足 right \u0026lt; n \u0026amp;\u0026amp; right \u0026lt; left。 DP 動態規劃則需觀察轉移方程式。 dp[0] base case： `` dp[1] 很容易得到：() dp[2] 也不難：()()、(()) 接下來觀察 dp[3]，可以分解為下面三個： ( + dp[0] + ) + dp[2]：()()()、()(()) ( + dp[1] + ) + dp[1]：(())() ( + dp[2] + ) + dp[0]：(()())、((())) 換句話說，轉移方程式可以寫成：dp[i] = \u0026quot;(\u0026quot; + dp[j] + \u0026quot;)\u0026quot; + dp[i-j-1] 三、解題 1. Backtrack Time complexity: \\(O(2^{2n})\\)，Wiki - Catalan number Space complexity: \\(O(n)\\) vector\u0026lt;string\u0026gt; generateParenthesis(int n) { string path; vector\u0026lt;string\u0026gt; res; backtrack(n, 0, 0, res, path); return res; } void backtrack(int n, int left, int right, vector\u0026lt;string\u0026gt;\u0026amp; res, string\u0026amp; path) { // terminate if (path.length() == 2*n) { res.push_back(path); return; } // select if (left \u0026lt; n) { path.push_back(\u0026#39;(\u0026#39;); backtrack(n, left+1, right, res, path); path.pop_back(); } if (right \u0026lt; n \u0026amp;\u0026amp; right \u0026lt; left) { path.push_back(\u0026#39;)\u0026#39;); backtrack(n, left, right+1, res, path); path.pop_back(); } } 2. Dynamic Programming Time complexity: \\(O(n^4)\\) Space complexity: \\(O(n)\\) vector\u0026lt;string\u0026gt; generateParenthesis(int n) { vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; dp(n+1); dp[0] = {\u0026#34;\u0026#34;}; for(int i=1;i\u0026lt;=n;i++){ for(int j=0;j\u0026lt;i;j++){ vector\u0026lt;string\u0026gt; left = dp[j]; vector\u0026lt;string\u0026gt; right = dp[i-j-1]; for(int k=0;k\u0026lt;left.size();k++){ for(int l=0;l\u0026lt;right.size();l++){ dp[i].push_back(\u0026#34;(\u0026#34; + left[k] + \u0026#34;)\u0026#34; + right[l]); } } } } return dp[n]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/22/","summary":"22. Generate Parentheses\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String、Dynamic Programming、Backtracking 一、題目 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nExample 1:\nInput: n = 3 Output: [\u0026quot;((()))\u0026quot;,\u0026quot;(()())\u0026quot;,\u0026quot;(())()\u0026quot;,\u0026quot;()(())\u0026quot;,\u0026quot;()()()\u0026quot;] Example 2:\nInput: n = 1 Output: [\u0026quot;()\u0026quot;] Constraints:\n1 \u0026lt;= n \u0026lt;= 8 二、分析 DFS 演算法是在遍歷「節點」，而回溯法是在遍歷「樹枝」。站在一個節點上，需思考三個問題： 路徑(PATH)：已做出的選擇。 選項(OPTION)：當前可以做的選擇。 終止條件(TERMINATE)：到達決策樹的底層，無法再做其它選擇。 以下為回溯法的框架： vector\u0026lt;PATH\u0026gt; res; void backtrack(PATH, OPTION) { if (TERMINATE) { res.push_back(PATH); return; } for (CHOICE : OPTION) { DO OPTION; backtrack(PATH, OPTION); CANCEL OPTION; } } 本題的終止條件是當 path 的長度為 2n 的時候。 而選項是增加左括號 ( 與增加右括號 )。 加上兩個子節點的條件便完成， 左節點需滿足 left \u0026lt; n。 右節點需滿足 right \u0026lt; n \u0026amp;\u0026amp; right \u0026lt; left。 DP 動態規劃則需觀察轉移方程式。 dp[0] base case： `` dp[1] 很容易得到：() dp[2] 也不難：()()、(()) 接下來觀察 dp[3]，可以分解為下面三個： ( + dp[0] + ) + dp[2]：()()()、()(()) ( + dp[1] + ) + dp[1]：(())() ( + dp[2] + ) + dp[0]：(()())、((())) 換句話說，轉移方程式可以寫成：dp[i] = \u0026quot;(\u0026quot; + dp[j] + \u0026quot;)\u0026quot; + dp[i-j-1] 三、解題 1.","title":"[LeetCode] 22. Generate Parentheses"},{"content":"21. Merge Two Sorted Lists\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Linked List、Recursion 一、題目 You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nExample 1:\nInput: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:\nInput: list1 = [], list2 = [] Output: [] Example 3:\nInput: list1 = [], list2 = [0] Output: [0] Constraints:\nThe number of nodes in both lists is in the range [0, 50]. -100 \u0026lt;= Node.val \u0026lt;= 100 Both list1 and list2 are sorted in non-decreasing order. 二、分析 這一題也是 linked list 的經典題型，特別需考慮到空鏈表的情況，所以可以用一個 dummy head 來避免這個情況的發生。 三、解題 1. Iteration Time complexity: \\(O(m+n)\\) Space complexity: \\(O(1)\\) ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* dummy = new ListNode(-1); // 建一個虛假鏈表做為頭 ListNode* curr = dummy; while (list1 \u0026amp;\u0026amp; list2) { // 依序將兩個表由小到大遍歷一遍 if (list1-\u0026gt;val \u0026lt;= list2-\u0026gt;val) { curr-\u0026gt;next = list1; list1 = list1-\u0026gt;next; } else { curr-\u0026gt;next = list2; list2 = list2-\u0026gt;next; } curr = curr-\u0026gt;next; } if (list1) curr-\u0026gt;next = list1; // 將尚未遍歷完的鏈表接到尾巴 if (list2) curr-\u0026gt;next = list2; return dummy-\u0026gt;next; // 最後記得回傳虛假鏈表的下一個節點 } 2. Recursion Time complexity: \\(O(m+n)\\) Space complexity: \\(O(1)\\) ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { if (!list1) return list2; // 其中一者遍歷完，將剩下的鏈表接到尾巴 if (!list2) return list1; ListNode* res; if (list1-\u0026gt;val \u0026lt;= list2-\u0026gt;val) { res = list1; list1-\u0026gt;next = mergeTwoLists(list1-\u0026gt;next , list2); // 較小的鏈表前進一個節點 } else { res = list2; list2-\u0026gt;next = mergeTwoLists(list1, list2-\u0026gt;next); } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/21/","summary":"21. Merge Two Sorted Lists\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Linked List、Recursion 一、題目 You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nExample 1:\nInput: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:","title":"[LeetCode] 21. Merge Two Sorted Lists"},{"content":"1047. Remove All Adjacent Duplicates In String\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String、Stack 一、題目 You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\nWe repeatly make duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made. It can be proven that the answer is unique.\nExample 1:\nInput: s = \u0026ldquo;abbaca\u0026rdquo; Output: \u0026ldquo;ca\u0026rdquo; Explanation: For example, in \u0026ldquo;abbaca\u0026rdquo; we could remove \u0026ldquo;bb\u0026rdquo; since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \u0026ldquo;aaca\u0026rdquo;, of which only \u0026ldquo;aa\u0026rdquo; is possible, so the final string is \u0026ldquo;ca\u0026rdquo;. Example 2:\nInput: s = \u0026ldquo;azxxzy\u0026rdquo; Output: \u0026ldquo;ay\u0026rdquo; Constraints:\n1 \u0026lt;= s.length \u0026lt;= 10^5 s consists of lowercase English letters. 二、分析 因為本題是連續移除，可運用 Stack 的概念，只要出現跟堆頂字元相同時，就 pop 掉堆頂。 三、解題 1. Stack Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) string removeDuplicates(string s) { string res = \u0026#34;\u0026#34;; for (char c : s) { if (res.empty()) { res.push_back(c); } else { if (res.back() == c) { res.pop_back(); } else { res.push_back(c); } } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1047/","summary":"1047. Remove All Adjacent Duplicates In String\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String、Stack 一、題目 You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\nWe repeatly make duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made. It can be proven that the answer is unique.","title":"[LeetCode] 1047. Remove All Adjacent Duplicates In String"},{"content":"901. Online Stock Span\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Stack、Design、Monotonic Stack、Data Stream 一、題目 Design an algorithm that collects daily price quotes for some stock and returns the span of that stock\u0026rsquo;s price for the current day.\nThe span of the stock\u0026rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today\u0026rsquo;s price.\nFor example, if the price of a stock over the next 7 days were [100,80,60,70,60,75,85], then the stock spans would be [1,1,1,2,1,4,6]. Implement the StockSpanner class:\nStockSpanner() Initializes the object of the class.\nint next(int price) Returns the span of the stock\u0026rsquo;s price given that today\u0026rsquo;s price is price.\nExample 1:\nInput: [\u0026ldquo;StockSpanner\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;]\n[[], [100], [80], [60], [70], [60], [75], [85]] Output: [null, 1, 1, 1, 2, 1, 4, 6] Explanation:\nStockSpanner stockSpanner = new StockSpanner();\nstockSpanner.next(100); // return 1\nstockSpanner.next(80); // return 1\nstockSpanner.next(60); // return 1\nstockSpanner.next(70); // return 2\nstockSpanner.next(60); // return 1\nstockSpanner.next(75); // return 4, because the last 4 prices (including today\u0026rsquo;s price of 75) were less than or equal to today\u0026rsquo;s price.\nstockSpanner.next(85); // return 6 Constraints:\n1 \u0026lt;= price \u0026lt;= 10^5 At most 10^4 calls will be made to next. 二、分析 可以用 Monotonic Stack 裝載 pair\u0026lt;int,int\u0026gt; 記錄當前 stock 的股價與天數，假如遇到當前股價還低者，便 pop 掉，當前股價與 Stack 頂的位置差即為低於當前股價的連續天數。 三、解題 1. Monotonic Stack Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) class StockSpanner { public: stack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; st; int day = 0; // 記錄第 ith day StockSpanner() { st.push(make_pair(INT_MAX, -1)); // 令 stack 不會為空 } int next(int price) { while (st.top().first \u0026lt;= price) st.pop(); // 遇到小於等於的都 pop掉 int res = day - st.top().second; // 堆頂的位置與當前位置差即為解 st.push(make_pair(price, day++)); // 再將當前股價推到堆中 return res; } }; 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/901/","summary":"901. Online Stock Span\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Stack、Design、Monotonic Stack、Data Stream 一、題目 Design an algorithm that collects daily price quotes for some stock and returns the span of that stock\u0026rsquo;s price for the current day.\nThe span of the stock\u0026rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today\u0026rsquo;s price.","title":"[LeetCode] 901. Online Stock Span"},{"content":"1544. Make The String Great\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String、Stack 一、題目 Given a string s of lower and upper case English letters.\nA good string is a string which doesn\u0026rsquo;t have two adjacent characters s[i] and s[i + 1] where:\n0 \u0026lt;= i \u0026lt;= s.length - 2 s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.\nTo make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.\nReturn the string after making it good. The answer is guaranteed to be unique under the given constraints.\nNotice that an empty string is also good. Example 1:\nInput: s = \u0026ldquo;leEeetcode\u0026rdquo; Output: \u0026ldquo;leetcode\u0026rdquo; Explanation: In the first step, either you choose i = 1 or i = 2, both will result \u0026ldquo;leEeetcode\u0026rdquo; to be reduced to \u0026ldquo;leetcode\u0026rdquo;. Example 2:\nInput: s = \u0026ldquo;abBAcC\u0026rdquo; Output: \u0026quot;\u0026quot; Explanation: We have many possible scenarios, and all lead to the same answer. For example:\n\u0026ldquo;abBAcC\u0026rdquo; \u0026ndash;\u0026gt; \u0026ldquo;aAcC\u0026rdquo; \u0026ndash;\u0026gt; \u0026ldquo;cC\u0026rdquo; \u0026ndash;\u0026gt; \u0026quot;\u0026quot;\n\u0026ldquo;abBAcC\u0026rdquo; \u0026ndash;\u0026gt; \u0026ldquo;abBA\u0026rdquo; \u0026ndash;\u0026gt; \u0026ldquo;aA\u0026rdquo; \u0026ndash;\u0026gt; \u0026quot;\u0026quot; Example 3:\nInput: s = \u0026ldquo;s\u0026rdquo; Output: \u0026ldquo;s\u0026rdquo; Constraints:\n1 \u0026lt;= s.length \u0026lt;= 100 s contains only lower and upper case English letters. 二、分析 當前後兩個字元互為大小寫的字元時，將之移除。可利用 stack 來操作之。 三、解題 1. Stack Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) char trans(char c) { // 大小寫互換 return (\u0026#39;a\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) ? c - 32 : c + 32; } string makeGood(string s) { string st; for (char c : s) { if (st.empty()) { st.push_back(c); } else { if (st.back() == trans(c)) { // 當 stack 頂端與下一個字元互為大小寫 st.pop_back(); } else { st.push_back(c); } } } return st; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1544/","summary":"1544. Make The String Great\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String、Stack 一、題目 Given a string s of lower and upper case English letters.\nA good string is a string which doesn\u0026rsquo;t have two adjacent characters s[i] and s[i + 1] where:\n0 \u0026lt;= i \u0026lt;= s.length - 2 s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.\nTo make the string good, you can choose two adjacent characters that make the string bad and remove them.","title":"[LeetCode] 1544. Make The String Great"},{"content":"2463. Minimum Total Distance Traveled\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Dynamic Programming、Sorting \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.\nThe positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.\nAll the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.\nAt any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.\nReturn the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.\nNote that\nAll robots move at the same speed. If two robots move in the same direction, they will never collide. If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other. If a robot passes by a factory that reached its limits, it crosses it as if it does not exist. If the robot moved from a position x to a position y, the distance it moved is |y - x|. Example 1:\nInput: robot = [0,4,6], factory = [[2,2],[6,2]] Output: 4 Explanation: As shown in the figure: The first robot at position 0 moves in the positive direction. It will be repaired at the first factory. The second robot at position 4 moves in the negative direction. It will be repaired at the first factory. The third robot at position 6 will be repaired at the second factory. It does not need to move.\nThe limit of the first factory is 2, and it fixed 2 robots.\nThe limit of the second factory is 2, and it fixed 1 robot.\nThe total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4. Example 2:\nInput: robot = [1,-1], factory = [[-2,1],[2,1]] Output: 2 Explanation: As shown in the figure: The first robot at position 1 moves in the positive direction. It will be repaired at the second factory. The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.\nThe limit of the first factory is 1, and it fixed 1 robot.\nThe limit of the second factory is 1, and it fixed 1 robot.\nThe total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2. Constraints:\n1 \u0026lt;= robot.length, factory.length \u0026lt;= 100 factory[j].length == 2 -10^9 \u0026lt;= robot[i], positionj \u0026lt;= 10^9 0 \u0026lt;= limitj \u0026lt;= robot.length The input will be generated such that it is always possible to repair every robot. 二、分析 初見此題，最先想到的方法是 Greedy + Binary Search，想法是每個機器人都先找離自己最近的工廠，解法參考如下，但實際上，第一個機器人的選擇會影響接下來的機器人的最近選擇：如 robot = [9,11,99,101], factory = [[7,1],[10,1],[14,1],[96,1][100,1],[103,1]]，若第一個位置在 9 的機器人選擇了位置在 10 的工廠，則會影響位置在 11 的機器人最近的工廠在 14，而這樣的選擇就導致錯過了最近解。所以這種解法還需要一些修正。 long long minimumTotalDistance(vector\u0026lt;int\u0026gt;\u0026amp; robot, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; factory) { map\u0026lt;int,int\u0026gt; mp; long long res = 0; for (auto f : factory) { if (f[1] == 0) continue; mp[f[0]] = f[1]; } for (auto r : robot) { auto it = mp.lower_bound(r); if (it == mp.end()) { it--; } else if (it != mp.begin()){ auto right = it--; if (r - it-\u0026gt;first \u0026gt; right-\u0026gt;first - r) { it = right; } } res += abs(it-\u0026gt;first - r); if (it-\u0026gt;second == 1) { mp.erase(it); } else { it-\u0026gt;second--; } } 也許可以將透過 sorting 將機器人分為幾個子群對應幾個工廠。 如果用 dfs + memoization 也就是 dynamic programming 的方式應該可解，透過將 factory 扁平化，並經過 sort 的之後，令 dp(i, j) 為總步數，i 為由左數到右第 ith 個機器人，j 為由左數到右第 jth 個工廠的「空位」。 三、解題 1. DP Time complexity: \\(O(m\\times n\\times k)\\) Space complexity: \\(O(m\\times n\\times k)\\) m = robot.size(), n = factory.size(), k = max(factory[i].size()) vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp; long long minimumTotalDistance(vector\u0026lt;int\u0026gt;\u0026amp; robot, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; factory) { long long res = 0; vector\u0026lt;int\u0026gt; fac; for (auto f : factory) { // 將 factory 扁平化成 1d array int times = f[1]; while (times--) { fac.push_back(f[0]); } } dp = vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;(robot.size()+1, vector\u0026lt;long long\u0026gt;(fac.size()+1, -1)); sort(robot.begin(), robot.end()); sort(fac.begin(), fac.end()); return dfs(robot, fac, 0, 0); } long long dfs(vector\u0026lt;int\u0026gt;\u0026amp; robot, vector\u0026lt;int\u0026gt;\u0026amp; fac, int i, int j) { if (i == robot.size()) return 0; // 當機器人都排列完畢，為終止條件 if (j == fac.size()) return (long long) (LONG_MAX/2); // 工廠空缺空用了，傳回一個有效的大數，使之不會是答案 if (dp[i][j] != -1) return dp[i][j]; dp[i][j] = min( dfs(robot, fac, i+1, j+1) + (long long)abs(robot[i]-fac[j]), // ith 機器人選擇 jth 工廠空位 dfs(robot, fac, i, j+1) // ith 機器人不選擇 jth 工廠空位 ); return dp[i][j]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2463/","summary":"2463. Minimum Total Distance Traveled\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Dynamic Programming、Sorting \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.","title":"[LeetCode] 2463. Minimum Total Distance Traveled"},{"content":"2462. Total Cost to Hire K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointer、Heap (Priority Queue)、Simulation \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker. You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\nYou will run k sessions and hire exactly one worker in each session. In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index. For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2]. In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process. If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index. A worker can only be chosen once. Return the total cost to hire exactly k workers. Example 1:\nInput: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 Output: 11 Explanation: We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2. In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4. In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.\nThe total hiring cost is 11. Example 2:\nInput: costs = [1,2,4,1], k = 3, candidates = 3 Output: 4 Explanation: We hire 3 workers in total. The total cost is initially 0. In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers. In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2. In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.\nThe total hiring cost is 4. Constraints:\n1 \u0026lt;= costs.length \u0026lt;= 10^5 1 \u0026lt;= costs[i] \u0026lt;= 10^5 1 \u0026lt;= k, candidates \u0026lt;= costs.length 二、分析 將數組左右兩邊 candidates 長度的數字加入各別的 min heap 中，按順序比較兩個 min heap，將小的加入和中。 注意當從 min heap 中取值之後，要移動指針，將新的值放入 min heap，除非當左右指針相撞(代表整個數組都在 candidate 的範圍內)。 三、解題 1. Heap (Priority Queue) Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) long long totalCost(vector\u0026lt;int\u0026gt;\u0026amp; costs, int k, int candidates) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; front, end; // 宣告兩個 min heap long long res = 0; int cnt = 0; int i = 0, j = costs.size()-1; front.push(INT_MAX); // 當 min heap 為空時，必定傳回另一個 min heap 的值 end.push(INT_MAX); while (i \u0026lt;= j \u0026amp;\u0026amp; cnt \u0026lt; candidates) { front.push(costs[i++]); // 左指針移動 if (i \u0026lt;= j) end.push(costs[j--]); // 右指針移動，左右指針相撞，代表已經包含整個數組 cnt++; } while (k--) { // 取 k 個數字 if (front.top() \u0026lt;= end.top()) { res += front.top(); front.pop(); if (i \u0026lt;= j) front.push(costs[i++]); // 左右指針相撞，不再加入新的值 } else { res += end.top(); end.pop(); if (i \u0026lt;= j) end.push(costs[j--]); // 左右指針相撞，不再加入新的值 } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2462/","summary":"2462. Total Cost to Hire K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointer、Heap (Priority Queue)、Simulation \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker. You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\nYou will run k sessions and hire exactly one worker in each session. In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.","title":"[LeetCode] 2462. Total Cost to Hire K"},{"content":"2461. Maximum Sum of Distinct Subarrays With Length K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Sliding Window \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:\nThe length of the subarray is k, and All the elements of the subarray are distinct. Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0. A subarray is a contiguous non-empty sequence of elements within an array. Example 1:\nInput: nums = [1,5,4,2,9,9,9], k = 3 Output: 15 Explanation: The subarrays of nums with length 3 are: [1,5,4] which meets the requirements and has a sum of 10. [5,4,2] which meets the requirements and has a sum of 11. [4,2,9] which meets the requirements and has a sum of 15. [2,9,9] which does not meet the requirements because the element 9 is repeated. [9,9,9] which does not meet the requirements because the element 9 is repeated.\nWe return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions Example 2:\nInput: nums = [4,4,4], k = 3 Output: 0 Explanation: The subarrays of nums with length 3 are: [4,4,4] which does not meet the requirements because the element 4 is repeated.\nWe return 0 because no subarrays meet the conditions. Example 3:\nInput: Output: Constraints:\n1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5 二、分析 標準的 Sliding Window 題型，將 window 控制在固定大小 k，並檢查 window 中沒有重複的數字。 三、解題 1. Sliding Window Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) long long maximumSubarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;int,int\u0026gt; map; int valid = 0; long long res = 0; long long sum = 0; int left = 0, right = 0; while (right \u0026lt; nums.size()) { int x = nums[right++]; // 右指針移動 sum += x; // 將值加入和 map[x]++; // 記錄右指針移動時數字的個數 if (map[x] == 1) valid++; // 右指針移動時，數字個數為 1 時，有效數加 1 if (right - left == k) { // 將 window 控制在大小為 k if (valid == k) res = max(res, sum); // 滿足條件，比較大小 int y = nums[left++]; // 左指針移動 if (map[y] == 1) valid--; // 左指針移動時，數字個數為 1 時，有效數減 1 map[y]--; // 記錄左指針移動時數字的個數 sum -= y; // 將值移去和 } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2461/","summary":"2461. Maximum Sum of Distinct Subarrays With Length K\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Sliding Window \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:\nThe length of the subarray is k, and All the elements of the subarray are distinct. Return the maximum subarray sum of all the subarrays that meet the conditions.","title":"[LeetCode] 2461. Maximum Sum of Distinct Subarrays With Length K"},{"content":"2460. Apply Operations to an Array\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Simulation \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 You are given a 0-indexed array nums of size n consisting of non-negative integers. You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation. After performing all the operations, shift all the 0\u0026rsquo;s to the end of the array. For example, the array [1,0,2,0,0,1] after shifting all its 0\u0026rsquo;s to the end, is [1,2,1,0,0,0]. Return the resulting array. Note that the operations are applied sequentially, not all at once. Example 1:\nInput: nums = [1,2,2,1,1,0] Output: [1,4,2,0,0,0] Explanation: We do the following operations: i = 0: nums[0] and nums[1] are not equal, so we skip this operation. i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0]. i = 2: nums[2] and nums[3] are not equal, so we skip this operation. i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0]. i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].\nAfter that, we shift the 0\u0026rsquo;s to the end, which gives the array [1,4,2,0,0,0]. Input: nums = [0,1] Output: [1,0] Explanation: No operation can be applied, we just shift the 0 to the end. Constraints:\n2 \u0026lt;= nums.length \u0026lt;= 2000 0 \u0026lt;= nums[i] \u0026lt;= 1000 二、分析 照題目的指示做兩件事： 將前後重複的數字，把前者乘二，後者歸零。 利用 Two Pointer 的技巧，將零全部丟到後面。 三、解題 1. Two Pointer Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) vector\u0026lt;int\u0026gt; applyOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size()-1; i++) { if (nums[i] == 0) continue; if (nums[i] == nums[i+1]) { // 將前後重複的數字加到前者 nums[i] *= 2; nums[i+1] = 0; } } int i = 0, j = 0; while (i \u0026lt; nums.size()) { if (nums[i] != 0) { // 將零全部移到後面 nums[j++] = nums[i++]; } else { i++; } } while (j \u0026lt; nums.size()) { nums[j++] = 0; } return nums; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2460/","summary":"2460. Apply Operations to an Array\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Simulation \\(\\color{blue}\\textsf{Weekly Contest 318}\\) 一、題目 You are given a 0-indexed array nums of size n consisting of non-negative integers. You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0.","title":"[LeetCode] 2460. Apply Operations to an Array"},{"content":"1323. Maximum 69 Number\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math、Greedy 一、題目 You are given a positive integer num consisting only of digits 6 and 9.\nReturn the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).\nExample 1:\nInput: num = 9669 Output: 9969 Explanation:\nChanging the first digit results in 6669.\nChanging the second digit results in 9969.\nChanging the third digit results in 9699.\nChanging the fourth digit results in 9666.\nThe maximum number is 9969. Example 2:\nInput: num = 9996 Output: 9999 Explanation: Changing the last digit 6 to 9 results in the maximum number. Example 3:\nInput: num = 9999 Output: 9999 Explanation: It is better not to apply any change. Constraints:\n1 \u0026lt;= num \u0026lt;= 10^4 num consists of only 6 and 9 digits. 二、分析 觀察規律，從數字從左開始，將第一個 6 換成 9者為解。 三、解題 1. Greedy Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int maximum69Number (int num) { string s = to_string(num); for (int i = 0; i \u0026lt; s.length(); i++) { if (s[i] == \u0026#39;6\u0026#39;) { s[i] = \u0026#39;9\u0026#39;; break; } } return stoi(s); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1323/","summary":"1323. Maximum 69 Number\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math、Greedy 一、題目 You are given a positive integer num consisting only of digits 6 and 9.\nReturn the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).\nExample 1:\nInput: num = 9669 Output: 9969 Explanation:\nChanging the first digit results in 6669.\nChanging the second digit results in 9969.\nChanging the third digit results in 9699.","title":"[LeetCode] 1323. Maximum 69 Number"},{"content":"Introduction to ML 統計學與機器學習差在哪裡? 同: 將資料(data)轉為資訊(info)\n異: 有無強烈的人為事先假設\n統計學\n統計學是在資料分析的基礎上，研究如何測定、收集、整理、歸納和分析反映資料，以便給出正確訊息的科學。 機器學習\n機器學習演算法是一類從資料中自動分析獲得規律，並利用規律對未知資料進行預測的演算法。 \\(\\begin{array}{lll} \\text{Item} \u0026amp; \\text{Statistics} \u0026amp; \\text{Machine Learning}\\\\\\hline \\text{特性} \u0026amp; \\text{伴隨事前假設，依賴明確規則，以模型定義資料關聯性，重視模型解釋性} \u0026amp; \\text{幾乎無視前假設，不依賴明確規則，相信經驗}\\\\ \u0026amp; \\text{事前假設(人)}\\rightarrow\\text{模型估計(機器)} \u0026amp; \\text{特徵萃取(機器)}\\rightarrow\\text{網路建構(機器)} \\\\\\hline \\text{優點} \u0026amp; \\text{模型可解釋} \u0026amp; \\text{不須事先假設或了解資料關聯性}\\\\ \u0026amp; \\text{推論有強烈理論根據} \u0026amp; \\text{可抓取資料的所有(幾乎)複雜特徵}\\\\ \u0026amp; \\text{符合事前假設前提下，可做更多的推論}\\\\ \u0026amp; \\text{符合事前假設前提下，不需大量資料} \\\\\\hline \\text{缺點} \u0026amp; \\text{所有推論接基於事前假設，常難以驗證假設的正確性} \u0026amp; \\text{模型難以解釋(黑盒子)}\\\\ \u0026amp; \\text{難以抓取資料中過於複雜的特徵} \u0026amp; \\text{推論無強烈理論根據} \\\\\\hline \\text{專家} \u0026amp; \\text{統計背景} \u0026amp; \\text{資訊背景及統計背景} \\\\\\hline \\end{array}\\) 結論 統計模型的重點是有合理的事前假設 在有合理假設之情況下，統計模型能發揮效力(即使資料量少) 機器學習的重點是大量有代表性的資料 在有大量有效資料之情況下，機器學習能發揮效力(即使人類對資料間的關聯之了解並不多) 何時使用統計方法? 何時使用機器學習? 資料關聯性清楚，容易給予合適的模型假設時，建議使用統計模型 資料無明確規則(如影像及語音辨識)，且資料量夠多時，建議使用機器學習方法(可以佐以人為提示) 統計與機器學習類似的專有名詞 \\(\\begin{array}{ll} \\text{Statistics} \u0026amp; \\text{Machine Learning} \\text{response, dependent variable} \u0026amp; \\text{label} \\\\\\hline \\text{covariate, explanatory variable, independent variable} \u0026amp; \\text{feature} \\\\\\hline \\text{model} \u0026amp; \\text{network} \\\\\\hline \\text{parameter, coefficient} \u0026amp; \\text{weight} \\\\\\hline \\text{fitting} \u0026amp; \\text{learning} \\\\\\hline \\text{refression, classification} \u0026amp; \\text{supervised learning} \\\\\\hline \\text{density estimation, cluster} \u0026amp; \\text{unsupervised learning} \\\\\\hline \\end{array}\\)\n","permalink":"http://intervalrain.github.io/posts/ml/lec1/","summary":"Introduction to ML 統計學與機器學習差在哪裡? 同: 將資料(data)轉為資訊(info)\n異: 有無強烈的人為事先假設\n統計學\n統計學是在資料分析的基礎上，研究如何測定、收集、整理、歸納和分析反映資料，以便給出正確訊息的科學。 機器學習\n機器學習演算法是一類從資料中自動分析獲得規律，並利用規律對未知資料進行預測的演算法。 \\(\\begin{array}{lll} \\text{Item} \u0026amp; \\text{Statistics} \u0026amp; \\text{Machine Learning}\\\\\\hline \\text{特性} \u0026amp; \\text{伴隨事前假設，依賴明確規則，以模型定義資料關聯性，重視模型解釋性} \u0026amp; \\text{幾乎無視前假設，不依賴明確規則，相信經驗}\\\\ \u0026amp; \\text{事前假設(人)}\\rightarrow\\text{模型估計(機器)} \u0026amp; \\text{特徵萃取(機器)}\\rightarrow\\text{網路建構(機器)} \\\\\\hline \\text{優點} \u0026amp; \\text{模型可解釋} \u0026amp; \\text{不須事先假設或了解資料關聯性}\\\\ \u0026amp; \\text{推論有強烈理論根據} \u0026amp; \\text{可抓取資料的所有(幾乎)複雜特徵}\\\\ \u0026amp; \\text{符合事前假設前提下，可做更多的推論}\\\\ \u0026amp; \\text{符合事前假設前提下，不需大量資料} \\\\\\hline \\text{缺點} \u0026amp; \\text{所有推論接基於事前假設，常難以驗證假設的正確性} \u0026amp; \\text{模型難以解釋(黑盒子)}\\\\ \u0026amp; \\text{難以抓取資料中過於複雜的特徵} \u0026amp; \\text{推論無強烈理論根據} \\\\\\hline \\text{專家} \u0026amp; \\text{統計背景} \u0026amp; \\text{資訊背景及統計背景} \\\\\\hline \\end{array}\\) 結論 統計模型的重點是有合理的事前假設 在有合理假設之情況下，統計模型能發揮效力(即使資料量少) 機器學習的重點是大量有代表性的資料 在有大量有效資料之情況下，機器學習能發揮效力(即使人類對資料間的關聯之了解並不多) 何時使用統計方法? 何時使用機器學習? 資料關聯性清楚，容易給予合適的模型假設時，建議使用統計模型 資料無明確規則(如影像及語音辨識)，且資料量夠多時，建議使用機器學習方法(可以佐以人為提示) 統計與機器學習類似的專有名詞 \\(\\begin{array}{ll} \\text{Statistics} \u0026amp; \\text{Machine Learning} \\text{response, dependent variable} \u0026amp; \\text{label} \\\\\\hline \\text{covariate, explanatory variable, independent variable} \u0026amp; \\text{feature} \\\\\\hline \\text{model} \u0026amp; \\text{network} \\\\\\hline \\text{parameter, coefficient} \u0026amp; \\text{weight} \\\\\\hline \\text{fitting} \u0026amp; \\text{learning} \\\\\\hline \\text{refression, classification} \u0026amp; \\text{supervised learning} \\\\\\hline \\text{density estimation, cluster} \u0026amp; \\text{unsupervised learning} \\\\\\hline \\end{array}\\)","title":"[ML] 機器學習與統計學"},{"content":"79. Word Search\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Backtracking、Matrix 一、題目 Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample 1:\nInput: board = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;E\u0026rdquo;],[\u0026ldquo;S\u0026rdquo;,\u0026ldquo;F\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;S\u0026rdquo;],[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;E\u0026rdquo;,\u0026ldquo;E\u0026rdquo;]], word = \u0026ldquo;ABCCED\u0026rdquo; Output: true Example 2:\nInput: board = [[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]], words = [\u0026ldquo;abcb\u0026rdquo;] Output: true Example 3:\nInput: board = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;E\u0026rdquo;],[\u0026ldquo;S\u0026rdquo;,\u0026ldquo;F\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;S\u0026rdquo;],[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;E\u0026rdquo;,\u0026ldquo;E\u0026rdquo;]], word = \u0026ldquo;ABCB\u0026rdquo; Output: false Constraints:\nm == board.length n = board[i].length 1 \u0026lt;= m, n \u0026lt;= 6 1 \u0026lt;= word.length \u0026lt;= 15 board and word consists of only lowercase and uppercase English letters. Follow up: Could you use search pruning to make your solution faster with a larger board?\n二、分析 這題是 [LeetCode] 212. Word Search II 的基本題，是 google 愛考的題型，先考你一題基礎題型，再看你能不能進一步微調。如先考最短路徑的「步數」，再考你最短路徑的「路徑」，此種題型容易藏細節，如最短路徑「步數」可以用 bfs，當走到終點立即回傳，但當考題改成路徑時，就不能立即回傳，因為有可能會有多個最短路徑。 這題有許多剪枝技巧： word 的字長不可能大於 board 的總字數，即 m x n。 word 個別的字數需小於 board 各別的字數。 word 如果是重複的字元組成，則重複的字元擺在尾巴可以有分枝的效果。 即 aaaaaaabc 可以處理成，找 cbaaaaaaa。 注意在 search 中回傳 bool 值前，要記得將 backtrack 走完，以免影響其它組解。 三、解題 1. Backtracking Time complexity: \\(O(m\\times n\\times l)\\)，\\(m \\) 為 board.size()，\\(n\\) 為 board[0].size()，\\(l\\) 為 word.length() Space complexity: \\(O(m\\times n)\\) class Board { private: vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; board; int m, n; int cnt[128]; // 用於上、下、左、右 int dirc[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; // 用於剪枝1與剪枝2，在進行算法前，檢查其是否可能為錯，時間複雜度為 O(1)，所以可以大大降低耗時。 bool isWordNumValid(string\u0026amp; word) { if (word.length() \u0026gt; m * n) return false; // 剪枝1 int charNum[128] = {0}; for (char c : word) charNum[c]++; for (int i = 0; i \u0026lt; 128; i++) { if (charNum[i] \u0026gt; cnt[i]) return false; // 剪枝2 } return true; } void reverseIfNeeded(string\u0026amp; word) { int left = word.find_first_not_of(word[0]); // 左邊重複 int right = word.length() - word.find_last_not_of(word[word.length()-1]); // 右邊重複 if (left \u0026gt; right) reverse(word.begin(), word.end()); // 左邊重複較長，則翻轉字串 } bool backtrack(string\u0026amp; word, int row, int col, int i) { if (i == word.length()) return true; // 到達終止條件，回傳 true if (row \u0026lt; 0 || col \u0026lt; 0 || row \u0026gt;= m || col \u0026gt;= n || board[row][col] != word[i]) return false; // out of bound 或不符合 char tmp = board[row][col]; // 記錄原本的格子 board[row][col] = \u0026#39;#\u0026#39;; // 用 \u0026#39;#\u0026#39; 代表 visited，省去另外創一個 visited 來記錄是否拜訪過 for (const auto\u0026amp; d : dirc) if (backtrack(word, row+d[0], col+d[1], i+1)) { // board[row][col] = tmp; // 記得將 backtrack 更動的部分走完，以免影響其它組解 return true; } board[row][col] = tmp; // 還原格子 return false; } public: Board(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board_) { this-\u0026gt;board = board_; this-\u0026gt;m = board_.size(); this-\u0026gt;n = board_[0].size(); memset(cnt, 0, sizeof(cnt)); for (const auto\u0026amp; row : board) { for (char c : row) { cnt[c]++; } } } bool search(string\u0026amp; word) { for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (!isWordNumValid(word)) return false; reverseIfNeeded(word); if (backtrack(word, i, j, 0)) return true; } } return false; } }; class Solution { public: bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { Board b(board); return b.search(word); } }; 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/79/","summary":"79. Word Search\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Backtracking、Matrix 一、題目 Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample 1:\nInput: board = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;E\u0026rdquo;],[\u0026ldquo;S\u0026rdquo;,\u0026ldquo;F\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;S\u0026rdquo;],[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;E\u0026rdquo;,\u0026ldquo;E\u0026rdquo;]], word = \u0026ldquo;ABCCED\u0026rdquo; Output: true Example 2:","title":"[LeetCode] 79. Word Search"},{"content":"212. Word Search II\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、String、Backtracking、Trie、Matrix 一、題目 Given an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nExample 1:\nInput: board = [[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;],[\u0026ldquo;e\u0026rdquo;,\u0026ldquo;t\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;e\u0026rdquo;],[\u0026ldquo;i\u0026rdquo;,\u0026ldquo;h\u0026rdquo;,\u0026ldquo;k\u0026rdquo;,\u0026ldquo;r\u0026rdquo;],[\u0026ldquo;i\u0026rdquo;,\u0026ldquo;f\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;v\u0026rdquo;]], words = [\u0026ldquo;oath\u0026rdquo;,\u0026ldquo;pea\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;rain\u0026rdquo;] Output: [\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;oath\u0026rdquo;] Example 2:\nInput: board = [[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]], words = [\u0026ldquo;abcb\u0026rdquo;] Output: [] Example 3:\nInput: Output: Constraints:\nm == board.length n == board[i].length 1 \u0026lt;= m, n \u0026lt;= 12 board[i][j] is a lowercase English letter. 1 \u0026lt;= words.length \u0026lt;= 3 * 104 1 \u0026lt;= words[i].length \u0026lt;= 10 words[i] consists of lowercase English letters. All the strings of words are unique. 二、分析 這題是 [LeetCode] 79. Word Search 的進階題，是 google 愛考的題型，先考你一題基礎題型，再看你能不能進一步微調。如先考最短路徑的「步數」，再考你最短路徑的「路徑」，此種題型容易藏細節，如最短路徑「步數」可以用 bfs，當走到終點立即回傳，但當考題改成路徑時，就不能立即回傳，因為有可能會有多個最短路徑。 這題有許多剪枝技巧： word 的字長不可能大於 board 的總字數，即 m x n。 word 個別的字數需小於 board 各別的字數。 word 如果是重複的字元組成，則重複的字元擺在尾巴可以有分枝的效果。 即 aaaaaaabc 可以處理成，找 cbaaaaaaa。 注意在 search 中回傳 bool 值前，要記得將 backtrack 走完，以免影響其它組解。 三、解題 1. Backtracking Time complexity: \\(O(m\\times n\\times l)\\)，\\(m \\) 為 board.size()，\\(n\\) 為 board[0].size()，\\(l\\) 為 word.length() Space complexity: \\(O(m\\times n)\\) class Board { private: vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; board; int m, n; int cnt[26]; // 用於上、下、左、右 int dirc[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; // 用於剪枝1與剪枝2，在進行算法前，檢查其是否可能為錯，時間複雜度為 O(1)，所以可以大大降低耗時。 bool isWordNumValid(string\u0026amp; word) { if (word.length() \u0026gt; m * n) return false; // 剪枝1 int charNum[26] = {0}; for (char c : word) charNum[c-\u0026#39;a\u0026#39;]++; for (int i = 0; i \u0026lt; 26; i++) { if (charNum[i] \u0026gt; cnt[i]) return false; // 剪枝2 } return true; } void reverseIfNeeded(string\u0026amp; word) { int left = word.find_first_not_of(word[0]); // 左邊重複 int right = word.length() - word.find_last_not_of(word[word.length()-1]); // 右邊重複 if (left \u0026gt; right) reverse(word.begin(), word.end()); // 左邊重複較長，則翻轉字串 } bool backtrack(string\u0026amp; word, int row, int col, int i) { if (i == word.length()) return true; // 到達終止條件，回傳 true if (row \u0026lt; 0 || col \u0026lt; 0 || row \u0026gt;= m || col \u0026gt;= n || board[row][col] != word[i]) return false; // out of bound 或不符合 char tmp = board[row][col]; // 記錄原本的格子 board[row][col] = \u0026#39;#\u0026#39;; // 用 \u0026#39;#\u0026#39; 代表 visited，省去另外創一個 visited 來記錄是否拜訪過 for (const auto\u0026amp; d : dirc) if (backtrack(word, row+d[0], col+d[1], i+1)) { board[row][col] = tmp; // 記得將 backtrack 更動的部分走完，以免影響其它組解 return true; } board[row][col] = tmp; // 還原格子 return false; } public: Board(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board_) { this-\u0026gt;board = board_; this-\u0026gt;m = board_.size(); this-\u0026gt;n = board_[0].size(); memset(cnt, 0, sizeof(cnt)); for (const auto\u0026amp; row : board) { for (char c : row) { cnt[c-\u0026#39;a\u0026#39;]++; } } } bool search(string word) { for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (!isWordNumValid(word)) return false; reverseIfNeeded(word); if (backtrack(word, i, j, 0)) return true; } } return false; } }; class Solution { public: vector\u0026lt;string\u0026gt; findWords(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, vector\u0026lt;string\u0026gt;\u0026amp; words) { Board b(board); vector\u0026lt;string\u0026gt; res; for (const auto\u0026amp; word : words) { if (b.search(word)) res.push_back(word); } return res; } }; 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/212/","summary":"212. Word Search II\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、String、Backtracking、Trie、Matrix 一、題目 Given an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nExample 1:\nInput: board = [[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;],[\u0026ldquo;e\u0026rdquo;,\u0026ldquo;t\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;e\u0026rdquo;],[\u0026ldquo;i\u0026rdquo;,\u0026ldquo;h\u0026rdquo;,\u0026ldquo;k\u0026rdquo;,\u0026ldquo;r\u0026rdquo;],[\u0026ldquo;i\u0026rdquo;,\u0026ldquo;f\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;v\u0026rdquo;]], words = [\u0026ldquo;oath\u0026rdquo;,\u0026ldquo;pea\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;rain\u0026rdquo;] Output: [\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;oath\u0026rdquo;] Example 2:","title":"[LeetCode] 212. Word Search II"},{"content":"2131. Longest Palindrome by Concatenating Two Letter Words\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、String、Greedy、Counting 一、題目 You are given an array of strings words. Each element of words consists of two lowercase English letters.\nCreate the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.\nReturn the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.\nA palindrome is a string that reads the same forward and backward.\nExample 1:\nInput: words = [\u0026ldquo;lc\u0026rdquo;,\u0026ldquo;cl\u0026rdquo;,\u0026ldquo;gg\u0026rdquo;] Output: 6 Explanation: One longest palindrome is \u0026ldquo;lc\u0026rdquo; + \u0026ldquo;gg\u0026rdquo; + \u0026ldquo;cl\u0026rdquo; = \u0026ldquo;lcggcl\u0026rdquo;, of length 6. Note that \u0026ldquo;clgglc\u0026rdquo; is another longest palindrome that can be created. Example 2:\nInput: words = [\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;ty\u0026rdquo;,\u0026ldquo;yt\u0026rdquo;,\u0026ldquo;lc\u0026rdquo;,\u0026ldquo;cl\u0026rdquo;,\u0026ldquo;ab\u0026rdquo;] Output: 8 Explanation:: One longest palindrome is \u0026ldquo;ty\u0026rdquo; + \u0026ldquo;lc\u0026rdquo; + \u0026ldquo;cl\u0026rdquo; + \u0026ldquo;yt\u0026rdquo; = \u0026ldquo;tylcclyt\u0026rdquo;, of length 8. Note that \u0026ldquo;lcyttycl\u0026rdquo; is another longest palindrome that can be created. Example 3:\nInput: words = [\u0026ldquo;cc\u0026rdquo;,\u0026ldquo;ll\u0026rdquo;,\u0026ldquo;xx\u0026rdquo;] Output: 2 Explanation: One longest palindrome is \u0026ldquo;cc\u0026rdquo;, of length 2. Note that \u0026ldquo;ll\u0026rdquo; is another longest palindrome that can be created, and so is \u0026ldquo;xx\u0026rdquo;. Constraints:\n1 \u0026lt;= words.length \u0026lt;= 10^5 words[i].length == 2 words[i] consists of lowercase English letters. 二、分析 此題可以利用 HashTable 來記錄有多少配對成功。 s[0] == t[1] \u0026amp;\u0026amp; s[1] == t[0]，所以可以檢查 map.count(word[1] + word[0]) 是否有在。 特別注意當 s[0] == s[1] 的時候，可以單獨擺在中間對稱也能成立，但要注意配對過的不能算。 三、解題 1. Hash Table Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int longestPalindrome(vector\u0026lt;string\u0026gt;\u0026amp; words) { unordered_map\u0026lt;string, int\u0026gt; paired; unordered_set\u0026lt;string\u0026gt; twin; int cnt = 0; for (string\u0026amp; word : words) { if (word[0] == word[1]) { if (twin.count(word)) { twin.erase(word); cnt += 4; } else { twin.insert(word); } } else { string rev = {word[1], word[0]}; if (paired.count(rev) \u0026amp;\u0026amp; paired[rev] \u0026gt; 0) { paired[rev]--; cnt += 4; } else { paired[word]++; } } } return cnt + (!twin.empty() ? 2 : 0); } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2131/","summary":"2131. Longest Palindrome by Concatenating Two Letter Words\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、String、Greedy、Counting 一、題目 You are given an array of strings words. Each element of words consists of two lowercase English letters.\nCreate the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.\nReturn the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.","title":"[LeetCode] 2131. Longest Palindrome by Concatenating Two Letter Words"},{"content":"433. Minimum Genetic Mutation\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table、String、Breadth-First Search 一、題目 A gene string can be represented by an 8-character long string, with choices from A, C, G, and T.\nSuppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.\nFor example, \u0026quot;AACCGGTT\u0026quot; --\u0026gt; \u0026quot;AACCGGTA\u0026quot; is one mutation.\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings start and end and the gene bank bank, return the minimum number of mutations needed to mutate from start to end. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank. Example 1:\nInput: start = \u0026ldquo;AACCGGTT\u0026rdquo;, end = \u0026ldquo;AACCGGTA\u0026rdquo;, bank = [\u0026ldquo;AACCGGTA\u0026rdquo;] Output: 1 Example 2:\nInput: start = \u0026ldquo;AACCGGTT\u0026rdquo;, end = \u0026ldquo;AAACGGTA\u0026rdquo;, bank = [\u0026ldquo;AACCGGTA\u0026rdquo;,\u0026ldquo;AACCGCTA\u0026rdquo;,\u0026ldquo;AAACGGTA\u0026rdquo;] Output: 2 Example 3:\nInput: start = \u0026ldquo;AAAAACCC\u0026rdquo;, end = \u0026ldquo;AACCCCCC\u0026rdquo;, bank = [\u0026ldquo;AAAACCCC\u0026rdquo;,\u0026ldquo;AAACCCCC\u0026rdquo;,\u0026ldquo;AACCCCCC\u0026rdquo;] Output: 3 Constraints:\nstart.length == 8 end.length == 8 0 \u0026lt;= bank.length \u0026lt;= 10 bank[i].length == 8 start, end, and bank[i] consist of only the characters ['A', 'C', 'G', 'T']. 二、分析 用 BFS 的策略，可以找到最快到達的路徑。 相互比較 gene string 是否是相鄰(mutation)，效率不如取代字元再去找是否存在路徑。 三、解題 1. BFS Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) const string code = \u0026#34;ATCG\u0026#34;; int minMutation(string start, string end, vector\u0026lt;string\u0026gt;\u0026amp; bank) { unordered_set\u0026lt;string\u0026gt; set(bank.begin(), bank.end()); if (!set.count(end)) return -1; queue\u0026lt;string\u0026gt; q; q.push(start); int cnt = 0; while (!q.empty()) { int sz = q.size(); while (sz--) { string curr = q.front(); q.pop(); if (curr == end) return cnt; set.erase(curr); for (int i = 0; i \u0026lt; start.length(); i++) { string tmp = curr; for (char c : code){ tmp[i] = c; if (set.count(tmp)) q.push(tmp); } } } cnt++; } return -1; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/433/","summary":"433. Minimum Genetic Mutation\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table、String、Breadth-First Search 一、題目 A gene string can be represented by an 8-character long string, with choices from A, C, G, and T.\nSuppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.\nFor example, \u0026quot;AACCGGTT\u0026quot; --\u0026gt; \u0026quot;AACCGGTA\u0026quot; is one mutation.","title":"[LeetCode] 433. Minimum Genetic Mutation"},{"content":"20. Valid Parentheses\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String、Stack 一、題目 Given a string s containing just the characters (, ), {, }, [ and ], determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:\nInput: s = \u0026ldquo;()\u0026rdquo; Output: true Example 2:\nInput: s = \u0026ldquo;()[]{}\u0026rdquo; Output: true Example 3:\nInput: s = \u0026ldquo;(]\u0026rdquo; Output: false Constraints:\n1 \u0026lt;= s.length \u0026lt;= 10^4 s consists of parentheses only ()[]{}. 二、分析 利用 stack 來解題。 遇到左括號時，將括號推至 stack 上，\n遇到右括號時，確認 stack 頂端是否為對應的括號，否則回傳 false。 最後所有的括號都有配對到時，stack 必須為空。 三、解題 1. Stack Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) unordered_map\u0026lt;char,char\u0026gt; map = {{\u0026#39;[\u0026#39;,\u0026#39;]\u0026#39;}, {\u0026#39;(\u0026#39;,\u0026#39;)\u0026#39;}, {\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;}}; bool isValid(string s) { stack\u0026lt;char\u0026gt; st; for (int i = 0; i \u0026lt; s.length(); i++) { if (s[i] == \u0026#39;[\u0026#39; || s[i] == \u0026#39;(\u0026#39; || s[i] == \u0026#39;{\u0026#39;) { // 左括號推到 stack 上 st.push(s[i]); } else { if (st.empty() || s[i] != map[st.top()]) return false; // 右括號檢查 stack 是否有配對到 st.pop(); } } return st.empty(); // 檢查 stack 是否為空 } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/20/","summary":"20. Valid Parentheses\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String、Stack 一、題目 Given a string s containing just the characters (, ), {, }, [ and ], determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:","title":"[LeetCode] 20. Valid Parentheses"},{"content":"1706. Where Will the Ball Fall\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming、Depth-First Search、Matrix、Simulation 一、題目 You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.\nEach cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\nA board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1. A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as -1.\nWe drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball get stuck if it hits a \u0026ldquo;V\u0026rdquo; shaped pattern between two boards or if a board redirects the ball into either wall of the box.\nReturn an array answer of size n where answer[i] is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, or -1 if the ball gets stuck in the box. Example 1:\nInput: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]] Output: [1,-1,-1,-1,-1] Explanation: This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1. Example 2:\nInput: grid = [[-1]] Output: [-1] Explanation: The ball gets stuck against the left wall. Example 3:\nInput: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]] Output: [0,1,2,3,4,-1] Constraints:\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 100 grid[i][j] is 1 or -1. 二、分析 這一題根據題意，球在落下的過程中，若碰到v-型或是牆，都會被卡住，可以歸納出下面幾條規則：(假設以 col 代表球的位置) grid[row][0] == -1 與 grid[row][n-1] == 1 代表撞到牆 當 grid[row][col] == 1 且 grid[row][col+1] == 1 時球可以落下。\n或 grid[row][col] == -1 且 grid[row][col-1] == -1 時球可以落下。 三、解題 1. DP Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(n)\\) vector\u0026lt;int\u0026gt; findBall(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = grid[0].size(); vector\u0026lt;int\u0026gt; state; for (int col = 0; col \u0026lt; grid[0].size(); col++) state.push_back(col); // 初始化球當前的位置 for (auto\u0026amp; boards : grid) { for (int col = 0; col \u0026lt; n; col++) { if (state[col] == -1) continue; // 球已經卡住了 int\u0026amp; pos = state[col]; if ((pos == 0 \u0026amp;\u0026amp; boards[pos] == -1) || (pos == n-1 \u0026amp;\u0026amp; boards[pos] == 1)) // 撞牆 pos = -1; else if (boards[pos] == 1 \u0026amp;\u0026amp; boards[pos+1] == 1) // 球往右移 pos += 1; else if (boards[pos] == -1 \u0026amp;\u0026amp; boards[pos-1] == -1) // 球往左移 pos -= 1; else // 球卡住 pos = -1; } } return state; } 2. DFS Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(n)\\) int m, n; vector\u0026lt;int\u0026gt; findBall(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { m = grid.size(), n = grid[0].size(); vector\u0026lt;int\u0026gt; res(n); for (int col = 0; col \u0026lt; n; col++) { res[col] = dfs(grid, 0, col); } return res; } int dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int row, int col) { if (row == m) return col; // 終止條件: 落地 if (col \u0026lt; 0 || col \u0026gt;= n) return -1; // 撞牆 if (col+1 \u0026lt; n \u0026amp;\u0026amp; grid[row][col] == 1 \u0026amp;\u0026amp; grid[row][col+1] == 1) // 右移 return dfs(grid, row+1, col+1); if (col-1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[row][col] == -1 \u0026amp;\u0026amp; grid[row][col-1] == -1) // 左移 return dfs(grid, row+1, col-1); return -1; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1706/","summary":"1706. Where Will the Ball Fall\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Dynamic Programming、Depth-First Search、Matrix、Simulation 一、題目 You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.\nEach cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\nA board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.","title":"[LeetCode] 1706. Where Will the Ball Fall"},{"content":"766. Toeplitz Matrix\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Matrix 一、題目 Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.\nExample 1:\nInput: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] Output: true Explanation:\nIn the above grid, the diagonals are:\n\u0026ldquo;[9]\u0026rdquo;, \u0026ldquo;[5, 5]\u0026rdquo;, \u0026ldquo;[1, 1, 1]\u0026rdquo;, \u0026ldquo;[2, 2, 2]\u0026rdquo;, \u0026ldquo;[3, 3]\u0026rdquo;, \u0026ldquo;[4]\u0026rdquo;.\nIn each diagonal all elements are the same, so the answer is True. Example 2: Input: matrix = [[1,2],[2,2]] Output: false Explanation:\nThe diagonal \u0026ldquo;[1, 2]\u0026rdquo; has different elements. Constraints:\nm == matrix.length n == matrix[i].length 1 \u0026lt;= m, n \u0026lt;= 20 0 \u0026lt;= matrix[i][j] \u0026lt;= 99 Follow up:\nWhat if the matrix is store on disk, and the memory is limited such that you can only load at most one row of the matrix into memory at once? What if the matrix is so large that you can only load up a partial row into memory at once? 二、分析 根據題意，除了第一行與第一列外，逐個去檢查與左上角的值是否相同。 三、解題 1. Simple traversal Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(1)\\) bool isToeplitzMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int m = matrix.size(), n = matrix[0].size(); for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { if (matrix[i][j] != matrix[i-1][j-1]) return false; } } return true; } 2. Follow up #1: load at most one row Time complexity: \\(O(m\\times n)\\) Space complexity: \\(O(n)\\) bool isToeplitzMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { deque\u0026lt;int\u0026gt; buffer; for (int j = 0; j \u0026lt; matrix[0].size()-1; j++) buffer.push_back(matrix[0][j]); // 一次處理一行 for (int i = 1; i \u0026lt; matrix.size(); i++) { for (int j = 1; j \u0026lt; matrix[0].size(); j++) { if (buffer.front() != matrix[i][j]) return false; buffer.pop_front(); buffer.push_back(matrix[i][j]); } buffer.push_front(matrix[i][0]); buffer.pop_back(); } return true; } 3. Follow up #2: load partial row/column each time bool isToeplitzMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int m = matrix.size(), n = matrix[0].size(); queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; q; for (int i = m-1; i \u0026gt; 0; i--) q.push({i, 0}); for (int i = 0 ; i \u0026lt; n; i++) q.push({0, i}); while (!q.empty()) { auto info = q.front(); q.pop(); int row = info.first; int col = info.second; int val = matrix[row][col]; while (++row \u0026lt; m \u0026amp;\u0026amp; ++col \u0026lt; n) { if (matrix[row][col] != val) return false; } } return true; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/766/","summary":"766. Toeplitz Matrix\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Matrix 一、題目 Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.\nExample 1:\nInput: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] Output: true Explanation:\nIn the above grid, the diagonals are:\n\u0026ldquo;[9]\u0026rdquo;, \u0026ldquo;[5, 5]\u0026rdquo;, \u0026ldquo;[1, 1, 1]\u0026rdquo;, \u0026ldquo;[2, 2, 2]\u0026rdquo;, \u0026ldquo;[3, 3]\u0026rdquo;, \u0026ldquo;[4]\u0026rdquo;.\nIn each diagonal all elements are the same, so the answer is True.","title":"[LeetCode] 766. Toeplitz Matrix"},{"content":"19. Remove Nth Node From End of List\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List、Two Pointers 一、題目 Given the head of a linked list, remove the nth node from the end of the list and return its head.\nExample 1:\nInput: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:\nInput: head = [1], n = 1 Output: [] Example 3:\nInput: head = [1,2], n = 1 Output: [1] Constraints:\nThe number of nodes in the list is sz. 1 \u0026lt;= sz \u0026lt;= 30 0 \u0026lt;= Node.val \u0026lt;= 100 1 \u0026lt;= n \u0026lt;= sz 二、分析 這是經典的鏈表問題，可以先遍歷一遍求得鏈表長度後，再去要刪去的節點從頭數是第幾個節點，接著找到該節點的前一個節點，再刪去該節點。 更聰明的方法是使用前後指針，利用前指針先前進 n 步後，前後指針同時往前等速移動，後指針到達鏈表尾時，前指針正好指向從鏈表尾部數倒數第 n 個節點。 三、解題 1. Straight Forward Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(-1, head); int len = 0; ListNode* curr = head; while (curr) { // 先求鏈表長度 len++; curr = curr-\u0026gt;next; } len -= n; // 求欲刪除的節點往頭算是第幾個節點 curr = dummy; while (len--) curr = curr-\u0026gt;next; // 移動至該節點前 curr-\u0026gt;next = curr-\u0026gt;next-\u0026gt;next; // 移除節點 return dummy-\u0026gt;next; } 2. Two Pointers Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(-1, head); ListNode* fast = dummy, *slow = dummy; while (n--) fast = fast-\u0026gt;next; // 前指針先走 n 步 while (fast-\u0026gt;next) { // 前後指針等速移動至前指針走完 fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; // 移除節點 return dummy-\u0026gt;next; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/19/","summary":"19. Remove Nth Node From End of List\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List、Two Pointers 一、題目 Given the head of a linked list, remove the nth node from the end of the list and return its head.\nExample 1:\nInput: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:\nInput: head = [1], n = 1 Output: [] Example 3:\nInput: head = [1,2], n = 1 Output: [1] Constraints:","title":"[LeetCode] 19. Remove Nth Node From End of List"},{"content":"1293. Shortest Path in a Grid with Obstacles Elimination\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.\nReturn the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles. If it is not possible to find such walk return -1.\nExample 1:\nInput: grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1 Output: 6 Explanation:\nThe shortest path without eliminating any obstacle is 10.\nThe shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -\u0026gt; (0,1) -\u0026gt; (0,2) -\u0026gt; (1,2) -\u0026gt; (2,2) -\u0026gt; (3,2) -\u0026gt; (4,2). Example 2: Input: grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1 Output: -1 Explanation:\nWe need to eliminate at least two obstacles to find such a walk. Constraints:\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 40 1 \u0026lt;= k \u0026lt;= m * n grid[i][j] is either 0 or 1. grid[0][0] == grid[m - 1][n - 1] == 0 二、分析 本題可以搭配 BFS，最早滿足終止條件時，回傳即為最短路徑。 由於本題並非可以單純的藉 visited 來記錄是否拜訪過，因為多了一個變數 k，所以在此可以將 vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited 換成 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; visited，並將記錄的值改成剩餘可消除障礙物的次數，依 greedy 的想法，在走同樣的距離下，剩餘可消除障礙物的次數愈多愈好，故我們可將拜訪過，但「剩餘次數少於或等於 visited[row][col]」的節點跳過。 三、解題 1. BFS Time complexity: \\(O(m\\times n\\times k)\\) Space complexity: \\(O(m\\times n)\\) int dirc[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}; int shortestPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int k) { int m = grid.size(), n = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; visited(m, vector\u0026lt;int\u0026gt;(n, -1)); // 餘愈多愈好，故預設為 -1 queue\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; q; // {row, col, len, k} q.push({0,0,0,k}); while (!q.empty()) { auto info = q.front(); q.pop(); int row = info[0]; int col = info[1]; int len = info[2]; int bomb = info[3]; // 超出範圍 out of bound if (row \u0026lt; 0 || col \u0026lt; 0 || row \u0026gt;= m || col \u0026gt;= n) continue; // 終止條件，到達右下角 if (row == m-1 \u0026amp;\u0026amp; col == n-1) return len; // 遇到障礙物 if (grid[row][col] == 1) { if (bomb \u0026gt; 0) bomb--; else continue; } // 減枝：拜訪過且剩餘次數較少者跳過 if (visited[row][col] \u0026gt;= bomb) continue; visited[row][col] = bomb; // 將下一步加入佇列 for (const auto\u0026amp; d : dirc){ q.push({row+d[0], col+d[1], len+1, bomb}); } } return -1; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1293/","summary":"1293. Shortest Path in a Grid with Obstacles Elimination\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.\nReturn the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles.","title":"[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination"},{"content":"2136. Earliest Possible Day of Full Bloom\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Greedy、Sorting 一、題目 You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed take time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:\nplantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total. growTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever. From the beginning of day 0, you can plant the seeds in any order.\nReturn the earliest possible day where all seeds are blooming. Example 1:\nInput: plantTime = [1,4,3], growTime = [2,3,1] Output: 9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming. Example 2: Input: plantTime = [1,2,3,2], growTime = [2,1,2,1] Output: 9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming. Example 3:\nInput: plantTime = [1], growTime = [1] Output: 2 Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming. Constraints:\nn == plantTime.length == growTime.length 1 \u0026lt;= n \u0026lt;= 10^5 1 \u0026lt;= plantTime[i], growTime[i] \u0026lt;= 10^4 二、分析 想像所有花是先長再種，其邏輯是長的時間是嚴格連續的，而種的時間是自由彈性的，所以我們先確保盡可能的讓所以花同時有動作在進行，再去彈性安排種的時間，用貪心法求解。 要注意當有一種花的 growTime 非常大時，其解會被該物件決定，變為 growTime[x] + plantTime[x]，故解不是簡單的 accumulate(plantTime.begin(), plantTime.end(), 0) + *min_element(growTime.begin(), growTime.end())。 三、解題 1. Greedy Time complexity: \\(O(n\\log n)\\) Space complexity: \\(O(n)\\) int earliestFullBloom(vector\u0026lt;int\u0026gt;\u0026amp; plantTime, vector\u0026lt;int\u0026gt;\u0026amp; growTime) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; v; for (int i = 0; i \u0026lt; plantTime.size(); ++i) v.push_back({growTime[i], plantTime[i]}); sort(begin(v), end(v)); int res = 0; for (auto [g, p] : v) res = max(res, g) + p; return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2136/","summary":"2136. Earliest Possible Day of Full Bloom\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Greedy、Sorting 一、題目 You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed take time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:\nplantTime[i] is the number of full days it takes you to plant the ith seed.","title":"[LeetCode] 2136. Earliest Possible Day of Full Bloom"},{"content":"18. 4Sum\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointer、Sorting 一、題目 Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n0 \u0026lt;= a, b, c, d \u0026lt; n a, b, c and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Example 1:\nInput: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2:\nInput: nums = [2,2,2,2,2], target = 8 Output: [[2,2,2,2]] Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 200 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 -10^9 \u0026lt;= target \u0026lt;= 10^9 二、分析 延續之前的 2Sum 跟 3Sum，大於 3 以上的 kSum 問題其實都是依樣畫葫蘆，其時間複雜度為 \\(O(k-1)\\)。 先試改寫 2Sum，先前為了達到最優解，採用的是 HashMap 的策略，但對於 k\u0026gt;2 時，因時間複雜度為 \\(O(n^{k-1})\\)，採用 Sorting 的時間複雜度為 \\(O(n\\log n)\\)。故以下會採用 Two Pointer 搭配 sorting 的策略去解題， 首先我們可以假設數組是已排序的，並參考 3Sum 去改寫 2Sum，並回傳滿足條件數字組合(注意與原題目不同)，且數組不重覆且為數列不為遞減： vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target, int start) { // nums 為 sorted array vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; int left = start; // 注意 left pointer 是從 nums[i] 的下一位開始，即 i+1，我們將之訂為 start int right = nums.size()-1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum \u0026lt; target) { while (left+1 \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left+1]) left++; // 優化，跳過重覆的值 left++; } else if (sum \u0026gt; target) { while (right-1 \u0026gt; left \u0026amp;\u0026amp; nums[right-1] == nums[right]) right--; // 優化，跳過重覆的值 right--; } else { res.push_back({nums[left], nums[right]}); while (left+1 \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left+1]) left++; // 避免重覆數組 while (right-1 \u0026gt; left \u0026amp;\u0026amp; nums[right-1] == nums[right]) right--; // 避免重覆數組 left++; right--; } } return res; } 接下來要求 3Sum 就很簡單了，我們只需要做下列兩件事： sort 代入 target 與 start，其中 target 便是 for (int i = 0; i \u0026lt; nums.size()-k+1; i++) { // 注意上限為 n-k+1 target = -nums[i]; // 注意為負 } 統整為下，[LeetCode]15. 3Sum： vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()) // 注意需先 sort vector\u0026lt;vector\u0026lt;in\u0026gt;\u0026gt; res; for (int i = 0; i \u0026lt; nums.size()-2; i++) { int target = -nums[i]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets = twoSum(nums, target, i+1); for (vector\u0026lt;int\u0026gt;\u0026amp; subset : subsets) { res.push_back({nums[i]}); res.back().push_back(subset[0]); res.back().push_back(subset[1]); } while (i+1 \u0026lt; nums.size()-2 \u0026amp;\u0026amp; nums[i] == nums[i+1]) i++; } return res; } 接下來我們試著用上面 3Sum 改寫成最簡單版的 kSum： // 假設 nums 已為 sorted array，並配合題目限制將 target 改為 long long vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; kSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, long long target, int start, int k) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (nums.size() \u0026lt; k) return res; // 若數組本身小於 k，則無解 if (k == 2) return twoSum(nums, target, start); for (int i = start; i \u0026lt; nums.size()-k+1; i++) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets = kSum(nums, target-nums[i], i+1, k-1); for (vector\u0026lt;int\u0026gt;\u0026amp; subset : subsets) { res.push_back({nums[i]}); // 加入 nums[i] res.back().insert(end(res.back()), begin(subset), end(subset)); // 加入符合以 -nums[i] 為 target 的 (k-1)Sum } while (i+1 \u0026lt; nums.size()-k+1 \u0026amp;\u0026amp; nums[i] == nums[i+1]) i++; // 避免重覆數組解 } return res; } 三、解題 1. KSum Time complexity: \\(O(n^3)\\) Space complexity: \\(O(1)\\) vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(begin(nums), end(nums)); // 注意需先做排序 return kSum(nums, target, 0, 4); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; kSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, long long target, int start, int k) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (nums.size() \u0026lt; k) return res; // 若數組的大小小於 k 則無解 // #優化1: 數組已無剩餘數字可用 if (start == nums.size()) return res; // #優化2: 數組的最小值的 k 倍需大於 target，數組的最大值的 k 倍需小於 target，但用乘法會超出 int 範圍，故用除法 if (target/k \u0026lt; nums[start]|| target/4 \u0026gt; nums.back()) return res; if (k == 2) return twoSum(nums, target, start); for (int i = start; i \u0026lt; nums.size()-k+1; i++) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets = kSum(nums, target-nums[i], i+1, k-1); for (vector\u0026lt;int\u0026gt;\u0026amp; subset : subsets) { res.push_back({nums[i]}); // 加入 nums[i] res.back().insert(end(res.back()), begin(subset), end(subset)); // 加入符合以 -nums[i] 為 target 的 (k-1)Sum } while (i+1 \u0026lt; nums.size()-k+1 \u0026amp;\u0026amp; nums[i] == nums[i+1]) i++; // 避免重覆數組解 } return res; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target, int start) { // nums 為 sorted array vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; int left = start; // 注意 left pointer 是從 nums[i] 的下一位開始，即 i+1，我們將之訂為 start int right = nums.size()-1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum \u0026lt; target) { while (left+1 \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left+1]) left++; // 優化，跳過重覆的值 left++; } else if (sum \u0026gt; target) { while (right-1 \u0026gt; left \u0026amp;\u0026amp; nums[right-1] == nums[right]) right--; // 優化，跳過重覆的值 right--; } else { res.push_back({nums[left], nums[right]}); while (left+1 \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left+1]) left++; // 避免重覆數組 while (right-1 \u0026gt; left \u0026amp;\u0026amp; nums[right-1] == nums[right]) right--; // 避免重覆數組 left++; right--; } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/18/","summary":"18. 4Sum\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointer、Sorting 一、題目 Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n0 \u0026lt;= a, b, c, d \u0026lt; n a, b, c and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Example 1:\nInput: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2:","title":"[LeetCode] 18. 4Sum"},{"content":"17. Letter Combinations of a Phone Number\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table,String,Backtracking 一、題目 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExample 1:\nInput: digits = \u0026ldquo;23\u0026rdquo; Output: [\u0026ldquo;ad\u0026rdquo;,\u0026ldquo;ae\u0026rdquo;,\u0026ldquo;af\u0026rdquo;,\u0026ldquo;bd\u0026rdquo;,\u0026ldquo;be\u0026rdquo;,\u0026ldquo;bf\u0026rdquo;,\u0026ldquo;cd\u0026rdquo;,\u0026ldquo;ce\u0026rdquo;,\u0026ldquo;cf\u0026rdquo;] Example 2:\nInput: \u0026quot;\u0026quot; Output: [] Example 3:\nInput: \u0026ldquo;2\u0026rdquo; Output: [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;] Constraints:\n0 \u0026lt;= digits.length \u0026lt;= 4 digits[i] is a digit in the range ['2', '9']. 二、分析 DFS 演算法是在遍歷「節點」，而回溯法是在遍歷「樹枝」。站在一個節點上，需思考三個問題： 路徑(PATH)：已做出的選擇。 選項(OPTION)：當前可以做的選擇。 終止條件(TERMINATE)：到達決策樹的底層，無法再做其它選擇。 以下為回溯法的框架： vector\u0026lt;PATH\u0026gt; res; void backtrack(PATH, OPTION) { if (TERMINATE) { res.push_back(PATH); return; } for (CHOICE : OPTION) { DO OPTION; backtrack(PATH, OPTION); CANCEL OPTION; } } 三、解題 1. Backtracking Time complexity: \\(O(m\\times n)，\\text{m }為\\text{ digits }的長度，\\text{n }為\\text{ dict[i] }的長度\\)， Space complexity: \\(O(m\\times n)\\) vector\u0026lt;string\u0026gt; letterCombinations(string digits) { vector\u0026lt;string\u0026gt; dict = {\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; // 選項 vector\u0026lt;string\u0026gt; res; if (digits.empty()) return res; string path; // 路徑 backtrack(dict, res, path, digits); return res; } void backtrack(vector\u0026lt;string\u0026gt; dict, vector\u0026lt;string\u0026gt;\u0026amp; res, string\u0026amp; path, string\u0026amp; digits) { if (path.length() == digits.length()) { // 終止條件 res.push_back(path); // 記錄路徑 return; } int i = path.size(); string letters = dict[digits[i] - \u0026#39;0\u0026#39;]; for (char letter : letters) { path.push_back(letter); // 做選擇 backtrack(dict, res, path, digits); path.pop_back(); // 撤銷選擇 } } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/17/","summary":"17. Letter Combinations of a Phone Number\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table,String,Backtracking 一、題目 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExample 1:\nInput: digits = \u0026ldquo;23\u0026rdquo; Output: [\u0026ldquo;ad\u0026rdquo;,\u0026ldquo;ae\u0026rdquo;,\u0026ldquo;af\u0026rdquo;,\u0026ldquo;bd\u0026rdquo;,\u0026ldquo;be\u0026rdquo;,\u0026ldquo;bf\u0026rdquo;,\u0026ldquo;cd\u0026rdquo;,\u0026ldquo;ce\u0026rdquo;,\u0026ldquo;cf\u0026rdquo;] Example 2:","title":"[LeetCode] 17. Letter Combinations of a Phone Number"},{"content":"no. Hardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointers、Sorting 一、題目 Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closet to target.\nReturn *the sum of the three integers`.\nYou may assume that each input would have exactly one solution.\nExample 1:\nInput: nums = [-1,2,1,-4], target = 1 Output: 2 Explanation: The sum that is closet to the target is 2. (-1 + 2 + 1 = 2). Example 2:\nInput: nums = [0,0,0], target = 1 Output: 0 Explanation: The sum that is closet to the target is 0. (0 + 0 + 0 = 0). Constraints:\n3 \u0026lt;= nums.length \u0026lt;= 500 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 -10^4 \u0026lt;= target \u0026lt;= 10^4 二、分析 若用暴力解求解的話，時間複雜度為 \\(O(n^3)\\)。 故我們可以嘗試先進行排序來簡化問題，時間複雜度為\\(O(n\\log n)\\)。 此題因為是找最接近的，所以無法用 HashMap 解。 使用 Two Pointer，並藉由比較和與 target 的差值來找到最接近的解。 三、解題 1. Two Pointer Time complexity: \\(O(n^2)\\) Space complexity: \\(O(1)\\) int threeSumCloset(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int res = INT_MAX; int n = nums.size(); if (n == 3) return accumulate(nums.begin(), nums.end(), 0); // 當 n = 3 時，這三個值必為解。 sort(nums.begin(), nums.end()) // 排序 for (int i = 0; i \u0026lt; n-2; i++) { int left = i+1, right = n-1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (abs(res - target) \u0026gt; abs(sum - target)) res = sum; if (sum \u0026gt; target) { right--; } else if (sum \u0026lt; target) { left++; } else { return sum; // 差值等於 0 時，不會再有更小的差值 } } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/16/","summary":"no. Hardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointers、Sorting 一、題目 Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closet to target.\nReturn *the sum of the three integers`.\nYou may assume that each input would have exactly one solution.\nExample 1:\nInput: nums = [-1,2,1,-4], target = 1 Output: 2 Explanation: The sum that is closet to the target is 2.","title":"[LeetCode] 16. 3Sum Closet"},{"content":"15. 3Sum\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointer、Sorting 一、題目 Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation:\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter. Example 2:\nInput: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3:\nInput: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet does sum up to 0. Constraints:\n3 \u0026lt;= nums.length \u0026lt;= 3000 -10^5 \u0026lt;= nums[i] \u0026lt;= 10^5 二、分析 若用暴力解求解的話，時間複雜度為 \\(O(n^3)\\)。 故我們可以嘗試先進行排序來簡化問題，時間複雜度為\\(O(n\\log n)\\)。 方法 1: HashMap 可以參考 Leetcode no.1 Two Sum，相當於一個迴圈選定 nums[i] 為 target，其餘兩者 nums[j] + nums[k] 的和為 -target，那這題就簡化成 Two Sum 了，時間複雜度為 \\(O(n^2)\\)。 方法 2: Two Pointer 同樣一個迴圈選定 nums[i] 為 target，其餘兩者以 Two Pointer 搜尋已排序的數組。 需注意上如何避免重複數組解： HashMap 可以直接指定到 HashMap 存的索引，利用 HashMap 會覆蓋掉同一組 key 的 value。 Two Pointer 可以藉由指標指向同一個值時，便跳過，來避免重複數組解。 三、解題 1. HashMap Time complexity: \\(O(n^2)\\) Space complexity: \\(O(n)\\) vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()); // 排序 unordered_map\u0026lt;int,int\u0026gt; map; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for (int i = 0; i \u0026lt; nums.size(); i++) { map[nums[i]] = i; // 將值「最右邊」的索引記到 map 中 } for (int i = 0; i \u0026lt; nums.size()-2; i++) { for (int j = i+1; j \u0026lt; nums.size()-1; j++) { int toFind = -(nums[i] + nums[j]); if (toFind \u0026lt; 0) continue; // 若 nums[i] 與 num[j] 的和為正時，無解。 if (map.find(toFind) != map.end() \u0026amp;\u0026amp; map[toFind] \u0026gt; j) { // 注意 map 中找到的值的索引，必須比第二個值的索引大 res.push_back({nums[i], nums[j], toFind}); } j = map[nums[j]]; // 避免重複數組解 } i = map[nums[i]]; // 避免重複數組解 } return res; } 2. Two Pointer Time complexity: \\(O(n^2)\\) Space complexity: \\(O(1)\\) vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()); // 排序 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; for (int i = 0; i \u0026lt; nums.size()-2; i++) { if (nums[i] \u0026gt; 0) break; // 排序後，三數組中最小的值若為正，則無解 int j = i+1, k = nums.size()-1; while (j \u0026lt; k) { int sum = nums[i] + nums[j] + nums[k]; if (sum \u0026lt; 0) { // 三數組合小於零，左指標右移。 while (j+1 \u0026lt; k \u0026amp;\u0026amp; nums[j] == nums[j+1]) j++; // 優化，同樣的值不需重複檢查 j++; } else if (sum \u0026gt; 0) { // 三數組合大於零，右指標左移。 while (k-1 \u0026gt; j \u0026amp;\u0026amp; nums[k-1] == nums[k]) k--; // 優化，同樣的值不需重複檢查 k--; } else { res.push_back({nums[i], nums[j], nums[k]}); while (j+1 \u0026lt; k \u0026amp;\u0026amp; nums[j] == nums[j+1]) j++; // 避免重複數組解 while (k-1 \u0026gt; j \u0026amp;\u0026amp; nums[k-1] == nums[k]) k--; // 避免重複數組解 j++; k--; } } while (i+1 \u0026lt; nums.size()-2 \u0026amp;\u0026amp; nums[i] == nums[i+1]) i++; // 避免重複數組解 } return res; } 參考文章: [LeetCode] 18. 4Sum\n回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/15/","summary":"15. 3Sum\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointer、Sorting 一、題目 Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation:\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.","title":"[LeetCode] 15. 3Sum"},{"content":"14. Longest Common Prefix\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String 一、題目 Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \u0026quot;\u0026quot;.\nExample 1:\nInput: strs = [\u0026ldquo;flower\u0026rdquo;, \u0026ldquo;flow\u0026rdquo;, \u0026ldquo;flight\u0026rdquo;] Output: \u0026ldquo;fl\u0026rdquo; Example 2:\nInput: strs = [\u0026ldquo;dog\u0026rdquo;, \u0026ldquo;racecar\u0026rdquo;, \u0026ldquo;car\u0026rdquo;] Output: \u0026quot;\u0026quot; Explanation: There is no common prefix among the input strings. Constraints:\n1 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].length \u0026lt;= 200 strs[i] consists of only lowercase English letters. 二、分析 簡單的字串比對問題。 需熟悉 string 的函數 substr() 的使用方式，常用以下兩種 s.substr(int start, int len)，從 start 起取長度為 len 的子字串。 s.substr(int start) 從 start 起取到字串的結尾。 三、解題 1. String Time complexity: \\(O(m\\times n)，\\text{m }為\\text{ strs }的長度，\\text{n }為\\text{ strs[i] }的長度\\)， Space complexity: \\(O(1)\\) string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res = strs[0]; for (int i = 1; i \u0026lt; strs.size(); i++) { int j = 0; for (; j \u0026lt; min(strs[i].length(), res.length()); j++) { if (strs[i][j] != res[j]) break; } res = res.substr(0, j); } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/14/","summary":"14. Longest Common Prefix\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: String 一、題目 Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \u0026quot;\u0026quot;.\nExample 1:\nInput: strs = [\u0026ldquo;flower\u0026rdquo;, \u0026ldquo;flow\u0026rdquo;, \u0026ldquo;flight\u0026rdquo;] Output: \u0026ldquo;fl\u0026rdquo; Example 2:\nInput: strs = [\u0026ldquo;dog\u0026rdquo;, \u0026ldquo;racecar\u0026rdquo;, \u0026ldquo;car\u0026rdquo;] Output: \u0026quot;\u0026quot; Explanation: There is no common prefix among the input strings. Constraints:\n1 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].","title":"[Leetcode] 14. Longest Common Prefix"},{"content":"13. Roman to Integer\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.\n\\(\\boxed{\\begin{array}{ll} \\textbf{Symbol}\u0026amp;\\textbf{Value}\\\\ \\texttt{I}\u0026amp;1\\\\ \\texttt{V}\u0026amp;5\\\\ \\texttt{X}\u0026amp;10\\\\ \\texttt{L}\u0026amp;50\\\\ \\texttt{C}\u0026amp;100\\\\ \\texttt{D}\u0026amp;500\\\\ \\texttt{M}\u0026amp;1000\\\\ \\end{array}}\\)\nFor example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer. Example 1:\nInput: s = \u0026ldquo;III\u0026rdquo; Output: 3 Explanation: III = 3. Example 2:\nInput: s = \u0026ldquo;LVIII\u0026rdquo; Output: 58 Explanation: L = 50, V = 5, III = 3. Example 3:\nInput: s = \u0026ldquo;MCMXCIV\u0026rdquo; Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 15 s contains only the character ('I', 'V', 'X', 'L', 'C', 'D', 'M') It is guaranteed that s is a valid roman numeral in the range [1, 3999]. 二、分析 將字串從後往前分析，有助於解題。 I 可以當 1 也可以當 -1，當 -1 的情況是 I 的後面接的是 V 或是 X 時。 X 可以當 10 也可以當 -10，當 -10 的情況是 X 的後面接的是 V 或是 X 時。 C 可以當 100 也可以當 -100，當 -100 的情況是 C 的後面接的是 V 或是 X 時。 三、解題 1. Math Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int romanToInt(string s) { unordered_map\u0026lt;char,int\u0026gt; map = { {\u0026#39;I\u0026#39;, 1}, {\u0026#39;V\u0026#39;, 5}, {\u0026#39;X\u0026#39;, 10}, {\u0026#39;L\u0026#39;, 50}, {\u0026#39;C\u0026#39;, 100}, {\u0026#39;D\u0026#39;, 500}, {\u0026#39;M\u0026#39;, 1000} }; int res = 0; for (int i = s.length()-1; i \u0026gt;=0; i--) { if (res \u0026gt; 4*map[s[i]]) res -= map[s[i]]; else res += map[s[i]]; } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/13/","summary":"13. Roman to Integer\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.\n\\(\\boxed{\\begin{array}{ll} \\textbf{Symbol}\u0026amp;\\textbf{Value}\\\\ \\texttt{I}\u0026amp;1\\\\ \\texttt{V}\u0026amp;5\\\\ \\texttt{X}\u0026amp;10\\\\ \\texttt{L}\u0026amp;50\\\\ \\texttt{C}\u0026amp;100\\\\ \\texttt{D}\u0026amp;500\\\\ \\texttt{M}\u0026amp;1000\\\\ \\end{array}}\\)\nFor example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.","title":"[Leetcode] 13. Roman to Integer"},{"content":"835. Image Overlap\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Matrix 一、題目 You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.\nWe translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images. Note also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix bordered are erased.\nReturn the largest possible overlap.\nExample 1:\nInput: img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]] Output: 3 Explanation: We translate img1 to right by 1 unit and down by 1 unit.\nThe number of positions that have a 1 in both images is 3 (shown in red). Example 2:\nInput: img1 = [[1]], img2 = [[1]] Output: 1 Example 3:\nInput: img1 = [[0]], img2 = [[0]] Output: 0 Constraints:\nn == img1.length == img1[i].length n == img2.length == img2[i].length n \u0026lt;= n \u0026lt;= 30 img1[i][j] is either 0 or 1. img2[i][j] is either 0 or 1. 二、分析 注意到 n 的範圍是 1 \u0026lt;= n \u0026lt;= 30。 我們可以用 bit manipulation 的方式來處理這一題。 將 vector 轉為二進制數字(n \u0026lt; 31)： 如 {1,0,0,1,0,1} 轉換成 100101。 int masking(vector\u0026lt;int\u0026gt; vec) { int res = 0; for (int i = 0; i \u0026lt; n; i++) { if (vec[i]) res |= (1 \u0026lt;\u0026lt; (n-1-i)); } } 數二進制數字中有幾個 bit 為 1： int count(int bit) { int cnt = 0; while (bit) { bit -= (bit \u0026amp; -bit); cnt++; } return cnt; } 把 matrix 視為 n 列以二進位表示的數字。 故題目可以簡化成「求 bitset1 \u0026amp; bitset2 中的最大值」。 實作 upshift、downshift、leftshift、rightshift。 upshift、downshift 我們可以看作兩張 img 的 rows 相對移動，將移動後的 row 補 0 leftshift、rightshift 可以很簡單的靠 \u0026gt;\u0026gt; 運算子達成，但要注意用 \u0026lt;\u0026lt; 可能會超出範圍，但我們可以利用 img2 向左移將相當於 img1 向右移的性質來達成。 三、解題 1. Bit Manipulation Time complexity: \\(O(n^3)\\) Space complexity: \\(O(n)\\) // 計算 bit 為 1 的數目：O(1) int count(int bit) { int cnt = 0; while (bit) { bit -= (bit \u0026amp; -bit); cnt++; } return cnt; } // 將 matrix 轉為 2 進制數字的 array：O(n^2) vector\u0026lt;int\u0026gt; masking(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; img) { vector\u0026lt;int\u0026gt; res(img.size(), 0); for (int i = 0; i \u0026lt; img.size(); i++) { for (int j = 0; j \u0026lt; img[i].size(); j++) { if (img[i][j]) res[i] |= (1 \u0026lt;\u0026lt; j); } } return res; } int largestOverlap(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; img1, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; img2) { int n = img1.size(); if (n == 0) return 0; vector\u0026lt;int\u0026gt; mask1 = masking(img1); vector\u0026lt;int\u0026gt; mask2 = masking(img2); int res = 0; for (int v = -n+1; v \u0026lt; n; v++) { for (int h = 0; h \u0026lt; n; h++) { int cnt1 = 0; int cnt2 = 0; for (int i = 0; i \u0026lt; n; i++) { int bit1 = (i+v\u0026lt;0 || i+v\u0026gt;=n) ? 0 : mask1[i+v]; // bit 上下移，越界補 0 int bit2 = mask2[i]; cnt1 += count((bit1 \u0026gt;\u0026gt; h) \u0026amp; bit2); // bit1 右移 cnt2 += count((bit2 \u0026gt;\u0026gt; h) \u0026amp; bit1); // bit2 右移(視為 bit1 左移) } res = max({res, cnt1, cnt2}); } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/835/","summary":"835. Image Overlap\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Matrix 一、題目 You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.\nWe translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images.","title":"[Leetcode] 835. Image Overlap"},{"content":"12. Integer to Roman\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.\n\\(\\boxed{\\begin{array}{ll} \\textbf{Symbol}\u0026amp;\\textbf{Value}\\\\ \\texttt{I}\u0026amp;1\\\\ \\texttt{V}\u0026amp;5\\\\ \\texttt{X}\u0026amp;10\\\\ \\texttt{L}\u0026amp;50\\\\ \\texttt{C}\u0026amp;100\\\\ \\texttt{D}\u0026amp;500\\\\ \\texttt{M}\u0026amp;1000\\\\ \\end{array}}\\)\nFor example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.\nGiven an integer, convert it to a roman numeral. Example 1:\nInput: num = 3 Output: \u0026ldquo;III\u0026rdquo; Explanation: 3 is represented as 3 ones. Example 2:\nInput: num = 58 Output: \u0026ldquo;LVIII\u0026rdquo; Explanation: L = 50, V = 5, III = 3. Example 3:\nInput: num = 1994 Output: \u0026ldquo;MCMXCIV\u0026rdquo; Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints:\n1 \u0026lt;= num \u0026lt;= 3999 二、分析 既然 num 的範圍不大，我們可以利用其轉換的規律，直接用 Array 去定義。 三、解題 1. Math Time complexity: \\(O(1)\\) Space complexity: \\(O(1)\\) string intToRoman(int num) { string M[] = {\u0026#34;\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;MM\u0026#34;, \u0026#34;MMM\u0026#34;}; string C[] = {\u0026#34;\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;CC\u0026#34;, \u0026#34;CCC\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;DC\u0026#34;, \u0026#34;DCC\u0026#34;, \u0026#34;DCCC\u0026#34;, \u0026#34;CM\u0026#34;}; string X[] = {\u0026#34;\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XX\u0026#34;, \u0026#34;XXX\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;LX\u0026#34;, \u0026#34;LXX\u0026#34;, \u0026#34;LXXX\u0026#34;, \u0026#34;XC\u0026#34;}; string I[] = {\u0026#34;\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;II\u0026#34;, \u0026#34;III\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;VI\u0026#34;, \u0026#34;VII\u0026#34;, \u0026#34;VIII\u0026#34;, \u0026#34;IX\u0026#34;}; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/12/","summary":"12. Integer to Roman\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.\n\\(\\boxed{\\begin{array}{ll} \\textbf{Symbol}\u0026amp;\\textbf{Value}\\\\ \\texttt{I}\u0026amp;1\\\\ \\texttt{V}\u0026amp;5\\\\ \\texttt{X}\u0026amp;10\\\\ \\texttt{L}\u0026amp;50\\\\ \\texttt{C}\u0026amp;100\\\\ \\texttt{D}\u0026amp;500\\\\ \\texttt{M}\u0026amp;1000\\\\ \\end{array}}\\)\nFor example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.","title":"[Leetcode] 12. Integer to Roman"},{"content":"11. Container With Most Water\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointer、Greedy 一、題目 You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotive that you may not slant the container.\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example 2:\nInput: height = [1,1] Output: 1 Constraints:\nn == height.length 2 \u0026lt;= n \u0026lt;= 10^5 0 \u0026lt;= height[i] \u0026lt;= 10^4 二、分析 此題用 Greedy 與 Two Pointer 的方向來思考。 兩個垂直線相距愈遠且線高愈高，則兩線間可裝的水愈多。 兩垂直線間可裝的水，受限於線高較低者。 任兩線間(相距變小)，有任一解大於當下解，只有在有線高高於兩線線高較低者。 故我們每次移動線高較低的那邊。 兩線間可裝的水為： int calArea(vector\u0026lt;int\u0026gt;\u0026amp; height, int left, int right) { return min(height[left], height[right]) * (right - left); } 三、解題 1. Two Pointer Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) int calArea(vector\u0026lt;int\u0026gt;\u0026amp; height, int left, int right) { return min(height[left], height[right]) * (right - left); } int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int left = 0, right = height.size()-1; int res = 0; do { res = max(res, calArea(height, left, right)); if (height[left] \u0026lt; height[right]) left++; else right--; } while (left \u0026lt; right); return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/11/","summary":"11. Container With Most Water\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Two Pointer、Greedy 一、題目 You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.","title":"[Leetcode] 11. Container With Most Water"},{"content":"10. Regular Expression Matching\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: String、Dynamic Programming、Recursion 一、題目 Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n'.' Matches any single character. '*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial). Example 1:\nInput: s = \u0026ldquo;aa\u0026rdquo;, p = \u0026ldquo;a\u0026rdquo; Output: false Explanation: \u0026ldquo;a\u0026rdquo; does not match the entire string \u0026ldquo;aa\u0026rdquo;. Example 2:\nInput: s = \u0026ldquo;aa\u0026rdquo;, p = \u0026ldquo;a*\u0026rdquo; Output: true Explanation: \u0026lsquo;*\u0026rsquo; means zero or more of the preceding element, \u0026lsquo;a\u0026rsquo;. Therefore, by repeating \u0026lsquo;a\u0026rsquo; once, it becomes \u0026ldquo;aa\u0026rdquo;. Example 3:\nInput: s = \u0026ldquo;ab\u0026rdquo;, p = \u0026ldquo;.*\u0026rdquo; Output: true Explanation: \u0026ldquo;.*\u0026rdquo; means \u0026ldquo;zero or more (*) of any character (.)\u0026rdquo;. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 20 1 \u0026lt;= p.length \u0026lt;= 30 s contains only lowercase English letters. p contains only lowercase English letters, '.', and '*'. It is guaranteed for each appearance of the character '*', there will be a previous valid character to match. 二、分析 觀察規律： 當 p 為空時，若 s 不為空回傳 false， s 為空回傳 true。 當 p 不為空時，分為以下情況： 當 *p 為英文字元，則 *s 必定為相同的英文字元，否則回傳 false。 當 *p 為 . 時，則 *s 可以為任意英文字元。 當 *p 為 * 時，則 *s 可以為 ' '、前一相符的字合，在此稱為 firstMatch。 三、解題 1. DFS Time complexity: \\(O(C(m+n,m))，\\text{m }為\\text{ s }的長度，\\text{n }為\\text{ p }的長度\\)，\n\\(\\begin{array}{l} T(m,n)=T(m,n-2)+T(m-1,n-2)+T(m-2,n-2)+\u0026hellip;+T(1,n-2)\\\\ T(m-1,n)=T(m-1,n-2)+T(m-2,n-2)+\u0026hellip;+T(1,n-2)\\\\ T(m,n)=T(m-1,n)+T(m,n-2)\\\\ T(0,n)=n, T(m,0)=1\\\\ \\end{array}\\)\nSpace complexity: \\(O(C(m+n,m))\\)\nint m, n; string s, p; bool isMatch(string s, string p) { this-\u0026gt;s = s; this-\u0026gt;p = p; this-\u0026gt;m = s.length(); this-\u0026gt;n = p.length(); return dfs(0, 0); } // 分別對應到 s 的第 i 個字元與 p 的第 j 個字元 bool dfs(int i, int j) { // 當 p 為空時，若 s 不為空回傳 false，s 為空回傳 true。 if (j == n) return i == m; // firstMatch 的情形 bool firstMatch = i \u0026lt; m \u0026amp;\u0026amp; (s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;); // *p 為 \u0026#39;*\u0026#39; 的情形 if (j+1 \u0026lt; n \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;) return dfs(i, j+2) || (firstMatch \u0026amp;\u0026amp; dfs(i+1, j)); return firstMatch \u0026amp;\u0026amp; dfs(i+1, j+1); } 2. DFS + DP(Top Bottom) Time complexity: \\(O(m\\times n)，\\text{m }為\\text{ s }的長度，\\text{n }為\\text{ p }的長度\\)， Space complexity: \\(O(m\\times n)\\) int m, n; string s, p; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; bool isMatch(string s, string p) { this-\u0026gt;m = s.length(); this-\u0026gt;n = p.length(); this-\u0026gt;s = s; this-\u0026gt;p = p; dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(m+1, vector\u0026lt;int\u0026gt;(n+1, -1)); // 用 dp[i][j] 記錄 s 前進 i 位與 p 前進 j 位的狀況 return dfs(0, 0); } bool dfs(int i, int j) { if (dp[i][j] != -1) return dp[i][j]; if (j == n) { dp[i][j] = i == m; return dp[i][j]; } bool firstMatch = i \u0026lt; m \u0026amp;\u0026amp; (s[i] == p[j] || p[j] == \u0026#39;.\u0026#39;); if (j+1 \u0026lt; n \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39;) dp[i][j] = dfs(i, j+2) || (firstMatch \u0026amp;\u0026amp; dfs(i+1, j)); else dp[i][j] = firstMatch \u0026amp;\u0026amp; dfs(i+1, j+1); return dp[i][j]; } 3. DP (Bottom Up) Time complexity: \\(O(m\\times n)，\\text{m }為\\text{ s }的長度，\\text{n }為\\text{ p }的長度\\)， Space complexity: \\(O(m\\times n)\\) bool isMatch(string s, string p) { int m = s.length(), n = p.length(); if (n == 0) return m == 0; bool dp[m+1][n+1]; memset(dp, false, sizeof(dp)); dp[0][0] = true; for (int i = 2; i \u0026lt;= n; i++) { if (p[i-1] == \u0026#39;*\u0026#39;) { dp[0][i] = dp[0][i-2]; } } for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (s[i-1] == p[j-1] || p[j-1] == \u0026#39;.\u0026#39;) { dp[i][j] = dp[i-1][j-1]; } else if (p[j-1] == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j-2] || ((s[i-1] == p[j-2] || p[j-2] == \u0026#39;.\u0026#39;) \u0026amp;\u0026amp; dp[i-1][j]); } } } return dp[m][n]; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/10/","summary":"10. Regular Expression Matching\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: String、Dynamic Programming、Recursion 一、題目 Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n'.' Matches any single character. '*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial). Example 1:\nInput: s = \u0026ldquo;aa\u0026rdquo;, p = \u0026ldquo;a\u0026rdquo; Output: false Explanation: \u0026ldquo;a\u0026rdquo; does not match the entire string \u0026ldquo;aa\u0026rdquo;.","title":"[Leetcode] 10. Regular Expression Matching"},{"content":"9. Palindrome Number\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math 一、題目 Given an integer x, return true if x is palindrome number.\nAn integer is a palindrome when it reads the same backward as forward.\nFor example, 121 is a palindrome while 123 is not. Example 1:\nInput: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left. Example 2:\nInput: x = -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:\nInput: x = 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Constraints:\n-2^31 \u0026lt;= x \u0026lt;= 2^31-1 Follow up: Could you solve it without converting the integer to a string?\n二、分析 若直接將數字轉換成 string，即可當作 palindrome string 的題目來處理，但題目在 follow up 規定不可以轉成 string，那我們可以嘗試用翻轉數字的方式來解題。 注意此處我們讓 rev \u0026lt;= x 時為終止條件 while (x \u0026gt; rev) { rev = 10 * rev + x % 10; x /= 10; } 觀察可得 x \u0026lt; 0 必非 palindrome x \u0026lt; 10 必為 palindrome x % 10 == 0 必非 palindrome 翻轉數字時，注意數字長可能為奇數或偶數，故 當偶數長時，翻轉到等長時，rev == x 時為 palindrome。 當奇數長時，翻轉到 rev 比 x 多一位時，若 rev/10 == x 時為 palindrome。 時間複雜度 \\(O(n)\\)，\\(n\\) 為 10 的冪次的絕對值，故 \\(O(n)=O(31)=O(1)\\)。 三、解題 1. Math Time complexity: \\(O(1)\\) Space complexity: \\(O(1)\\) bool isPalindrome(int x) { if (x \u0026lt; 0) return false; if (x \u0026lt; 10) return true; if (x % 10 == 0) return false; int rev = 0; while (x \u0026gt; rev) { rev = 10 * rev + x % 10; x /= 10; } return rev == x || rev/10 == x; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/9/","summary":"9. Palindrome Number\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Math 一、題目 Given an integer x, return true if x is palindrome number.\nAn integer is a palindrome when it reads the same backward as forward.\nFor example, 121 is a palindrome while 123 is not. Example 1:\nInput: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left. Example 2:\nInput: x = -121 Output: false Explanation: From left to right, it reads -121.","title":"[Leetcode] 9. Palindrome Number"},{"content":"8. String to Integer (atoi)\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String 一、題目 Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++\u0026rsquo;s atoi function).\nThe algorithm for myAtoi(string s) is as follows:\nRead in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. Convert these digits into an integer (i.e. \u0026quot;123\u0026quot; -\u0026gt; 123, \u0026quot;0032\u0026quot; -\u0026gt; 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). If the integer is out of the 32-bit signed integer range [-2^31, 2^31-1], then clamp the integer so that it remains in the range. Specifically, integers less than -2^31 should be clamped to -2^31, and integer greater than 2^31-1 should be clamped to 2^31-1. Return the integer as the final result. Note:\nOnly the space character ' ' is considered a whitespace character. Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. Example 1:\nInput: s = \u0026ldquo;42\u0026rdquo; Output: 42 Explanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \u0026ldquo;42\u0026rdquo; (no characters read because there is no leading whitespace) Step 2: \u0026ldquo;42\u0026rdquo; (no characters read because there is neither a \u0026lsquo;-\u0026rsquo; nor \u0026lsquo;+\u0026rsquo;)\nStep 3: \u0026ldquo;42\u0026rdquo; (\u0026ldquo;42\u0026rdquo; is read in)\nThe parsed integer is 42.\nSince 42 is in the range [-2^31, 2^31 - 1], the final result is 42. Example 2:\nInput: s = \u0026quot; -42\u0026quot; Output: -42 Explanation:\nStep 1: \u0026quot; -42\u0026quot; (leading whitespace is read and ignored)\nStep 2: \u0026quot; -42\u0026quot; (\u0026rsquo;-\u0026rsquo; is read, so the result should be negative)\nStep 3: \u0026quot; -42\u0026quot; (\u0026ldquo;42\u0026rdquo; is read in)\nThe parsed integer is -42.\nSince -42 is in the range [-2^31, 2^31 - 1], the final result is -42. Example 3:\nInput: s = \u0026ldquo;4193 with words\u0026rdquo; Output: 4193 Explanation:\nStep 1: \u0026ldquo;4193 with words\u0026rdquo; (no characters read because there is no leading whitespace)\nStep 2: \u0026ldquo;4193 with words\u0026rdquo; (no characters read because there is neither a \u0026lsquo;-\u0026rsquo; nor \u0026lsquo;+\u0026rsquo;)\nStep 3: \u0026ldquo;4193 with words\u0026rdquo; (\u0026ldquo;4193\u0026rdquo; is read in; reading stops because the next character is a non-digit)\nThe parsed integer is 4193.\nSince 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193. Constraints:\n0 \u0026lt;= s.length \u0026lt;= 200 s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'. 二、分析 此題只需根據條件一一去排除： 處理 leading spaces 判斷 s[0] 處理超過範圍 [-2^31, 2^31-1] 的數 處理終止條件 可代入幾個處理字串常用的自訂函式： 判斷是否為英文字母 isLetter() bool isLetter(char c) { return (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) || (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;); } 判斷是否為數字 isDigit() bool isDigit(char c) { return c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } 去除左邊空白、右邊空白 ltrim()、rtrim() void ltrim(string\u0026amp; s) { s.erase( s.begin(), find_if(s.begin(), s.end(), not1(ptr_fun\u0026lt;int, int\u0026gt;(isspace))) ); } void rtrim(string\u0026amp; s) { s.erase( find_if(s.rbegin(), s.rend(), not1(ptr_fun\u0026lt;int, int\u0026gt;(isspace))).base(), s.end() ); } 分隔 split() vector\u0026lt;string\u0026gt; split(string\u0026amp; s, char del) { stringstream ss(str); string item; vector\u0026lt;string\u0026gt; res; while (getline(ss, item, del)) if (!item.empty()) res.push_back(item); return res; } 合併 concat() string concat(vector\u0026lt;string\u0026gt;\u0026amp; svec, char del) { stringstream ss; for (const auto\u0026amp; s : svec) ss \u0026lt;\u0026lt; s \u0026lt;\u0026lt; del; return ss.str(); } 三、解題 1. String Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) // 判斷是否為英文字母 bool isLetter(char c) { return (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) || (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;); } // 判斷是否為數字 bool isDigit(char c) { return c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } // 去除左邊空白 void ltrim(string\u0026amp; s) { s.erase( s.begin(), find_if(s.begin(), s.end(), not1(ptr_fun\u0026lt;int, int\u0026gt;(isspace))) ); } int myAtoi(string s) { int res = 0; // 去除左邊空白 ltrim(s); // 判斷 s[0]，取正負值 bool neg = false; if (s[0] == \u0026#39;-\u0026#39;) neg = true; else if (isEnglish(s[0]) || s[0] == \u0026#39;.\u0026#39;) return 0; else if (isDigit(s[0])) res += (s[0] - \u0026#39;0\u0026#39;); for (int i = 1; i \u0026lt; s.length(); i++) { // 終止條件：不再是數字 if (!isDigit(s[i])) break; // 超出數字範圍 if (neg \u0026amp;\u0026amp; (res \u0026lt; INT_MIN/10 || (res == INT_MIN/10 \u0026amp;\u0026amp; s[i] == \u0026#39;9\u0026#39;))) return INT_MIN; else if (!neg \u0026amp;\u0026amp; (res \u0026gt; INT_MAX/10 || (res == INT_MAX/10 \u0026amp;\u0026amp; s[i] \u0026gt;= \u0026#39;8\u0026#39;))) return INT_MAX; // 累計數值 if (neg) res = 10 * res - (s[i] - \u0026#39;0\u0026#39;); else res = 10 * res + (s[i] - \u0026#39;0\u0026#39;); } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/8/","summary":"8. String to Integer (atoi)\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String 一、題目 Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++\u0026rsquo;s atoi function).\nThe algorithm for myAtoi(string s) is as follows:\nRead in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either.","title":"[Leetcode] 8. String to Integer (atoi)"},{"content":"7. Reverse Integer\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Math 一、題目 Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31-1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nInput: x = 123 Output: 321 Example 2:\nInput: x = -123 Output: -321 Example 3:\nInput: 120 Output: 21 Constraints:\n-2^31 \u0026lt;= x \u0026lt;= 2^31-1 二、分析 考慮最簡單的翻轉數字為： int reverse(int x) { int res = 0; while (x) { res = res * 10 + x % 10; x /= 10; } return res; } 此題的難點在於邊界條件： 若答案超出 [-2^31, 2^31-1] 的範圍，則回傳 0。 不可用 64-bit integer(long)。 我們可以考慮幾個 testcases 來測試邊界條件，如： 2147483647(INT_MAX) \\(\\rightarrow\\) 回傳 0 當 x \u0026gt; 0時，在 res * 10 之前，若 x \u0026gt;= 8，則超出範圍。 -2147483648(INT_MIN) \\(\\rightarrow\\) 回傳 0 當 x \u0026lt; 0時，在 res * 10 之前，若 x == -9，則超出範圍。 時間複雜度 \\(O(n)\\)，\\(n\\) 為 10 的冪次的絕對值，故 \\(O(n)=O(31)=O(1)\\)。 三、解題 1. Math Time complexity: \\(O(1)\\) Space complexity: \\(O(1)\\) int reverse(int x) { int res = 0; while (x) { // 考慮邊界條件 if (res \u0026lt; INT_MIN/10 || (res == INT_MIN/10 \u0026amp;\u0026amp; x == -9)) return 0; else if (res \u0026gt; INT_MAX/10 || (res == INT_MAX/10 \u0026amp;\u0026amp; x \u0026gt;= 8 )) return 0; // 一般的數字翻轉 res = res * 10 + x % 10; x /= 10; } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/7/","summary":"7. Reverse Integer\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Math 一、題目 Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31-1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nInput: x = 123 Output: 321 Example 2:\nInput: x = -123 Output: -321 Example 3:","title":"[Leetcode] 7. Reverse Integer"},{"content":"6. Zigzag Conversion\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String 一、題目 The string \u0026quot;PAYPALISHIRING\u0026quot; is written in a zigzag pattern on a given number of rows like this: (you may want to dispaly this pattern in a fixed font for better legibility)\n\\( \\quad\\texttt{P A H N}\\\\ \\quad\\texttt{APLSIIG}\\\\ \\quad\\texttt{Y I R}\\\\ \\)\nAnd then read line by line: \u0026quot;PAHNAPLSIIGYIR\u0026quot;\nWrite the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows\nExample 1:\nInput: s = \u0026ldquo;PAYPALISHIRING\u0026rdquo;, numRows = 3 Output: \u0026ldquo;PAHNAPLSIIGYIR\u0026rdquo; Example 2:\nInput: s = \u0026ldquo;PAYPALISHIRING\u0026rdquo;, numRows = 3 Output: \u0026ldquo;PINALSIGYAHRPI\u0026rdquo; Explanation:\n\\( \\quad\\texttt{P　I　N}\\\\ \\quad\\texttt{A LS IG}\\\\ \\quad\\texttt{YA HR}\\\\ \\quad\\texttt{P　I}\\\\ \\) Example 3:\nInput: s = \u0026ldquo;A\u0026rdquo;, numRows = 1 Output: \u0026ldquo;A\u0026rdquo; Constraints:\n1 \u0026lt;= s.length \u0026lt;= 1000 s consists of English letters (lower-case and upper-case), ',' amd '.'. 1 \u0026lt;= numRows \u0026lt;= 1000\u0026gt; 二、分析 創建 numRows 個 vectors，依照，用一個 k 控制當下的字元要放到哪一個 vector 中。 用一個 unit 來控制 k 要往上走還是往下走。 按照規律，當 k + unit 為 numRows 與 -1 時，unit 要正負翻轉。 特例：當 numRows 等於 1 時，輸出等於輸入。 三、解題 1. Array Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) string convert(string s, int numRows) { if (numRows == 1) return s; vector\u0026lt;string\u0026gt; rows(numRows); int unit = 1; int k = 0; for (int i = 0; i \u0026lt; s.length(); i++) { if (k + unit == numRows || k + unit == -1) unit *= -1; rows[k].push_back(s[i]); k += unit; } string res; for (string\u0026amp; s : rows) res += s; return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/6/","summary":"6. Zigzag Conversion\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String 一、題目 The string \u0026quot;PAYPALISHIRING\u0026quot; is written in a zigzag pattern on a given number of rows like this: (you may want to dispaly this pattern in a fixed font for better legibility)\n\\( \\quad\\texttt{P A H N}\\\\ \\quad\\texttt{APLSIIG}\\\\ \\quad\\texttt{Y I R}\\\\ \\)\nAnd then read line by line: \u0026quot;PAHNAPLSIIGYIR\u0026quot;\nWrite the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows","title":"[Leetcode] 6. Zigzag Conversion"},{"content":"5. Longest Substring Without Repeating Characters\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String、Dynamic Programming 一、題目 Given a string s, return the longest palindromic substring in s.\nA string is called a palindrome string if the reverse of that string is the same of the original string.\nExample 1:\nInput: s = \u0026ldquo;babad\u0026rdquo; Output: \u0026ldquo;bab\u0026rdquo; Explanation: \u0026ldquo;aba\u0026rdquo; is also a valid answer. Example 2:\nInput: s = \u0026ldquo;cbbd\u0026rdquo; Output: \u0026ldquo;bb\u0026rdquo; Constraints:\n1 \u0026lt;= s.length \u0026lt;= 1000 s consists of only digits and English letters. 二、分析 注意 palindrome string 的特性： 當長度為 1 時，必為 palindrome string 當長度為 2 時，兩個字元必須相同才為 palindrome string 當長度 \u0026gt;2 時，palindrome string 必須滿足 最左邊的字元等於最右邊的字元，即 s[left] == s[right] 除去最左邊的字元跟最右邊的字元，必須為 palindrome string，\n即 s.substr(left+1, len-2) 為 palindromic。 三、解題 1. Dynamic Prograimming Time complexity: \\(O(n^2)\\) Space complexity: \\(O(n^2)\\) string longestPalindrome(string s) { int n = s.length(); string res; bool dp[n][n]; memset(dp, false, sizeof(dp)); int len = 0; for (int j = 0; j \u0026lt; n; j++) { for (int i = 0; i \u0026lt;= j; i++) { if (i == j) { // 長度為 1 dp[i][j] = true; } else if (j - i == 1) { // 長度為 2 dp[i][j] = s[i] == s[j]; } else { // 長度 \u0026gt; 2 dp[i][j] = s[i] == s[j] \u0026amp;\u0026amp; dp[i+1][j-1]; } if (dp[i][j] \u0026amp;\u0026amp; j - i + 1 \u0026gt; len) { // 比較長度 len = j - i + 1; res = s.substr(i, len); } } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/5/","summary":"5. Longest Substring Without Repeating Characters\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: String、Dynamic Programming 一、題目 Given a string s, return the longest palindromic substring in s.\nA string is called a palindrome string if the reverse of that string is the same of the original string.\nExample 1:\nInput: s = \u0026ldquo;babad\u0026rdquo; Output: \u0026ldquo;bab\u0026rdquo; Explanation: \u0026ldquo;aba\u0026rdquo; is also a valid answer. Example 2:\nInput: s = \u0026ldquo;cbbd\u0026rdquo; Output: \u0026ldquo;bb\u0026rdquo; Constraints:\n1 \u0026lt;= s.","title":"[LeetCode] 5. Longest Palindromic Substring"},{"content":"4. Median of Two Sorted Arrays\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Binary Search、Divide and Conquer 一、題目 Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nInput: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2:\nInput: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5. Constraints:\nnums1.length == m nums2.length == n 0 \u0026lt;= m \u0026lt;= 1000 0 \u0026lt;= n \u0026lt;= 1000 -10^6 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10^6 二、分析 這題用暴力解，先兩個數組合併後再求值，其時間複雜度為 \\(O(m+n)\\)。不符合題目要求。 因為兩個數組為已排序的數組，故我們可以利用其性質： nums1 中第 k 個元素表示有 k-1 個數比它還小。 故我們可以用分治法去處理這個問題， 求第 kth 個元素。 若 nums1 中前 3 個數確定小於 median 值，則我們可以視為求第 k-3 個數 \\(\\texttt{[1,2,3,3,4]}\\) 求 9 個數中的第 5 小的數\n\\(\\text{}\\uparrow\\)\n\\(\\texttt{[2,4,6,8]}\\)\n\\(\\text{}\\uparrow\\) \\(\\texttt{[1,2,3,3,4]}\\) 求剩下 6 個數中的第 2 小的數\n\\(\\text{　}\\uparrow\\)\n\\(\\texttt{[2,4,6,8]}\\)\n\\(\\text{}\\uparrow\\) 如此一來，我們每次可以逼進 Median 的個數為 log(m)或 log(n)，也就是說時間複雜度降為 \\(O(\\log(m+n))\\) 或是我們也可以將 num1 與 nums2 各別分為兩個子數組，並以長度較小的數組來切(可以降低時間複雜度)。 \\(\\texttt{[1,2|3,4]}\\) \\(\\texttt{[2,4|6,8,9]}\\) 其切割線左右的四個值 l1、l2、r1、r2 符合以下性質時可求得 median l1 \u0026lt;= r2 l2 \u0026lt;= r1 奇數時為 max(l1, l2) 偶數時為 max(l1, l2) + min(r1,r2) 的平均 三、解題 1. Brute Method Time complexity: \\(O(m+n)\\) Space complexity: \\(O(m+n)\\) double findMedianSortedArray(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int m = nums1.size(), n = num2.size(); vector\u0026lt;int\u0026gt; nums; // 先將兩個數組 merge 後再求 median int i = 0, j = 0; while (i \u0026lt; m \u0026amp;\u0026amp; j \u0026lt; n) { if (nums1[i] \u0026lt; nums2[j]) nums.push_back(nums1[i++]); else nums.push_back(nums2[j++]); } while (i \u0026lt; m) nums.push_back(nums1[i++]); while (j \u0026lt; n) nums.push_back(nums2[j++]); int len = nums.size(); // 若數組長度為奇數則回傳中間的值，若為偶數則為中間兩數的平均。 return (len \u0026amp; 1) ? (nums[len/2]/1.0) : (nums[len/2-1] + nums[len/2])/2.0; } 2. Kth Element Time complexity: \\(O(\\log(m+n))\\) Space complexity: \\(O(1)\\) vector\u0026lt;int\u0026gt; nums1, nums2 int m, n; // nums1 確定有 i 個元素小於 median，nums2 中確定有 j 個元素小於 median，求第 k 個元素 double kth(int i, int j, int k) { if (i == m) return nums2[j+k-1]; // nums1 用完了，直接對 nums2 取第 j+k 個元素 if (j == n) return nums1[i+k-1]; // nums2 用完了，直接對 nums1 取第 i+k 個元素 if (k == 1) return min(nums1[i], nums2[j]); //當前比較小的即為第 k 個元素 int mid1 = (i+k/2-1) \u0026gt;= m ? INT_MAX : nums1[i+k/2-1]; int mid2= (i+k/2-1) \u0026gt;= n ? INT_MAX : unms2[j+k/2-1]; // 兩個數組都往前推 k/2 個，其當前值較小的，其數組前 k/2 個數必定小於 median if (mid1 \u0026lt; mid2) return kth(i+k/2, j, k-k/2); else return kth(i, j+k/2, k-k/2); } double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { this-\u0026gt;nums1 = nums1; this-\u0026gt;nums2 = nums2; this-\u0026gt;m = nums1.size(); this-\u0026gt;n = nums2.size(); int len = m + n; // 若數組長度為奇數則回傳中間的值，若為偶數則為中間兩數的平均。 if (len \u0026amp; 1) return kth(0, 0, len/2+1)/1.0; return (kth(0, 0, len/2) + kth(0, 0, len/2+1))/2.0; } 3. Binary Search Time complexity: \\(O(\\log(\\text{min}(m+n)))\\) Space complexity: \\(O(1)\\) double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int m = nums1.size(), n = nums2.size(); int len = m + n; // 確保 nums1 的長度比較短，以減少時間複雜度 if (m \u0026gt; n) return findMedianSortedArrays(nums2, nums1); int l = 0, r = m; int l1, l2, r1, r2; // binary search while (l \u0026lt;= r) { int cut1 = (l+r)/2; int cut2 = (len+1)/2 - cut1; // 注意 len+1 l1 = cut1 == 0 ? INT_MIN : nums1[cut1-1]; l2 = cut2 == 0 ? INT_MIN : nums2[cut2-1]; r1 = cut1 == m ? INT_MAX : nums1[cut1]; r2 = cut2 == n ? INT_MAX : nums2[cut2]; if (l1 \u0026lt;= r2 \u0026amp;\u0026amp; l2 \u0026lt;= r1) { // median 必定為 l1 或 l2 break; } else if (l1 \u0026gt; r2) { r = cut1-1; } else { l = cut1+1; } } if (len \u0026amp; 1) return max(l1, l2)/1.0; return (max(l1, l2) + min(r1, r2))/2.0; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/4/","summary":"4. Median of Two Sorted Arrays\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Array、Binary Search、Divide and Conquer 一、題目 Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nInput: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2:\nInput: nums1 = [1,2], nums2 = [3,4] Output: 2.","title":"[LeetCode] 4. Median of Two Sorted Arrays"},{"content":"3. Longest Substring Without Repeating Characters\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table、String、Sliding Window 一、題目 Given a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = \u0026ldquo;abcabcbb\u0026rdquo; Output: 3 Explanation: The answer is \u0026ldquo;abc\u0026rdquo;, with the length of 3. Example 2:\nInput: s = \u0026ldquo;bbbbb\u0026rdquo; Output: 1 Explanation: The answer is \u0026ldquo;b\u0026rdquo;, with the length of 1. Example 3:\nInput: s = \u0026ldquo;pwwkew\u0026rdquo; Output: 3 Explanation: The answer is \u0026ldquo;wke\u0026rdquo;, with the length of 3. Notice that the answer must be a substring, \u0026ldquo;pwke\u0026rdquo; is a subsequence and not a substring. Constraints:\n0 \u0026lt;= s.length \u0026lt;= 5 * 10^4 s consists of English letters, digits, symbols and spaces. 二、分析 這題是 Sliding Window 的應用，創建一個 sliding window，右指標滑動的條件為，window 中無重複的字元，當出現重複字元時，則滑動左指標。 時間複雜度為 \\(O(n)\\)，空間複雜度為 \\(O(1)\\)。 空間複雜度為 \\(O(k)\\)，k 為字元的個數，最多為 128 個(題目限制字元為 letters, digits, symbols and spaces)，故\\(O(k)=O(128)=O(1)\\) 三、解題 1. Sliding Window Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) int lengthOfLongestSubstring(string s) { int cnt[128] = {0}; int left = 0, right = 0; int res = 0; while (right \u0026lt; s.length()) { char c = s[right++]; while (cnt[c]) { // 若 window 中已有該字元，則滑動左指標 char d = s[left]++; cnt[d]--; // 將 window 中，左指標的字元數減 1 } res = max(res, right - left); // 比較當前的長度 cnt[c]++; // 將 window 中，右指標的字元數加 1 } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/3/","summary":"3. Longest Substring Without Repeating Characters\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Hash Table、String、Sliding Window 一、題目 Given a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = \u0026ldquo;abcabcbb\u0026rdquo; Output: 3 Explanation: The answer is \u0026ldquo;abc\u0026rdquo;, with the length of 3. Example 2:\nInput: s = \u0026ldquo;bbbbb\u0026rdquo; Output: 1 Explanation: The answer is \u0026ldquo;b\u0026rdquo;, with the length of 1. Example 3:\nInput: s = \u0026ldquo;pwwkew\u0026rdquo; Output: 3 Explanation: The answer is \u0026ldquo;wke\u0026rdquo;, with the length of 3.","title":"[LeetCode] 3. Longest Substring Without Repeating Characters"},{"content":"2. Add Two Numbers\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List、Math、Recursion 一、題目 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807 Example 2:\nInput: l1 = [0], l2 = [0] Output: [0] Example 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] Constraints:\nThe number of nodes in each linked list is in the range [1, 100]. 0 \u0026lt;= Node.val \u0026lt;= 9 It is guaranteed that the list represents a number that does not have leading zeros. 二、分析 此題是加法器的現作，只是改成 linked list 的型式。 要注意進位時要新增新的 node。 時間複雜度為 \\(O(n)\\)，若可利用原本的鏈表，空間複雜度可降為 \\(O(1)\\)。 三、解題 1. Recursion Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { return add(l1, l2, 0); } ListNode* add(ListNode* l1, ListNode* l2, int cin){ // 將 cin 設為 carry in l1-\u0026gt;val += l2-\u0026gt;val + cin; cin = l1-\u0026gt;val / 10; // 進位 l1-\u0026gt;val %= 10; if (l1-\u0026gt;next || l2-\u0026gt;next || cin != 0){ // 若有下一位數，或 carry in 不等於 0 l1-\u0026gt;next = add((l1-\u0026gt;next == NULL ? new ListNode(0) : l1-\u0026gt;next), (l2-\u0026gt;next == NULL ? new ListNode(0) : l2-\u0026gt;next), cin); } return l1; } } 2. Iteration Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* dummy = new ListNode(-1, l1); // 設置一個 sentinel node ListNode* curr = dummy; // 設置一個在當前位置前的節點來控制資料 int cin = 0; while (l1 || l2 || cin \u0026gt; 0) { // 當必定有下一位時 // 借用 l1 或 l2，若兩者皆為空節點，則新建一個 ListNode* tmp = l1 ? l1 : l2 : l2 : new ListNode(0); // 加法器 tmp-\u0026gt;val = (l1 ? l1-\u0026gt;val : 0) + (l2 ? l2-\u0026gt;val : 0) + cin; cin = tmp / 10; tmp-\u0026gt;val %= 10; // 處理當 l1 為空結點的狀況 if (!l1 \u0026amp;\u0026amp; l2) { // l2 不為空節點時，則借 l2 來用 curr-\u0026gt;next = l2; } else { // 若 l1 跟 l2 都是空節點，建一個新的節點 curr-\u0026gt;next = tmp; } if (l1) l1 = l1-\u0026gt;next; // 前進一個節點 if (l2) l2 = l2-\u0026gt;next; curr = curr-\u0026gt;next; } return dummy-\u0026gt;next; // 記得回傳的是 sentinel-\u0026gt;next } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/2/","summary":"2. Add Two Numbers\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Linked List、Math、Recursion 一、題目 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807 Example 2:","title":"[LeetCode] 2. Add Two Numbers"},{"content":"1. Two Sum\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Hash Table 一、題目 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], taget = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0,1]. Example 2:\nInput: nums = [3,2,4], taget = 6 Output: [1,2] Example 3:\nInput: nums = [3,3], taget = 6 Output: [0,1] Constraints:\n2 \u0026lt;= nums.length \u0026lt;= 10^4 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 -10^9 \u0026lt;= target \u0026lt;= 10^9\u0026gt; Only one valid answer exists 二、分析 可藉由兩個迴圈暴力解求值，其時間複雜度為 \\(O(n^2)\\)。 若我們將已迭代過的值存入 HashMap，接下來我們就只需要找 HashMap 中是否有值與當下的值 nums[i] 相加為 target。因為只迭代一遍，故時間複雜度為 \\(O(n)\\)。 三、解題 1. HashMap Time complexity: \\(O(n)\\) Space complexity: \\(O(n)\\) vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int,int\u0026gt; map; // {值, 索引} int i; // 將 i 宣告在 for-loop 外 for (i = 0; i \u0026lt; nums.size(); i++) { if (map.find(target - nums[i]) != map.end()) break; // 若找到答案，則退出迴圈 map[nums[i]] = i; // 若沒有符合的答案，將值加入 HashMap } return {map[target-nums[i]], i}; // 注意加入 HashMap 的索引值會比當下的 i 值還小 } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/1/","summary":"1. Two Sum\nHardness: \\(\\color{green}\\textsf{Easy}\\) Ralated Topics: Array、Hash Table 一、題目 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], taget = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0,1].","title":"[LeetCode] 1. Two Sum"},{"content":"Catalog 一、依題號 1-500(44) 1. Two Sum\n2. Add Two Numbers\n3. Longest Substring Without Repeating Characters\n4. Median of Two Sorted Array\n5. Longest Palindromic Substring\n6. Zigzag Conversion\n7. Reverse Integer\n8. String to Integer (atoi)\n9. Palindrome Number\n10. Regular Expression Matching\n11. Container With Most Water\n12. Integer to Roman\n13. Roman to Integer\n14. Longest Common Prefix\n15. 3Sum\n16. 3Sum Closet\n17. Letter Combinations of a Phone Number\n18. 4Sum\n19. Remove Nth Node From End of List\n20. Valid Parentheses\n21. Merge Two Sorted Lists\n22. Generate Parentheses\n23. Merge k Sorted Lists\n24. Swap Nodes in Pairs\n25. Reverse Nodes in k-Group\n53. Maximum Subarray\n70. Climbing Stairs\n79. Word Search\n100. Same Tree\n124. Binary Tree Maximum Path Sum\n149. Max Points on a Line\n151. Reverse Words in a String\n198. House Robber\n212. Word Search II\n213. House Robber II\n223. Rectangle Area\n279. Perfect Squares\n290. Word Pattern\n300. Longest Increasing Subsequence\n322. Coin Change\n328. Odd Even Linked List\n337. House Robber III\n347. Top K Frequent Elements\n374. Guess Number Higher or Lower II\n433. Minimum Genetic Mutation\n446. Arithmetic Slices II - Subsequence\n452. Minimum Number of Arrows to Burst Balloons\n501-1000(14) 520. Detect Capital\n587. Erect the Fence\n766. Toeplitz Matrix\n790. Domino and Tromino Tiling\n835. Image Overlap\n841. Keys and Rooms\n872. Leaf-Similar Trees\n901. Online Stock Span\n918. Maximum Sum Circular Subarray\n926. Flip String to Monotone Increasing\n931. Minimum Falling Path Sum\n938. Range Sum of BST\n944. Delete Columns to Make Sorted\n947. Most Stones Removed with Same Row or Column\n1001-1500(7) 1026. Maximum Difference Between Node and Ancestor\n1047. Remove All Adjacent Duplicates In String\n1143. Longest Common Subsequence\n1235. Maximum Profit in Job Scheduling\n1293. Shortest Path in a Grid with Obstacles Elimination\n1323. Maximum 69 Number\n1339. Maximum Product of Splitted Binary Tree\n1501-2000(6) 1519. Number of Nodes in the Sub-Tree With the Same Label\n1544. Make The String Great\n1706. Where Will the Ball Fall\n1834. Single-Threaded CPU\n1926. Nearest Exit from Entrance in Maze\n1962. Remove Stones to Minimize the Total\n2001-2500(21) 2131. Longest Palindrome by Concatenating Two Letter Words\n2136. Earliest Possible Day of Full Bloom\n2279. Maximum Bags With Full Capacity of Rocks\n2389. Longest Subsequence With Limited Sum\n2460. Apply Operations to an Array\n2461. Maximum Sum of Distinct Subarrays With Length K\n2462. Total Cost to Hire K\n2463. Minimum Total Distance Traveled\n2465. Number of Distinct Averages\n2466. Count Ways To Build Good Strings\n2467. Most Profitable Path in a Tree\n2468. Split Message Based on Limit\n2469. Convert the Temperature\n2470. Number of Subarrays With LCM Equal to K\n2471. Minimum Number of Operations to Sort a Binary Tree by Level\n2472. Maximum Number of Non-overlapping Palindrome Substrings\n2485. Find the Pivot Integer\n2486. Accept Characters to String to Make Subsequence\n2487. Remove Nodes From Linked List\n2488. Count Subarrays With Median K\n2500. Delete Greatest Value in Each Row\n2501-3000(5) 2501. Longest Square Streak in an Array\n2520. Count the Digits That Divide a Number\n2521. Distinct Prime Factors of Product of Array\n2522. Partition String Into Substrings With Values at Most K\n2523. Closest Prime Numbers in Range\n二、依難度 Easy(24) 1. Two Sum\n9. Palindrome Number\n13. Roman to Integer\n14. Longest Common Prefix\n20. Valid Parentheses\n21. Merge Two Sorted Lists\n70. Climbing Stairs\n100. Same Tree\n374. Guess Number Higher or Lower II\n520. Detect Capital\n766. Toeplitz Matrix\n872. Leaf-Similar Trees\n938. Range Sum of BST\n944. Delete Columns to Make Sorted\n1047. Remove All Adjacent Duplicates In String\n1323. Maximum 69 Number\n1544. Make The String Great\n2389. Longest Subsequence With Limited Sum\n2460. Apply Operations to an Array\n2465. Number of Distinct Averages\n2469. Convert the Temperature\n2485. Find the Pivot Integer\n2500. Delete Greatest Value in Each Row\n2520. Count the Digits That Divide a Number\nMedium(59) 2. Add Two Numbers\n3. Longest Substring Without Repeating Characters\n5. Longest Palindromic Substring\n6. Zigzag Conversion\n7. Reverse Integer\n8. String to Integer (atoi)\n11. Container With Most Water\n12. Integer to Roman\n15. 3Sum\n16. 3Sum Closet\n17. Letter Combinations of a Phone Number\n18. 4Sum\n19. Remove Nth Node From End of List\n22. Generate Parentheses\n24. Swap Nodes in Pairs\n53. Maximum Subarray\n79. Word Search\n151. Reverse Words in a String\n198. House Robber\n213. House Robber II\n223. Rectangle Area\n279. Perfect Squares\n300. Longest Increasing Subsequence\n322. Coin Change\n328. Odd Even Linked List\n337. House Robber III\n347. Top K Frequent Elements\n433. Minimum Genetic Mutation\n452. Minimum Number of Arrows to Burst Balloons\n790. Domino and Tromino Tiling\n835. Image Overlap\n841. Keys and Rooms\n901. Online Stock Span\n918. Maximum Sum Circular Subarray\n926. Flip String to Monotone Increasing\n931. Minimum Falling Path Sum\n947. Most Stones Removed with Same Row or Column\n1026. Maximum Difference Between Node and Ancestor\n1143. Longest Common Subsequence\n1339. Maximum Product of Splitted Binary Tree\n1519. Number of Nodes in the Sub-Tree With the Same Label\n1706. Where Will the Ball Fall\n1834. Single-Threaded CPU\n1926. Nearest Exit from Entrance in Maze\n1962. Remove Stones to Minimize the Total\n2131. Longest Palindrome by Concatenating Two Letter Words\n2279. Maximum Bags With Full Capacity of Rocks\n2461. Maximum Sum of Distinct Subarrays With Length K\n2462. Total Cost to Hire K\n2466. Count Ways To Build Good Strings\n2467. Most Profitable Path in a Tree\n2470. Number of Subarrays With LCM Equal to K\n2471. Minimum Number of Operations to Sort a Binary Tree by Level\n2486. Accept Characters to String to Make Subsequence\n2487. Remove Nodes From Linked List\n2501. Longest Square Streak in an Array\n2521. Distinct Prime Factors of Product of Array\n2522. Partition String Into Substrings With Values at Most K\n2523. Closest Prime Numbers in Range\nHard(16) 4. Median of Two Sorted Array\n10. Regular Expression Matching\n23. Merge k Sorted Lists\n25. Reverse Nodes in k-Group\n124. Binary Tree Maximum Path Sum\n149. Max Points on a Line\n212. Word Search II\n446. Arithmetic Slices II - Subsequence\n587. Erect the Fence\n1235. Maximum Profit in Job Scheduling\n1293. Shortest Path in a Grid with Obstacles Elimination\n2136. Earliest Possible Day of Full Bloom\n2463. Minimum Total Distance Traveled\n2468. Split Message Based on Limit\n2472. Maximum Number of Non-overlapping Palindrome Substrings\n2488. Count Subarrays With Median K\n三、依分類 Array(43) 1. Two Sum\n4. Median of Two Sorted Array\n11. Container With Most Water\n15. 3Sum\n16. 3Sum Closet\n18. 4Sum\n53. Maximum Subarray\n79. Word Search\n149. Max Points on a Line\n198. House Robber\n212. Word Search II\n213. House Robber II\n300. Longest Increasing Subsequence\n322. Coin Change\n347. Top K Frequent Elements\n446. Arithmetic Slices II - Subsequence\n452. Minimum Number of Arrows to Burst Balloons\n587. Erect the Fence\n766. Toeplitz Matrix\n835. Image Overlap\n918. Maximum Sum Circular Subarray\n931. Minimum Falling Path Sum\n944. Delete Columns to Make Sorted\n1235. Maximum Profit in Job Scheduling\n1293. Shortest Path in a Grid with Obstacles Elimination\n1706. Where Will the Ball Fall\n1834. Single-Threaded CPU\n1926. Nearest Exit from Entrance in Maze\n1962. Remove Stones to Minimize the Total\n2131. Longest Palindrome by Concatenating Two Letter Words\n2136. Earliest Possible Day of Full Bloom\n2279. Maximum Bags With Full Capacity of Rocks\n2389. Longest Subsequence With Limited Sum\n2460. Apply Operations to an Array\n2461. Maximum Sum of Distinct Subarrays With Length K\n2462. Total Cost to Hire K\n2463. Minimum Total Distance Traveled\n2465. Number of Distinct Averages\n2467. Most Profitable Path in a Tree\n2470. Number of Subarrays With LCM Equal to K\n2488. Count Subarrays With Median K\n2500. Delete Greatest Value in Each Row\n2501. Longest Square Streak in an Array\nBacktracking(4) 17. Letter Combinations of a Phone Number\n22. Generate Parentheses\n79. Word Search\n212. Word Search II\nBinary Search(7) 4. Median of Two Sorted Array\n300. Longest Increasing Subsequence\n374. Guess Number Higher or Lower II\n1235. Maximum Profit in Job Scheduling\n2389. Longest Subsequence With Limited Sum\n2468. Split Message Based on Limit\n2501. Longest Square Streak in an Array\nBinary Search Tree(1) 938. Range Sum of BST\nBinary Tree(8) 100. Same Tree\n124. Binary Tree Maximum Path Sum\n337. House Robber III\n938. Range Sum of BST\n872. Leaf-Similar Trees\n1026. Maximum Difference Between Node and Ancestor\n1339. Maximum Product of Splitted Binary Tree\n2471. Minimum Number of Operations to Sort a Binary Tree by Level\nBreadth-First Search(10) 100. Same Tree\n279. Perfect Squares\n322. Coin Change\n433. Minimum Genetic Mutation\n841. Keys and Rooms\n1293. Shortest Path in a Grid with Obstacles Elimination\n1519. Number of Nodes in the Sub-Tree With the Same Label\n1926. Nearest Exit from Entrance in Maze\n2467. Most Profitable Path in a Tree\n2471. Minimum Number of Operations to Sort a Binary Tree by Level\nBucket Sort(1) 347. Top K Frequent Elements\nCounting(3) 347. Top K Frequent Elements\n1519. Number of Nodes in the Sub-Tree With the Same Label\n2131. Longest Palindrome by Concatenating Two Letter Words\nData Stream(1) 901. Online Stock Span\nDepth-First Search(12) 100. Same Tree\n124. Binary Tree Maximum Path Sum\n337. House Robber III\n841. Keys and Rooms\n872. Leaf-Similar Trees\n938. Range Sum of BST\n947. Most Stones Removed with Same Row or Column\n1026. Maximum Difference Between Node and Ancestor\n1339. Maximum Product of Splitted Binary Tree\n1519. Number of Nodes in the Sub-Tree With the Same Label\n1706. Where Will the Ball Fall\n2467. Most Profitable Path in a Tree\nDesign(1) 901. Online Stock Span\nDivide and Conquer(5) 4. Median of Two Sorted Array\n23. Merge k Sorted Lists\n53. Maximum Subarray\n347. Top K Frequent Elements\n918. Maximum Sum Circular Subarray\nDynamic Programming(24) 5. Longest Palindromic Substring\n10. Regular Expression Matching\n22. Generate Parentheses\n53. Maximum Subarray\n70. Climbing Stairs\n124. Binary Tree Maximum Path Sum\n198. House Robber\n213. House Robber II\n279. Perfect Squares\n300. Longest Increasing Subsequence\n322. Coin Change\n337. House Robber III\n446. Arithmetic Slices II - Subsequence\n790. Domino and Tromino Tiling\n918. Maximum Sum Circular Subarray\n926. Flip String to Monotone Increasing\n931. Minimum Falling Path Sum\n1143. Longest Common Subsequence\n1235. Maximum Profit in Job Scheduling\n1706. Where Will the Ball Fall\n2463. minimum Total Distance Traveled\n2466. Count Ways To Build Good Strings\n2472. Maximum Number of Non-overlapping Palindrome Substrings\n2501. Longest Square Streak in an Array\nGeometry(3) 149. Max Points on a Line\n223. Rectangle Area\n587. Erect the Fence\nGraph(3) 841. Keys and Rooms\n947. Most Stones Removed with Same Row or Column\n2467. Most Profitable Path in a Tree\nGreedy(8) 11. Container With Most Water\n452. Minimum Number of Arrows to Burst Balloons\n1323. Maximum 69 Number\n2131. Longest Palindrome by Concatenating Two Letter Words\n2136. Earliest Possible Day of Full Bloom\n2279. Maximum Bags With Full Capacity of Rocks\n2389. Longest Subsequence With Limited Sum\n2486. Accept Characters to String to Make Subsequence\nHash Table(15) 1. Two Sum\n3. Longest Substring Without Repeating Characters\n12. Integer to Roman\n13. Roman to Integer\n17. Letter Combinations of a Phone Number\n149. Max Points on a Line\n290. Word Pattern\n347. Top K Frequent Elements\n433. Minimum Genetic Mutation\n1519. Number of Nodes in the Sub-Tree With the Same Label\n2131. Longest Palindrome by Concatenating Two Letter Words\n2461. Maximum Sum of Distinct Subarrays With Length K\n2465. Number of Distinct Averages\n2488. Count Subarrays With Median K\n2501. Longest Square Streak in an Array\nHeap (Priority Queue)(5) 23. Merge k Sorted Lists\n347. Top K Frequent Elements\n1834. Single-Threaded CPU\n1962. Remove Stones to Minimize the Total\n2462. Total Cost to Hire K\nInteractive(1) 374. Guess Number Higher or Lower II\nLinked List(8) 2. Add Two Numbers\n19. Remove Nth Node From End of List\n21. Merge Two Sorted Lists\n23. Merge k Sorted Lists\n24. Swap Nodes in Pairs\n25. Reverse Nodes in k-Group\n328. Odd Even Linked List\n2487. Remove Nodes From Linked List\nMath(14) 2. Add Two Numbers\n7. Reverse Integer\n9. Palindrome Number\n12. Integer to Roman\n13. Roman to Integer\n70. Climbing Stairs\n149. Max Points on a Line\n223. Rectangle Area\n279. Perfect Squares\n587. Erect the Fence\n1323. Maximum 69 Number\n2469. Convert the Temperature\n2470. Number of Subarrays With LCM Equal to K\n2485. Find the Pivot Integer\nMatrix(9) 79. Word Search\n212. Word Search II\n766. Toeplitz Matrix\n835. Image Overlap\n931. Minimum Falling Path Sum\n1293. Shortest Path in a Grid with Obstacles Elimination\n1706. Where Will the Ball Fall\n1926. Nearest Exit from Entrance in Maze\n2500. Delete Greatest Value in Each Row\nMemoization(1) 70. Climbing Stairs\nMerge Sort(1) 23. Merge k Sorted Lists\nMonotonic Stack(2) 901. Online Stock Span\n2487. Remove Nodes From Linked List\nMonotonic Queue(1) 918. Maximum Sum Circular Subarray\nNumber Theory(1) 2470. Number of Subarrays With LCM Equal to K\nPrefix Sum(3) 2389. Longest Subsequence With Limited Sum\n2485. Find the Pivot Integer\n2488. Count Subarrays With Median K\nQueue(1) 918. Maximum Sum Circular Subarray\nQuickselect(1) 347. Top K Frequent Elements\nRecursion(6) 2. Add Two Numbers\n10. Regular Expression Matching\n21. Merge Two Sorted Lists\n24. Swap Nodes in Pairs\n25. Reverse Nodes in k-Group\n2487. Remove Nodes From Linked List\nSimulation(3) 1706. Where Will the Ball Fall\n2460. Apply Operations to an Array\n2462. Total Cost to Hire K\nSliding Window(2) 3. Longest Substring Without Repeating Characters\n2461. Maximum Sum of Distinct Subarrays With Length K\nSorting(14) 15. 3Sum\n16. 3Sum Closet\n18. 4Sum\n347. Top K Frequent Elements\n452. Minimum Number of Arrows to Burst Balloons\n1235. Maximum Profit in Job Scheduling\n1834. Single-Threaded CPU\n2136. Earliest Possible Day of Full Bloom\n2279. Maximum Bags With Full Capacity of Rocks\n2389. Longest Subsequence With Limited Sum\n2463. Minimum Total Distance Traveled\n2465. Number of Distinct Averages\n2500. Delete Greatest Value in Each Row\n2501. Longest Square Streak in an Array\nStack(5) 20. Valid Parentheses\n901. Online Stock Span\n1047. Remove All Adjacent Duplicates In String\n1544. Make The String Great\n2487. Remove Nodes From Linked List\nString(25) 3. Longest Substring Without Repeating Characters\n5. Longest Palindromic Substring\n6. Zigzag Conversion\n8. String to Integer (atoi)\n10. Regular Expression Matching\n12. Integer to Roman\n13. Roman to Integer\n14. Longest Common Prefix\n17. Letter Combinations of a Phone Number\n20. Valid Parentheses\n22. Generate Parentheses\n151. Reverse Words in a String\n212. Word Search II\n290. Word Pattern\n433. Minimum Genetic Mutation\n520. Detect Capital\n926. Flip String to Monotone Increasing\n944. Delete Columns to Make Sorted\n1047. Remove All Adjacent Duplicates In String\n1143. Longest Common Subsequence\n1544. Make The String Great\n2131. Longest Palindrome by Concatenating Two Letter Words\n2468. Split Message Based on Limit\n2472. Maximum Number of Non-overlapping Palindrome Substrings\n2486. Accept Characters to String to Make Subsequence\nTree(10) 100. Same Tree\n124. Binary Tree Maximum Path Sum\n337. House Robber III\n872. Leaf-Similar Trees\n938. Range Sum of BST\n1026. Maximum Difference Between Node and Ancestor\n1339. Maximum Product of Splitted Binary Tree\n1519. Number of Nodes in the Sub-Tree With the Same Label\n2467. Most Profitable Path in a Tree\n2471. Minimum Number of Operations to Sort a Binary Tree by Level\nTrie(1) 212. Word Search II\nTwo Pointer(9) 11. Container With Most Water\n15. 3Sum\n16. 3Sum Closet\n18. 4Sum\n19. Remove Nth Node From End of List\n151. Reverse Words in a String\n2462. Total Cost to Hire K\n2465. Number of Distinct Averages\n2486. Accept Characters to String to Make Subsequence\nUnion Find(1) 947. Most Stones Removed with Same Row or Column\n","permalink":"http://intervalrain.github.io/posts/leetcode/","summary":"Catalog 一、依題號 1-500(44) 1. Two Sum\n2. Add Two Numbers\n3. Longest Substring Without Repeating Characters\n4. Median of Two Sorted Array\n5. Longest Palindromic Substring\n6. Zigzag Conversion\n7. Reverse Integer\n8. String to Integer (atoi)\n9. Palindrome Number\n10. Regular Expression Matching\n11. Container With Most Water\n12. Integer to Roman\n13. Roman to Integer\n14. Longest Common Prefix\n15. 3Sum\n16. 3Sum Closet\n17. Letter Combinations of a Phone Number","title":"[LeetCode] Catalog"},{"content":"Version Query\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Binary Search、Segment Tree、Heap (Priority Queue、Hash Table 一、題目 Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.\nThe given apk_info structure is given as below.\nstruct apk_info {\nint apk_version;\nint min_version = 1;\nint max_version = INT_MAX;\n}\nExample 1:\n\\(\\begin{array}{|l|}\\hline \\text{Input: }\\\\ \\begin{array}{|c|c|c|}\\hline \\text{apk version}\u0026amp;\\text{min OS version}\u0026amp;\\text{max OS version}\\\\\\hline \\text{1}\u0026amp;\\text{14}\u0026amp;\\text{}\\\\\\hline \\text{2}\u0026amp;\\text{}\u0026amp;\\text{8}\\\\\\hline \\text{3}\u0026amp;\\text{12}\u0026amp;\\text{16}\\\\\\hline \\end{array}\\\\ \\text{OS version query = [18,4,14,10]}\\\\\\\\ \\text{Output:}\\\\\\text{apk version = [1,2,3,0]}(0 \\text{ means not found})\\\\\\hline \\end{array}\\)\nConstraints:\n\\(\\begin{array}{|l|}\\hline \\text{1. 1} \\le \\text{Apk version \u0026lt; } 10^{31}\\\\ \\text{2. 1} \\le \\text{OS version \u0026lt; } 10^{31}\\\\ \\text{3. 1} \\le \\text{Query times \u0026lt; } 10^{31}\\\\\\hline \\end{array}\\)\n二、分析 重點其實就是區間求極值，所以筆者最先開始想到的是線段樹，線段樹的介紹可參考這裡：Segment Tree 線段樹 爾後才想到這題其實概念上很接近 Leetcode 218. The Skyline Problem 上這張題後就懂了，把 apk version 看成建築的高度， min OS version 與 max OS version 看成建築的 x 座標，就變成一樣的題目了，差別在於把 skyline 建成之後，再對其作 binary search。 三、解題 Priority Queue struct apk_info{ int apk_version; int min_version = 1; int max_version = INT_MAX; apk_info(int ver, int mn, int mx){ this-\u0026gt;apk_version = ver; this-\u0026gt;min_version = mn; this-\u0026gt;max_version = mx; } }; class Solution { public: unordered_map\u0026lt;int, int\u0026gt; waitList; void remove(priority_queue\u0026lt;int\u0026gt;\u0026amp; pq, int item){ if (pq.top() == item) { // 若 pq 的頂是要移除的對象，則直接移除 pq.pop(); while (waitList.find(pq.top()) != waitList.end() \u0026amp;\u0026amp; waitList[pq.top()] \u0026gt; 0) { waitList[pq.top()]--; pq.pop(); } } else { waitList[item]++; // 若 pq 的頂非要移除的對象，則加入 waitList，待之後再移除 } } vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; getRangeMax(vector\u0026lt;apk_info*\u0026gt; infos) { vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; rangeMax, osVers; for (const auto\u0026amp; info : infos) { osVers.push_back({info-\u0026gt;min_version, -info-\u0026gt;apk_version}); // 以負值代表 skyline 的開始 osVers.push_back({info-\u0026gt;max_version, info-\u0026gt;apk_version}); // 以正值代表 skyline 的結束 } sort(osVers.begin(), osVers.end()); // 以 x 值(os_version) 進行排序 priority_queue\u0026lt;int\u0026gt; pq; pq.push(0); // not found 時，預設回傳 0 int prev = 0; // 在還沒插入 item 前一開始的最大值就是 0 for (const auto\u0026amp; osVer : osVers) { if (osVer.second \u0026lt; 0){ // 開始 pq.push(-osVer.second); } else { // 結束，需移除該點 remove(pq, osVer.second); } int curr = pq.top(); if (prev != curr) { // 若最大值有變，則需把 skyline 記錄下來 if (prev \u0026lt; curr || osVer.first == INT_MAX) rangeMax.push_back({osVer.first, curr}); // x 軸為 os version，y 軸為 apk version else // 為做成 [a, b) 左閉右開的區間，若 skyline 往下，x 軸的點位置需加 1 (版本以大的為主) rangeMax.push_back({osVer.first+1, curr}); prev = curr; } } return rangeMax; } public: vector\u0026lt;int\u0026gt; findOSVersion(vector\u0026lt;apk_info*\u0026gt; infos, vector\u0026lt;int\u0026gt; queries) { vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; rangeMax = getRangeMax(infos); // 以範例來說會回傳 [[1,2],[9,0],[12,3],[17,1],[INT_MAX, 0]] vector\u0026lt;int\u0026gt; res; for (const int\u0026amp; q : queries){ auto it = upper_bound(rangeMax.begin(), rangeMax.end(), make_pair(q, INT_MAX)); // 開區間找上限後，往前推一位 it--; res.push_back(it-\u0026gt;second); } return res; } }; // test case int main(){ apk_info* a1 = new apk_info(1, 14, INT_MAX); apk_info* a2 = new apk_info(2, 1, 8); apk_info* a3 = new apk_info(3, 12, 16); vector\u0026lt;apk_info*\u0026gt; infos = {a1, a2, a3}; vector\u0026lt;int\u0026gt; queries = {18,4,14,10}; // 1, 2, 3, 0 Solution* sol = new Solution(); vector\u0026lt;int\u0026gt; res = sol-\u0026gt;findOSVersion(infos, queries); for (int i = 0; i \u0026lt; res.size(); i++){ cout \u0026lt;\u0026lt; res[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 補充(segment tree) 用segment tree 來解區域更新的題目時，若把每個子葉點退化到單點的話，其空間複雜度會太高，可以用兩個 map 由左到右將 x 軸從小到大帶入，每個索引值 i 對應到一個有使用到的 x 軸座標。然後用左閉右開(\\([a,b)\\))的方式去維護區間的值。 在用segment tree 做區域更新時，若每次都對所有子葉做更新的話，其時間複雜度會拉高到\\(O(k)\\)，\\(k\\) 為線段長。其下 slash 掉的部分，在 the skyline problem 中會造成 TLE，所以我們每次只對其必要的點做更新，待全部資料輸入完後，再一次從上而下做更新(renew)。其時間複雜度雜到\\(O(klogk+n)\\)，\\(n\\) 為 x 軸的個數。 區域查詢也可以用差不多的概念完成。 class Solution { class Tree { vector\u0026lt;int\u0026gt; arr; int m, n; public: Tree (int sz) { n = sz; for (m=1; m \u0026lt; n; m\u0026lt;\u0026lt;=1); arr.assign(2*m, 0); } // void update(int b, int e, int val) { // int i = b+m, j = e+m; // for (; i \u0026amp;\u0026amp; j \u0026amp;\u0026amp; i \u0026lt;= j; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1){ // for (int k = i; k \u0026lt;= j; k++){ // arr[k] = max(arr[k], val); // } // } // } // void renew(){} void update(int b, int e, int val){ for (b+=m, e+=m; b \u0026lt;= e; b\u0026gt;\u0026gt;=1, e\u0026gt;\u0026gt;=1) { if (b\u0026amp;1) arr[b++] = max(arr[b], val); if (!(e\u0026amp;1)) arr[e--] = max(arr[e], val); } } void renew() { for (int i = 1; i \u0026lt; m; i++) { arr[i\u0026lt;\u0026lt;1] = max(arr[i\u0026lt;\u0026lt;1], arr[i]); arr[i\u0026lt;\u0026lt;1|1] = max(arr[i\u0026lt;\u0026lt;1|1], arr[i]); } } int query(int i) { return arr[i+m]; } }; unordered_map\u0026lt;int,int\u0026gt; i2x, x2i; public: int mapping(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; buildings) { set\u0026lt;int\u0026gt; sets; for (const auto\u0026amp; building : buildings) { sets.insert(building[0]); sets.insert(building[1]); } int cnt = 0; for (const auto\u0026amp; x : sets){ i2x[cnt] = x; x2i[x] = cnt++; } return cnt; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; getSkyline(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; buildings) { int n = mapping(buildings); Tree* root = new Tree(n); for (const auto\u0026amp; building : buildings) { int b = x2i[building[0]]; int e = x2i[building[1]]; root-\u0026gt;update(b, e-1, building[2]); } root-\u0026gt;renew(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; int prev = 0; for (int i = 0; i \u0026lt; n; i++){ int x = i2x[i]; int y = root-\u0026gt;query(i); if (prev != y) { res.push_back({x, y}); prev = y; } } return res; } }; ","permalink":"http://intervalrain.github.io/posts/leetcode/versionquery/","summary":"Version Query\nHardness: \\(\\color{red}\\textsf{Hard}\\) Ralated Topics: Binary Search、Segment Tree、Heap (Priority Queue、Hash Table 一、題目 Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.\nThe given apk_info structure is given as below.\nstruct apk_info {\nint apk_version;\nint min_version = 1;\nint max_version = INT_MAX;\n}","title":"[Problem] Version Query"},{"content":"線段樹 Segment Tree 簡介 線段樹是演算法中常用來維護區間訊息的資料結構。 空間複雜度為 \\(O(n)\\)，\\(n\\) 代表區間數。 查詢的時間複雜度為 \\(O(\\log n+k)\\)，\\(k\\) 代表符合條件的區間數量。 線段樹將每個長度為為 1 的區間劃分為左右兩個區間遞迴求解，把整個線段劃分為一個樹型結構，通過合併左右兩個區間訊息來求得該區間的訊息。 在實現時，我們考慮遞迴建樹，設當前的根節點為 root，如果根節點管轄的區間長度已經是 1，則可以直接根據數組上相應位置的值初始化該節點。否則需將該區間從中點處分割為兩個子區間，分別進入左右子節點遞迴建樹，最後合併兩個子節點的訊息， 建樹 build void build(int s, int t, int p, const vector\u0026lt;int\u0026gt;\u0026amp; arr){ if (s == t){ tree[p] = SegmentItem(arr[s], 1); return; } int m = s + ((t - s) \u0026gt;\u0026gt; 1); build(s, m, p*2, arr); build(m+1, t, p*2+1, arr); // push_up tree[p] = tree[p*2] + tree[(p*2)+1]; } 查詢 query SegmentItem find(int l, int r, int s, int t, int p){ if (l \u0026lt;= s \u0026amp;\u0026amp; t \u0026lt;= r){ return tree[p]; } int m = s + ((t - s) \u0026gt;\u0026gt; 1); SegmentItem sum; if (r \u0026lt;= m) return find(l, r, s, m, p*2); if (l \u0026gt; m) return find(l, r, m+1, t, p*2+1); return find(l, r, s, m, p*2) + find(l, r, m+1, t, p*2+1); } zkw 線段樹 來自清華大學張昆瑋(zkw)-《統計的力量》 以非遞迴的方式構建，效率更高，程式更短。 普通的線段樹是從上到下做處理，容易定位根節點，卻不容易定位子節點。 zkw 線段樹是當二叉樹是滿二叉樹時，因為子節點的編號具有以下規律： 葉子節點(left) 全部退化為線段 \\([x,x]\\) 。 \\(n\\) 個數據點則取大於等 \\(n\\)且為 \\(2\\) 的冪次的兩倍作為數組大小。 \\((m=2^a\\ge n)\\) for (int m = 1; m \u0026lt;= n; m \u0026gt;\u0026gt;= 1) 維護點為 \\(n\\) 個。索引為\\([m,m+n)\\)。 子葉數目為 \\(m\\) 個。索引為\\([m,2m)\\) 節點數為 \\(2m-1\\) 個。(數組大小需設 \\(2m\\) 因為 zkw tree是 1-index的) 樹高 \\(H=\\log_2(m)+1\\) 層。 第 \\(h\\) 層有 \\(2^{h-1}\\) 個節點， 該層線段長度為 \\(2^{H-h}\\)。 若某節點為 \\(p\\)，父節點為 \\(p/2\\)，子節點為 \\(2p\\) 和 \\(2p+1\\) int parent = p \u0026gt;\u0026gt; 1; int left = p \u0026lt;\u0026lt; 1; int right = p \u0026lt;\u0026lt; 1 | 1; 若兩節點為 \\(p\\) 與 \\(q\\)，且兩節點互為兄弟節點，則 \\(p\\oplus q=1\\) if (left ^ right) // left 與 right 為兄弟節點 else // left 與 right 不為兄弟節點 除根節點外，左節點皆為偶數，右節點皆為奇數 if (i == 1) // i 為根節點 else if (i \u0026amp; 1) // i 為奇數，為右節點 else if (!(i \u0026amp; 1)) // i 為偶數，為左節點 結構 線段樹索引堆疊： 轉成二進制： 規律： 一個節點的父節點是該數右移 1，低位捨棄。 一個節點的左子節點是該數左移 1，右子節點是該數左移 1 再加 1。 同一層的節點是依次遞增的，第 \\(n\\) 層有 \\(2^{n-1}\\)個節點 最後一層有多少個節點，值域就是多少。 建樹 build 取 m 值有許多版本，有些版本會直接取 \\(m=2^{log_2(n+5)+1}\\)以節省迭代計算 寫成 int n = 1 \u0026lt;\u0026lt; __lg(n+5)+1; 可以有開區間與閉區間兩種做法，差別在於從子葉節點的最左邊 \\(m+i\\) 開始，或是第二個子葉節點 \\(m+1+i\\) 開始。 由下而上更新時，開區間與閉區間的終止條件不同： 開區間的終止條件為兩子節點互為兄弟節點 while (i^j^1) // operation 閉區間的終止條件為右節點小於左節點 while (i \u0026lt;= j) // operation class Tree { private: vector\u0026lt;int\u0026gt; arr; int n, m; // n 為維護點數, m 為 zkw-tree 子葉節點數 public: Tree (vector\u0026lt;int\u0026gt;\u0026amp; nums){ n = nums.size(); for (m = 1; m \u0026lt;= n; m \u0026lt;\u0026lt;= 1); // 取大於等於 n 且為 2 的冪次的最小整數 arr.assign(2*m, 0); // 節點數設為 2m 個，其中 0 為空節點 } void build(vector\u0026lt;int\u0026gt; nums){ for (int i = 0; i \u0026lt; n; i++) { arr[i+m] = nums[i]; // 從子葉節點最左邊往右更新節點。 mx[i+m] = nums[i]; mn[i+m] = nums[i]; } for (int i = m-1; i; i--){ // 向上更新父節點。 arr[i] = in(x); } } }; 根據不同需求代換 \\(\\text{in(x)}\\)：取和、最大值、最小平 // 取和 arr[i] = arr[i\u0026lt;\u0026lt;1] + arr[i\u0026lt;\u0026lt;1|1]; // 取最大值 arr[i] = max(arr[i\u0026lt;\u0026lt;1], arr[i\u0026lt;\u0026lt;1|1]); // 取最小值 arr[i] = min(arr[i\u0026lt;\u0026lt;1], arr[i\u0026lt;\u0026lt;1|1]); 更新 update 單點修改(以和為例) 更新時，以差分方式，將所有父節點加上更新點的差值。 void update(int i, int val){ int diff = val - arr[m+i] // 原值 arr[m+i] 與新值 val 的差 for (i += m; i; i \u0026gt;\u0026gt;= 1){ arr[i] += diff; } } 查詢 query 單點查詢(以和為例)：閉區間做法 判斷左邊界是否為右節點，若為右節點則加上後往右邊的父節點移動。 判斷右邊界是否為左節點，若為左節點則加上後往左邊的父節點移動。 int query(int left, int right){ int sum = 0; int i = left+m; // 左閉區間 int j = right+m; // 右閉區間 for (; i \u0026lt;= j; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1){ if (i \u0026amp; 1) sum += arr[i++]; if (!(j \u0026amp; 1)) sum += arr[j--]; } return sum; } 備註：開區間作法 (0-index 時會出現 -1 的情形，建議使用閉區間) int query(int left, int right){ int sum = 0; int i = left+m-1; int j = right+m+1; for(; i^j^1; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1){ if (~i \u0026amp; 1) sum += arr[i^1]; if (j \u0026amp; 1) sum += arr[j^1]; } return sum; } 區間修改 在非遞迴的情況下，標記下傳是比較困難的，所以作法上改成將標記永久化。 具體而言，與查詢類似，當左端點是左子節點且右端點是右子節點時，我們對它的兄弟節點進行修改並標記，表示這顆子樹中的每個節點都要被修改。但單純這樣還不夠，因上述修改還會波及到這些節點的各級祖先，所以我們需要在途中根據實際修改的區間長度來更新各級祖先的值，這種操作需要一路上推到根節點。 (開區間作法) void update(int left, int right, int diff){ int len = 1, cntl = 0, cntr = 0; // cntl, cntr 是左右邊分別實際修改的區間長度 left += m-1; right += m+1; for (; left^right^1; left \u0026gt;\u0026gt; 1, right \u0026gt;\u0026gt; 1, len \u0026lt;\u0026lt; 1){ arr[left] += cntl * diff; arr[right] += cntr * diff; if (~left \u0026amp; 1) { arr[left^1] += diff * len; mark[left^1] += diff; cntl += len; } if (right \u0026amp; 1) { arr[right^1] += diff * len; mark[right^1] += diff; cntr += len; } } for (; left; left \u0026gt;\u0026gt;= 1, right \u0026gt;\u0026gt;= 1){ arr[left] += cntl * diff; arr[right] += cntr * diff; } } 在有區間修改存在時，區間查詢也需要考慮標記的影響。 所以除了加上端點的兄弟節點訊息，沿途中遇到的標記也對答案有貢獻，同樣需要上推到根節點。 int query(int left, int right){ int sum = 0, len = 1, cntl = 0, cntr = 0; left += m - 1; right += m + 1; for (; left^right^1; left \u0026gt;\u0026gt;= 1, right \u0026gt;\u0026gt;= 1, len \u0026lt;\u0026lt; 1){ sum += cntl * mark[left] + cntr * mark[right]; if (~left \u0026amp; 1) sum += arr[left^1], cntl += len; if (right \u0026amp; 1) sum += arr[right^1], cntr += len; } for (; left; left \u0026gt;\u0026gt; 1, right \u0026gt;\u0026gt; 1){ sum += cntl * mark[left] + cntr * mark[right]; } return sum; } 區間查詢最大值： void update(int l, int r, int d) { for (l += N - 1, r += N + 1; l ^ r ^ 1; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { if (l \u0026lt; N) tree[l] = max(tree[l \u0026lt;\u0026lt; 1], tree[l \u0026lt;\u0026lt; 1 | 1]) + mark[l], tree[r] = max(tree[r \u0026lt;\u0026lt; 1], tree[r \u0026lt;\u0026lt; 1 | 1]) + mark[r]; if (~l \u0026amp; 1) tree[l ^ 1] += d, mark[l ^ 1] += d; if (r \u0026amp; 1) tree[r ^ 1] += d, mark[r ^ 1] += d; } for (; l; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) if (l \u0026lt; N) tree[l] = max(tree[l \u0026lt;\u0026lt; 1], tree[l \u0026lt;\u0026lt; 1 | 1]) + mark[l], tree[r] = max(tree[r \u0026lt;\u0026lt; 1], tree[r \u0026lt;\u0026lt; 1 | 1]) + mark[r]; }; int query(int l, int r) { int maxl = -INF, maxr = -INF; for (l += N - 1, r += N + 1; l ^ r ^ 1; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) { maxl += mark[l], maxr += mark[r]; if (~l \u0026amp; 1) cmax(maxl, tree[l ^ 1]); if (r \u0026amp; 1) cmax(maxr, tree[r ^ 1]); } for (; l; l \u0026gt;\u0026gt;= 1, r \u0026gt;\u0026gt;= 1) maxl += mark[l], maxr += mark[r]; return max(maxl, maxr); }; Leetcode. 307 範例 https://leetcode.com/problems/range-sum-query-mutable/ TreeNode 變形 class NumArray { class SegTree { public: int val; int begin, end; SegTree* left, *right; SegTree(int v):val(v) {} SegTree(int v, int b, int e):val(v), begin(b), end(e) {} SegTree(int v, int b, int e, SegTree* l, SegTree* r) :val(v), begin(b), end(e), left(l), right(r) {} }; SegTree* root; SegTree* build(vector\u0026lt;int\u0026gt;\u0026amp; nums, int b, int e){ if (e \u0026lt; b) return NULL; if (b == e) return new SegTree(nums[b], b, b); int mid = b + (e-b)/2; SegTree* left = build(nums, b, mid); SegTree* right = build(nums, mid+1, e); return new SegTree(left-\u0026gt;val + right-\u0026gt;val, b, e, left, right); } void update(SegTree* node, int index, int val){ if (node-\u0026gt;begin == index \u0026amp;\u0026amp; node-\u0026gt;end == index){ node-\u0026gt;val = val; } else { int mid = node-\u0026gt;begin + (node-\u0026gt;end - node-\u0026gt;begin)/2; if (index \u0026lt;= mid){ update(node-\u0026gt;left, index, val); } else { update(node-\u0026gt;right, index, val); } node-\u0026gt;val = node-\u0026gt;left-\u0026gt;val + node-\u0026gt;right-\u0026gt;val; } } int query(SegTree* node, int left, int right){ if (node-\u0026gt;begin == left \u0026amp;\u0026amp; node-\u0026gt;end == right){ return node-\u0026gt;val; } int mid = node-\u0026gt;begin + (node-\u0026gt;end - node-\u0026gt;begin)/2; if (right \u0026lt;= mid){ return query(node-\u0026gt;left, left, right); } else if (left \u0026gt; mid){ return query(node-\u0026gt;right, left, right); } return query(node-\u0026gt;left, left, mid) + query(node-\u0026gt;right, mid+1, right); } public: NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { root = build(nums, 0, nums.size()-1); } void update(int index, int val) { update(root, index, val); } int sumRange(int left, int right) { return query(root, left, right); } }; zkw 線段樹 class NumArray { class SegTree { vector\u0026lt;int\u0026gt; arr; int m, n; public: SegTree(vector\u0026lt;int\u0026gt;\u0026amp; nums) { n = nums.size(); for (m = 1; m \u0026lt; n; m \u0026lt;\u0026lt;= 1); build(nums); } void build(vector\u0026lt;int\u0026gt;\u0026amp; nums) { arr.assign(2*m, 0); for (int i = 0; i \u0026lt; n; ++i) arr[m+i] = nums[i]; for (int i = m-1; i; --i) arr[i] = arr[i\u0026lt;\u0026lt;1] + arr[i\u0026lt;\u0026lt;1|1]; } void update(int index, int val) { int diff = val - arr[m+index]; for (index += m; index; index \u0026gt;\u0026gt;= 1) arr[index] += diff; } int query(int left, int right) { int sum = 0; for (int i = left+m, j = right+m; i \u0026lt;= j; i \u0026gt;\u0026gt;= 1, j \u0026gt;\u0026gt;= 1){ if (i \u0026amp; 1) sum += arr[i++]; if (!(j \u0026amp; 1)) sum += arr[j--]; } return sum; } }; public: SegTree* root; NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { root = new SegTree(nums); } void update(int index, int val) { root-\u0026gt;update(index, val); } int sumRange(int left, int right) { return root-\u0026gt;query(left, right); } }; BIT(binary indexed tree) class NumArray { public: class Bit { public: vector\u0026lt;int\u0026gt; bit; int n; Bit(vector\u0026lt;int\u0026gt;\u0026amp; nums) { n = nums.size(); bit.assign(n+1, 0); for (int i = 0; i \u0026lt; n; i++){ build(i+1, nums[i]); } } void build(int index, int val) { while (index \u0026lt;= n){ bit[index] += val; index = next(index); } } int next(int index) { return index + (index \u0026amp; -index); } int parent(int index) { return index - (index \u0026amp; -index); } int getSum(int index) { int sum = 0; while (index){ sum += bit[index]; index = parent(index); } return sum; } }; Bit* bit; NumArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { bit = new Bit(nums); } void update(int index, int val) { int diff = val - sumRange(index, index); bit-\u0026gt;build(index+1, diff); } int sumRange(int left, int right) { return bit-\u0026gt;getSum(right+1) - bit-\u0026gt;getSum(left); } }; ","permalink":"http://intervalrain.github.io/posts/c++/segtree/","summary":"線段樹 Segment Tree 簡介 線段樹是演算法中常用來維護區間訊息的資料結構。 空間複雜度為 \\(O(n)\\)，\\(n\\) 代表區間數。 查詢的時間複雜度為 \\(O(\\log n+k)\\)，\\(k\\) 代表符合條件的區間數量。 線段樹將每個長度為為 1 的區間劃分為左右兩個區間遞迴求解，把整個線段劃分為一個樹型結構，通過合併左右兩個區間訊息來求得該區間的訊息。 在實現時，我們考慮遞迴建樹，設當前的根節點為 root，如果根節點管轄的區間長度已經是 1，則可以直接根據數組上相應位置的值初始化該節點。否則需將該區間從中點處分割為兩個子區間，分別進入左右子節點遞迴建樹，最後合併兩個子節點的訊息， 建樹 build void build(int s, int t, int p, const vector\u0026lt;int\u0026gt;\u0026amp; arr){ if (s == t){ tree[p] = SegmentItem(arr[s], 1); return; } int m = s + ((t - s) \u0026gt;\u0026gt; 1); build(s, m, p*2, arr); build(m+1, t, p*2+1, arr); // push_up tree[p] = tree[p*2] + tree[(p*2)+1]; } 查詢 query SegmentItem find(int l, int r, int s, int t, int p){ if (l \u0026lt;= s \u0026amp;\u0026amp; t \u0026lt;= r){ return tree[p]; } int m = s + ((t - s) \u0026gt;\u0026gt; 1); SegmentItem sum; if (r \u0026lt;= m) return find(l, r, s, m, p*2); if (l \u0026gt; m) return find(l, r, m+1, t, p*2+1); return find(l, r, s, m, p*2) + find(l, r, m+1, t, p*2+1); } zkw 線段樹 來自清華大學張昆瑋(zkw)-《統計的力量》 以非遞迴的方式構建，效率更高，程式更短。 普通的線段樹是從上到下做處理，容易定位根節點，卻不容易定位子節點。 zkw 線段樹是當二叉樹是滿二叉樹時，因為子節點的編號具有以下規律： 葉子節點(left) 全部退化為線段 \\([x,x]\\) 。 \\(n\\) 個數據點則取大於等 \\(n\\)且為 \\(2\\) 的冪次的兩倍作為數組大小。 \\((m=2^a\\ge n)\\) for (int m = 1; m \u0026lt;= n; m \u0026gt;\u0026gt;= 1) 維護點為 \\(n\\) 個。索引為\\([m,m+n)\\)。 子葉數目為 \\(m\\) 個。索引為\\([m,2m)\\) 節點數為 \\(2m-1\\) 個。(數組大小需設 \\(2m\\) 因為 zkw tree是 1-index的) 樹高 \\(H=\\log_2(m)+1\\) 層。 第 \\(h\\) 層有 \\(2^{h-1}\\) 個節點， 該層線段長度為 \\(2^{H-h}\\)。 若某節點為 \\(p\\)，父節點為 \\(p/2\\)，子節點為 \\(2p\\) 和 \\(2p+1\\) int parent = p \u0026gt;\u0026gt; 1; int left = p \u0026lt;\u0026lt; 1; int right = p \u0026lt;\u0026lt; 1 | 1; 若兩節點為 \\(p\\) 與 \\(q\\)，且兩節點互為兄弟節點，則 \\(p\\oplus q=1\\) if (left ^ right) // left 與 right 為兄弟節點 else // left 與 right 不為兄弟節點 除根節點外，左節點皆為偶數，右節點皆為奇數 if (i == 1) // i 為根節點 else if (i \u0026amp; 1) // i 為奇數，為右節點 else if (!","title":"[C++] Segment Tree"},{"content":"stringstream 需引用 \u0026lt;sstream\u0026gt; , \u0026lt;iostream\u0026gt;, \u0026lt;string\u0026gt;函式庫 配合 str() 將 stringstream 類轉換成 string 類別。 split() vector\u0026lt;string\u0026gt; split(string\u0026amp; str, char del){ stringstream ss(str); string item; vector\u0026lt;string\u0026gt; res; while (getline(ss, item, del)){ if (!item.empty()){ res.push_back(item); } } return res; } concat() string concat(vector\u0026lt;string\u0026gt;\u0026amp; svec, char del){ stringstream ss; for (const auto\u0026amp; s : svec){ ss \u0026lt;\u0026lt; s \u0026lt;\u0026lt; del; } return ss.str(); } [leetcode 1859. Sorting the Sentence] class Solution { public: string sortSentence(string s) { vector\u0026lt;string\u0026gt; tmp = split(s, \u0026#39; \u0026#39;); int n = tmp.size(); vector\u0026lt;string\u0026gt; svec(n); for (const string\u0026amp; s : tmp){ int pos = s.back() - \u0026#39;1\u0026#39;; svec[pos] = s.substr(0, s.length()-1); } return concat(svec, \u0026#39; \u0026#39;); } string concat(vector\u0026lt;string\u0026gt;\u0026amp; svec, char del){ string res; stringstream ss; for (const string\u0026amp; s : svec) ss \u0026lt;\u0026lt; del \u0026lt;\u0026lt; s; res = ss.str(); return res.substr(1); } vector\u0026lt;string\u0026gt; split(string\u0026amp; str, char del){ vector\u0026lt;string\u0026gt; res; stringstream ss(str); string item; while (getline(ss, item, del)){ if (!item.empty()){ res.push_back(item); } } return res; } }; ","permalink":"http://intervalrain.github.io/posts/c++/stringstream/","summary":"stringstream 需引用 \u0026lt;sstream\u0026gt; , \u0026lt;iostream\u0026gt;, \u0026lt;string\u0026gt;函式庫 配合 str() 將 stringstream 類轉換成 string 類別。 split() vector\u0026lt;string\u0026gt; split(string\u0026amp; str, char del){ stringstream ss(str); string item; vector\u0026lt;string\u0026gt; res; while (getline(ss, item, del)){ if (!item.empty()){ res.push_back(item); } } return res; } concat() string concat(vector\u0026lt;string\u0026gt;\u0026amp; svec, char del){ stringstream ss; for (const auto\u0026amp; s : svec){ ss \u0026lt;\u0026lt; s \u0026lt;\u0026lt; del; } return ss.str(); } [leetcode 1859. Sorting the Sentence] class Solution { public: string sortSentence(string s) { vector\u0026lt;string\u0026gt; tmp = split(s, \u0026#39; \u0026#39;); int n = tmp.","title":"[C++] stringstream 類範例 - split 與 concat"},{"content":"一、Big O 表示法 Big O 的數學定義： \\(\\boxed{O(g(n)) = \\lbrace{f(n):存在正常量\\space c\\space 和\\space n_0，使得對所有\\space n\\ge n_0，有\\space 0 \\le f(n) \\le cg(n)\\rbrace}}\\) 我們常用的 big O 表示法中的 \\(O\\) 其實代表了一個函數的集合，比方說 \\(O(n^2)\\) 代表著一個由 \\(g(n) = n^2\\) 派生出來的一個函數集合；我們說一個演算法的時間複雜度為 \\(O(n^2)\\)，意思就是描述該演算法的複雜度函數屬於這個函數集合之中。 分析複雜度時，常用的兩個特性： 只保留增長速率最快的項，其它省略 \\(\\boxed{O(2n+100) = O(n)}\\) \\(\\boxed{O(2^{n+1}) = O(2^n)}\\) \\(\\boxed{O(m+3n+99) = O(m+n)}\\) \\(\\boxed{O(n^3+999\\times n^2+999\\times n) = O(n^3)}\\) Big O 記號表示複雜度的「上限」 換句話說，只要給出的是一個上限，用 Big O 表示法都是正確的。 但在習慣上，我們特別取最緊臨的上限。但若複雜度會跟算法的輸入數據有關，沒辦法提前給出一個特別精確的時間複雜度時，擴大時間複雜度的上限就變得有意義了。 例如湊零錢問題中，金額 amount 的值為 n，coins 列表中的個數為 k，則這棵遞迴樹就是 K 叉樹。而節點的數量與樹的結構有關，而我們無法提前知道樹的結構，所以我們按照最壞情形來處理，高度為 n 的一棵滿 k 叉樹，其節點數為 \\(\\frac{k^n-1}{k-1}\\)，用 big O 表示就是 \\(O(k^n)\\)。 回到目錄：[Algo] 演算法筆記 接著閱讀：[Algo] 0-2. 演算法思維 ","permalink":"http://intervalrain.github.io/posts/cs/algo/bigo/","summary":"一、Big O 表示法 Big O 的數學定義： \\(\\boxed{O(g(n)) = \\lbrace{f(n):存在正常量\\space c\\space 和\\space n_0，使得對所有\\space n\\ge n_0，有\\space 0 \\le f(n) \\le cg(n)\\rbrace}}\\) 我們常用的 big O 表示法中的 \\(O\\) 其實代表了一個函數的集合，比方說 \\(O(n^2)\\) 代表著一個由 \\(g(n) = n^2\\) 派生出來的一個函數集合；我們說一個演算法的時間複雜度為 \\(O(n^2)\\)，意思就是描述該演算法的複雜度函數屬於這個函數集合之中。 分析複雜度時，常用的兩個特性： 只保留增長速率最快的項，其它省略 \\(\\boxed{O(2n+100) = O(n)}\\) \\(\\boxed{O(2^{n+1}) = O(2^n)}\\) \\(\\boxed{O(m+3n+99) = O(m+n)}\\) \\(\\boxed{O(n^3+999\\times n^2+999\\times n) = O(n^3)}\\) Big O 記號表示複雜度的「上限」 換句話說，只要給出的是一個上限，用 Big O 表示法都是正確的。 但在習慣上，我們特別取最緊臨的上限。但若複雜度會跟算法的輸入數據有關，沒辦法提前給出一個特別精確的時間複雜度時，擴大時間複雜度的上限就變得有意義了。 例如湊零錢問題中，金額 amount 的值為 n，coins 列表中的個數為 k，則這棵遞迴樹就是 K 叉樹。而節點的數量與樹的結構有關，而我們無法提前知道樹的結構，所以我們按照最壞情形來處理，高度為 n 的一棵滿 k 叉樹，其節點數為 \\(\\frac{k^n-1}{k-1}\\)，用 big O 表示就是 \\(O(k^n)\\)。 回到目錄：[Algo] 演算法筆記 接著閱讀：[Algo] 0-2.","title":"[Algo] 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis"},{"content":"一、二叉樹的思維模式 二叉樹的解題模式大致分為兩類： 是否可以通過遍歷一遍得解 是否可以定義一個遞迴函數，通過分治法推導出原問題的答案？ [LeetCode. 104] Maximum Depth of Binary Tree(Easy) 以此題為例，可以遍歷完整個樹，並比較當下的樹的深度，得以求解。 int depth = 0; int maxDepth(TreeNode* root){ traverse(root, 1); return depth; } void traverse(TreeNode* root, int currDepth){ if (!root) return; traverse(root-\u0026gt;left, currDepth+1); depth = max(depth, currDepth); traverse(root-\u0026gt;right, currDepth+1); } 若想辦法定義一個遞迴函數，通過分治法推導出原問題，換言之，就是先處理更小的樹，再藉由小的樹處理大的樹： int maxDepth(TreeNode* root) { if (root == NULL) return 0; return 1 + max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)); } 事實上，兩個思維模式便對應著兩種演算法：回溯法(back tracking)與動態規劃(dynamic programming) 二、前序、中序、後序 無論使用哪種思維模式(遍歷或找出遞迴函數)，都要思考單獨抽出一個節點，它需要在何時(前、中、後序)做哪些事情，其它的節點交由遞迴函數去執行相同的操作。 以下我們以 quick sort 與 merge sort 為例，同樣是分治法，看看在數組上有什麼同樣的思維模式。 quick sort 從 sort() 函式便可見類似於前序的結構。 void sort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ if (left \u0026gt;= right) return; // 終止條件 int mid = partition(nums, left, right); // 做什麼事(pre-order) sort(nums, left, mid-1); // 左子樹 sort(nums, mid+1, right); // 右子樹 } int partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ int pivot = right; while (left \u0026lt; right){ while (nums[left] \u0026lt; nums[pivot]) left++; while (nums[right] \u0026gt; nums[pivot]) right--; if (left \u0026lt; right) swap(nums[left], nums[right]); } if (left == right \u0026amp;\u0026amp; nums[left] \u0026gt; nums[pivot] || nums[right] \u0026lt; nums[pivot]){ swap(nums[left], pivot); return left; } return pivot; } merge sort 從 sort() 函式便可見類似於後序的結構。 void sort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ if (right \u0026lt;= left) return; // 終止條件 int mid = left + (right-left)/2; sort(nums, left, mid); // 左子樹 sort(nums, mid+1, right); // 右子樹 merge(nums, left, mid, right); // 做什麼事(post-order) } void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int mid, int right){ vector\u0026lt;int\u0026gt; vec; int i = left, j = mid+1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right){ int x = nums[i] \u0026lt; nums[j] ? nums[i++] : nums[j++]; vec.push_back(x); } while (i \u0026lt;= mid) vec.push_back(nums[i++]); while (j \u0026lt;= right) vec.push_back(nums[j++]); for (int i = left; i \u0026lt;= right; i++) nums[i] = vec[i-left]; } 換言之，以上就是一個遍歷全部節點的函式，所以本質上數組、鏈表、二叉樹都是在做同樣的事。 數組 void traverse(vector\u0026lt;int\u0026gt; nums, int i){ if (i == nums.size()) return; // pre-order traverse(nums, i+1); // post-order } 鏈表 void traverse(ListNode* head){ if (!head) return; // pre-order traverse(head-\u0026gt;next); // post-order } 二叉樹 void traverse(TreeNode* root){ if (!root) return; // pre-order traverse(root-\u0026gt;left); // in-order traverse(root-\u0026gt;right); // post-order } 三、層序遍歷（level-order) Level-order 對應於 BFS(Breadth-First Search)，完下當下的層才會進入到下一層。 void traverse(TreeNode* root){ queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while (!q.empty()){ int sz = q.size(); while (sz--){ TreeNode* curr = q.front(); q.pop(); // operation if (curr-\u0026gt;left) q.push(curr-\u0026gt;left); if (curr-\u0026gt;right) q. push(curr-\u0026gt;right); } } } 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 0-3. 鏈表(Linked List) ","permalink":"http://intervalrain.github.io/posts/cs/algo/binary_tree/","summary":"一、二叉樹的思維模式 二叉樹的解題模式大致分為兩類： 是否可以通過遍歷一遍得解 是否可以定義一個遞迴函數，通過分治法推導出原問題的答案？ [LeetCode. 104] Maximum Depth of Binary Tree(Easy) 以此題為例，可以遍歷完整個樹，並比較當下的樹的深度，得以求解。 int depth = 0; int maxDepth(TreeNode* root){ traverse(root, 1); return depth; } void traverse(TreeNode* root, int currDepth){ if (!root) return; traverse(root-\u0026gt;left, currDepth+1); depth = max(depth, currDepth); traverse(root-\u0026gt;right, currDepth+1); } 若想辦法定義一個遞迴函數，通過分治法推導出原問題，換言之，就是先處理更小的樹，再藉由小的樹處理大的樹： int maxDepth(TreeNode* root) { if (root == NULL) return 0; return 1 + max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)); } 事實上，兩個思維模式便對應著兩種演算法：回溯法(back tracking)與動態規劃(dynamic programming) 二、前序、中序、後序 無論使用哪種思維模式(遍歷或找出遞迴函數)，都要思考單獨抽出一個節點，它需要在何時(前、中、後序)做哪些事情，其它的節點交由遞迴函數去執行相同的操作。 以下我們以 quick sort 與 merge sort 為例，同樣是分治法，看看在數組上有什麼同樣的思維模式。 quick sort 從 sort() 函式便可見類似於前序的結構。 void sort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ if (left \u0026gt;= right) return; // 終止條件 int mid = partition(nums, left, right); // 做什麼事(pre-order) sort(nums, left, mid-1); // 左子樹 sort(nums, mid+1, right); // 右子樹 } int partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ int pivot = right; while (left \u0026lt; right){ while (nums[left] \u0026lt; nums[pivot]) left++; while (nums[right] \u0026gt; nums[pivot]) right--; if (left \u0026lt; right) swap(nums[left], nums[right]); } if (left == right \u0026amp;\u0026amp; nums[left] \u0026gt; nums[pivot] || nums[right] \u0026lt; nums[pivot]){ swap(nums[left], pivot); return left; } return pivot; } merge sort 從 sort() 函式便可見類似於後序的結構。 void sort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ if (right \u0026lt;= left) return; // 終止條件 int mid = left + (right-left)/2; sort(nums, left, mid); // 左子樹 sort(nums, mid+1, right); // 右子樹 merge(nums, left, mid, right); // 做什麼事(post-order) } void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int mid, int right){ vector\u0026lt;int\u0026gt; vec; int i = left, j = mid+1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right){ int x = nums[i] \u0026lt; nums[j] ?","title":"[Algo] 0-4. 二叉樹(Binary Tree)"},{"content":"一、鏈表的基本結構 鏈表是由節點和指針構成的數據結構，每個節點存有一個值，和一個指向下一個節點的指針。不同於數組，鏈表並不能隨機訪問，必須透過指針找到該節點才能獲取其值；同理在未遍歷到鏈表結尾時，我們也無法知道鏈表長度，除非依賴其它數據結構儲存長度。 LeetCode 中默認的鏈表： struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; 二、鏈表的基本操作 在開始演算法實踐前，先來練習一下鏈表的 CRUD 吧！ 1. 查(Read) 由於鏈表並非在儲存格中連續分布，所以無法用索引進行隨機訪問，所以我們必須逐個訪問，直到到達我們想要的元素。 藉由指針每次指向當前節點的 next，移動 n 次到達 index 為 n 的節點。 int at(ListNode* head, int n){ // index 為 n ListNode* curr = head; while (n--){ // 移動 n 次 curr = curr-\u0026gt;next; } return curr-\u0026gt;val; } 2. 改(Update) 改的步驟，只是將查完的元素予以賦值。 void update(ListNode* head, int n, int val){ ListNode* curr = head; while (n--){ curr = curr-\u0026gt;next; } curr-\u0026gt;val = val; // 查完後賦值 } 3. 增(create) 如果要新增節點，則必須找到要插入位置的前一個節點。 ListNode* insert(ListNode* head, int n, int val){ if (!head) return NULL; // 處理當鏈表為空的狀態 if (n == 0){ // 處理當插入位置為 0 時的特例 ListNode* newHead = new ListNode(val, head); head = newHead; return head; } ListNode* curr = head; while (curr \u0026amp;\u0026amp; --n){ // 移動到插入位置的前一位 curr = curr-\u0026gt;next; } ListNode* tmp = curr-\u0026gt;next; // 預先存下來插入位置的後一位 curr-\u0026gt;next = new ListNode(val); // 插入元素 curr-\u0026gt;next-\u0026gt;next = tmp; // 將元素的下一位指派給存下來的後一位 return head; } 上述的寫法很直觀，但需要處例首位的特例，不夠漂亮，這時我們常會用到 DUMMY HEAD 的手法，即在鏈表最開頭先創一個假的節點，最後再返回該節點的下一位。 ListNode* insert(ListNode* head, int n, int val){ if (!head) return NULL; ListNode* dummy = new ListNode(-1, head); // 創建一個 dummy head ListNode* curr = dummy; while (curr \u0026amp;\u0026amp; n--){ // 注意為 n-- curr = curr-\u0026gt;next; } ListNode* tmp = curr-\u0026gt;next; curr-\u0026gt;next = new ListNode(val); curr-\u0026gt;next-\u0026gt;next = tmp; return dummy-\u0026gt;next; // 注意為返回 dummy 的下一位 } 前面兩解都是在可以取得前一位，且不更改節點的值的前提下的解法。如果只能取得當下的節點，則可以使用增+更的手法。 void insert(ListNode* node, int val){ int tmp = node-\u0026gt;val; node-\u0026gt;val = val; node-\u0026gt;next = new ListNode(tmp, node-\u0026gt;next); } 4. 減(delete) 與增類似，取得前一位再利用更改指針的方式達到刪除。 ListNode* erase(ListNode* head, int n, int val){ if (!head) return NULL; ListNode* dummy = new ListNode(-1, head); ListNode* curr = dummy; while (curr \u0026amp;\u0026amp; n--){ curr = curr-\u0026gt;next; } curr-\u0026gt;next = curr-\u0026gt;next-\u0026gt;next; // 將前一位的後一位指給後一位 return dummy-\u0026gt;next; } 只能取得當下節點的作法： [LeetCode. 237] Delete Node in a Linked List(Medium) void insert(ListNode* node, int val){ node-\u0026gt;val = node-\u0026gt;next-\u0026gt;val; // 將當前的值賦值成下一位的值 node-\u0026gt;next = node-\u0026gt;next-\u0026gt;next; // 將下一個節點刪除 } 三、鏈表的進階操作 1. 刪值 如何刪除表中第一個出現指定值的節點，同樣找到該值的前一個節點，再使用刪除的手法即可： void remove(ListNode* head, int target){ ListNode* prev = NULL; ListNode* curr = head; while (curr \u0026amp;\u0026amp; curr-\u0026gt;val != target){ prev = curr; curr = curr-\u0026gt;next; } if (!prev) // 處理例外 head = head-\u0026gt;next; else prev-\u0026gt;next = prev-\u0026gt;next-\u0026gt;next; } 2. 建表 如何藉由一個數組建立一鏈表，可以藉由前面使用的 dummy head 的手法： ListNode* build(vector\u0026lt;int\u0026gt; nums){ ListNode* dummy = new ListNode(-1); ListNode* prev = dummy; ListNode* curr = NULL; for (int i = 0; i \u0026lt; nums.size(); i++){ curr = new ListNode(nums[i]); prev-\u0026gt;next = curr; prev = curr; curr = curr-\u0026gt;next; } ListNode* head = dummy-\u0026gt;next; delete(dummy); return head; } 3. 鏈表的後序遍歷 前文說過，鏈表也可以做前序與後序的遍歷，在此我們再複習一次。 void traverse(ListNode* head){ // pre-order traverse(head-\u0026gt;next); // post-order } 如果我們想移除鏈表中所有值等於 target 的節點，用迭代的作法為： void removeAll(ListNode* head, int target){ ListNode* dummy = new ListNode(-1, head); ListNode* curr = dummy; while (curr \u0026amp;\u0026amp; curr-\u0026gt;next){ if (curr-\u0026gt;next-\u0026gt;val == target){ // 當前節點的下一位符合 target 則刪除它 curr-\u0026gt;next = curr-\u0026gt;next-\u0026gt;next; } else { curr = curr-\u0026gt;next; // 否則則繼續後下遍歷 } } } 那如果用遞迴的寫法呢： void removeAll(ListNode* head, int target){ if (!head) return; // 假如鏈表為空，則退出函式 while (head \u0026amp;\u0026amp; head-\u0026gt;val == target){ if (head-\u0026gt;next){ head-\u0026gt;val = head-\u0026gt;next-\u0026gt;next; head-\u0026gt;next = head-\u0026gt;next-\u0026gt;next; // 刪除 } else { head = NULL; // 當最後一個元素需移除時 } } removeAll(head-\u0026gt;next, target) // 前序遍歷 } 後序跟前序有個很維妙的差別在於：後序遍歷可以將值傳回給前一個元素！ 試試看用後序回傳值的特徵來實作這個函式 void removeAll(ListNode* head, int target){ int tmp; if (head-\u0026gt;next) tmp = removeAll(head-\u0026gt;next, target) // recursion if (tmp == target) // 後序遍歷可以取得下一位的回傳的值 head-\u0026gt;next = head-\u0026gt;next-\u0026gt;next; // 有了需要刪除的節點的前一位，要刪除就容易啦！ return head-\u0026gt;val // 傳回當前節點的值 } 四、秀一波的操作 1. 刪值 用兩個節點去做到鏈表刪除的操作，還是有一點點不夠美，試試看下面這個 pointer to pointer 的解法吧！ 改自文章你所不知道的 C 語言: linked list 和非連續記憶體 void remove(ListNode* head, int target){ ListNode** curr = \u0026amp;head; // 將指向指針的 curr 指向 head while ((*curr)-\u0026gt;val != target) curr = \u0026amp;(*curr)-\u0026gt;next; if (!(*curr)) return; // 避免掉指向 NULL *curr = (*curr)-\u0026gt;next } 2. 建表 學會上面這個 pointer to pointer 的作法，不如試試看來用這個方法來建表！ ListNode* build(vector\u0026lt;int\u0026gt; nums){ ListNode* head = new ListNode(nums[0]); ListNode** curr = \u0026amp;head; for (int i = 0; i \u0026lt; nums.size(); i++){ (*curr)-\u0026gt;next = new ListNode(nums[i]); curr = \u0026amp;(*curr)-\u0026gt;next; } } 五、鏈表的演算法 1. 反轉鏈表 [LeetCode. 206] Reverse Linked List(Easy) 藉由剛剛學習到鏈表的操作，用迭代的方式來解題吧。 考慮到一個反轉鏈表的連續操作，我們需要有三個節點 prev, curr, next。 ListNode* reverse(ListNode* head){ ListNode* prev = NULL; ListNode* curr = head; ListNode* next = NULL; while (curr){ next = curr-\u0026gt;next; // 先記住下一個位置 curr-\u0026gt;next = prev; // 將指針指向前一位，以達成反轉的目的 prev = curr; // 往前移動 curr = next; // 往前移垂 } return prev; } 那如果用遞迴的方式寫呢？ ListNode* reverse(ListNode* head){ if (!head || head-\u0026gt;next) return head; // 處理終止條件 ListNode last = reverse(head-\u0026gt;next); // post-order traversal：回傳已排序好的子鏈表，並傳回最後一項 head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = NULL; return last; } [[Followup] 反轉前 N 個節點 反轉鏈表的前 N 個節點：用前面的函式稍作修改 ListNode* successor = NULL; ListNode* reverseN(ListNode* head, int n){ if (n == 1){ // 只反轉 1 個節點相當於沒有反轉，故轉回自己 successor = head-\u0026gt;next; // 記錄反轉後的鏈表要接到哪裡-\u0026gt;剩餘鏈表的頭 return head; } ListNode last = reverseN(head-\u0026gt;next, n-1); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = successor; // 最後將鏈表的尾巴接到剩餘鏈表的頭 return last; } [LeetCode. 92] Reverse Linked List II(Medium) 反轉第 m 到第 n 個節點中間的節點 前進 m - 1 次就相當於就相當於反轉前 (n-m-1) 個節點，就可以用 reverseN 解了。 ListNode* reverseBetween(ListNode* head, int m, int n){ if (m == 1){ return reverseN(head, n); // 與 LeetCode.92 一樣 } head-\u0026gt;next = reverseBetween(head-\u0026gt;next, m-1, n-1); // 前進到 base case return head; } [LeetCode. 25] Reverse Nodes in k-Group (Hard) 結合前面的經驗，注意遞迴該返回的值是什麼。 注意結尾若節數小於 k 則不則 reverse。 ListNode* reverseKGroup(ListNode* head, int k) { ListNode* curr = head; int cnt = 0; while (curr \u0026amp;\u0026amp; cnt \u0026lt; k){ curr = curr-\u0026gt;next; cnt++; } if (cnt == k){ // 當節數小於 k 時，不做 reverse curr = reverseKGroup(curr, k); // 傳回的是 reverse 完的鏈表的 head，故需把 reverse 完的尾與之相接 while (cnt-- \u0026gt; 0){ ListNode* next = head-\u0026gt;next; head-\u0026gt;next = curr; curr = head; head = next; } return curr; // 當節數等於 k 時回傳的是尾巴 } return head; // 注意節數小於 k 時仍回傳 head } 2. 環型鏈表(龜兔賽跑-快慢指針) [LeetCode. 141] Linked List Cycle(Easy) 快慢指針是雙指針的一種應用，利用兩個指針移動的速度不同來達到目的。最經典的題型就是找尋鏈表是否含有環。 要檢查鏈表是否有環，可以使用找尋圖(graph)中是否有環的技巧，並利用 visited 來檢查是否有拜訪過，但下面快慢指針的技巧可以不用額外使用空間，使空間複雜度降到 \\(O(1)\\)。 bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next){ // 確保快指針與他的下一位都不是 NULL fast = fast-\u0026gt;next-\u0026gt;next; // 快指針走兩步 slow = slow-\u0026gt;next; // 慢指針走一步 if (fast == slow) return true; // 若兩者相撞，則必有環 } return false; } [LeetCode. 142] Linked List Cycle II(Medium) 此題是要找尋鏈表中若有環，則相交點是哪一點： 因為快指針走的距離是慢指針 k 的兩倍，令相遇點距相交點距離為 m 圓環的長度為 L：\n\\(\\text{L + m + k = 2 * k}\\)\n\\(\\text{L = k - m}\\)\n故起點到相交點的長度 \\(\\text{k - m}\\) 與相遇點到相交點的長度 \\(\\text{k - m}\\) 相同。 ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next){ fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; if (fast == slow) break; // 若有環則退出 } if (!fast || !fast-\u0026gt;next) return NULL; // 若快指針已經走到底表示沒有環 fast = head; // 讓其中一個指針從頭開始走，並一同樣的速度走 while (fast != slow){ // 相遇點即為相交點 fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } return fast; } [LeetCode. 876] Middle of the Linked List(Easy) 這題當然可以先遍歷一遍取得鏈表長度後，再重新以長度計量，走一半的長度來得到答案，但很顯然不夠漂亮，用快慢指針，令快指針比慢指針移動速度快兩倍，當快指針走完時，慢指針即指向中點。以此類推可求1/3的節點、2/5的節點等。 ListNode* middleNode(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next){ fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } return slow; } 3. 雙指針(前後指針) [LeetCode. 19] Remove Nth Node From End of List(Medium) 這題也是簡單的雙指針問題，當前指針先走 n 步，兩指針以同樣速度往前走(即前後指針始終保持 n 的距離)，則前指針走完時，後指針指向倒數第 k 個節點。 ListNode* removeNthFromEnd(ListNode* head, int n) { // 注意以下我們要刪除第 n 個節點，故我們需找第 n-1 個節點，為避免刪除第一個節點的例子，我們引入 dummy ListNode* dummy = new ListNode(-1, head); ListNode* slow = dummy; ListNode* fast = dummy; while (fast \u0026amp;\u0026amp; n--){ // 前指針先行走 n 個節點 fast = fast-\u0026gt;next; } while (fast-\u0026gt;next){ // 保持等速 slow = slow-\u0026gt;next; fast = fast-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; // 刪除第 n 個節點 return dummy-\u0026gt;next; } [LeetCode. 160] Intersection of Two Linked Lists(Easy) 找兩條鏈表的相交點，這題也可以用雙指針的方式解，當 A 鏈懷走完鏈表立即讓它接回 B 鏈表，B 鏈表亦如是，則相遇點則會是相交點，因為此時它們各別則的距離是都是 A 鏈表的長度加上 B 鏈表的長度，但要注意要記錄是否已經接過一遍，如果沒有相交點，又無限接下去，則程式永遠不會停止。 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* a = headA; ListNode* b = headB; bool flagA = true; // 用來標記是否已接過另一鏈表 bool flagB = true; // 用來標記是否已接過另一鏈表 while (a \u0026amp;\u0026amp; b){ if (a == b) return a; // 相遇表示相交點 a = a-\u0026gt;next; b = b-\u0026gt;next; if (!a \u0026amp;\u0026amp; flagA){ a = headB; flagA = false; // 已接過另一鏈表 } if (!b \u0026amp;\u0026amp; flagB){ b = headA; flagB = false; // 已接過另一鏈表 } } return NULL; } [LeetCode. 86] Partition List(Medium) 具體作法可將鏈表一分為二，待兩條鏈表皆完成後再頭尾相接。 ListNode* partition(ListNode* head, int x) { ListNode* dummy1 = new ListNode(-1); ListNode* dummy2 = new ListNode(-1); ListNode* curr1 = dummy1; ListNode* curr2 = dummy2; while (head){ if (head-\u0026gt;val \u0026lt; x){ curr1-\u0026gt;next = head; curr1 = curr1-\u0026gt;next; } else { curr2-\u0026gt;next = head; curr2 = curr2-\u0026gt;next; } head = head-\u0026gt;next; } curr1-\u0026gt;next = dummy2-\u0026gt;next; curr2-\u0026gt;next = NULL; return dummy1-\u0026gt;next; } [LeetCode. 21] Merge Two Sorted Lists(Easy) 簡單的 if-else，搭配 dummy 的做法即可解題。 ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* dummy = new ListNode(-1); ListNode* curr = dummy; while (list1 \u0026amp;\u0026amp; list2){ if (list1-\u0026gt;val \u0026lt;= list2-\u0026gt;val){ curr-\u0026gt;next = list1; list1 = list1-\u0026gt;next; } else { curr-\u0026gt;next = list2; list2 = list2-\u0026gt;next; } curr = curr-\u0026gt;next; } curr-\u0026gt;next = list1 ? list1 : list2; return dummy-\u0026gt;next; } 4. 優先佇列 [LeetCode. 23] Merge k Sorted Lists(Hard) 這一題有點 tricky，我們可以用到優先佇列，由於每次比較只會比較鏈表的頭節表，故我們連續將鏈表推至 min heap 上，並每次把 min heap 頂端的節點接到新的鏈表後，再把 min heap 上的鏈表拿去頭後，再丟回優先佇列中，至到鏈表走完，即完成。 ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { auto cmp = [](ListNode* a, ListNode* b){return a-\u0026gt;val \u0026gt; b-\u0026gt;val;}; priority_queue\u0026lt;ListNode*, vector\u0026lt;ListNode*\u0026gt;, decltype(cmp)\u0026gt; pq(cmp); ListNode* dummy = new ListNode(-1); ListNode* curr = dummy; for (ListNode* node : lists){ if (node) pq.push(node); } while (!pq.empty()){ ListNode* node = pq.top(); pq.pop(); curr-\u0026gt;next = node; curr = curr-\u0026gt;next; node = node-\u0026gt;next; if (node) pq.push(node); } return dummy-\u0026gt;next; } 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 0-2. 演算法思維 接著閱讀：[Algo] 0-4. 二元樹(Binary Tree) ","permalink":"http://intervalrain.github.io/posts/cs/algo/linked_list/","summary":"一、鏈表的基本結構 鏈表是由節點和指針構成的數據結構，每個節點存有一個值，和一個指向下一個節點的指針。不同於數組，鏈表並不能隨機訪問，必須透過指針找到該節點才能獲取其值；同理在未遍歷到鏈表結尾時，我們也無法知道鏈表長度，除非依賴其它數據結構儲存長度。 LeetCode 中默認的鏈表： struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; 二、鏈表的基本操作 在開始演算法實踐前，先來練習一下鏈表的 CRUD 吧！ 1. 查(Read) 由於鏈表並非在儲存格中連續分布，所以無法用索引進行隨機訪問，所以我們必須逐個訪問，直到到達我們想要的元素。 藉由指針每次指向當前節點的 next，移動 n 次到達 index 為 n 的節點。 int at(ListNode* head, int n){ // index 為 n ListNode* curr = head; while (n--){ // 移動 n 次 curr = curr-\u0026gt;next; } return curr-\u0026gt;val; } 2. 改(Update) 改的步驟，只是將查完的元素予以賦值。 void update(ListNode* head, int n, int val){ ListNode* curr = head; while (n--){ curr = curr-\u0026gt;next; } curr-\u0026gt;val = val; // 查完後賦值 } 3.","title":"[Algo] 0-3. 鏈表(Linked List)"},{"content":"一、資料結構概要 資料結構的存儲方式大體上只分為兩種： Array、Linked List。\n雖說資料結構有 disjoint matrix, queue, stack, tree, graph 等等，但它們都可以視為 Array 與 Linked List 的上層結構，可以看成是以 Array 或 Linked List 為基底上的操作，只是 API 不同而已。 Array：由於是緊湊連續儲存的，可以隨機訪問，通過 index 快速找到對應元素，且相對節約空間。但也因必須一次性分配儲存空間，所以 array 如果需要擴充容量，就必須再重新分配一塊更大的空間，再把數孛複製過去，其時間複雜度為 \\(O(N)\\)；在 array 中間進行 delete 與 insert，必須搬移後面所有數據以保持連續，故時間複雜度也為\\(O(N)\\)。 Linked List：因為元素不連續，而是靠指針指向下一個元素的位置，所以不存在 array 的擴充容量的問題，如果知道某一元素的前一個節點與後一個節點，操作指針即可刪除該元素或者插入新元素，時間複雜度為\\(O(1)\\)。但正因為儲存空間不連續，無法根擇 index 算出對應元素的地址，所以不能隨機訪問；而且由於每個元素必須額外儲存前後元素位置的指針，相對較耗空間。 在 C、C++ 語言中，指針(pointer)的存在使得其能更直接對儲存空間的位址做操作，所以在處理 C 語言時，要額外了解指針的運作方式。 二、資料結構的基本操作 資料結構的基本操作不外乎： 遍歷(traverse)、增減查改(CRUD, create, read, update, delete) Array：數組的遍歷框架 -\u0026gt; 典型的線性迭代結構： void traverse(vector\u0026lt;int\u0026gt; arr){ for (int i = 0; i \u0026lt; arr.size(); i++){ // iteration } } ListNode：鏈表的遍歷框架 -\u0026gt; 兼具迭代與遞迴 class ListNode { public: int val; ListNode* next; }; void traverse(ListNode* head){ for (ListNode curr = head; curr != NULL; curr = curr-\u0026gt;next){ // iteration } } void traverse(ListNode* head){ // recursion traverse(head-\u0026gt;next); } 由上述兩種基底可推廣至各種結構： 二叉樹(Binary Tree) class TreeNode { public: int val; TreeNode* left, right; }; void traverse(TreeNode* root){ traverse(root-\u0026gt;left); traverse(root-\u0026gt;right); } N 叉樹(N-ary Tree) class TreeNode { public: int val; vector\u0026lt;TreeNode*\u0026gt; children } void traverse(TreeNode* root){ for (TreeNode* child : root-\u0026gt;children){ traverse(child); } } 圖(graph)：可視為 N 叉樹的結合體，再利用 visited 處理環(circle) class Node { public: int val; vector\u0026lt;Node*\u0026gt; neighbors; } unordered_set\u0026lt;Node*\u0026gt; visited; // 處理已拜訪過的節點 void traverse(Node* node){ if (visited) return; // 檢查是否拜訪過了 visited.insert(node) // 將現在拜訪的節點標記成已拜訪的節點 for (TreeNode* neighbor : neighbors){ traverse(neighbor) } } 三、前序(pre-order)、中序(in-order)、後序(post-order) 在開始複雜的演算法前，重點在於熟悉如何處理不同的結構，並採用基礎的解題策略。 前序、中序、後序指的是遍歷一棵二元樹的方式。 基本框架 void traverse(TreeNode* root){ // pre-order traverse(root-\u0026gt;left); // in-order traverse(root-\u0026gt;right); // post-order } 鏈表其實也可以有前序、後序的關係： void traverse(ListNode* curr){ // pre-order traverse(curr-\u0026gt;next); // post-order } 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis 接著閱讀：[Algo] 0-3. 鏈表(LinkedList) ","permalink":"http://intervalrain.github.io/posts/cs/algo/concept/","summary":"一、資料結構概要 資料結構的存儲方式大體上只分為兩種： Array、Linked List。\n雖說資料結構有 disjoint matrix, queue, stack, tree, graph 等等，但它們都可以視為 Array 與 Linked List 的上層結構，可以看成是以 Array 或 Linked List 為基底上的操作，只是 API 不同而已。 Array：由於是緊湊連續儲存的，可以隨機訪問，通過 index 快速找到對應元素，且相對節約空間。但也因必須一次性分配儲存空間，所以 array 如果需要擴充容量，就必須再重新分配一塊更大的空間，再把數孛複製過去，其時間複雜度為 \\(O(N)\\)；在 array 中間進行 delete 與 insert，必須搬移後面所有數據以保持連續，故時間複雜度也為\\(O(N)\\)。 Linked List：因為元素不連續，而是靠指針指向下一個元素的位置，所以不存在 array 的擴充容量的問題，如果知道某一元素的前一個節點與後一個節點，操作指針即可刪除該元素或者插入新元素，時間複雜度為\\(O(1)\\)。但正因為儲存空間不連續，無法根擇 index 算出對應元素的地址，所以不能隨機訪問；而且由於每個元素必須額外儲存前後元素位置的指針，相對較耗空間。 在 C、C++ 語言中，指針(pointer)的存在使得其能更直接對儲存空間的位址做操作，所以在處理 C 語言時，要額外了解指針的運作方式。 二、資料結構的基本操作 資料結構的基本操作不外乎： 遍歷(traverse)、增減查改(CRUD, create, read, update, delete) Array：數組的遍歷框架 -\u0026gt; 典型的線性迭代結構： void traverse(vector\u0026lt;int\u0026gt; arr){ for (int i = 0; i \u0026lt; arr.size(); i++){ // iteration } } ListNode：鏈表的遍歷框架 -\u0026gt; 兼具迭代與遞迴 class ListNode { public: int val; ListNode* next; }; void traverse(ListNode* head){ for (ListNode curr = head; curr !","title":"[Algo] 0-2. 算法思維"},{"content":" From the begining:\nWasham\u0026rsquo;s Coding Interview University 演算法 Leetcode 演算法筆記 計算機結構 計算機結構 作業系統 計算機作業系統 網路 計算機網路 HTTP Socket 資料庫 資料庫系統原理 SQL 語法 NoSQL Redis 系統設計 系統設計基礎 分布式 集群 駭客技術 緩存 訊息佇列 物件導向 物件導向概念 設計模式 工具 Git Docker Kubernetes MVC 程式碼實踐 重構(Refactoring) Google Coding Style(C++) ","permalink":"http://intervalrain.github.io/posts/csindex/","summary":" From the begining:\nWasham\u0026rsquo;s Coding Interview University 演算法 Leetcode 演算法筆記 計算機結構 計算機結構 作業系統 計算機作業系統 網路 計算機網路 HTTP Socket 資料庫 資料庫系統原理 SQL 語法 NoSQL Redis 系統設計 系統設計基礎 分布式 集群 駭客技術 緩存 訊息佇列 物件導向 物件導向概念 設計模式 工具 Git Docker Kubernetes MVC 程式碼實踐 重構(Refactoring) Google Coding Style(C++) ","title":"CS 學習筆記"},{"content":" 前言：此系列文章為參考 labuladong 的 fucking algorithm與 Leetcode101(高暢) 作為基底，簡化核心內容，並將程式碼以自己的 C++ code 替代，作為自己的學習筆記。\n第零章、核心框架 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis 0-2. 算法思維 0-3. 鏈表 Linked List 0-4. 二叉樹 Binary Tree 第一章、資料結構、STL 1-1. vector 1-2. list, forward_list 1-3. stack 1-4. queue 1-5. set, multiset, unordered_set, unordered_multiset 1-6. map, multimap, unordered_map, unordered_multimap 1-7. deque 1-8. priority_queue 1-9. algorithm 第二章、演算法設計 2-1. 暴力演算法 Brute Force 2-2. 貪心演算法 Greedy 2-3. 分治法 Divide and Conquer 2-4. 回溯法 Backtacking 2-5. 動態規劃 Dynamic Programming 第三章、主題介紹 4-1. Binary Search 4-2. Two Pointer/Sliding Window 4-3. Monotonic Stack 4-4. DFS 4-5. BFS 4-6. Topological Sort 4-7. KMP 4-8. Prefix 4-9. Segment Tree 4-10. Bit Indexed Tree 4-11. Union Find 4-12. Trie 4-13. Bit Manipulation 4-14. Bitmask 4-15. Rolling Hash ","permalink":"http://intervalrain.github.io/posts/cs/algo/","summary":"前言：此系列文章為參考 labuladong 的 fucking algorithm與 Leetcode101(高暢) 作為基底，簡化核心內容，並將程式碼以自己的 C++ code 替代，作為自己的學習筆記。\n第零章、核心框架 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis 0-2. 算法思維 0-3. 鏈表 Linked List 0-4. 二叉樹 Binary Tree 第一章、資料結構、STL 1-1. vector 1-2. list, forward_list 1-3. stack 1-4. queue 1-5. set, multiset, unordered_set, unordered_multiset 1-6. map, multimap, unordered_map, unordered_multimap 1-7. deque 1-8. priority_queue 1-9. algorithm 第二章、演算法設計 2-1. 暴力演算法 Brute Force 2-2. 貪心演算法 Greedy 2-3. 分治法 Divide and Conquer 2-4.","title":"[DS] 演算法筆記"},{"content":"動態鏈結庫(Dynamic Linked Library, DDL) 將程式中重複引用的程式庫獨立包裝出來以便共同引用 好處是比起靜態庫更節省空間 也可以單獨修改動態庫文件 示例 創建一個自定義程式庫 math.c // math.c int add(int a, int b) { return a + b; } 建建一個 math.h 只包含函式的宣告 // math.h int add(int a, int b); 將 math.c 編譯成一個動態庫 -shared 表明是一個 shared library .so 是 Linux 下的動態庫的副檔名，Windows 下為 .dll $ gcc -shared -fPIC math.c -o libmath.so 在主程式中包含 math.h 頭文件 // main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main() { printf(\u0026#34;add(1, 2) returns %d\\n\u0026#34;, add(1, 2)); return 0; } 利用 -l 編譯主程式 省略 libmath.so 中的 lib 與 .so 為 -lmath gcc main.c -lmath -L. -o main 系統在路徑下找不到文件的解決方案 將動態庫複製到系統路徑下(需要 root 權限) $ sudo ^C cp libmath.so /usr/local/lib/ 使用環境變量，將當前目錄加到 LD_LIBRARY_PATH 環境變量中 $ export LD_LIBRARY_PATH=\u0026#34;$(pwd)\u0026#34; // 將當前目錄叫到 LD_LIBRARY_PATH中 $ echo $LD_LIBRARY_PATH // 測試是否調用成功 ","permalink":"http://intervalrain.github.io/posts/it/ddl/","summary":"動態鏈結庫(Dynamic Linked Library, DDL) 將程式中重複引用的程式庫獨立包裝出來以便共同引用 好處是比起靜態庫更節省空間 也可以單獨修改動態庫文件 示例 創建一個自定義程式庫 math.c // math.c int add(int a, int b) { return a + b; } 建建一個 math.h 只包含函式的宣告 // math.h int add(int a, int b); 將 math.c 編譯成一個動態庫 -shared 表明是一個 shared library .so 是 Linux 下的動態庫的副檔名，Windows 下為 .dll $ gcc -shared -fPIC math.c -o libmath.so 在主程式中包含 math.h 頭文件 // main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main() { printf(\u0026#34;add(1, 2) returns %d\\n\u0026#34;, add(1, 2)); return 0; } 利用 -l 編譯主程式 省略 libmath.","title":"[IT] 動態鏈結庫(DDL)"},{"content":"String Functions ASCII Return the ASCII value for the specific character CHAR_LENGTH or CHARACTER_LENGTH Return the length of string (in characters) CONCAT Adds two or more expressions together CONCAT_WS Adds two or more expressions together with a separator FIELD Returns the index position of a value in a list of values FIND_IN_SET Returns the position of a string within a list of strings FORMAT Return sFormats a number to a format like \u0026ldquo;#,###,###.##\u0026rdquo;, rounded to a specified number of decimal places INSERT Inserts a string within a string at the specified position and for a certain number of characters INSTR Returns the position of the first occurrence of a string in another string LCASE Converts a string to lower-case LEFT Extracts a number of characters from a string (starting from left) LENGTH Returns the length of a string (in bytes) LOCATE Returns the position of the first occurrence of a substring in a string LOWER Converts a string to lower-case LPAD Left-pads a string with another string, to a certain length LTRIM Removes leading spaces from a string MID Extracts a substring from a string (starting at any position) POSITION Returns the position of the first occurrence of a substring in a string REPEAT Repeats a string as many times as specified REPLACE Replaces all occurrences of a substring within a string, with a new substring REVERSE Reverses a string and returns the result RIGHT Extracts a number of characters from a string (starting from right) RPAD Right-pads a string with another string, to a certain length RTRIM Removes trailing spaces from a string SPACE Returns a string of the specified number of space characters STRCMP Compares two strings SUBSTR Extracts a substring from a string (starting at any position) SUBSTRING Extracts a substring from a string (starting at any position) SUBSTRING_INDEX Returns a substring of a string before a specified number of delimiter occurs TRIM Removes leading and trailing spaces from a string UCASE Converts a string to upper-case UPPER Converts a string to upper-case Numeric Functions ABS Returns the absolute value of a number ACOS Returns the arc cosine of a number ASIN Returns the arc sine of a number ATAN Returns the arc tangent of one or two numbers ATAN2 Returns the arc tangent of two numbers AVG Returns the average value of an expression CEIL Returns the smallest integer value that is \u0026gt;= to a number CEILING Returns the smallest integer value that is \u0026gt;= to a number COS Returns the cosine of a number COT Returns the cotangent of a number COUNT Returns the number of records returned by a select query DEGREES Converts a value in radians to degrees DIV Used for integer division EXP Returns e raised to the power of a specified number FLOOR Returns the largest integer value that is \u0026lt;= to a number GREATEST Returns the greatest value of the list of arguments LEAST Returns the smallest value of the list of arguments LN Returns the natural logarithm of a number LOG Returns the natural logarithm of a number, or the logarithm of a number to a specified base LOG10 Returns the natural logarithm of a number to base 10 LOG2 Returns the natural logarithm of a number to base 2 MAX Returns the maximum value in a set of values MIN Returns the minimum value in a set of values MOD Returns the remainder of a number divided by another number PI Returns the value of PI POW Returns the value of a number raised to the power of another number POWER Returns the value of a number raised to the power of another number RADIANS Converts a degree value into radians RAND Returns a random number ROUND Rounds a number to a specified number of decimal places SIGN Returns the sign of a number SIN Returns the sine of a number SQRT Returns the square root of a number SUM Calculates the sum of a set of values TAN Returns the tangent of a number TRUNCATE Truncates a number to the specified number of decimal places Date Functions ADDDATE Adds a time/date interval to a date and then returns the date ADDTIME Adds a time interval to a time/datetime and then returns the time/datetime CURDATE Returns the current date CURRENT_DATE Returns the current date CURRENT_TIME Returns the current time CURRENT_TIMESTAMP Returns the current date and time CURTIME Returns the current time DATE Extracts the date part from a datetime expression DATEDIFF Returns the number of days between two date values DATE_ADD Adds a time/date interval to a date and then returns the date DATE_FORMAT Formats a date DATE_SUB Subtracts a time/date interval from a date and then returns the date DAY Returns the day of the month for a given date DAYNAME Returns the weekday name for a given date DAYOFMONTH Returns the day of the month for a given date DAYOFWEEK Returns the weekday index for a given date DAYOFYEAR Returns the day of the year for a given date EXTRACT Extracts a part from a given date FROM_DAYS Returns a date from a numeric datevalue HOUR Returns the hour part for a given date LAST_DAY Extracts the last day of the month for a given date LOCALTIME Returns the current date and time LOCALTIMESTAMP Returns the current date and time MAKEDATE Creates and returns a date based on a year and a number of days value MAKETIME Creates and returns a time based on an hour, minute, and second value MICROSECOND Returns the microsecond part of a time/datetime MINUTE Returns the minute part of a time/datetime MONTH Returns the month part for a given date MONTHNAME Returns the name of the month for a given date NOW Returns the current date and time PERIOD_ADD Adds a specified number of months to a period PERIOD_DIFF Returns the difference between two periods QUARTER Returns the quarter of the year for a given date value SECOND Returns the seconds part of a time/datetime SEC_TO_TIME Returns a time value based on the specified seconds STR_TO_DATE Returns a date based on a string and a format SUBDATE Subtracts a time/date interval from a date and then returns the date SUBTIME Subtracts a time interval from a datetime and then returns the time/datetime SYSDATE Returns the current date and time TIME Extracts the time part from a given time/datetime TIME_FORMAT Formats a time by a specified format TIME_TO_SEC Converts a time value into seconds TIMEDIFF Returns the difference between two time/datetime expressions TIMESTAMP Returns a datetime value based on a date or datetime value TO_DAYS Returns the number of days between a date and date \u0026ldquo;0000-00-00\u0026rdquo; WEEK Returns the week number for a given date WEEKDAY Returns the weekday number for a given date WEEKOFYEAR Returns the week number for a given date YEAR Returns the year part for a given date YEARWEEK Returns the year and week number for a given date Advanced Functions BIN Returns a binary representation of a number BINARY Converts a value to a binary string CASE Goes through conditions and return a value when the first condition is met CAST Converts a value (of any type) into a specified datatype COALESCE Returns the first non-null value in a list CONNECTION_ID Returns the unique connection ID for the current connection CONV Converts a number from one numeric base system to another CONVERT Converts a value into the specified datatype or character set CURRENT_USER Returns the user name and host name for the MySQL account that the server used to authenticate the current client DATABASE Returns the name of the current database IF Returns a value if a condition is TRUE, or another value if a condition is FALSE IFNULL Return a specified value if the expression is NULL, otherwise return the expression ISNULL Returns 1 or 0 depending on whether an expression is NULL LAST_INSERT_ID Returns the AUTO_INCREMENT id of the last row that has been inserted or updated in a table NULLIF Compares two expressions and returns NULL if they are equal. Otherwise, the first expression is returned SESSION_USER Returns the current MySQL user name and host name SYSTEM_USER Returns the current MySQL user name and host name USER Returns the current MySQL user name and host name VERSION Returns the current version of the MySQL database ","permalink":"http://intervalrain.github.io/posts/it/mysql/","summary":"String Functions ASCII Return the ASCII value for the specific character CHAR_LENGTH or CHARACTER_LENGTH Return the length of string (in characters) CONCAT Adds two or more expressions together CONCAT_WS Adds two or more expressions together with a separator FIELD Returns the index position of a value in a list of values FIND_IN_SET Returns the position of a string within a list of strings FORMAT Return sFormats a number to a format like \u0026ldquo;#,###,###.","title":"[IT] MySQL Functions"},{"content":"Introduction What is SQL? SQL stands for Structured Query Language SQL lets you access and manipualate databases SQL becaome a standard of the American National Standards Institute (ANSI) in 1986, and of the International Organization for Standardization (ISO) in 1987 RDBMS RDBMS stands for Relational Database Management System. RDBMS is the basis for SQL, and for all modern database systems such as MS SQL Server, IBM DB2, Oracle, MySQL, and Microsoft Access. The data in RDBMS is stored in database objects called tables. A table is a collection of related data entries and it consists of columns and rows. Syntax SELECT * FROM Customers; SQL keywords are NOT case sensitive. Some database systems requires a semicolon at the end of each SQL statement. Semicolon is the standard way to separate each SQL statement in database systems that allow more than one SQL statement to be executed in the same call to the server. Most Important SQL Commands SELECT - extracts data from a database UPDATE - updates data in a database DELETE - deletes data from a database INSERT INTO - inserts new data into a database CREATE DATABASE - creates a new database ALTER DATABASE - modifies a database CREATE TABLE - creates a new table ALTER TABLE - modifies a table DROP TABLE - deletes a table CREATE INDEX - creates an index (search key) DROP INDEX - deletes an index SELECT The SELECT statement is used to select data from a database.\nThe data returned is stored in a result table, called the result-set. SELECT column1, column2, ... FROM table_name; SELECT DISTINCT The SELECT DINSTINCT statement is used to return only distinct (different) values.\nInside a table, a column often contains many duplicate values; and sometimes you only want to list the different (distinct) values. SELECT DISTINCT column1, column2, ... FROM table_name; WHERE The WHERE clause is used to filter records.\nIt is used to extract only those records that fultill a specified condition. SELECT column1, column2, ... FROM table_name WHERE condition; Operators can be used in the WHERE clause: \\(\\begin{array}{|c|l|}\\hline \\text{Operator}\u0026amp;\\text{Description}\\\\\\hline \\text{=}\u0026amp;\\text{Equal}\\\\\\hline \\text{\u0026gt;}\u0026amp;\\text{Greater than}\\\\\\hline \\text{\u0026lt;}\u0026amp;\\text{Less than}\\\\\\hline \\text{\u0026gt;=}\u0026amp;\\text{Greater than or equal}\\\\\\hline \\text{\u0026lt;=}\u0026amp;\\text{Less than or equal}\\\\\\hline \\text{\u0026lt;\u0026gt;, !=}\u0026amp;\\text{Not equal}\\\\\\hline \\text{BETWEEN}\u0026amp;\\text{Between a certain range}\\\\\\hline \\text{LIKE}\u0026amp;\\text{Search for a pattern}\\\\\\hline \\text{IN}\u0026amp;\\text{To specify multiple possible values for a column}\\\\\\hline \\end{array}\\) AND, OR, NOT THE WHERE clause can be combined with AND, OR, and NOT operators.\nThe AND and OR operators are used to filter records based on more than one condition: The AND operator displays a record if all the conditons separated by AND are TRUE. The OR operator displays a record if any of the conditons separated by OR is TRUE. THE NOT operator display a record if the condition(s) it NOT TRUE. SELECT column1, column2, ... FROM table_name; WHERE NOT condition1 AND condition2 OR condition3 ...; ORDER BY The ORDER BY keyword is used to sort the result-set in ascending or descending order. The ORDER BY keyword sorts the records in ascending order by default.\nTo sort the records in descending order, used DESC keyword. SELECT column1, column2, ... FROM table_name ORDER BY column1, column2, ... ASC|DESC; INSERT INTO The INSERT INTO statement is used to insert new records in a table. Specify both the column names and the values to be inserted: INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...); If you are adding values for all the columns of the table, you do not need to specify the column names in the SQL query. However, make sure the order of the values is in the same order as the columns in the table. Here, the INSERT INTO syntax would be as follows: INSERT INTO table_name VALUES (value1, value2, value3, ...); IS NULL, IS NOT NULL What is a NULL Value?\nA field with a NULL value is a field with no value.\nIf a field in a table is optional, it is possible to insert a new record or update a record without adding a value to this field. Then the field will be saved with a NULL value. A NULL value is different from a zero value or a field that contains spaces. A field with a NULL value is one that has been left blank during record creation. How to test for NULL Values?\nUse the IS NULL and IS NOT NULL operators. SELECT column_names FROM table_name WHERE column_name IS NULL|IS NOT NULL; UPDATE The UPDATE statement is used to modify the existing records in a table. UPDATE table_name SET columns1 = value1, column2 = value2, ... WHERE condition; DELETE The DELETE statement is used to delete existing records in a table. DELETE FROM table_name WHERE condition; TOP, LIMIT, FETCH FIRST, ROWNUM The SELECT TOP clause is used to specify the number of records to return. The SELECT TOP clause is useful on large tables with thousands of records.\nReturning a large number of records can impact performance. Note: Not all database systems support the SELECT TOP clause.\nMySQL supports the LIMIT clause to select a limited number of records,\nwhile Oracle uses FETCH FIRST n ROWS ONLY and ROWNUM.\nSQL Server/Ms Access: SELECT TOP number|percent column_names(s) FROM table_name WHERE condition; MySQL: SELECT column_names(s) FROM table_name WHERE condition LIMIT number; Oracle 12: SELECT column_names(s) FROM table_name ORDER BY column_name(s) FETCH FIRST number ROWS only; Older Oracle: SELECT column_names(s) FROM table_name WHERE ROWNUM \u0026lt;= number; Older Oracle(with ORDER BY) SELECT * FROM ( SELECT column_name(s) FROM table_name ORDER BY column_name(s) ) WHERE ROWNUM \u0026lt;= number; MIN() The MIN() function returns the smallest value of the selected column. SELECT MIN(column_name) FROM table_name WHERE condition; MAX() The MAX() function returns the largest value of the selected column. SELECT MAX(column_name) FROM table_name WHERE condition; COUNT() The COUNT() function returns the number of rows that matches a specified criterion. SELECT COUNT(column_name) FROM table_name WHERE condition; AVG() The AVG() function returns the average value of a numeric column. SELECT AVG(column_name) FROM table_name WHERE condition; SUM() The SUM() function returns the total sum of a numeric column. SELECT SUM(column_name) FROM table_name WHERE condition; LIKE Operator The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. There are two wildcards often used in conjunction with LIKE operator: The percent sign(%) represents zero, one, or multiple characters The underscore sign(_) represents one, single character Note: Ms Access uses an asterisk(*) instead of the percent sign(%), and a question mark(?) instead of the underscore(_).\nSELECT column1, column2 FROM table_name WHERE columnN LIKE \u0026#39;_a%\u0026#39;; Wildcards A wildcard character is used to substitute one or more characters in a string.\nWildcard characters are used with LIKE operator. The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.\nMS Access:\nSymbal Description Example * Represents zero or more characters bl* finds bl, black, blue, and blob ? Represents a single character h?t finds hot, hat, and hit [] Represents any single character within the brackets h[oa]t finds hot and hat ! Represents any character not in the brackets h[!oa]t finds hit - Represents any single character within the specified range c[a-b]t finds cat and cbt # Represents any single numeric character 2#5 finds 205,215,225,235,245,255,265,275,285,295 SQL Server:\nSymbal Description Example % Represents zero or more characters bl% finds bl, black, blue, and blob _ Represents a single character h_t finds hot, hat, and hit [] Represents any single character within the brackets h[oa]t finds hot and hat ^ Represents any character not in the brackets h[^oa]t finds hit - Represents any single character within the specified range c[a-b]t finds cat and cbt IN The IN operator allows you to specify multiple values in a WHERE clause.\nThe IN operator is a short hand for multiple OR conditinos. SELECT column_name(s) FROM table_name WHERE column_name IN (value1, value2, ...); or\nSELECT column_name(s) FROM table_name WHERE column_name IN (SELECT STATEMENT); BETWEEN The BETWEEN operator selects values within a given range. The values can be numbers, text, or dates.\nThe BETWEEN operator is inclusive: begin and end values are included. SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2; Aliases SQL aliases are used to give a table, or a column in a table, a temporary name.\nAliases are often used to make column names more readable.\nAn alias only exists for the duration of that query.\nAn alias is created with the AS keyword.\nAlias Column Syntax\nSELECT column_name AS alias_name FROM table_name; Alias Table syntax SELECT column_name(s) FROM table_name AS alias_name; Joins A JOIN clause is used to combine rows from two ormore tables, based on a related column between them. Orderes\nOrderId CustomerID OrderDate 10308 2 1996-09-18 10309 37 1996-09-19 10310 77 1996-09-20 Customers\nCustomerID CustomerName ContactName Country 1 Alfreds Futterkiste Maria Anders Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Mexico 3 Antonio Moreno Taqueria Antonio Moreno Mexico SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate FROM Orders INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID; Result\nOrderID CustomerName OrderDate 10308 Ana Trujillo Emparedados y helados 9/18/1996 10365 Antonio Moreno Taquería 11/27/1996 10383 Around the Horn 12/16/1996 10355 Around the Horn 11/15/1996 10278 Berglunds snabbköp 8/12/1996 INNER JOIN The INNER JOIN keyword selects records that have matching values in both tables. SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; LEFT JOIN The LEFT JOIN keyword returns all records from the left table(table1), and the matching records from the right table(table2). The result is 0 records from the right side, if there is no match. SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name = table2.column_name; RIGHT JOIN (RIGHT OUTER JOIN) The RIGHT JOIN keyword returns all records from the right table(table2), and the matching records from the left table (table1). The result is 0 records from the left side, if there is no match. SELECT column_name(s) FROM table1 RIGHT JOIN table2 ON table1.column_name = table2.column_name; FULL JOIN (FULL OUTER JOIN) The FULL JOIN keyword returns all records when there is a match in left(table1) or right (table2) table records. SELECT column_name(s) FROM table1 FULL JOIN table2 ON table1.column_name = table2.column_name WHERE condition; Self Join A self join is a regular join, but the table is joined with itself. SELECT column_name(s) FROM table1 T1, table1 T2 WHERE condition; Customers\nCustomerID CustomerName ContactName Address City PostalCode Country 1 Alfreds Futterkiste Maria Anders Obere Str. 57 Berlin 12209 Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Avda. de la Constitución 2222 México D.F. 05021 Mexico 3 Antonio Moreno Taquería Antonio Moreno Mataderos 2312 México D.F. 05023 Mexico SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City FROM Customers A, Customers B WHERE A.CustomerID \u0026lt;\u0026gt; B.CustomerID AND A.City = B.City ORDER BY A.City; UNION The UNION operator is ued to combine the result-set of two or more SELECT statements. Every SELECT statement within UNION must have the same number of columns The columns must also have similar data types The columns in every SELECT statement must also be in the same order. SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2 The UNION operator selects only distinct values by default. To allow deuplicate values, use UNION ALL: SELECT column_name(s) FROM table1 UNION ALL SELECT column_name(s) FROM table2 Note: The column names in the result-set are usually equal to the column names in the first SELECT statement.\nGROUP BY The GROUP BY statement groups rows that have the same values into summary rows, like \u0026ldquo;find the number of customers in each country\u0026rdquo;. The GROUP BY statment is often used with aggregate functions (COUNT(),MAX(),MIN(),SUM(),AVG()) to group the result-set by one ore more columns. SELECT column_name(s) FROM table_name WHERE condition GROUP BY column_name(s) ORDER BY column_name(s); HAVING The HAVING clause was added to SQL because the WHERE keyword cannot be used with aggregate functions. SELECT column_name(s) FROM table_name WHERE conditon GROUP BY column_name(s) HAVING condition ORDER BY column_name(s); Sample SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country HAVING COUNT(CustomerID) \u0026gt; 5; EXISTS The EXISTS operator is used to test for the existence of any record in a subquery. The EXISTS operator returns TRUE if the subquery returns one or more records. SELECT column_name(s) FROM table_name WHERE EXISTS (SELECT column_name(s) FROM table_name WHERE condition ); ANY The ANY operator: returns a boolean value as a result returns TRUE if ANY of the subquery values meet the condition ANY means that the conditon will be true if the operation is true for any of the values in the range. SELECT column_name(s) FROM table_name WHERE column_name(s) opeartor ANY (SELECT column_name FROM table_name WHERE condition); ALL The ALL opeartor: returns a boolean value as a result returns TRUE if ALL of the subquery values meet the conditon is used with SELECT, WHERE and HAVING statements ALL means that the conditon will be true only if the operation is true for all values in the range. SELECT ALL column_name(s) FROM table_name WHERE conditon syntax with WHRER or HAVING SELECT column_name(s) FROM table_name WHERE column_name operator ALL (SELECT column_name FROM table_name WHERE condition); SELECT INTO The SELECT INTO statement copies data from one table into a new table.\nCopy all columns into a new table:\nSELECT * INTO newtable [IN externaldb] FROM oldtable WHERE condition Copy only some columns into a new table: SELECT column1, column2, column3, ... INTO new table [IN externaldb] FROM oldtable WHERE condition; INSERT INTO SELECT The INSERT INTO SELECT statement copies data from one table and inserts it into another table. The INSERT INTO SELECT statement requires that the data types in source and target tables match. Note: The existing records in the target table are unaffected.\nCopy all columns from one table to another table: INSERT INTO table2 SELECT * FROM table1 WHERE condition Copy only some columns from one table into another table: INSERT INTO table2 (column1, column2, column3, ...) SELECT column1, column2, column3, ... FROM table1 WHERE condition CASE The CASE expression goes through conditions and returns a value when the first condition is met (like an if-then-else statement). So, once a condition is true, it will stop reading and return the result. If no conditions are true, it returns the value in the ELSE cluase. If there is no ELSE part and no condtions are true, it retures NULL. CASE WHEN conditon1 THEN result1 WHEN conditon2 THEN result2 WHEN conditonN THEN resultN ELSE resuklt END NULL Functions Products |P_Id|ProductName|UnitPrice|UnitsInStock|UnitsOnOrder| |1|Jarlsberg|10.45|16|15| |2|Mascarpone|32.56|23| | |3|Gorgonzola|15.67|9|20|\nSuppose that the \u0026ldquo;UnitsOnOrder\u0026rdquo; column is optional, and may contain NULL values.\nMySQL\nINFULL() SELECT ProductName, UnitPrice * (UnitsInStock + IFNULL(UnitsOnOrder, 0)) FROM Products; COALESCE() SELECT ProductName, UnitPrice * (UnitsInStock + COALESCE(UnitsOnOrder, 0)) FROM Products; SQL Server ISNULL() SELECT ProductName, UnitPrice * (UnitsInStock + ISNULL(UnitsOnOrder, 0)) FROM Products; COALESCE() SELECT ProductName, UnitPrice * (UnitsInStock + COALESCE(UnitsOnOrder, 0)) FROM Products; MS Access IsNULL() SELECT ProductName, UnitPrice * (UnitsInStock + IIF(IsNull(UnitsOnOrder), 0, UnitsOnOrder)) FROM Products; Oracle NVL() SELECT ProductName, UnitPrice * (UnitsInStock + NVL(UnitsOnOrder, 0)) FROM Products; COALESCE() SELECT SELECT ProductName, UnitPrice * (UnitsInStock + COALESCE(UnitsOnOrder, 0)) FROM Products; Sotred Precedures A stored procedure is a prepared SQL code that you can save, so the code can be reused over and over again.\nSo if you have an SQL query that you write over and over again, save it as a stored procedure, and then just call it to execute it.\nYou can also pass parameters to a stored procedure, so that the stored procedure can act based on the parameter value(s) that is passed.\nStored Procedure Syntax\nCREATE PROCEDURE procedure_name AS sql_statement GO; ** Execute as Stored Procedure\nEXEC procedure_name; Comments Single line comments --. Multi-line comments /* and */. ","permalink":"http://intervalrain.github.io/posts/it/sql/","summary":"Introduction What is SQL? SQL stands for Structured Query Language SQL lets you access and manipualate databases SQL becaome a standard of the American National Standards Institute (ANSI) in 1986, and of the International Organization for Standardization (ISO) in 1987 RDBMS RDBMS stands for Relational Database Management System. RDBMS is the basis for SQL, and for all modern database systems such as MS SQL Server, IBM DB2, Oracle, MySQL, and Microsoft Access.","title":"[IT] SQL"},{"content":"兼愛 非攻 尚賢 尚同 節用 節葬 天志 明鬼 非樂 非命 ","permalink":"http://intervalrain.github.io/posts/life/mohism/","summary":"兼愛 非攻 尚賢 尚同 節用 節葬 天志 明鬼 非樂 非命 ","title":"[Life] Mohism 墨"},{"content":"347. Top K Frequent Elements\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Divide and Conquer、Sorting、Heap (Priority Queue)、Bucket Sort、Counting、Quickselect 一、題目 Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:\nInput: nums = [1], k = 1 Output: [1] Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 k is in the range [1, the number of unique elements in the array]. It is guaranteed that the answer is unique. Follow up: Your algorithm\u0026rsquo;s time complexity must be better than O(n log n), where n is the array\u0026rsquo;s size.\n二、分析 先以 HashMap 統計每個數字出現的頻率後，再以出現的頻率做排序。Bucket sort 或是 max heap。 priority_queue 的宣告方式。 greater\u0026lt;\u0026gt; 與 less\u0026lt;\u0026gt; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // descending order (min heap) priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, less\u0026lt;int\u0026gt;\u0026gt; pq; // ascending order (max heap) custom comparactor auto comp = [](const auto\u0026amp; a, const auto\u0026amp; b) { return condition; } ; priority_queue\u0026lt;element, container, decltype(comp)\u0026gt; pq(iterator::start, iterator::end, comp); default: max heap priority_queue\u0026lt;element\u0026gt; pq; // 預設為 max heap 三、解題 1. Priority Queue Time complexity: \\(O(n\\log k)\\) Space complexity: \\(O(n)\\) vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;int,int\u0026gt; freq; for (const int\u0026amp; num : nums) // 統計每個數字出現的次數 freq[num]++; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; pq; for (const auto\u0026amp; x : freq) // 用 max_heap 裝 {頻率, 數字} pq.push(make_pair(x.second, x.first)); vector\u0026lt;int\u0026gt; res; while (k--) { // 取出現頻率前 k 高的 res.push_back(pq.top().second); pq.pop(); } return res; } 2. Bucket Sort Time complexity: \\(O(n)\\) Space complexity: \\(O(1)\\) vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { unordered_map\u0026lt;int,int\u0026gt; freq; for (const int\u0026amp; num : nums) // 統計每個數字出現的次數 freq[num]++; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; bucket; for (const auto f : freq) { while (bucket.size() \u0026lt;= f.second) { // 將數字，依不同頻率次數放到相對應的 vector 中 bucket.push_back({}); } bucket[f.second].push_back(f.first); } vector\u0026lt;int\u0026gt; res; for (int i = bucket.size()-1; i \u0026gt;= 0; i--) { for (int j = 0; j \u0026lt; bucket[i].size() \u0026amp;\u0026amp; k; j++, k--) { // 拿頻率前 k 多的元素 res.push_back(bucket[i][j]); } } return res; } 回目錄 Catalog\n","permalink":"http://intervalrain.github.io/posts/leetcode/347/","summary":"347. Top K Frequent Elements\nHardness: \\(\\color{orange}\\textsf{Medium}\\) Ralated Topics: Array、Hash Table、Divide and Conquer、Sorting、Heap (Priority Queue)、Bucket Sort、Counting、Quickselect 一、題目 Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:\nInput: nums = [1], k = 1 Output: [1] Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 k is in the range [1, the number of unique elements in the array].","title":"[Leetcode] 347. Top K Frequent Elements"},{"content":"Next step: Technical Phone Interview:\nDuration: 45mins Google Hangouts call (video is optional) Coding is done on Google Docs Please ensure you have a working internet connection and current web browser :)\nThere will be about 1-3 different questions (dependent on complexity - e.g. 1 Hard OR 2 Medium problems) related to coding, data structures and algorithms. You will be expected to come up with optimized and production-ready code, free of bugs. You should not write in pseudo-code.\nI would highly recommend watching this video first to get a good grasp of the tips/ideas/areas of focus for the interviews here at Google. Do then read the next part to concretise these interview tips.\nRefresh yourself with CS fundamentals We do expect you to know a lot about algorithms and data structures and especially be able to implement them into your solutions - there is a great bigocheatsheet that may also help you! Steve Yegge’s Blog Google Style Guides (C++) Geek for Geeks - Study algorithms and data structure System Design resources: System design interview tip! Hired in Tech Coding Practice + CS review When you practice, do not use an IDE. You need to be able to write legible, compilable code without help with regards to layout, or spelling of standard library class/method names. I suggest solving similar style algorithmic/ DS problems on a google document or on paper to simulate a real interview. Several sites that provide similar problems to those typically asked in the interview are:\nLeetcode Code Jam Kickstart - great practice to get a glimpse of Google coding and algorithm questions. Code Jam hosts online Kickstart rounds that give participants the opportunity to test and grow their coding abilities! Participate in one—or join them all! You can also learn how to solve those problems by reading our analysis Codeforces HackerRank Topcoder ACM-ICPC Code Jam Below are some tips for your Coding Rounds: Write very clean, well-structured code and proactively address potential errors. Exhibit advanced coding approach (e.g. may have conducted exhaustive error-checking for boundary conditions, use appropriate idiomatic constructs in code, etc.\nTest covered several corner cases, tests are simple but thorough - (dependency injection, no static cling, etc.)\nIdentify data structures to design a solution with optimal efficiency.\nPropose multiple algorithmic approaches to single and compound problems.\nIdentify an optimal solution for given time-space tradeoffs.\nPropose novel, creative algorithmic solutions or come up with alternative optimal solutions for different constraints.\nCreate a workable design for a complex problem using a sound problem solving approach (e.g., gathered requirements, identified solutions, mapped solutions to design, understand constraints and trade-offs, estimated unknowns reasonably)\nShow robust comprehension of problems, identifying supplemental contingencies/challenges. Provide examples and/or alternative explanations to clarify rationale. Communicate code/algorithms/etc. in a way that leaves no room for confusion.\nTranslate ideas into code/action without the need for revision. Proactively identify and provide solutions for additional considerations beyond the initial problem, expanding the complexity/scope of solution.\nImportant areas of assessment Coding - Good code quality (No IDE. Fully functional code. Take care of syntax, good language constructs, clean and concise code) \u0026amp; coding fast (you can code in Codechef timed challenges to practise coding under time pressure)\nDS \u0026amp; Algo - Refer to below topics on what we are assessing for\nGood communication - Talk out loud, explain your thought process to the interviewer\nAttitude - Being independent, lead/drive the discussion forward while being receptive to hints from interviewers and integrating it in your solution\nSpeed of solving the question (Ideally 20mins per question - refer to below notes on time allocation)\nStrategy for Success (Framework) Step 1: Clarify the problem Step 2: Define your approach Step 3: Propose a solution Propose a solution before coding. Feel free to say that your first solution will be refined later Run through at least one or two examples to check for correctness Use reasonable variable names or clean up the code after the first pass Ask if the interviewer has any questions before refinement Step 4: Propose an alternative solution Step 5: Implementation Time Allocation During Interview (Suggestion from Googlers for your reference) + Solve 1 question in 20 mins + 2 mins for gathering all requirements and asking clarifying questions from the interviewer. + Approx 8-10 mins for coming up with a valid solution to the question, discuss with the interviewer about your solution, trade offs, the time and space complexity. + 5 mins for coding the solution. + 5 mins for dry run (sample test cases) along with discussion with the interviewer. Breakdown of Framework Tip 1: Think out Loud \u0026amp; Communicate your Thought Process\nGoogle interviewers are assessing you based on your problem solving skills, and want to know your full thought process behind why and how you derived the final result\nTalk through your entire thought process \u0026amp; explain about your approach, how you derive a certain algorithm, explain the trade offs, and discuss the complexity of the solutions you are proposing and explain your code (Talk and Code).\nMost important would be to pick the right data structure and algorithm for a specific problem! Talk about how they\u0026rsquo;re implemented and why you\u0026rsquo;d choose one implementation or data structure instead of another.\nDo not mumble to yourself or keep silent when thinking.\nTip 2: Ask Clarifying Questions (Very Important!)\nNever jump straight and code up the solution. Always take a pause, look at the interview question and ask some clarifying questions\nThese clarifying questions should enable you to cover for edge/boundary cases better and to define the scope of the question. Eg:\u0026ldquo;Describe a good algorithm for sorting a million numbers\u0026rdquo;\nGood Clarifying Questions: What is the range of the numbers? How are they distributed? Are the numbers integers or floating points? How much memory is available? Are there duplicates? Tip 3: Discuss algorithmic complexities \u0026amp; Identify all Edge Cases Independently\nFor Algorithms, you will need to know big-o notation very well.\nAlways state time and space complexities upfront. Think of how you can reduce the complexity further to reach an optimised solution!\nDistinguish between average case/worst case runtime\nConsider amortized time complexities!\nThe goal is to reach the most optimised solution at the end of the interview, and to have a complete working solution.\nTip 4: Test your Code\nCheck for boundary conditions!\nStress tests to ensure that the code runs within time constraint\nCreate tests that have 100% code coverage\nRectify any bugs in your code before the interviewer points it out\nTip 5: Ensure Good Code Quality on Google Docs\nYou are expected to code in Google Docs. Since it does not have any IDE, you are expected to type out your code from scratch\nType as close to fully functional code as possible. This code should be maintainable and readable by a large database of engineers\nCode in the latest version of your preferred language and use appropriate language constructs. Take care of variable names and syntax.\nDo not use Pseudo code or shortcuts, it is not good enough.\nAlways cover for Edge/Boundary cases\nTip 6: Positive \u0026amp; Independent Attitude \u0026amp; Being Open to Feedback\nIf you get stuck, stay calm, asking questions can help to reduce the scope of the problem.\nAim to solve as much independently as possible, ideally with as few hints as possible.\nAlways take the initiative in the interview, and treat it like a technical discussion.\nListen attentively to the interviewer, and integrate the hints/suggestions by the interviewer to your solution.\nInterview Preparation Plan (created by Google Software Engineers) Revise all concepts on data structures \u0026amp; algorithms- you can also use this gitHub link on CS fundamentals that can serve as a checklist while preparing. This BigO cheat sheet http://bigocheatsheet.com/ could help you as well!\nStructured Revision plan on the topics that to cover (Eg. hashtable, hashmaps, trees, arrays, strings, graphs, dynamic programming and more)\nPractise per category\nPractice up to a level that you reach competency - Solve the question in 20/40 minutes (for medium and hard problems respectively) and come up with the optimal solutions\nPractice Problem Identification by picking random problems and practice identifying “Which category does this problem belong to? Backtracking/Dynamic programming? Solution/Algorithmic design?”.\nPractice coding without an IDE, be familiar with the differences in how you should write code in Google Docs. Do practise coding in Google Docs within a set time frame and getting comfortable talking while coding.\nIn summary: Practise a wide variety of questions, and simulate actual interview conditions! You can also run mock interviews here at pramp.com\nFrequently asked topics (in no particular order) Binary search\nBFS/DFS/Flood fill\nTree traversals\nHash tables\nLinked list, stacks, queues, two pointers/sliding window\nBinary heaps\nDynamic programming\nUnion find\nAd hoc/string manipulations\nOther good to know topics: Trie, segment trees/fenwick trees, bitmask\nGoogle Interview Style Guides (C++, Python, Java; Javascript)\nYou\u0026rsquo;ll be expected to know and apply: lists, maps, stacks, priority queues, binary trees, graphs, bags, and sets.\nFor algorithms you\u0026rsquo;ll want to know greedy algorithms, divide and conquer, dynamic programming, recursion, and brute force search.\nYou\u0026rsquo;ll definitely want to be conversant with big­O notation, time­-space complexity, and real world performance of all of this.\nWhat we are assessing for Data Structures \u0026amp; Algorithms Can you implement the most optimized data structure and algorithm for the question?\nCan you explain the tradeoffs between the data structure/solution?\nCan you explain why you choose a data structure for implementation\nCan you explain and analyze the time and space complexity correctly\nCan you translate the algorithm to code well?\nSystem Design Tips System Design assesses a candidate\u0026rsquo;s ability to combine knowledge, theory, experience and judgement toward solving a real-world engineering problem with significant ambiguity.\nSystems Design questions are about learning from your experience and applying those lessons to future projects. We are looking for you to be able to:\nClarify the problem - System Design questions are deliberately underspecified, and we expect candidates to understand where the gaps are and ask followup questions, just like in a real project, where you have to probe to find the boundaries of the problem space.\nBreak down a complex problem into parts, and be able to discuss the overall design at both a high level and to do a deep dive into how a component in your system works. Note you will likely have to dig deeper into the problem initially presented to clarify details and understand resource requirements and limitations.\nIdentify and analyze tradeoffs in your design, understanding what the implications are. Note that we are more interested in seeing that you understand the implications of the various tradeoffs you make in your design \u0026ndash; we want to see a coherent design rather than evaluating if specific tradeoffs are “correct” or not.\nRecovering from failure. Things go wrong in real life. At large scale they can happen more often. How do you detect and defend against failures?\nAvoid answers, which involve \u0026ldquo;use a standard database and do queries against it;\u0026rdquo; we\u0026rsquo;re not looking for answers involving off-the-shelf products, rather how do you build from scratch? [*Talking about why or why not available solutions could or could not be effective does hold value]\nSystems design Building large-scale distributed systems (video version) The Google File System Bigtable: A Distributed Storage System for Structured Data https://backendology.com/2018/09/10/distributed-systems-course-reading-list/ Useful Resources\nVideos/Blogs:\nCoding Practice:\nFree Refresher Courses:\nExample Coding/Engineering Interview\nHow to: Prepare for a Google Engineering Interview\nInterview tips from Google Software Engineers\nSteve Yegge’s Blog (read me!)\nCheck out this YouTube playlist!\nHackerRank\nTopcoder\nLeetCode\nInterviewcake\nKattis\nGeeksforgeeks\nPramp - Mock Interview\nInterviewing.io\nStrategy for algorithmic problem solving - step by step\nIntro (https://www.coursera.org/learn/cs-tech-interview/lecture/hYbvm/algorithmic-problem-solving-and-interviews)\nWhat to do first (https://www.coursera.org/learn/cs-tech-interview/lecture/hAbVU/case-study-introduction)\nStarting with a naive solution (https://www.coursera.org/learn/cs-tech-interview/lecture/gs7Tg/case-study-a-first-solution)\nOptimizing your solution (https://www.coursera.org/learn/cs-tech-interview/lecture/Qu7hy/case-study-going-deeper)\nMIT Open courseware - Introduction to Algorithms\nAll the best with your preparation! Please let me know if you have any questions.\n","permalink":"http://intervalrain.github.io/posts/life/prepare/","summary":"Next step: Technical Phone Interview:\nDuration: 45mins Google Hangouts call (video is optional) Coding is done on Google Docs Please ensure you have a working internet connection and current web browser :)\nThere will be about 1-3 different questions (dependent on complexity - e.g. 1 Hard OR 2 Medium problems) related to coding, data structures and algorithms. You will be expected to come up with optimized and production-ready code, free of bugs.","title":"[Life] July's plan"},{"content":" 本文是筆者基於工作上統計製程控制(Statistical Process Control, SPC) 的心得與學習筆記，可能有紕漏，僅供參考。\n統計學(Statistics) 基本名詞 群體(population)：研究對象的主體。 如上例的\\(\\red{\\text{全國人民的政治傾向}}\\)、\\(\\red{\\text{此家工廠的產品品質}}\\)。 樣本(sample)：群體的一部分。 如上例的\\(\\red{\\text{台灣部分的民眾}}\\)、\\(\\red{\\text{工廠部分的抽樣}}\\)。 目的：了解美國總統大選誰會獲勝? 群體：美國有投票權的公民 此時不是美國公民的台灣民眾，就不會是這個題目的樣本。 參數(parameter)：由群體資料所計算之群體表徵值。 統計量(statistic)：由樣本資料所計算之樣本表徵值。 為何需要統計學? 統計學是一種工具，人們為了下決策所作的一系列蒐集資料、整理、分析、與解析，是目的導向的。 比方說，每次總統大選會花費大量人力，動員全國上下公教人員，花錢印選舉公報、印選票，選後還要花費大量的時間開票、驗票。假如我只是個學生想了解目前國家人民的政治傾向，不可能收集台灣上下每個人的答案，所以我們會進行抽樣。 比方說工廠出貨會抽樣調查產品有沒有損壞，不可能全部的產品都拿去做測試，因為成本太高。 藉由普查或抽樣的結果來描述全體的行為，作為決策的依據。 統計的目的：\\(\\red{\\text{由樣本資料推論母體參數}}\\)。\n解決統計問題的五大步驟 問題定義 先決定你要討論的問題，跟此問題可能相關的對象為何？可以收集哪些資料？\n定義問題的群體與樣本。 例如：我想了解 A 工廠「晶片良率」，我認為可能跟「晶片厚度」有關係。 群體：A 工廠生產的晶片良率 樣本：某段時間內 A 工廠某機台生產晶片的厚度 例如：我想了解 B 國小附幼「小朋友學習狀況」，我認為可能跟「A 考卷的成績」有關。 群體：B 國小附幼小朋友的學習狀況 樣本：某次活動後的一次學習單成績。 資料收集 要收集哪些資料？哪些資料有可能可以協助我解決我想了解的問題？\n例如，收集晶片的氧化層厚度、爐管的溫度、機台的編號、機台的廠商\n測量尺度 等比尺度(Ratio measurements)：具有零值且資料間的距離是相等被定義的。 如晶片的氧化層厚度 等距尺度(Interval measurements)：資料間的距離是相等被定義的，定零值並非絕對的無，而是自行定義的。 如爐管的溫度(攝氏) 順序尺度(Ordinal measurements)：數據的意義是並非表現在值上而是在其順序上。 如機台的編號 名目尺度(Nominal measurements)：測量值不具量的意義。 如機台的廠商 資料整理 很多時候我們光看數字，會對研究主體沒感覺，所以引入畫圖來協助我們判斷資料。\n資料的整理分為兩個部分： 審查資料 篩選有用的資料，收集來的資料是不是與預想的一致，資料是否有錯誤、遺漏、矛盾或是其它可疑的地方？應立刻設法檢查並更正。如果資料由不同單位蒐集而來，可能需要經過正常化(normalization)加以換算統一。太過複雜的資料應依照研究目的加以整理，以求簡化，並藉以顯示研究對象全體的通則。 資料表現 資料經過整理分析得到一些統計結果，為了方便說明，我們常以圖表的方式陳示出來，以供參考使用。 散點圖(Scatter plot): 可以看相關係數 常態分布圖(高斯分布圖 normal distribution, gauss distribution)：\n可以看數據分布→變異數(低濶峰變異數大，高狹峰變異數小) 直方圖：跟常態分布圖用途接近，當數據點少的時候使用。\n條狀圖(柱狀圖)：分類\n折線圖：看時間趨勢(看股票?)\n圓餅圖：看組成\n瀑布圖：看累計量(也是看股票?)\n累積直方圖(CDF)： 族繁不及備載…\n資料分析 從圖表看到的有時候過於直觀，\n於是我們開始用你收集到的資料來做數學，然後進一步分析。\n有比較基本、常用的「統計量」與、「指標」(如平均數、標準差)，\n也有比較進階的根據不同領域所設計的「進階指標」(如吉尼係數(研究貧富差距))。\n常用統計量、指標 統計量用來描述研究對象的表徵，\n例如一家公司的年薪中位數，可以了解這家公司的薪資水準。\n例如西瓜班的平均身高，可以了解在同齡的小朋友身高狀況。\n例如新竹市市民的家庭收入標準差，可以了解新竹市的貧富差距狀況。 統計量不外乎就是用來描述「程度」與「分布」。\n集中趨勢：用來描述研究對象(大多數)的「程度」。 平均數 群體平均數：\\(\\boxed{\\mu=\\frac{\\sum X_i}{N}}\\) 樣本平均數：\\(\\boxed{\\bar{X}=\\frac{\\sum X_i}{n}}\\) 中位數：最中間的那個值 眾數：重複最多次的那個值 離中趨勢：用來描述研究對象「分佈的情形」 全距： \\(\\boxed{R=\\text{Max}-\\text{Min}}\\) 當數據有離群值時，會失去離中趨勢代表性。 變異數： 群體變異數：\\(\\boxed{\\sigma^2=\\frac{\\sum(X_i-\\mu)^2}{N}}\\) 樣本變異數：\\(\\boxed{S^2=\\frac{\\sum(X_i-\\bar{X})^2}{n-1}}\\)\n(記得樣本數的分子要減) 比較好算的版本 \\(\\boxed{\\sigma^2=\\frac{\\sum_i^NX_i^2-(\\sum_i^NX_i)^2/N}{N}}\\) \\(\\boxed{S^2=\\frac{\\sum_i^nX_i^2-(\\sum_i^nX_i)^2/n}{n-1}}\\) 標準差：變異數的平方，單位跟平均數一樣，在應用上可以做加減。 群體標準差：\\(\\boxed{\\sigma=\\sqrt{\\sigma^2}=\\sqrt{\\frac{\\sum(X_i-\\mu)^2}{N}}}\\) 樣本標準差：\\(\\boxed{S=\\sqrt{S^2}=\\sqrt{\\frac{\\sum(X_i-\\bar{X})^2}{n-1}}}\\) 偏態：數據分佈的「形態」口訣：\\(\\red{\\text{平地、山腰、種樹}\\rightarrow\\text{平均數、中位數、眾數}}\\) 對稱：\\(\\red{\\text{平均數=中位數=眾數}(山頂在中間)}\\) 右偏、正偏：\\(\\red{\\text{平均數\u0026gt;中位數\u0026gt;眾數}(山頂在左邊)}\\) 左偏、負偏：\\(\\red{\\text{平均數\u0026lt;中位數\u0026lt;眾數}(山頂在右邊)}\\) 偏態係數 \\(\\text{g}_1\\) \\(\\gray{\\text{g}_1=\\frac{\\sum_i^n(X_i-\\bar{X})^3/(n-1)}{S^3}}\\) \\(\\red{\\text{g}_1\\text{=0表示對稱}}\\) \\(\\red{\\text{g}_1\\text{\u0026gt;0表示右偏}}\\) \\(\\red{\\text{g}_1\\text{\u0026lt;0表示左偏}}\\) 峰態：山頂高不高 峰度係數 \\(\\text{g}_2\\) \\(\\gray{\\text{g}_1=\\frac{\\sum_i^n(X_i-\\bar{X})^4/(n-1)}{S^4}-3}\\) \\(\\red{\\text{g}_2\\text{=0表示常態分佈}}\\) \\(\\red{\\text{g}_2\\text{\u0026gt;0表示高狹峰}}\\) \\(\\red{\\text{g}_2\\text{\u0026lt;0表示低濶峰}}\\) 正態分布解析 若一組資料滿足自然分布(高斯分布、常態分布、正態分布、鐘型分布)，便會滿足以下的性質。 68、95、99.7 原則 即平均值一倍標準差內佔 68.27%。 即平均值二倍標準差內佔 95.45%。 即平均值三倍標準差內佔 99.73%。 不受高狹峰或低濶峰影響。 但偏態則會影響。 百分位數、百分等級、z 分數、t 分數都可以是從這個固定的分配比例衍生來的。 百分位數(Ppr、Pp) 代表「累計百分比」 小明某次考試 90 分贏過 70% 的考生，小明的百分位數即為 70。 百分等級 與「資料的個數」有關 \\(\\text{PR=}100\\times R+\\frac{50}{N}\\) 小明在 10 個人中排第 3 名，表示他贏過 7 個人，累計百分比為 70%， \\(\\text{PR=}100\\times 70\\%+\\frac{50}{\\red{10}}=70+5=75\\) 小明如果考 90 分，則此次考試 PR 75 的原始分數即為 90 分。 小明如果在 50 個人中排第 15 名，同樣的累計百分比為 70 %，但是 PR 值變成 \\(\\text{PR=}100\\times 70\\%+\\frac{50}{\\red{50}}=70+1=71\\) 小明如果是參加五萬人的選拔，同樣贏過 70% 的人，\n\\(\\text{PR=}100\\times 70\\%+\\frac{50}{\\red{50000}}=70+0.001=70.001\\approx70\\\\ \\red{\\text{PR只分100個等級，故不會有小數點，所以要四捨五入，}\\\\\\text{換言之，受試者超過101人，PR=Ppr}}\\) 累積百分比與標準差 \\(-3\\times\\sigma=50\\%-99.73\\%/2\\approx0.1\\%\\) \\(-2\\times\\sigma=50\\%-95.45\\%/2\\approx2.3\\%\\) \\(-1\\times\\sigma=50\\%-68.27\\%/2\\approx15.9\\%\\) \\(+0\\times\\sigma=50\\%\\) \\(+1\\times\\sigma=50\\%-68.27\\%/2\\approx84.1\\%\\) \\(+2\\times\\sigma=50\\%-95.45\\%/2\\approx97.7\\%\\) \\(+3\\times\\sigma=50\\%-99.73\\%/2\\approx99.9\\%\\) z 分數 換言之就是標準差。 小明贏過 84.1% 的人，z 分數即為 +1。 小明贏過 2.3% 的人，z 分數即為 -2。 t 分數 設定百分位數 50% 為 50 分，每增加一個標準差多 10分 反之亦然。 公式：\\(\\boxed{z = \\frac{t-50}{10}}\\) 或 \\(\\boxed{t=10z+50}\\) 小明的 t 分數是 70 分，代表它的 z 分數是 +2，累計百分比是 97.7%，百分位數是97.7，假設受試人超過101人，PR等級為 98。 信賴區間 用以一段區間描述研究對象。\n例如，95% 信賴水準下，台灣男生的身高為 160~180 公分。代表你去路上隨機街訪，大約95% 的機率，路人(男)的身高都會落在 160~180 公分以內。\n注意以上的描述不一定為真，因為抽樣結果與群體間會有誤差。\n假設我今天做了一個台灣男生身高抽樣調查，結果結果剛好呈現常態分布，並且平均身高是 170 公分，標準差是 5 公分。 68% 信賴水準下，台灣的男生身高會落在 165~175 公分的區間內。 95% 信賴水準下，台灣的男生身高會落在 160~180 公分的區間內。 99.7% 信賴水準下，台灣的男生身高會落在 155~185 公分的區間內。 信賴水準 \\(1-\\alpha\\)：從上例可見，當信賴區間增加，信賴水準也會增加。 顯著水準 \\(\\alpha\\)：反之，顯著水準增增加，代表愈寬鬆。通常定為 0.05。 白話：你只有 5% 的機率找到例外。 假設今天收集的數據不為常態分布，為左偏或右偏，它可以滿足 99.7% 的信賴區間，但不一定滿足 95% 信賴區間。 P 值： 定義：假使虛無假設是真的，實際觀測獲得比取樣更極端的值的機率是多少。 白話：假設台灣男生的身高都落在 160~180 公分之間，找到比 160 公分以下和 180 公分以上的機率是多少？ P 值無法用來證明何者絕對正確，只能透過機率來「合理推斷」 跟\\(\\alpha\\)的關係： 假設我做了一次調查，發現 1000 個人之中只有 20 個人高於 180 公分或矮於 160 公分，即 P 值為 0.02。 此時若此份調查宣稱信賴水準是 95%，即 \\(\\alpha=0.05\\)，則我們可以推斷這份調查是準確的，所以我們無法拒絕虛無假設。 此時若此份調查宣稱信賴水準是 99%，即 \\(\\alpha=0.01\\)，則我們可以推斷這份調查可能不準確，所以我們可以拒絕虛無假設。 也就是如果調查是正確的，我們應該只能從 1000 個人裡面找到小於 10 個極端值。不過因為 P 值是機率，我們可以拒絕，但不表示調查就是完全不正確的，也許我們再擴大調查，也許有可能在 10000 個人裡面總共只找到 45 個極端值，那這份調查又變成有效的了。 假設檢定 單尾、雙尾 單尾代表只有一個拒絕域，右分為左尾與右尾。 左尾：台灣男性有 95% 都高於 160 公分。 右尾：台灣男性有 95% 都矮於 180 公分。 雙尾代表有兩個拒絕域 雙尾：台灣男生有 95% 落在 160 公分到 180 公分的區間內。 結論與決策 可信度 當你做完數據，你的最終目的是想把你的研究對象跟你的調查數據關聯起來，這個關聯性必須要有可信度。\n前面的一大堆資料分析、檢定目的在於「證明抽樣有沒有辦法代表母體」。 現在「兩個足以代表母體的數據」，就可以來測試關聯性。\n相關係數 以下的圖稱為散佈圖，把兩個數據分別放於 X 軸與 Y 軸，如果兩者是相關的，表示在座標平面上，你可以找到「一條線(趨勢線)」(不一定要是直線)來描述他。 為什麼不一定要是直線? 因為 X軸跟 Y 可以是不同的尺規，X-Y 也有可能是對數尺規或是指數尺規。 |相關係數|愈高，則數據愈貼近趨勢線。 一般來說， \\(\\gamma=1\\)，完全線性正相關。 \\(\\gamma=-1\\)，完全線性負相關。 \\(0.7\\le\\gamma\u0026lt;1\\)，強正相關。 \\(-0.7\\ge\\gamma\u0026gt;-1\\)，強負相關。 \\(0.3\\le\\gamma\u0026lt;0.7\\)，弱正相關。 \\(-0.3\\ge\\gamma\u0026lt;-0.7\\)，弱負相關。 \\(-0.3\u0026lt;\\gamma\u0026lt;0.3\\)，無相關。 工程上喜歡用 \\(R^2\\) 來表示相關性，其實就是相關係數的平方，不討論正、負相關，只考慮相關性。 最後的最後 你學會了定義問題、收集資料、整理資料、資料分析跟最後的關聯性分析，你就可以下結論並做決策了！是不是很棒啊。 記得統計學只是工具，過程一定要有問題，目標是下決策。 例如，我想知道怎麼樣提升學生的學習成效。\n我發現學生的學習成效跟讀書時間的長短呈現強相關，且讀書時間愈長，學習成效愈好。那麼作為一名老師，我還不叫你把書讀爆！就是在說你，還不快點去讀書！！ ","permalink":"http://intervalrain.github.io/posts/device/statistics/","summary":"本文是筆者基於工作上統計製程控制(Statistical Process Control, SPC) 的心得與學習筆記，可能有紕漏，僅供參考。\n統計學(Statistics) 基本名詞 群體(population)：研究對象的主體。 如上例的\\(\\red{\\text{全國人民的政治傾向}}\\)、\\(\\red{\\text{此家工廠的產品品質}}\\)。 樣本(sample)：群體的一部分。 如上例的\\(\\red{\\text{台灣部分的民眾}}\\)、\\(\\red{\\text{工廠部分的抽樣}}\\)。 目的：了解美國總統大選誰會獲勝? 群體：美國有投票權的公民 此時不是美國公民的台灣民眾，就不會是這個題目的樣本。 參數(parameter)：由群體資料所計算之群體表徵值。 統計量(statistic)：由樣本資料所計算之樣本表徵值。 為何需要統計學? 統計學是一種工具，人們為了下決策所作的一系列蒐集資料、整理、分析、與解析，是目的導向的。 比方說，每次總統大選會花費大量人力，動員全國上下公教人員，花錢印選舉公報、印選票，選後還要花費大量的時間開票、驗票。假如我只是個學生想了解目前國家人民的政治傾向，不可能收集台灣上下每個人的答案，所以我們會進行抽樣。 比方說工廠出貨會抽樣調查產品有沒有損壞，不可能全部的產品都拿去做測試，因為成本太高。 藉由普查或抽樣的結果來描述全體的行為，作為決策的依據。 統計的目的：\\(\\red{\\text{由樣本資料推論母體參數}}\\)。\n解決統計問題的五大步驟 問題定義 先決定你要討論的問題，跟此問題可能相關的對象為何？可以收集哪些資料？\n定義問題的群體與樣本。 例如：我想了解 A 工廠「晶片良率」，我認為可能跟「晶片厚度」有關係。 群體：A 工廠生產的晶片良率 樣本：某段時間內 A 工廠某機台生產晶片的厚度 例如：我想了解 B 國小附幼「小朋友學習狀況」，我認為可能跟「A 考卷的成績」有關。 群體：B 國小附幼小朋友的學習狀況 樣本：某次活動後的一次學習單成績。 資料收集 要收集哪些資料？哪些資料有可能可以協助我解決我想了解的問題？\n例如，收集晶片的氧化層厚度、爐管的溫度、機台的編號、機台的廠商\n測量尺度 等比尺度(Ratio measurements)：具有零值且資料間的距離是相等被定義的。 如晶片的氧化層厚度 等距尺度(Interval measurements)：資料間的距離是相等被定義的，定零值並非絕對的無，而是自行定義的。 如爐管的溫度(攝氏) 順序尺度(Ordinal measurements)：數據的意義是並非表現在值上而是在其順序上。 如機台的編號 名目尺度(Nominal measurements)：測量值不具量的意義。 如機台的廠商 資料整理 很多時候我們光看數字，會對研究主體沒感覺，所以引入畫圖來協助我們判斷資料。\n資料的整理分為兩個部分： 審查資料 篩選有用的資料，收集來的資料是不是與預想的一致，資料是否有錯誤、遺漏、矛盾或是其它可疑的地方？應立刻設法檢查並更正。如果資料由不同單位蒐集而來，可能需要經過正常化(normalization)加以換算統一。太過複雜的資料應依照研究目的加以整理，以求簡化，並藉以顯示研究對象全體的通則。 資料表現 資料經過整理分析得到一些統計結果，為了方便說明，我們常以圖表的方式陳示出來，以供參考使用。 散點圖(Scatter plot): 可以看相關係數 常態分布圖(高斯分布圖 normal distribution, gauss distribution)：","title":"[統計] 統計學概要"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/cs/ca/memory/","summary":"準備中 ","title":"[CA] 記憶體"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/cs/ca/pipeline/","summary":"準備中 ","title":"[CA] Pipeline"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/cs/ca/processor/","summary":"準備中 ","title":"[CA] 處理器"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/cs/ca/arithmetic/","summary":"準備中 ","title":"[CA] 計算機算術"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/cs/ca/isa/","summary":"準備中 ","title":"[CA] 指令集架構"},{"content":"計算機組織與結構 計算機抽象化與科技 指令集架構 計算機算術 處理器 Pipeline 記憶體 參考資料 黃婷婷 清大開放式課程 計算機結構 Mr. opengate ","permalink":"http://intervalrain.github.io/posts/cs/ca/","summary":"計算機組織與結構 計算機抽象化與科技 指令集架構 計算機算術 處理器 Pipeline 記憶體 參考資料 黃婷婷 清大開放式課程 計算機結構 Mr. opengate ","title":"[作業系統] 計算機組織與結構"},{"content":"CPU 個數、核心數、執行緒數 定義 CPU 個數即 CPU 晶片個數。 **CPU 核心數(core)**是指物理上，也就是硬體上存在著幾個核心。比如，雙核就是包括 2 個相對獨立的 CPU 核心單元組，四核就包含 4 個相對獨立的 CPU 核心單元組。 **執行緒數(thread)**是一種邏輯的概念，簡單地說，就是模擬出的 CPU 核心數。比如，可以通過一個 CPU 核心數模擬出 2 執行緒的 CPU，也就是說，這個單核心的 CPU 被模擬成了一個類似雙核心 CPU 的功能。我們從工作管理員的效能標籤頁中看到的是兩個 CPU。比如 Intel 賽揚 G460 是單核心、雙執行緒的 CPU，Intel 酷睿 i3 3220 是雙核心、四執行緒，Intel 酷睿 i7 4770K 是四核心、八執行緒，Intel 酷睿 i5 4570 是四核心四執行緒等等。對於一個 CPU，執行緒數總是大於或等於核心數的。一個核心最少對應一個執行緒，但通過超執行緒(Hyper Thread)技術，一個核心可以對應兩個執行緒，也就是說它可以同時執行兩個執行緒。 CPU 的執行緒數概念僅僅只針對 Intel 的 CPU 才有用，因為它是通過 Intel 超執行緒技術來實現的，最早應用在 Pentium4 上。如果沒有超執行緒技術，一個 CPU 核心對應一個執行緒。所以，對於 AMD 的 CPU 來說，只有核心數的概念，沒有執行緒數的概念。\n為何要增加執行緒數? CPU 之所以要增加執行緒數，是源於多工處理(multi-tasking)的需要。執行緒數越多，越有利於同時執行多個程式，因為執行緒數等同於在某個瞬間 CPU 能並行處理(concurrent)的任務數。因此，執行緒數是一種邏輯的概念，簡單地說，就是模擬出的 CPU 核心數。一個核心最少對應一個執行緒，但英特爾有個超執行緒技術可以把一個物理執行緒模擬出兩個執行緒來用，充分發揮 CPU 效能，即一個核心可以有兩個到多個執行緒。 intel x86：一核心有 2 個邏輯執行緒。 IBM power8：一核心有 8 個邏輯執行緒。 多核 CPU 多核心 CPU 主要分原生多核和封裝多核。 原生多核指的是真正意義上的多核，最早由 AMD 提出，每個核心之間都是完全獨立的，都擁有自己的前端匯流排，不會造成衝突，即使在高負載狀況下，每個核心都能保證自己的效能不受太大的影響，通俗的說，原生多核的抗壓能力強，但是需要先進的工藝，每擴充套件一個核心都需要很多的研發時間。 封裝多核是隻把多個核心直接封裝在一起，比如 Intel 早期的 PD 雙核系列，就是把兩個單核直接封裝在一起，但兩核心只能共同擁有一條前端匯流排，在兩個核心滿載時，兩個核心會爭搶前端匯流排，導致效能大幅度下降，所以早期的PD被扣上了高頻低能的帽子，要提高封裝多核的效能，在多工的高壓下儘量減少效能損失，只能不斷的擴大前端匯流排的總體大小，來彌補多核心爭搶資源帶來的效能損失，但這樣做只能在一定程度上彌補效能的不足，和原生的比起來還是差了很多，而且後者成本比較高，優點在於多核心的發展要比原生快的多。 核心 核心(Die)又稱為核心，是 CPU 最重要的組成部分。CPU 中心那塊隆起的晶片就是核心，是由單晶矽以一定的生產工藝製造出來的，CPU 所有的計算、接受/儲存命令、處理資料都由核心執行。各種 CPU 核心都具有固定的邏輯結構，一級快取、二級快取、執行單元、指令級單元和匯流排介面等邏輯單元都會有科學的佈局。 多核心處理器(Multi-core processor) 又稱多核心微處理器，是在單個 CPU 中，加入兩個或以上的獨立實體中央處理單元，或稱核心(core)。這些核心可以分別獨立地執行程式指令，利用平行計算的能力加快程式的執行速度。只有兩個核心的處理器，稱為雙核心處理器(dual-core processor)。多核心通常是對於中央處理器 CPU 而論的，但是某些時候也指 DSP 和 SoC。 把將兩個或更多獨立處理器封裝在一個單一積體電路(IC)中的方案稱為多核心處理器；而封裝在不同 IC 中的獨立處理器形成的計算機系統被稱為多處理器。 多核心處理器 != 多處理器 多核心處理器可以在不將每個核心分別獨立物理封裝的情況下進行多工處理(執行緒級併發處理（Thread-Level Parallelism, TLP)，這種形式的TLP通常被認為是晶片級多處理。 單核多 CPU 與多核單 CPU 一台計算機的處理器部分的架構\n單核多 CPU，那麼每一個 CPU 都需要有較為獨立的電路支援，有自己的 Cache，而他們之間通過板上的匯流排進行通訊(一致性問題)。假如在這樣的架構上，我們要跑一個多執行緒的程式，不考慮超執行緒，那麼每一個執行緒就要跑在一個獨立的 CPU 上，執行緒間的所有協作都要走匯流排，而共享的資料更是有可能要在好幾個 Cache 裡同時存在。這樣的話，匯流排開銷相比較而言是很大的，怎麼辦？那麼多 Cache，即使我們不心疼儲存能力的浪費，也無法保證一致性。 多核單 CPU，那麼我們只需要一套晶片組，一套儲存，多核之間通過晶片內部匯流排進行通訊，共享使用記憶體。在這樣的架構上，如果我們跑一個多執行緒的程式，那麼執行緒間通訊將比上一種情形更快。 多個 CPU 常見於分散式系統，用於普通消費級市場的不多，多用於叢集系統(Clustered system)、雲端計算平臺。多 CPU 架構最大的瓶頸就是 I/O，尤其是各個 CPU 之間的通訊，低成本的都用 100M 乙太網做，稍微好一點的用 1000M 乙太網，再好的就用光纖等等，但無論如何速度和通量都比不上主機板的主線。所以多 CPU 適用於大計算量，對時間成本不敏感的任務，比如一些工程建模，或者像 SATI 找外星人這種極端的，跑上幾千年都不著急的。而且多 CPU 架構更簡單清晰，可以用消費級產品簡單做數量堆疊，成本上有優勢。而多核單 CPU 則適合對通訊 I/O 速度要求較快的應用，在相同核數量下成本上也高一些，好像只有在超級計算機裡會用到以萬為單位的核心數，普通消費級產品也就是到 16 核封頂了，因為成本控制的原因。 ","permalink":"http://intervalrain.github.io/posts/cs/os/cpucorethread/","summary":"CPU 個數、核心數、執行緒數 定義 CPU 個數即 CPU 晶片個數。 **CPU 核心數(core)**是指物理上，也就是硬體上存在著幾個核心。比如，雙核就是包括 2 個相對獨立的 CPU 核心單元組，四核就包含 4 個相對獨立的 CPU 核心單元組。 **執行緒數(thread)**是一種邏輯的概念，簡單地說，就是模擬出的 CPU 核心數。比如，可以通過一個 CPU 核心數模擬出 2 執行緒的 CPU，也就是說，這個單核心的 CPU 被模擬成了一個類似雙核心 CPU 的功能。我們從工作管理員的效能標籤頁中看到的是兩個 CPU。比如 Intel 賽揚 G460 是單核心、雙執行緒的 CPU，Intel 酷睿 i3 3220 是雙核心、四執行緒，Intel 酷睿 i7 4770K 是四核心、八執行緒，Intel 酷睿 i5 4570 是四核心四執行緒等等。對於一個 CPU，執行緒數總是大於或等於核心數的。一個核心最少對應一個執行緒，但通過超執行緒(Hyper Thread)技術，一個核心可以對應兩個執行緒，也就是說它可以同時執行兩個執行緒。 CPU 的執行緒數概念僅僅只針對 Intel 的 CPU 才有用，因為它是通過 Intel 超執行緒技術來實現的，最早應用在 Pentium4 上。如果沒有超執行緒技術，一個 CPU 核心對應一個執行緒。所以，對於 AMD 的 CPU 來說，只有核心數的概念，沒有執行緒數的概念。\n為何要增加執行緒數? CPU 之所以要增加執行緒數，是源於多工處理(multi-tasking)的需要。執行緒數越多，越有利於同時執行多個程式，因為執行緒數等同於在某個瞬間 CPU 能並行處理(concurrent)的任務數。因此，執行緒數是一種邏輯的概念，簡單地說，就是模擬出的 CPU 核心數。一個核心最少對應一個執行緒，但英特爾有個超執行緒技術可以把一個物理執行緒模擬出兩個執行緒來用，充分發揮 CPU 效能，即一個核心可以有兩個到多個執行緒。 intel x86：一核心有 2 個邏輯執行緒。 IBM power8：一核心有 8 個邏輯執行緒。 多核 CPU 多核心 CPU 主要分原生多核和封裝多核。 原生多核指的是真正意義上的多核，最早由 AMD 提出，每個核心之間都是完全獨立的，都擁有自己的前端匯流排，不會造成衝突，即使在高負載狀況下，每個核心都能保證自己的效能不受太大的影響，通俗的說，原生多核的抗壓能力強，但是需要先進的工藝，每擴充套件一個核心都需要很多的研發時間。 封裝多核是隻把多個核心直接封裝在一起，比如 Intel 早期的 PD 雙核系列，就是把兩個單核直接封裝在一起，但兩核心只能共同擁有一條前端匯流排，在兩個核心滿載時，兩個核心會爭搶前端匯流排，導致效能大幅度下降，所以早期的PD被扣上了高頻低能的帽子，要提高封裝多核的效能，在多工的高壓下儘量減少效能損失，只能不斷的擴大前端匯流排的總體大小，來彌補多核心爭搶資源帶來的效能損失，但這樣做只能在一定程度上彌補效能的不足，和原生的比起來還是差了很多，而且後者成本比較高，優點在於多核心的發展要比原生快的多。 核心 核心(Die)又稱為核心，是 CPU 最重要的組成部分。CPU 中心那塊隆起的晶片就是核心，是由單晶矽以一定的生產工藝製造出來的，CPU 所有的計算、接受/儲存命令、處理資料都由核心執行。各種 CPU 核心都具有固定的邏輯結構，一級快取、二級快取、執行單元、指令級單元和匯流排介面等邏輯單元都會有科學的佈局。 多核心處理器(Multi-core processor) 又稱多核心微處理器，是在單個 CPU 中，加入兩個或以上的獨立實體中央處理單元，或稱核心(core)。這些核心可以分別獨立地執行程式指令，利用平行計算的能力加快程式的執行速度。只有兩個核心的處理器，稱為雙核心處理器(dual-core processor)。多核心通常是對於中央處理器 CPU 而論的，但是某些時候也指 DSP 和 SoC。 把將兩個或更多獨立處理器封裝在一個單一積體電路(IC)中的方案稱為多核心處理器；而封裝在不同 IC 中的獨立處理器形成的計算機系統被稱為多處理器。 多核心處理器 !","title":"CPU 個數、CPU 核心數、CPU 執行緒數"},{"content":"計算機作業系統 概述 進程管理 死鎖 記憶體管理 設備管理 鏈接 參考資料 cyc2018 Mr. opengate ","permalink":"http://intervalrain.github.io/posts/cs/os/","summary":"計算機作業系統 概述 進程管理 死鎖 記憶體管理 設備管理 鏈接 參考資料 cyc2018 Mr. opengate ","title":"[作業系統] 計算機作業系統"},{"content":"作業系統 簡介 電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)\n硬體(hardware)：為系統提供基本的計算資源。 中央處理器(central processing unit, CPU) 記憶體(memory) I/O 裝置 應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。 使用者(users) 作業系統(Operating system, OS)： 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。\nOS 最主要的兩個功能是：\n資源分配：根據需求調配資源分配率(resource utilization)與效能(performance) 監控使用者程式的執行，避免不正常的運作造成對系統的危害。 一個標準的 PC 作業系統應該提供以下的功能：\n行程管理(Processing management) 記憶體管理(Memory management) 檔案系統(File system) 網路通訊(Networking) 安全機制(Security) 使用者介面(User interface) 驅動程式(Device drivers) PC 基本特徵 1. 並行計算(Concurrent computing) Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 分享(Sharing) 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬(Virtual) 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4. 異步(Asynchronous) 異步指進程不是一次性執行完畢，而是走走停停，以不可知的速度向前推進。 基本功能 1. 進程管理(Process management) 進程管理、進程同步、進程通信、死鎖處理、處理調度等。 2. 記憶體管理(Memory management) 記憶體分配、地址映射、記憶體保護與共享、虛擬記憶體等。 3. 文件管理(File management) 文件儲存空間的管理、目錄管理、文件讀寫管理和保護等。 4. 設備管理(Equipment management) 完成用戶的 I/O 請求，方便用戶使用各種設備，並提高設備的利用率。 主要包含緩衝管理、設備分配、設備處理、虛擬設備等。 系統調用 如果一個進程在用戶模式(user mode)需要使用內核模式(kernel mode)的功能，就進行系統調用從而陷入內核，由作業系統代為完成。 Linux 的系統調用主要有以下這些： Task Commands 進程控制 fork(); exit(); wait(); 進程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 設備操作 ioctl(); read(); write(); 訊息維護 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 內核與微內核 1. 內核(kernel) 內核是將作業系統功能作為一個緊密結合的整體放到內核。 由於各模塊共享訊息，因此有很高的性能。 2. 微內核(microkernel) 由於作業系統不斷複雜化，因此將一部分作業系統功能移出內核，從而降低內核的複雜性。移出的部分根據分層的原則劃分成若干服務，相互獨立。 在微內核結構下，作業系統被劃分成小的、定義良好的模塊，只有微內核這一個模塊運行在內核模式，其餘模塊運行時在用戶模式。 因為脫試頻繁地在用戶模式與內核模式間進行切換，所以有一定的性能損失。 中斷分類 1. 中斷(interrupt) 由 CPU 執行指令以外的事件引起，如 I/O 完成中斷，表示設備輸入/輸出處理已經完成，處理器能夠發送下一個輸入/輸出請求。此外還有時鐘中斷、控制台中斷等。 2. 異常(exception) 由 CPU 執行指令的內部事件引起，如非法操作碼、地址越界、算術溢位(overflow)等。 3. 陷入(trap) 在用戶程序中使用系統調用。 常見系統類型分類 1. 批次處理系統(Batch Processing System) 一次性的處理已經蒐集的資料。 適合處理週期性的大筆資料。 如大型機(Mainframe)。 2. 多行程系統(Muliprogramming System) 系統中存在多組行程同時(concurrent)執行，避免CPU閒置，提升CPU利用度。\n**注意，不是平行運算(parallel computing) Multiprogramming Degree：指系統內所存在等待執行的行程(proess)數目。 Multiprogramming Degree 愈高，則 CPU 使用度可能愈高，但若產生 Thrashing，可能會使 CPU 效能降低。 振盪(Thrashing)：當 CPU 效能降低時，系統會想引入更多的 process 讓 CPU 盡可能地工作。但當存有太多 process 時，大部分的工作會花費在 Page Fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 的效能越來越低。 降低 Multiprogramming Degree。 利用 Page Fault Frequencry (Ratio) 控制來防止 Thrashing。 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數，以防止 Thrashing。 3. 分時系統(Time Sharing System) 或稱多工系統(Multi-Tasking System)。 多行程系統的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，提升反應時間(Response Time)。 常見配置： 行程排程使用輪詢調度(Robin Round Scheduling, RR Scheduling)。 記憶體空間所有使用者共享。 使用虛擬記憶體技術。 I/O 裝置透過 4. 多核系統與平行系統(Multiprocessor System and Parallel System) 具有一個以上的CPU核心單元組，各核心之間共享記憶體、匯流排等資源，將工作同時分配給多個 CPU 處理。 執行緒數是邏輯上模擬出來的 CPU 核心數，用於多工處理的需要。 多核處理器又可分為： Symmetric Multiprocessing (SMP)：對稱式多處理器，每一個處理器具有相同的功能，可靠度較高，強調負載平衡。 Asymmetric Multiprocessing (ASMP)：非對稱式多處理器，主僕架構。 補充：CPU個數、CPU核心數、CPU執行緒數 5. 分散式系統(Distributed System) 整合各地不同的電腦，以網路連線的方式，將工作分派給不同的電腦執行以提高效率。 需滿足兩個條件： 硬體上每台電腦都是自主的 軟體上用戶將整個系統看作是一台電腦。 一般分為兩類，分別是： 主僕式系(Client-Server System) P2P系統(Peer-to-peer) 好處： 資源共享(Resource Sharing) 加快計算速度(Speed Up) 可靠性(Reliability) 通訊需求(Communication Need) 6. 即時系統(Real Time System) 定義嚴謹的固定時間限制，電腦在處理工作時必須在這個定義的時間內完成，否則工作就算失效。 依類型可分為兩類： 硬性即時系統(Hard Real Time System) 軟性即時系統(Soft Real Time System) 7. 叢集系統(Clustered System) 叢叢集系統共享儲存裝置，集合許多 CPU 並且由網路連線緊密地連結以完成工作。叢集系統主要是利用多台獨立的電腦系統或是工作站來共同完成大型數值的平行計算。 通常較不依賴記憶體。 ","permalink":"http://intervalrain.github.io/posts/cs/os/intro/","summary":"作業系統 簡介 電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)\n硬體(hardware)：為系統提供基本的計算資源。 中央處理器(central processing unit, CPU) 記憶體(memory) I/O 裝置 應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。 使用者(users) 作業系統(Operating system, OS)： 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。\nOS 最主要的兩個功能是：\n資源分配：根據需求調配資源分配率(resource utilization)與效能(performance) 監控使用者程式的執行，避免不正常的運作造成對系統的危害。 一個標準的 PC 作業系統應該提供以下的功能：\n行程管理(Processing management) 記憶體管理(Memory management) 檔案系統(File system) 網路通訊(Networking) 安全機制(Security) 使用者介面(User interface) 驅動程式(Device drivers) PC 基本特徵 1. 並行計算(Concurrent computing) Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 分享(Sharing) 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬(Virtual) 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4.","title":"[計算機作業系統] 概述"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/cs/os/deadlock/","summary":"準備中 ","title":"[計算機作業系統] 死鎖"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/cs/os/memorymanagement/","summary":"準備中 ","title":"[計算機作業系統] 記憶體管理"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/cs/os/equipmentmanagement/","summary":"準備中 ","title":"[計算機作業系統] 設備管理"},{"content":"進程管理 進程與執行緒 1. 進程(process) 進程是資源分配的基本單位。 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。 2. 執行緒(thread) 執行緒又稱線程，是獨立調度的基本單位。 一個進程可以有多個執行緒，它們共享進程資源。 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。 3. 區別 擁有資源 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。 調度 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。 系統開銷 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。 通訊 執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。 進程狀態的切換 就緒就態(ready)：等待被調度 執行狀態(running) 阻塞狀態(waiting)：等待資源 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。 進程調度演算法 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。 1. 批次處理系統(batch system) 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。 1.1 先來先服務(first-come first-served, FCFS) 非搶占式的調度，按照請求的順序進行調度。 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長 1.2 短作業優先(shortest job first, SJF) 非搶占式的調度算法，按估計運行時間最短的順序進行調度。 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。 1.3 最短剩餘時間優先(shortest remaining time next, SRTN) 最短作業優先的搶占式版本，按剩餘運行時間的順序進行調度。當一個新的作業到達時，其整個運行時間與當前進程的剩餘時間作比較。如果新的進程需要的時間更少，則夠停當下進程，運行新的進程；否則則讓新的進程進入等待。 2. 交互式系統(time-sharing system) 交互式系統有大量的用戶交互操作，在該系統中調度演算法的目標是快速地進行響應。 2.1 時間片段輪轉(robin round scheduling, RR) 將所有就緒進程按 FCFS 的原則排成一個佇列，每次調度時，把 CPU 時間分配給佇首進程，該進程可以執行一個時間片段，當時間片段用完時，由計時器發出時鐘中斷，調度程序便停止該進程的執行，並將它送往就緒佇尾，同時繼續把 CPU 時間分配給佇首的進程。 時間片段輪轉演算法的效率和時間片段的大小很有關係： 因為進程切換都要保存進程的訊息並且載入新進程的訊息，如果時間片段太小，會導致頻繁地切換進程，導致時間浪費。 而如果時間片段過長，那麼實時性就不能得到保証。 2.2 優先級調度(priority scheduling) 為每個進程分配一個優先級，按優先級進行調度。 為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。 2.3 多級反饋佇列(Multilevel Feedback-Queue Scheduling, MLFQ) 一個進程需要執行 100 個時間片段，如果採用時間片段輪轉調度演算法，那麼需要交換 100 次。 多級佇列是為這種需要連續執行多個時間片段的進程考慮，它設置了多個佇列，每個佇列時間片段大小都不同，例如 1, 2, 4, 8,\u0026hellip;。進程在第一個佇列沒執行完，就會被移到下一個佇列。這種方式下，之前的進程只需要交換 7 次。 每個佇列優先權也不同，最上面的優先權最高。因此只有上一個佇列沒有進程在排隊，才能調度當前佇列上的進程。可以將這種調度算法看成是時間片段輪轉調度算法和優先級調度算法的結合。 3. 實時系統(real time system) 實時系統要求一個請求在一個確定時間內得到響應。 分為硬實時和軟實時，前者必須滿足絕對的截止時間，後者可以容忍一定的超時。 進程同步 1. 臨界區 對臨界資源進行訪問的那段代碼稱為臨界區。 為了互斥訪問臨界資源，每個進程在進入臨界區之前，需要先進行檢查。 // entry section // crtical section; // exit section 2. 同步與互斥(synchronization and mutex) 同步(synchronization)：多個進程因為合作產生的直接制約關係，使得進程有一定的先後執行關係。 互斥(mutual exclusion, mutex)：多個進程在同一時刻只有一個進程能進入臨界區。 3. 號誌(Semaphore) 號誌，或稱信號量，是一個整數變數，可以對其執行 down 和 up 操作，也就是常見的 P 和 V 操作。 down：如果號誌量大於 0，執行 -1 操作；如果號誌等於 0，進程睡眠，等待號誌大於 0。 up：對號誌執行 +1 操作，喚醒睡眠的進程讓其完成 down 操作。 down 和 up 操作需要被設計成原語，不可分割，通常的做法是在執行這些操作的時候屏蔽中斷。\n如果號誌的取值只能為 0 或者 1，那麼就成為了互斥(mutex)，0 表示臨界區已經加鎖，1 表示臨界區解鎖。 typedef int semaphore; semaphore mutex = 1; void P1(){ down(\u0026amp;mutex); // critical section up(\u0026amp;mutex); } void P2(){ down(\u0026amp;mutex); // critical section up(\u0026amp;mutex); } 使用號誌實現生產者-消費者問題 問題描述：使用一個緩衝區來保存物品，只有緩沖區沒有滿，生產者才可以放入物品；只有緩衝區不為空，消費者才可以拿走物品。 因為緩衝區屬於臨界資源，因此需要使用一個互斥 mutex 來控制對緩衝區的互斥訪問。 為了同步生產者和消費者的行為，需要記錄緩衝區中物品的數量。數量可以使用號誌來進行統計，這裡需要使用兩個號誌：empty 記錄空緩衝區的數量，full 記錄滿緩衝區的數量。其中，empty 號誌是在生產者進程中使用，當 empty 不為 0 時，生產者才可以放入物品；full 號誌是在消費者進程中使用，當 full 號誌不為 0 時，消費者才可以取走物品。 注意，不能先對緩衝區進行加鎖，再測試號誌。也就是說，不能先執行 down(mutex) 再執行 down(empty)。如果這麼做了，那麼可能會出現這種情況：生產者對緩衝區加鎖後，執行 down(empty) 操作，發現 empty = 0，此時生產者睡眠。消費者不能進入臨界區，因為生產者對緩衝區加鎖了，消費者就無法執行 up(empty) 操作，empty 永遠都為 0，導致生產者永遠等待下，不會釋放鎖，消費者因此也會永遠等待下去。 #define N 100 typedef int semaphore; semaphore mutex = 1; semaphore empty = N; semaphore full = 0; void producer() { while(TRUE) { int item = produce_item(); down(\u0026amp;empty); up(\u0026amp;mutex); // entry section insert_item(item); // critical section up(\u0026amp;mutex); // exit section up(\u0026amp;full); } } void consumer() { while(TRUE) { down(\u0026amp;full); down(\u0026amp;mutex); // entry section int item = remove_item(); // critical section consume_item(item); // exit section up(\u0026amp;mutex); up(\u0026amp;empty); } } 4. 管程 使用號誌機制實現的生產者消費者問題需要客戶端代碼做很多控制，而管程把控制的代碼獨立出來，不僅不容易出錯，也使得客戶端程式碼調用更容易。 C 語言不支持管程，下面的示範程式碼使用了類 Pascal 語言來描述管程。範例程式碼的管程提供 insert() 和 remove() 方法，客戶端程式碼通過調用這兩個方法來解決生產者-消費者問題。 monitor ProducerConsumer integer i condition c; procedure insert(); begin // ... end procedure remove(); begin // ... end end monitor; 管程有一個重要特性：在一個時刻只能有一個進程使用管程。進程在無法繼續執行的時候不能一直占用管程，否則其它進程永遠不能使用管程。 管程引入了條件變量以及相關的操作：wait() 和 signal() 來實現同步操作。對條件變數執行 wait() 操作會導致調用進程阻塞，把管程讓出來給另一個進程持有。signal() 操作用於喚醒被阻塞的進程。 monitor ProducerConsumer condition full, empty; integer count = 0; conditon c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N - 1 then signal(full); end; end monitor; precedure producer begin while true do begin item = produce_item; ProducerConsumer.insert(item); end; end; Procedure consumer begin while true do begin item = ProducerConsumer.remove; consume_item(item); end; end; 經典同步問題 1. 哲學家進餐問題 問題描述：五個哲學家圍著一張圓桌，每個哲學家面前放著食物。哲學家的生活有兩種交替活動：吃飯和思考。當一個哲學家吃飯時，需要先拿起自己左右邊的兩根筷子，並且一次只能拿起一根筷子。 若所有哲學家同時拿起左手邊的筷子，那麼所有哲學家都在等待其它哲學家吃完並放下手中的筷子，導致 dead lock。 為了防止 dead lock 的產生，可以設置兩個條件： 必須同時拿起左右兩根筷子； 只有在兩個鄰居都沒有進餐的情況下才允許進餐。 #define N 5 #define LEFT (i + N - 1) % N #define RIGHT (i + 1) % N #define THINKING 0 #define HUNGRY 1 #define EATING 2 typedef int semaphore; int state[N]; // philosopher\u0026#39;s state semaphore mutex = 1; // mutex for critical section semaphore s[N]; // semaphore of philosopher void philosopher(int i){ while(TRUE){ think(i); take_two(i); eat(i); put_two(i); } } void take_two(int i){ down(\u0026amp;mutex); state[i] = HUNGRY; check(i); up(\u0026amp;mutex); down(\u0026amp;s[i]); // eat only if receive notification, or wait } void put_two(int i){ down(\u0026amp;mutex); state[i] = THINKING; check(LEFT); // notify left and right check(RIGHT); up(\u0026amp;mutex); } void eat(int i){ down(\u0026amp;mutex); state[i] = EATING; up(\u0026amp;mutex); } void check(int i ){ if (state[i] == HUNGRY \u0026amp;\u0026amp; state[LEFT] != EATING \u0026amp;\u0026amp; state[EIGHT] != EATING){ state[i] = EATING; up(\u0026amp;s[i]); } } 2. 讀寫問題 問題描述：允許多個進程同時對數據進行讀操作，但是不允許讀和寫以及寫和寫操作同時發生。 一個整數變數 count 記錄在對數據進行讀操作的進程數量，一個互斥量 count_mutex 用於對 count 加鎖，一個互斥量 data_mutex 用於對讀寫的數據加鎖。 typedef int semaphore semaphore count_mutex = 1; semaphore data_mutex = 1; int count = 0; void reader(){ while(TRUE) { down(\u0026amp;count_mutex); count++; if(count == 1) down(\u0026amp;data_mutex); up(\u0026amp;count_mutex); read(); down(\u0026amp;count_mutex); count--; if(count == 0) up(\u0026amp;data_mutex); up(\u0026amp;count_mutex); } } void writer(){ while(TRUE) { down(\u0026amp;data_mutex); write(); up(\u0026amp;data_mutex); } } 以上範例可能會造成作家飢餓(starve)。只有當讀者早於作家進入佇列中，它才會進行等待。 int readcount, writecount; // initial value = 0 semaphore, rmutex, wmutex, readLock, resource; // initial value = 1 void reader() { // Entry section down(\u0026amp;readLock); // reader is trying to enter down(\u0026amp;mutex); // lock to increase readcount readcount++; if (readcount == 1) down(\u0026amp;resource); // if you are the first reader then lock the source up(\u0026amp;rmutex); // release for other readers up(\u0026amp;readLock); // done with trying to access the resource // critical section // \u0026lt;reading is performed\u0026gt; // Exit section down(\u0026amp;mutex); // reserve exit section - avoid race condition with readers readcount--; // indicate you\u0026#39;re leaving if (readcount == 0) // checks if you are last reader leaving up(\u0026amp;resource); // if last, you must release the locked resource up(\u0026amp;rmutex); // release exit section for other readers } void writer() { // Entry section down(\u0026amp;wmutex); // reserve entry section for writers - avoids race conditions writecount++; // report yourself as a writing entering if (writecount == 1) // checks if you\u0026#39;re the first writer down(\u0026amp;readLock); // if you\u0026#39;re first, then you must lock the readers out. Prevent them from trying to enter CS up(\u0026amp;wmutex); // release entry section // critical section down(\u0026amp;resource) // reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource // \u0026lt;writing is performed\u0026gt; up(\u0026amp;resource) // release file // Exit section down(\u0026amp;wmutex); // release exit section writecount--; // indicate you\u0026#39;re leaving if (writecount == 0) // check if you\u0026#39;re the last writer up(\u0026amp;readLock); // if you\u0026#39;re last writer, you must unlock the readers. Allows them to try enter CS for reading up(\u0026amp;wmutex); // release exit section } 我們可以觀察到每個讀者都被強迫上鎖。另一方面，作家無須各自上鎖。一旦第一個作家把 Readlcok 鎖上，則會等到佇列中沒有作家時才會被釋放。 從以上兩個範例我們可以發現，讀者與作家有一方必須飢餓(starve)。以下第三個範例的新增條件，會限制沒有執行緒被允許飢餓(starve)，也就是說，以下操作將會在一段時間之後停止。 int readCount // init to 0; number of readers currently accessing resource // all semaphore initialized to 1 Semaphore resourceAccess; // controls access (read/write) to the resource Semaphore readCountAccess; // for syncing changes to shared variable readCount Semaphore serviceQueue; // FAIRNESS: preserves ordering of requests (signaling must be FIFO) void writer(){ down(\u0026amp;servcieQueue); // wait in line to be services // \u0026lt;enter\u0026gt; down(\u0026amp;resourceAccess); // request exclusive access to resource // \u0026lt;/enter\u0026gt; up(\u0026amp;serviceQueue); // let next in line be serviced // \u0026lt;write\u0026gt; writeResource(); // writing is performed // \u0026lt;/write\u0026gt; // \u0026lt;exit\u0026gt; up(\u0026amp;resourceAccess); // release resource access for next reader/writer // \u0026lt;/exit\u0026gt; } void reader(){ down(\u0026amp;serviceQueue); // wait in line to be serviced down(\u0026amp;readCountAccess); // request exclusive access to readCount // \u0026lt;enter\u0026gt; if (readCount == 0) // if there are no readers already reading down(\u0026amp;resourceAccess); // request resource access for reader (writer blocked) readCount++; // update count of active readers // \u0026lt;/enter\u0026gt; up(\u0026amp;serviceQueue); // let next in line be serviced up(\u0026amp;readCountAccess); // release access to readCount // \u0026lt;read\u0026gt; readResource() // reading is performed // \u0026lt;/read\u0026gt; down(\u0026amp;readCountAccess); // request exclusive access to readCount // \u0026lt;exit\u0026gt; readCount--; // update count of active readers if (readCount == 0) // if there are no readers left up(\u0026amp;resourceAccess); // release resource access for all // \u0026lt;/exit\u0026gt; up(\u0026amp;readCountAccess) // release access to readCount } 進程通訊 進程同步與進程通訊很容易混淆，它們的區別在： 進程同步(process synchronization)：控制多個進程按一定順序執行。 進程通訊(process communication)：進程間傳遞訊息 進程通訊是一種手段，進程同步是一種目的。也可以說，為了能夠達成進程同步的目的，需要讓進程進行通訊，傳遞一些進程同步所需要的訊息。 1. 管道 管道是通用調用 pipe 函數創建的，fd[0] 用於讀，fd[1] 用於寫。 #include \u0026lt;unistd.h\u0026gt; int pipe(int fd[2]); 它具有以下的限制：\n只支持半雙工通訊(單向交替傳輸) 只能在父子進程或者兄弟進程中使用。 2. FIFO 也稱為管道，去除了管道只能在父子進程中的使用限制。 #include \u0026lt;sys/stat.h\u0026gt; int mkfifo(const char *path, mode_t mode); int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用於客戶-伺服器應用程式中，FIFO 用於匯聚點，在客戶進程與伺服器進程之間傳遞數據。 3. 訊息佇列 相較於 FIFO，訊息佇列有以下優點： 消息佇列可以獨立於讀寫進程存在，從而避免了 FIFO 中同步管道的打開和關閉時可能產生的困難。 避免了 FIFO 的同步阻塞問題，不需要進程自己提供同步方法。 讀進程可以根據訊息類型有選擇性地接收訊息，而不像 FIFO 那樣只能全盤地接受。 4. 訊號量 一個計數器，用於為多個進程提供對共享數據的物件作訪問。 5. 記憶體共享 允許多個進程共享一個給定的記憶體空間。因為數據不需要在進程之間複制，所以這是最快的一種 IPC(Inter-Process Communication)。 需要使用訊號量來同步對共享記憶體的訪問。 多個進程可以將同一個文件映射到它們的地址空間從而實現共享記憶體。另外 XSI 共享記憶體不是使用文件，而是使用記憶體的匿名段。 6. word 套接 與其它通訊機制不同的是，它可以用於不同機器間的進程通訊。 ","permalink":"http://intervalrain.github.io/posts/cs/os/processmanagement/","summary":"進程管理 進程與執行緒 1. 進程(process) 進程是資源分配的基本單位。 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。 2. 執行緒(thread) 執行緒又稱線程，是獨立調度的基本單位。 一個進程可以有多個執行緒，它們共享進程資源。 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。 3. 區別 擁有資源 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。 調度 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。 系統開銷 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。 通訊 執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。 進程狀態的切換 就緒就態(ready)：等待被調度 執行狀態(running) 阻塞狀態(waiting)：等待資源 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。 進程調度演算法 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。 1. 批次處理系統(batch system) 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。 1.1 先來先服務(first-come first-served, FCFS) 非搶占式的調度，按照請求的順序進行調度。 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長 1.2 短作業優先(shortest job first, SJF) 非搶占式的調度算法，按估計運行時間最短的順序進行調度。 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。 1.","title":"[計算機作業系統] 進程管理"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/cs/os/link/","summary":"準備中 ","title":"[計算機作業系統] 鏈接"},{"content":"什麼是 AI \u0026amp; ML \u0026amp; DL 人工智慧是我們想要達成的目標，而機器學習是想要達成目標的手段，希望機器通過學習的方式，變得跟人一樣聰明。 而深度學習就是機器學習的其中一種方法。\n人工智慧(Aritificial Intelligence, AI) → 目標 機器學習(Machine Learning, ML) → 手段 深度學習(Deep Learning, DL) … 在機器學習出現之前 生物的行為取決於兩件事，一個是後天學習的結果，一個是天生的本能。\nHand-crafted rules: 人類為機器設定好的天生本能 僵化，無法超越創造者 需要大量人力，不適合小企業 機器學習 寫程式讓機器可以學習 → 尋找關聯資料的函式 舉例：語音辨識、影像辨識、Alpha Go、對話機器人 框架(Framework) 設定一定量的函數 餵入數據 評估函數的好壞 找出最好的函數\n\\(\\begin{array}{rc} \\text{step1}\u0026amp;\\boxed{\\text{Define a set of function}}\\\\ \u0026amp;\\downarrow\\\\ \\text{step2}\u0026amp;\\boxed{\\text{Evaluate goodness of function}}\\\\ \u0026amp;\\downarrow\\\\ \\text{step3}\u0026amp;\\boxed{\\text{Pick the best function}}\\end{array}\\) 告訴機器 input 和正確的 output 這就叫作 supervised learning。 機器學習相關的技術 任務(Task) 迴歸(Regression) Regression 指的是函數的輸出為 scalar(數值)，如 PM2.5。 分類(Classification) Classification 指的是函數的輸出為 東西的類別。 當分類為 Yes or No，則為 Binary Classificatino，如垃圾郵件。 當分類是多個選項的，則為 Multi-Classification，如新聞分類。 結構性學習(Structured Learning) 讓機器的輸出具有結構性。 如語音辨識，聲音訊號為輸入，句子為輸出。 如影像辨識，圖片是輸入，人名是輸出。 方法(Method) 選不同的 function set 就是選不同的 model。\nModel Linear Model Non-linear model Deep learning SVM, decision tree, K-NN \u0026hellip; 場景(Scenario) 監督式學習 Supervised Learning 需要 inputs 與對應的 outputs(label) 大量的資料需求 半監督式學習 Semi-supervised Learning 同時有 Labelled data 與 Unlabelled data 可減少資料的需求量。 遷移學習 Transfer Leanring 有大量的 Labelled data 與 Unlabelled data 其中包含有關聯的與無關聯的。 無監督學習 Unsuperviesd Learning 只有大量的 inputs 而沒有 outputs 或大量的 outputs 而沒有 inputs 強化學習 沒有告訴機器正確的答案，機器有的只是一個分數，就是它做得好或不好。 Alpha Go 是 Supervised learning + Reinforcement learning (先人工餵棋譜，再讓機器人互相下棋) 利用 reinforcement learning 來訓練聊天機器人，把機器人發到客服電話，讓機器人自己應對客人，若客人的反應勃然大怒，則機器會學到剛才應對的方式是錯的，讓機器自己去檢討哪個步驟做的不好。\n我們為何要學機器學習? 好的 AI 需要好的 AI 訓練師，AI 訓練師討選合適的 model、loss function，不同 model、loss function 適合解決不同的問題。 有些模型的最佳化比較困難，例如深度學習，此時可能就需要有經驗的 AI 訓練師來處理。\n","permalink":"http://intervalrain.github.io/posts/ml/lec0/","summary":"什麼是 AI \u0026amp; ML \u0026amp; DL 人工智慧是我們想要達成的目標，而機器學習是想要達成目標的手段，希望機器通過學習的方式，變得跟人一樣聰明。 而深度學習就是機器學習的其中一種方法。\n人工智慧(Aritificial Intelligence, AI) → 目標 機器學習(Machine Learning, ML) → 手段 深度學習(Deep Learning, DL) … 在機器學習出現之前 生物的行為取決於兩件事，一個是後天學習的結果，一個是天生的本能。\nHand-crafted rules: 人類為機器設定好的天生本能 僵化，無法超越創造者 需要大量人力，不適合小企業 機器學習 寫程式讓機器可以學習 → 尋找關聯資料的函式 舉例：語音辨識、影像辨識、Alpha Go、對話機器人 框架(Framework) 設定一定量的函數 餵入數據 評估函數的好壞 找出最好的函數\n\\(\\begin{array}{rc} \\text{step1}\u0026amp;\\boxed{\\text{Define a set of function}}\\\\ \u0026amp;\\downarrow\\\\ \\text{step2}\u0026amp;\\boxed{\\text{Evaluate goodness of function}}\\\\ \u0026amp;\\downarrow\\\\ \\text{step3}\u0026amp;\\boxed{\\text{Pick the best function}}\\end{array}\\) 告訴機器 input 和正確的 output 這就叫作 supervised learning。 機器學習相關的技術 任務(Task) 迴歸(Regression) Regression 指的是函數的輸出為 scalar(數值)，如 PM2.5。 分類(Classification) Classification 指的是函數的輸出為 東西的類別。 當分類為 Yes or No，則為 Binary Classificatino，如垃圾郵件。 當分類是多個選項的，則為 Multi-Classification，如新聞分類。 結構性學習(Structured Learning) 讓機器的輸出具有結構性。 如語音辨識，聲音訊號為輸入，句子為輸出。 如影像辨識，圖片是輸入，人名是輸出。 方法(Method) 選不同的 function set 就是選不同的 model。","title":"[ML] introduction"},{"content":"陣雨：\n在每日一題 Leetcode 的日常中，看到 LinkedIn 上來自 LinkedIn 自己工程師的建議，一語驚醒夢中人，於是記錄下來，警醒自己：\n作者 Nikita Kothari Software Engineer @ LinkedIn The University of Texas at Dallas 正文 Nikita:\nRecently I interviewed and got 7 offers within two months of preparation and accepted Senior Software Engineer position at LinkedIn. I want to share some useful resources which might help you to land your dream job.\n最近，我在兩個月內準備了面試並錄取了七個職位，且最終且接收了 LinkedIn 的高級軟體工程師一職。我想要分享一些有用的資源，這些資源可能可以幫助你找到你夢寐以求的工作。\n1. 自信 Confidence is the key. Don’t jump into the interview process when you are not fully prepared.\n信心是關鍵。當你還沒有做好充分準備前，不要貿然的進入面試階段。\n2. 刷題 Rather than doing 1000s of leetcode (https://lnkd.in/gyRnXuHQ), do few examples and understand the patterns which will help you to crack any problem. Also, think about all edge cases and test cases.\n比起刷 1000 題 leetcode，做幾個經典例題並瞭解其模式(pattern)，這將會有助於你破解任何問題。同時，請充分考慮邊際條件(edge cases)與測資(test cases)。\n3. 複雜度 At the end, spend some time thinking about time and space complexity. It gets tricky with graph and tree problems.\n在解題的最後，花點時間思考時間複雜度與空間複雜度。特別在棘手的圖形與樹問題。\n4. 應用 Think about the possible use cases of the given problem, for example, flood fill is nothing but the paint app and try to explain that to the interviewer.\n思考題目可能應用的實況，舉例來說，flood-fill 只不過是繪畫應用程式，並嘗試向面試官解釋。\n5. 專案 Create a Google doc and list down all recent/interesting project you worked on. Start with design, implementation, testing, monitoring, your contribution and ask yourself what questions a person can ask if he/she doesn’t have any idea about the project. This will also help you during the system design interview.\n創建一個 Google 文件並列出所有你最近正在著手或有趣的專案。從設計、實作、測試、監控、你的貢獻開始，並問自己，如果一個人對此專案毫無概念時，他/她可以問什麼問題。\n6. STAR Also, create a Google doc for behavior questions (https://lnkd.in/gPp8iE_x) and write down what was the situation, what was your task, what action you took and what was the result. Read more about the STAR approach. Companies like Amazon, pays more attention to these questions so be well-prepared.\n此外，為行為問題創建一個 Google 文件，並寫下情況，你的任務是什麼，你採取了什麼行動，結果是什麼。閱讀更多有關 STAR 的方法。像亞馬遜這類的公司，更在乎這類的問題，所以需要做好充分準備。 註：情境/任務/動作/結果 Situation/Task/Action/Result\n7. 模擬面試 Do practice interviews with your friends and peers, and take feedback seriously.\n與你的朋友、同儕練習面試，並且認真的對待他們的回饋。\n8. 記錄面試 At the end of an onsite interview, make a list of what went well and where you need to put more attention and work on it.\n在現場面試後，列出哪些方面進展順利，哪些需要投入更多的注意力與力氣。\n9. 連結經驗 While practicing system design, try to relate things with your current or past experience. Like how server side configuration has been set up or how APIs are implemented in your current project. This way you will remember things easily.\n在練習系統設計時，試著與你現在或以前的經驗聯繫起來。例如伺服器端配置的方法、API 在你當前的專案中是怎麼被實現的。這些方法會讓你更容易記得這些事。\n10. 參考 Before your onsite interview, visit Glassdoor (https://lnkd.in/gwKXeYQA) and read about other’s experiences. That will give you an idea on what to expect.\n在現場面試前，參考並閱讀其他人的經驗，這將給你多一點面試時的想法。\n11. 保持正向 Lastly, don’t get dejected by rejections. Sometimes it looks difficult, but with enough practice and hard work, you will get your dream job.\n最後，不要因為被拒絕而沮喪。有時候，看起很困難的事情，在經過足夠的練習與努力後，都可以迎刃而解的。\nAll the very best, and feel free to reach out to me if you need any help on anything.\n其他資源 Grokking the Object Oriented Design Interview 系統設計入門 (https://lnkd.in/g6jQaM6e) 軟體結構 (https://lnkd.in/gM8WgW3S) 系統設計 (https://lnkd.in/gYF5saRb)\n#work #softwareengineer #interviewskills #design #job ","permalink":"http://intervalrain.github.io/posts/life/nikita_kothari/","summary":"陣雨：\n在每日一題 Leetcode 的日常中，看到 LinkedIn 上來自 LinkedIn 自己工程師的建議，一語驚醒夢中人，於是記錄下來，警醒自己：\n作者 Nikita Kothari Software Engineer @ LinkedIn The University of Texas at Dallas 正文 Nikita:\nRecently I interviewed and got 7 offers within two months of preparation and accepted Senior Software Engineer position at LinkedIn. I want to share some useful resources which might help you to land your dream job.\n最近，我在兩個月內準備了面試並錄取了七個職位，且最終且接收了 LinkedIn 的高級軟體工程師一職。我想要分享一些有用的資源，這些資源可能可以幫助你找到你夢寐以求的工作。\n1. 自信 Confidence is the key. Don’t jump into the interview process when you are not fully prepared.","title":"[Life] Some change of road to SWE"},{"content":"Deque 不同於 stack 與 queues， deques 兩個端點都支援擴展。 基於 doubly linked list，deques 有幾項額外的特徵： 支援隨機存取 插入元素時間 \\(O(1)\\) 函式 1. push_front() 2. push_back() 3. front() 4. back() 5. begin() 6. end() 7. insert() 8. erase() 9. pop_front() 10. pop_back() 11. empty() 12. clear() 13. random_access() 內部運作原理 上述所有函數和操作都在雙鏈表中以O（1）時間執行，但這些清單不能隨機訪問任何元素。C++中的deque也是如此。這個 O（1） 在 deque 中可以使用圓形陣列來實現。使用循環陣列，可以在O（1）時間內實現從陣列的正面和背面插入和刪除等操作以及元素的隨機訪問。但這帶來了一個問題。當 deque 增長到超出容量時，使用者將需要將數位大小加倍，並將所有數據複製到陣列中。此外，如果數據是某個使用者定義的對象，那麼加倍和複製數據的成本就會變得非常昂貴。 這是一個基本的解決方案。Deque使用一些棘手的實現，當它說O（1）來push_back（）和push_front（）時，它實際上是調用的複製構造函數數量的常數時間。因此，如果數據物件是具有多個成員的某個類物件，則最小化複製構造函數調用的數量將節省時間。此外，複製構造函數調用的次數是恆定的。現在讓我們看看如何實現這一點。 這可以通過使用指向一些固定大小的塊的指標數位來實現，這些塊包含deque數據。下面是一個說明性示例。 這些 Deque 數據被劃分為固定大小的塊。在這裡，我們考慮了將數據劃分為大小為5的固定塊。 塊的填充從指標的兩個 deque 陣列的中間開始，並使用push_front和push_back操作向前和向後擴展。中間塊通常是滿的，當它被填滿時，數據被移動到上部或下部塊。 在上部塊中，元素以相反的順序推送，因為在這種情況下，填充數據的第一個位置將是4，然後是3，2，1，0。但是在中間和下部塊中，數據按正向順序填充，如0，1，2，3，4等。 當上面的塊被填滿時，指標將創建一個新塊並開始指向一個新的數位塊。這為更多數據創造了空間。在這種情況下，也可以填充指標塊。這會導致一個問題。 這是加倍來救援的時候。在加倍時，指標陣列的大小加倍。這不會複製整個數據，而只會複製指標。這是許多人在討論恆定時間時提出的一般論點。時間在調用的複製構造函數數方面保持不變。 如果數據集非常大，則指標塊幾乎不會執行加倍，因為單個指標可以指向大量數據塊。因此，指標陣列被填充並加倍的可能性非常小。 ","permalink":"http://intervalrain.github.io/posts/c++/stl_deque/","summary":"Deque 不同於 stack 與 queues， deques 兩個端點都支援擴展。 基於 doubly linked list，deques 有幾項額外的特徵： 支援隨機存取 插入元素時間 \\(O(1)\\) 函式 1. push_front() 2. push_back() 3. front() 4. back() 5. begin() 6. end() 7. insert() 8. erase() 9. pop_front() 10. pop_back() 11. empty() 12. clear() 13. random_access() 內部運作原理 上述所有函數和操作都在雙鏈表中以O（1）時間執行，但這些清單不能隨機訪問任何元素。C++中的deque也是如此。這個 O（1） 在 deque 中可以使用圓形陣列來實現。使用循環陣列，可以在O（1）時間內實現從陣列的正面和背面插入和刪除等操作以及元素的隨機訪問。但這帶來了一個問題。當 deque 增長到超出容量時，使用者將需要將數位大小加倍，並將所有數據複製到陣列中。此外，如果數據是某個使用者定義的對象，那麼加倍和複製數據的成本就會變得非常昂貴。 這是一個基本的解決方案。Deque使用一些棘手的實現，當它說O（1）來push_back（）和push_front（）時，它實際上是調用的複製構造函數數量的常數時間。因此，如果數據物件是具有多個成員的某個類物件，則最小化複製構造函數調用的數量將節省時間。此外，複製構造函數調用的次數是恆定的。現在讓我們看看如何實現這一點。 這可以通過使用指向一些固定大小的塊的指標數位來實現，這些塊包含deque數據。下面是一個說明性示例。 這些 Deque 數據被劃分為固定大小的塊。在這裡，我們考慮了將數據劃分為大小為5的固定塊。 塊的填充從指標的兩個 deque 陣列的中間開始，並使用push_front和push_back操作向前和向後擴展。中間塊通常是滿的，當它被填滿時，數據被移動到上部或下部塊。 在上部塊中，元素以相反的順序推送，因為在這種情況下，填充數據的第一個位置將是4，然後是3，2，1，0。但是在中間和下部塊中，數據按正向順序填充，如0，1，2，3，4等。 當上面的塊被填滿時，指標將創建一個新塊並開始指向一個新的數位塊。這為更多數據創造了空間。在這種情況下，也可以填充指標塊。這會導致一個問題。 這是加倍來救援的時候。在加倍時，指標陣列的大小加倍。這不會複製整個數據，而只會複製指標。這是許多人在討論恆定時間時提出的一般論點。時間在調用的複製構造函數數方面保持不變。 如果數據集非常大，則指標塊幾乎不會執行加倍，因為單個指標可以指向大量數據塊。因此，指標陣列被填充並加倍的可能性非常小。 ","title":"[C++] The C++ Standard Template Library(STL) - deque"},{"content":"C++ Custom Comparator sort(iter, iter, comp) Lambda function int main(){ auto comp = [](int a, int b){ return a \u0026lt; b; } vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Usual boolean function bool comp(const int\u0026amp; a, const int\u0026amp; b){ return a \u0026lt; b; } int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Old solution using struct/class with () operator struct cmp { bool operator() (int a, int b) const { return a \u0026lt; b; } }; int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp()); // 1,2,3,4,5,6,7,8,9 } priority_queue(element, container, comp) Modern C++20 Solution(lambda) We can use lambda function as comparator. As usual, comparator should return boolean value, indicating whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines. int main(){ auto comp = [](int a, int b){ return a \u0026lt; b; } vector\u0026lt;int\u0026gt; vec = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int, decltype(comp)\u0026gt; pq; for (int num : vec) pq.push(num); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } Modern C++11 Solution(lambda) Before C++20 we need to pass lambda function as argument to set constructor. int main(){ auto comp = [](int a, int b){ return a \u0026lt; b; } vector\u0026lt;int\u0026gt; vec = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int, decltype(comp)\u0026gt; pq(comp); for (int num : vec) pq.push(num); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } Usual function Make comparator as usual boolean function bool comp(int a, int b){ return a \u0026lt; b; } int main(){ vector\u0026lt;int\u0026gt; vec = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int, decltype(\u0026amp;comp)\u0026gt; pq(comp); // priority_queue\u0026lt;int, vector\u0026lt;int, decltype(comp)*\u0026gt; pq(comp); // in C++20, constructor can be ignored the same as lambda function. for (int num : vec) pq.push(num); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } Old solution using struct/class with () operator struct cmp { bool operator() (int a, int b) const { return a \u0026lt; b; } }; int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, comp\u0026gt; pq(vec.begin(), vec.end()); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } Alternative solution: create struct/class from boolean function bool comp(int a, int b){ return a \u0026lt; b; } #include \u0026lt;type_traits\u0026gt; using Cmp = integral_constant\u0026lt;decltype(\u0026amp;comp), \u0026amp;comp\u0026gt;; int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; priority_queue\u0026lt;int, vector\u0026lt;int, decltype(\u0026amp;comp)\u0026gt; pq(comp); for (int num : vec) pq.push(num); while (!pq.empty()) { cout \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 9,8,7,6,5,4,3,2,1 pq.pop(); } cout \u0026lt;\u0026lt; endl; } ","permalink":"http://intervalrain.github.io/posts/c++/custom_comparator/","summary":"C++ Custom Comparator sort(iter, iter, comp) Lambda function int main(){ auto comp = [](int a, int b){ return a \u0026lt; b; } vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Usual boolean function bool comp(const int\u0026amp; a, const int\u0026amp; b){ return a \u0026lt; b; } int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Old solution using struct/class with () operator struct cmp { bool operator() (int a, int b) const { return a \u0026lt; b; } }; int main(){ vector\u0026lt;int\u0026gt; = {3,6,7,2,1,9,5,4,8}; sort(vec.","title":"[C++] Custom Comparator"},{"content":"pair 函式庫 #include \u0026lt;utility\u0026gt; 宣告 pair\u0026lt;data_type1, data_type2\u0026gt; Pair_name; 初始化 pair\u0026lt;int, int\u0026gt; p1; // 宣告但不初始化 pair\u0026lt;int, char\u0026gt; p2(1, \u0026#39;a\u0026#39;); // 不同資料型態的初始化 pair\u0026lt;int, int\u0026gt; p3(1, 10); // 同資料型態的初始化 pair\u0026lt;int, int\u0026gt; p4(p3); // 利用其它 pair 來初始化 pair\u0026lt;int, int\u0026gt; p5 = {1, 2} // 用 assign 的方式初始化 p2 = make_pair(1, \u0026#39;a\u0026#39;); // 利用 make_pair 函式 成員 .first .second 函式 1. make_pair(v1, v2); 2. pair1.swap(pair2); 3. tie(a,b) 示例 #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; using namespace std; int main(){ // initialize pair\u0026lt;int,int\u0026gt; p1; pair\u0026lt;int,int\u0026gt; p2(2,4); pair\u0026lt;int,char\u0026gt; p3(3,\u0026#39;c\u0026#39;); pair\u0026lt;int,int\u0026gt; p4(p2); pair\u0026lt;int,int\u0026gt; p5 = {5,10}; // member cout \u0026lt;\u0026lt; p2.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p2.second \u0026lt;\u0026lt; endl; // 2 4 cout \u0026lt;\u0026lt; p3.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p3.second \u0026lt;\u0026lt; endl; // 3 c cout \u0026lt;\u0026lt; p4.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p4.second \u0026lt;\u0026lt; endl; // 2 4 cout \u0026lt;\u0026lt; p5.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p5.second \u0026lt;\u0026lt; endl; // 5 10 // function p1 = make_pair(1,2); cout \u0026lt;\u0026lt; p1.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p1.second \u0026lt;\u0026lt; endl; // 1 2 // a.swap(b) p1.swap(p2); cout \u0026lt;\u0026lt; p1.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p1.second \u0026lt;\u0026lt; endl; // 2 4 cout \u0026lt;\u0026lt; p2.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p2.second \u0026lt;\u0026lt; endl; // 1 2 // tie(a,b) = pair int a, b; tie(a, b) = p1; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; // 2 4 return 0; } ","permalink":"http://intervalrain.github.io/posts/c++/stl_pair/","summary":"pair 函式庫 #include \u0026lt;utility\u0026gt; 宣告 pair\u0026lt;data_type1, data_type2\u0026gt; Pair_name; 初始化 pair\u0026lt;int, int\u0026gt; p1; // 宣告但不初始化 pair\u0026lt;int, char\u0026gt; p2(1, \u0026#39;a\u0026#39;); // 不同資料型態的初始化 pair\u0026lt;int, int\u0026gt; p3(1, 10); // 同資料型態的初始化 pair\u0026lt;int, int\u0026gt; p4(p3); // 利用其它 pair 來初始化 pair\u0026lt;int, int\u0026gt; p5 = {1, 2} // 用 assign 的方式初始化 p2 = make_pair(1, \u0026#39;a\u0026#39;); // 利用 make_pair 函式 成員 .first .second 函式 1. make_pair(v1, v2); 2. pair1.swap(pair2); 3. tie(a,b) 示例 #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; using namespace std; int main(){ // initialize pair\u0026lt;int,int\u0026gt; p1; pair\u0026lt;int,int\u0026gt; p2(2,4); pair\u0026lt;int,char\u0026gt; p3(3,\u0026#39;c\u0026#39;); pair\u0026lt;int,int\u0026gt; p4(p2); pair\u0026lt;int,int\u0026gt; p5 = {5,10}; // member cout \u0026lt;\u0026lt; p2.","title":"[C++] The C++ Standard Template Library(STL) - pair"},{"content":"HDLBits HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。 由教學的題型由淺入深，逐步建立起電路設計的技能。 每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。\nCatalog 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n1 Getting Started \\(\\text{assign one}\\) Build a circuit with no inputs and one output. The output should always drive 1 (or logic high). module top_module( output one); assign one = 1\u0026#39;b1; endmodule \\(\\text{assign zero}\\) Build a circuit with no inputs and one output that outputs a constant 0. module top_module( output zero ); assign zero = 1\u0026#39;b0; endmodule ","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits1/","summary":"HDLBits HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。 由教學的題型由淺入深，逐步建立起電路設計的技能。 每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。\nCatalog 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n1 Getting Started \\(\\text{assign one}\\) Build a circuit with no inputs and one output. The output should always drive 1 (or logic high). module top_module( output one); assign one = 1\u0026#39;b1; endmodule \\(\\text{assign zero}\\) Build a circuit with no inputs and one output that outputs a constant 0.","title":"[VHDL] HDLbits 1 - Getting Started"},{"content":"1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n2 Verilog Language 2.1 Basics wire Create a module with one input and ont output that behaves like a wire module top_module( input in, output out); assign out = in; endmodule multi-in-out Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: module top_module( input a,b,c, output w,x,y,z ); assign w = a; assign x = b; assign y = b; assign z = c; endmodule not gate Create a module that implements a NOT gate. module top_module( input in, output out ); assign out = ~in; endmodule and gate Create a module that implments an AND gate. module top_module( input a,b, output out ); assign out = a \u0026amp; b; endmodule nor gate Create a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog. module top_module( input a,b, output out ); assign out = ~(a|b); endmodule xnor gate Create a module that implements a XNOR gate. module top_module( input a, b, output out ); assign out = ~(a^b); endmodule wire declaration Implement following circuits. Create two intermediate wires to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire out, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs. module top_module( input a,b,c,d, output out, out_n ); wire w1, w2; assign w1 = a \u0026amp; b; assign w2 = c \u0026amp; d; assign out = w1 | w2; assign out_n = ~out; endmodule 7458 The 7458 is a chip with four AND gates and two OR gates. Create a module with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. module top_module( input p1a, p1b, p1c, p1d, p1e, p1f, output p1y, intput p2a, p2b, p2c, p2d, output p2y ); wire w1a, w1b; wire w2a, w2b; assign w1a = p1a \u0026amp; p1b \u0026amp; p1c; assign w1b = p1d \u0026amp; p1e \u0026amp; p1f; assign p1y = w1a | w1b; assign w2a = p2a \u0026amp; p2b; assign w2b = p2c \u0026amp; p2d; assign p2y = w2a | w2b; endmodule 2.2 Vectors vector Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect outputs o0 to the input vector\u0026rsquo;s position 0, o1 to position 1, etc.\nIn a diagram, a tick mark with a number next to it indicates the width of the vector (or \u0026ldquo;bus\u0026rdquo;), rather than drawing a separate line for each bit in the vector. module top_module ( input wire [2:0] vec, output wire [2:0] outv, output wire o2, output wire o1, output wire o0 ); assign outv = vec; assign o0 = vec[0]; assign o1 = vec[1]; assign o2 = vec[2]; endmodule vector select Build a combinational circuit that splits an input half-word (16 bits, [15:0]) into lower [7:0] and upper [15:8] bytes. module top_module ( input [15:0] in, output [7:0] out_hi, output [7:0] out_lo ); assign out_hi = in[15:8]; assign out_lo = in[7:0]; endmodule vector swap A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of the 4-byte word.\nAaaaaaaaBbbbbbbbCcccccccDddddddd =\u0026gt; DdddddddCcccccccBbbbbbbbAaaaaaaa\nThis operation is often used when the endianness of a piece of data needs to be swapped, for example between little-endian x86 systems and the big-endian formats used in many Internet protocols. module top_module ( input [31:0] in, output [31:0] out ); assign out[31:24] = in[ 7: 0]; assign out[23:16] = in[15: 8]; assign out[15: 8] = in[23:16]; assign out[ 7: 0] = in[31:24]; endmodule vector gates uild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half. module top_module ( input [2:0] a, input [2:0] b, output [2:0] out_or_bitwise, output out_or_logical, output [5:0] out_not ); assign out_or_bitwise = a | b; assign out_or_logical = a || b; assign out_not[2:0] = ~a; assign out_not[5:3] = ~b; endmodule gate-prefix vector Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: out_and: output of a 4-input AND gate. out_or: output of a 4-input OR gate. out_xor: outout of a 4-input XOR gate. module top_module ( input [3:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026amp; in; assign out_or = | in; assign out_xor = ^ in; endmodule vector concatenate Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for module top_module ( input [4:0] a, b, c, d, e, f, output [7:0] w, x, y, z ); assign {w, x, y, z} = {a, b, c, d, e, f, 2\u0026#39;b11}; endmodule vector reverse Given an 8-bit input vector [7:0], reverse its bit ordering. module top_module( input [7:0] in, output [7:0] out ); assign {out[0], out[1], out[2], out[3], out[4], out[5], out[6], out[7]} = in endmodule module top_module( input [7:0] in, output [7:0] out ); always @(*) begin for (int i=0; i\u0026lt;8; i++) out[i] = in[8-i-1]; end endmodule module top_module( input [7:0] in, output [7:0] out ); generate genvar i; for (i=0; i\u0026lt;8; i = i+1) begin: my_block_name assign out[i] = in[8-i-1]; end endgenerate endmodule vector replication Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself. module top_module ( input [7:0] in, output [31:0] out ); assign out = {{24{in[7]}}, in}; endmodule vector replication2 Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. module top_module ( input a, b, c, d, e, output [24:0] out ); assign out = ~{{5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}}} ^ {5{a,b,c,d,e}}; endmodule 2.3 Modules: Hierarchy By now, you\u0026rsquo;re familiar with a module, which is a circuit that interacts with its outside through input and output ports. Larger, more complex circuits are built by composing bigger modules out of smaller modules and other pieces (such as assign statements and always blocks) connected together. This forms a hierarchy, as modules can contain instances of other modules.\nThe figure below shows a very simple circuit with a sub-module. In this exercise, create one instance of module mod_a, then connect the module\u0026rsquo;s three pins (in1, in2, and out) to your top-level module\u0026rsquo;s three ports (wires a, b, and out). The module mod_a is provided for you — you must instantiate it.\nWhen connecting modules, only the ports on the module are important. You do not need to know the code inside the module. The code for module mod_a looks like this:\nmodule mod_a ( input in1, input in2, output out ); // Module body endmodule The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written inside another module\u0026rsquo;s body (Code for different modules are not nested).\nYou may connect signals to the module by port name or port position. For extra practice, try both methods.\nConnecting Signals to Module Ports\nThere are two commonly-used methods to connect a wire to a port: by position or by name.\nBy position\nThe syntax to connect wires to ports by position should be familiar, as it uses a C-like syntax. When instantiating a module, ports are connected left to right according to the module\u0026rsquo;s declaration. For example:\nmod_a instance1 ( wa, wb, wc );\nThis instantiates a module of type mod_a and gives it an instance name of \u0026ldquo;instance1\u0026rdquo;, then connects signal wa (outside the new module) to the first port (in1) of the new module, wb to the second port (in2), and wc to the third port (out). One drawback of this syntax is that if the module\u0026rsquo;s port list changes, all instantiations of the module will also need to be found and changed to match the new module.\nBy name\nConnecting signals to a module\u0026rsquo;s ports by name allows wires to remain correctly connected even if the port list changes. This syntax is more verbose, however.\nmod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );\nThe above line instantiates a module of type mod_a named \u0026ldquo;instance2\u0026rdquo;, then connects signal wa (outside the module) to the port named in1, wb to the port named in2, and wc to the port named out. Notice how the ordering of ports is irrelevant here because the connection will be made to the correct name, regardless of its position in the sub-module\u0026rsquo;s port list. Also notice the period immediately preceding the port name in this syntax.\nmodule module top_module ( input a, input b, output out ); mod_a u_mod_a ( .in1 (a), .in2 (b), .out (out) ); endmodule module_pos This problem is similar to the previous one (module). You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. You must connect the 6 ports by position to your top-level module\u0026rsquo;s ports out1, out2, a, b, c, and d, in that order. You are given the following module: module top_module ( input a, b, c, d, output out1, out2 ); mod_a u_mod_a(out1, out2, a, b, c, d); endmodule module_name This problem is similar to module. You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. You must connect the 6 ports by name to your top-level module\u0026rsquo;s ports:You are given the following module: module top_module ( input a, input b, input c, input d, output out1, output out2 ); mod_a u_mod_a( .out1 (out1), .out2 (out2), .in1 (a), .in2 (b), .in3 (c), .in4 (d) ); endmodule module_shift You are given a module my_dff with two inputs and one output (that implements a D flip-flop). Instantiate three of them, then chain them together to make a shift register of length 3. The clk port needs to be connected to all instances. Note that to make the internal connections, you will need to declare some wires. Be careful about naming your wires and module instances: the names must be unique.\nThe module provided to you is: module my_dff ( input clk, input d, output q ); module top_module ( input clk, input d, output q ); wire q1; wire q2; my_dff(clk, d, q1); my_dff(clk, q1, q2); my_dff(clk, q2, q); endmodule module_shift8 You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: The value at the input d, after the first, after the second, or after the third D flip-flop. (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.) The module provided to you is: module my_dff8 ( input clk, input [7:0] d, output [7:0] q );\nThe multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside. module top_module ( input clk, input [7:0] d, input [1:0] sel, output [7:0] q ); wire [7:0] q1; wire [7:0] q2; wire [7:0] q3; my_dff8 (clk, d, q1); my_dff8 (clk, q1, q2); my_dff8 (clk, q2, q3); // multiplexer: mux9to1v always@(*) begin case(sel) 2\u0026#39;d0: q = d; 2\u0026#39;d1: q = q1; 2\u0026#39;d2: q = q2; 2\u0026#39;d3: q = q3; endcase end endmodule module_Half Adder You are given a module add16 that performs a 16-bit addition. Instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result, after receiving the carry-out from the first adder. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored), but the internal modules need to in order to function correctly. (In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).\nConnect the modules together as shown in the diagram below. The provided module add16 has the following declaration: module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout ); module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire [15:0] sum1; wire [15:0] sum2; wire cout1; wire cout2; add16 (a[15:0], b[15:0], 1\u0026#39;b0, sum1, cout1); add16 (a[31:16], b[31:16], cout1, sum2, cout2); assign sum = {sum2, sum1}; endmodule module_Full Adder You are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).\nConnect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nWithin each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. You must write the full adder module that has the following declaration:\nmodule add1 ( input a, input b, input cin, output sum, output cout );\nRecall that a full adder computes the sum and carry-out of a+b+cin.\nIn summary, there are three modules in this design: top_module — Your top-level module that contains two of\u0026hellip; add16, provided — A 16-bit adder module that is composed of 16 of\u0026hellip; add1 — A 1-bit full adder module. module top_module ( input [31:0] a, input [31:0] b, output [31:0] sum ); wire [15:0] sum1; wire [15:0] sum2; wire cout1; wire cout2; add16 (a[15:0], b[15:0], 1\u0026#39;b0, sum1, cout1); add16 (a[31:16], b[31:16], cout1, sum2, cout2); assign sum = {sum2, sum1}; endmodule module add1 ( input a, input b, input cin, output sum, output cout ); assign sum = a ^ b ^ cin; assign cout = (a\u0026amp;b)|(b\u0026amp;cin)|(cin\u0026amp;a); // assign {cout, sum} = a + b + cin; endmodule module_Carry Select Adder One drawback of the ripple carry adder is that the delay for an adder to compute the carry out (from the carry-in, in the worst case) is fairly slow, and the second-stage adder cannot begin computing its carry-out until the first-stage adder has finished. This makes the adder slow. One improvement is a carry-select adder, shown below. The first-stage adder is the same as before, but we duplicate the second-stage adder, one assuming carry-in=0 and one assuming carry-in=1, then using a fast 2-to-1 multiplexer to select which result happened to be correct.\nYou are provided with the same module add16 as the previous exercise, which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. You must instantiate three of these to build the carry-select adder, using your own 16-bit 2-to-1 multiplexer.\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nConnect the modules together as shown in the diagram below. The provided module add16 has the following declaration: module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire sel; wire [15:0] wire0, wire1; add16 (a[15: 0], b[15: 0], 1\u0026#39;b0, sum[15:0], sel); add16 (a[31:16], b[31:16], 1\u0026#39;b0, wire0, ); add16 (a[31:16], b[31:16], 1\u0026#39;b1, wire1, ); // selector always@(*) begin case(sel) 1\u0026#39;b0: sum[31:16] = wire0; 1\u0026#39;b1: sum[31:16] = wire1; endcase end // ternary operator // assign sum[31:16] = sel ? wire1 : wire0; endmodule module_Adder-Subtractor An adder-subtractor can be built from an adder by optionally negating one of the inputs, which is equivalent to inverting the input then adding 1. The net result is a circuit that can do two operations: (a + b + 0) and (a + ~b + 1). Build the adder-subtractor below. You are provided with a 16-bit adder module, which you need to instantiate twice:\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nUse a 32-bit wide XOR gate to invert the b input whenever sub is 1. (This can also be viewed as b[31:0] XORed with sub replicated 32 times. See replication operator.). Also connect the sub input to the carry-in of the adder. module top_module( input [31:0] a, input [31:0] b, input sub, output [31:0] sum ); wire cout; wire [31:0] bin; assign bin = {32{sub}} ^ b; add16 (a[15: 0], bin[15: 0], sub, sum[15: 0], cout); add16 (a[31:16], bin[31:16], cout, sum[31:16], ); endmodule 2.4 Procedures Alwaysblock For synthesizing hardware, two types of always blocks are relevant: Combinational: always @(*) Clocked: always @(posedge clk) Combinational always blocks are equivalent to assign statements, thus there is always a way to express a combinational circuit both ways. The choice between which to use is mainly an issue of which syntax is more convenient. The syntax for code inside a procedural block is different from code that is outside. Procedural blocks have a richer set of statements (e.g., if-then, case), cannot contain continuous assignments*, but also introduces many new non-intuitive ways of making errors. (*Procedural continuous assignments do exist, but are somewhat different from continuous assignments, and are not synthesizable.) For combinational always blocks, always use a sensitivity list of (*). Explicitly listing out the signals is error-prone (if you miss one), and is ignored for hardware synthesis. If you explicitly specify the sensitivity list and miss a signal, the synthesized hardware will still behave as though (*) was specified, but the simulation will not and not match the hardware\u0026rsquo;s behaviour. (In SystemVerilog, use always_comb.) A note on wire vs. reg: The left-hand-side of an assign statement must be a net type (e.g., wire), while the left-hand-side of a procedural assignment (in an always block) must be a variable type (e.g., reg). These types (wire vs. reg) have nothing to do with what hardware is synthesized, and is just syntax left over from Verilog\u0026rsquo;s use as a hardware simulation language. Build an AND gate using both an assign statement and a combinational always block. module top_module( input a, input b, output wire out_assign, output reg out_alwaysblock ); assign out_assign = a \u0026amp; b; always @(*) begin out_alwaysblock = a \u0026amp; b; end endmodule Clocked Clocked always blocks create a blob of combinational logic just like combinational always blocks, but also creates a set of flip-flops (or \u0026ldquo;registers\u0026rdquo;) at the output of the blob of combinational logic. Instead of the outputs of the blob of logic being visible immediately, the outputs are visible only immediately after the next (posedge clk). Blocking vs. Non-Backing Assignment\nThere are three types of assignments in Verilog:\nContinuous assignments (assign x = y;): Can only be used when not inside a procedure (\u0026ldquo;always block\u0026rdquo;). Procedural blocking assignment (x = y;): Can only be used inside a procedure. Procedural non-blocking assignment (x \u0026lt;= y;): Can only be used inside a procedure. In a combinational always block, use blocking assignments. In a clocked always block, used non-blocking assignments. A full understanding of why is not particularly usedful for hardware design and requires a good understanding of how Verilog simulators keep track of events. Not following this rule results in extremely hard to find errors that are both non-deterministic and differ between simulation and synthesized hardware.\nBuild an XOR gate three ways, using an assignment, a combinational always block, and a clocked always block. Note that the clocked always block precedures a different circuit from the other two: There is a flip-flop so the output is delayed. module top_module( input clk, input a, input b, output wire out_assign, output reg out_always_comb, output reg out_always_ff ); assign out_assign = a ^ b; always @(*) begin out_always_comb = a ^ b; end always @(posedge clk) begin out_always_ff \u0026lt;= a ^ b; end endmodule If statement An if statement usually creates a 2-to-1 multiplexer, selecting one input if the condition is true, and the other input if the condition is false. always @(*) begin if (condition) begin out = x; end else begin out = y; end end This is equivalent to using a continuous assignment with a conditional operator:\nassign out = (condition) ? x : y;\nHowever, the procedural if statement provides a new way to make mistakes. The circuit is combinational only if out is always assigned a value.\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement. \\(\\begin{array}{|c|c|c|}\\hline \\text{sel\\_b1}\u0026amp;\\text{sel\\_b2}\u0026amp;\\text{out\\_assign, out\\_always} \\\\\\hline 0\u0026amp;0\u0026amp;a\\\\\\hline 0\u0026amp;1\u0026amp;a\\\\\\hline 1\u0026amp;0\u0026amp;a\\\\\\hline 1\u0026amp;1\u0026amp;b\\\\\\hline \\end{array\nmodule top_module( input a, input b, input sel_b1, input sel_b2, output wire out_assign, output reg out_always ); assign out_assign = sel_b1 \u0026amp; sel_b2 ? b : a; always @(*) begin if (sel_b1 \u0026amp; sel_b2) begin out_always = b; end else begin out_always = a; end end // always @(*) begin // case ({sel_b1, sel_b2}) //\t2\u0026#39;d0:begin //\tout_always = a; // end // 2\u0026#39;d1:begin //\tout_always = a; // end // 2\u0026#39;d2:begin //\tout_always = a; // end // 2\u0026#39;d3:begin //\tout_always = b; // end // endcase // end endmodule If statement latches A common source of errors: How to avoid making latches\nWhen designing circuits, you must think first in terms of circuits:\nI want this logic gate I want a combinational blob of logic that has these inputs and produces these outputs I want a combinational blob of logic followed by a set of flip-flops What you must not do is write the code first, then hope it generates a proper circuit.\nIf (cpu_overheated) then shut_off_computer = 1; If (~arrived) then keep_driving = ~gas_tank_empty; Syntactically-correct code does not necessarily result in a reasonable circuit (combinational logic + flip-flops). The usual reason is: \u0026ldquo;What happens in the cases other than those you specified?\u0026rdquo;. Verilog\u0026rsquo;s answer is: Keep the outputs unchanged.\nThis behaviour of \u0026ldquo;keep outputs unchanged\u0026rdquo; means the current state needs to be remembered, and thus produces a latch. Combinational logic (e.g., logic gates) cannot remember any state. Watch out for Warning (10240): \u0026hellip; inferring latch(es)\u0026quot; messages. Unless the latch was intentional, it almost always indicates a bug. Combinational circuits must have a value assigned to all outputs under all conditions. This usually means you always need else clauses or a default value assigned to the outputs.\nDemonstration\nThe following code contains incorrect behaviour that creates a latch. Fix the bugs so that you will shut off the computer only if it\u0026rsquo;s really overheated, and stop driving if you\u0026rsquo;ve arrived at your destination or you need to refuel. always @(*) begin if (cpu_overheated) shut_off_computer = 1; end always @(*) begin if (~arrived) keep_driving = ~gas_tank_empty; end module top_module ( input cpu_overheated, output reg shut_off_computer, input arrived, input gas_tank_empty, output reg keep_driving ); // always @(*) begin if (cpu_overheated) shut_off_computer = 1; else shut_off_computer = 0; end always @(*) begin if (~arrived) keep_driving = ~gas_tank_empty; else keep_driving = 0; end endmodule Case statement Case statements in Verilog are nearly equivalent to a sequence of if-elseif-else that compares one expression to a list of others. Its syntax and functionality differs from the switch statement in C. always @(*) begin // This is a combinational circuit case (in) 1\u0026#39;b1: begin out = 1\u0026#39;b1; // begin-end if \u0026gt;1 statement end 1\u0026#39;b0: out = 1\u0026#39;b0; default: out = 1\u0026#39;bx; endcase end The case statement begins with case and each \u0026ldquo;case item\u0026rdquo; ends with a colon. There is no \u0026ldquo;switch\u0026rdquo;. Each case item can execute exactly one statement. This makes the \u0026ldquo;break\u0026rdquo; used in C unnecessary. But this means that if + you need more than one statement, you must use begin ... end.\nDuplicate (and partially overlapping) case items are permitted. The first one that matches is used. C does not allow duplicate case items.\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide. Be careful of inferring latches.\n// synthesis verilog_input_version verilog_2001 module top_module ( input [2:0] sel, input [3:0] data0, input [3:0] data1, input [3:0] data2, input [3:0] data3, input [3:0] data4, input [3:0] data5, output reg [3:0] out ); always @(*) begin case(sel) 0: out = data0; 1: out = data1; 2: out = data2; 3: out = data3; 4: out = data4; 5: out = data5; default: out = 0; endcase end endmodule Priority encoder A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3\u0026rsquo;d4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations. module top_module ( input [3:0] in, output reg [1:0] pos ); always @(*) begin case (in) 4\u0026#39;h0: pos = 2\u0026#39;h0; //0000 4\u0026#39;h1: pos = 2\u0026#39;h0; //0001 4\u0026#39;h2: pos = 2\u0026#39;h1; //0010 4\u0026#39;h3: pos = 2\u0026#39;h0; //0011 4\u0026#39;h4: pos = 2\u0026#39;h2; //0100 4\u0026#39;h5: pos = 2\u0026#39;h0; //0101 4\u0026#39;h6: pos = 2\u0026#39;h1; //0110 4\u0026#39;h7: pos = 2\u0026#39;h0; //0111 4\u0026#39;h8: pos = 2\u0026#39;h3; //1000 4\u0026#39;h9: pos = 2\u0026#39;h0; //1001 4\u0026#39;ha: pos = 2\u0026#39;h1; //1010 4\u0026#39;hb: pos = 2\u0026#39;h0; //1011 4\u0026#39;hc: pos = 2\u0026#39;h2; //1100 4\u0026#39;hd: pos = 2\u0026#39;h0; //1101 4\u0026#39;he: pos = 2\u0026#39;h1; //1110 4\u0026#39;hf: pos = 2\u0026#39;h0; //1111 default: pos = 2\u0026#39;b0; endcase end endmodule Priority encoder with casez Build previous problem with casez. If the case items in the case statement supported con\u0026rsquo;t care bits. This is what casez is for: It treats bits that have the value z as don\u0026rsquo;t care in the comparison. A case statement behaves as though each item is checked sequentially (in reality, a big combinational logic function). Notice how there are certain inputs (e.g., 4\u0026rsquo;b1111) that will match more than one case item. The first match is chosen (so 4\u0026rsquo;b1111 matches the first item, out = 0, but not any of the later ones). There is also a similar casex that treats both x and z as don\u0026rsquo;t-care. I don\u0026rsquo;t see much purpose to using it over casez. The digit ? is a synonym for z. so 2\u0026rsquo;bz0 is the same as 2\u0026rsquo;b?0 It may be less error-prone to explicitly specify the priority behaviour rather than rely on the ordering of the case items. For example, the following will still behave the same way if some of the case items were reordered, because any bit pattern can only match at most one case item: module top_module ( input [7:0] in, output reg [2:0] pos ); always @(*) begin casez(in) 8\u0026#39;bzzzzzzz1: pos = 3\u0026#39;d0; 8\u0026#39;bzzzzzz10: pos = 3\u0026#39;d1; 8\u0026#39;bzzzzz100: pos = 3\u0026#39;d2; 8\u0026#39;bzzzz1000: pos = 3\u0026#39;d3; 8\u0026#39;bzzz10000: pos = 3\u0026#39;d4; 8\u0026#39;bzz100000: pos = 3\u0026#39;d5; 8\u0026#39;bz1000000: pos = 3\u0026#39;d6; 8\u0026#39;b10000000: pos = 3\u0026#39;d7; default: pos = 2\u0026#39;d0; endcase end endmodule Avoiding latches Suppose you\u0026rsquo;re building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n\\(\\begin{array}{|c|c|}\\hline \\text{Scancode [15:0]}\u0026amp;\\text{Arrow key}\\\\\\hline \\text{16\u0026rsquo;he06b}\u0026amp;\\text{left arrow}\\\\\\hline \\text{16\u0026rsquo;he072}\u0026amp;\\text{down arrow}\\\\\\hline \\text{16\u0026rsquo;he074}\u0026amp;\\text{right arrow}\\\\\\hline \\text{16\u0026rsquo;he075}\u0026amp;\\text{up arrow}\\\\\\hline \\text{Anything else}\u0026amp;\\text{none}\\\\\\hline \\end{array Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output. To avoid creating latches, all outputs must be assigned a value in all possible conditions. Simply having a default case is not enough. You must assign a value to all four outputs in all four cases and the default case. This can involve a lot of unnecessary typing. One easy way around this is to assign a \u0026ldquo;default value\u0026rdquo; to the outputs before the case statement: always @(*) begin up = 1\u0026#39;b0; down = 1\u0026#39;b0; left = 1\u0026#39;b0; right = 1\u0026#39;b0; case (scancode) ... // Set to 1 as necessary. endcase end This style of code ensures the outputs are assigned a value (of 0) in all possible cases unless the case statement overrides the assignment. This also means that a default: case item becomes unnecessary. Reminder: The logic synthesizer generates a combinational circuit that behaves equivalently to what the code describes.Hardware does not \u0026ldquo;execute\u0026rdquo; the lines of code in sequence. module top_module ( input [15:0] scancode, output reg left, output reg down, output reg right, output reg up ); always @(*) begin left = 0; down = 0; right = 0; up = 0; case(scancode) 16\u0026#39;he06b: left = 1; 16\u0026#39;he072: down = 1; 16\u0026#39;he074: right = 1; 16\u0026#39;he075: up = 1; endcase end endmodule 2.5 More Verilog Features Conditional ternary operator Verilog has a ternary conditional operator ( ? : ) much like C: (condition ? if_true : if_false) Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a \u0026lt; b). Use the conditional operator to make two-way min circuits, then compose a few of them to create a 4-way min circuit. You\u0026rsquo;ll probably want some wire vectors for the intermediate results. module top_module ( input [7:0] a, b, c, d, output [7:0] min);// wire [7:0] wire1; wire [7:0] wire2; assign wire1 = a \u0026gt; b ? b : a; assign wire2 = c \u0026gt; d ? d : c; assign min = wire1 \u0026gt; wire2 ? wire2 : wire1; endmodule Reduction operators Some syntactic sugar for reduction: \u0026amp; a[3:0] // AND: a[3] \u0026amp; a[2] \u0026amp; a[1] \u0026amp; a[0]. Equivalent to (a[3:0] == 4\u0026#39;hf) | b[3:0] // OR: b[3] | b[2] | b[1] | b[0]. Equivalent to (b[3:0] != 4\u0026#39;h0) ^ c[2:0] // XOR: c[2] ^ c[1] ^ c[0] Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \u0026ldquo;even\u0026rdquo; parity, where the parity bit is just the XOR of all 8 data bits. module top_module ( input [7:0] in, output parity); assign parity = ^ in; endmodule Reduction: Even wider gates Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: out_and: output of a 100-input AND gate. out_or: output of a 100-input OR gate. out_xor: output of a 100-input XOR gate. module top_module( input [99:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026amp; in; assign out_or = | in; assign out_xor = ^ in; endmodule Combinational for-loop: Vector reversal Given a 100-bit input vector [99:0], reverse its bit ordering. module top_module( input [99:0] in, output [99:0] out ); always @(*) begin for (int i = 0; i \u0026lt; 100; i++) begin out[i] = in[99 - i]; end end endmodule Combinational for-loop: 255-bit population count A \u0026ldquo;population count\u0026rdquo; circuit counts the number of \u0026lsquo;1\u0026rsquo;s in an input vector. Build a population count circuit for a 255-bit input vector. module top_module( input [254:0] in, output [7:0] out ); always @(*) begin out = 0; for (int i = 0; i \u0026lt; 255; i++) begin out += in[i]; end end endmodule Generate for-loop: 100-bit binary adder Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see. module top_module( input [99:0] a, b, input cin, output [99:0] cout, output [99:0] sum ); always @(*) begin {cout[0], sum[0]} = a[0] + b[0] + cin; for (int i = 1; i \u0026lt; 100; i++) begin {cout[i], sum[i]} = a[i] + b[i] + cout[i-1]; end end endmodule Generate for-loop: 100-digit BCD adder You are provided with a BCD one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out. module bcd_fadd ( input [3:0] a, input [3:0] b, input cin, output cout, output [3:0] sum ); Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) and a carry-in to produce a 100-digit sum and carry out. module top_module( input [399:0] a, b, input cin, output cout, output [399:0] sum ); wire[99:0] carryin; generate genvar i; bcd_fadd(a[3:0], b[3:0], cin, carryin[0], sum[3:0]); for (i = 4; i \u0026lt; 400; i += 4) begin:adder bcd_fadd(a[i+3:i], b[i+3:i], carryin[i/4-1], carryin[i/4], sum[i+3:i]); end assign cout = carryin[99]; endgenerate endmodule ","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits2/","summary":"1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n2 Verilog Language 2.1 Basics wire Create a module with one input and ont output that behaves like a wire module top_module( input in, output out); assign out = in; endmodule multi-in-out Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: module top_module( input a,b,c, output w,x,y,z ); assign w = a; assign x = b; assign y = b; assign z = c; endmodule not gate Create a module that implements a NOT gate.","title":"[VHDL] HDLbits 2 - Verilog Language"},{"content":"1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n3 Circuits 3.1 Combinational Logic 3.1.1 Basic Gates Wire module top_module ( input in, output out); assign out = in; endmodule GND module top_module ( output out); assign out = 1\u0026#39;b0; endmodule NOR module top_module ( input in1, input in2, output out); assign out = ~(in1|in2); endmodule Another Gate module top_module ( input in1, input in2, output out); assign out = in1 \u0026amp; (~in2); endmodule Two gates module top_module ( input in1, input in2, input in3, output out); wire w1; assign w1 = ~(in1^in2); assign out = w1^in3; endmodule More logic gates module top_module( input a, b, output out_and, output out_or, output out_xor, output out_nand, output out_nor, output out_xnor, output out_anotb ); assign out_and = a \u0026amp; b; assign out_or = a | b; assign out_xor = a ^ b; assign out_nand = ~(a \u0026amp; b); assign out_nor = ~(a | b); assign out_xnor = ~(a ^ b); assign out_anotb = a \u0026amp; (~b); // and(out_and, a, b); // or(out_or, a, b); // xor(out_xor, a, b); // nand(out_nand, a, b); // nor(out_nor, a, b); // xnor(out_xnor, a, b); // and(out_anotb, a , ~b); endmodule 7420 chip module top_module ( input p1a, p1b, p1c, p1d, output p1y, input p2a, p2b, p2c, p2d, output p2y ); assign p1y = ~(p1a \u0026amp; p1b \u0026amp; p1c \u0026amp; p1d); assign p2y = ~(p2a \u0026amp; p2b \u0026amp; p2c \u0026amp; p2d); endmodule\\ Truth tables \\(\\begin{array}{|c|ccc|c|}\\hline \\text{Row}\u0026amp;\u0026amp;\\text{Inputs}\u0026amp;\u0026amp;\\text{Outputs}\\\\\\hline \\text{number}\u0026amp;\\text{x3}\u0026amp;\\text{x2}\u0026amp;\\text{x1}\u0026amp;\\text{f}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\\\hline 2\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 3\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline 4\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 5\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 6\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\hline 7\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array module top_module( input x3, input x2, input x1, output f ); assign f = ((~x3)\u0026amp;x2)|(x3\u0026amp;x1); endmodule Two-bit equality Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0. module top_module ( input [1:0] A, input [1:0] B, output z ); assign z = (A == B); endmodule Simple circuit A module top_module (input x, input y, output z); assign z = (x^y) \u0026amp;x; endmodule Simple circuit B module top_module ( input x, input y, output z ); assign z = (x==y); // assign z = ~(x ^ y); endmodule Combine circuits A and B module top_module (input x, input y, output z); wire o1, o2, o3, o4; A ia1(x,y,o1); B ib1(x,y,o2); A ia2(x,y,o3); B ib2(x,y,o4); assign z = (o1|o2)^(o3\u0026amp;o4); endmodule module A( input x, y, output z); assign z = (x ^ y) \u0026amp; x; endmodule module B( input x, y, output z); assign z = x ~^ y; endmodule Ringer Suppose you are designing a circuit to control a cellphone\u0026rsquo;s ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates. Design hint: When designing circuits, one often has to think of the problem \u0026ldquo;backwards\u0026rdquo;, starting from the outputs then working backwards towards the inputs. This is often the opposite of how one would think about a (sequential, imperative) programming problem, where one would look at the inputs first then decide on an action (or output). For sequential programs, one would often think \u0026ldquo;If (inputs are ___ ) then (output should be ___ )\u0026rdquo;. On the other hand, hardware designers often think \u0026ldquo;The (output should be ___ ) when (inputs are ___ )\u0026rdquo;. The above problem description is written in an imperative form suitable for software programming (if ring then do this), so you must convert it to a more declarative form suitable for hardware implementation (assign ringer = ___). Being able to think in, and translate between, both styles is one of the most important skills needed for hardware design. module top_module ( input ring, input vibrate_mode, output ringer, // Make sound output motor // Vibrate ); assign ringer = ring \u0026amp; (~vibrate_mode); assign motor = ring \u0026amp; (vibrate_mode); endmodule Thermostat A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates. 畫出真值表\n\\(\\begin{array}{|cccc|ccc|}\\hline \\text{mode}\u0026amp;\\text{too\\_cold}\u0026amp;\\text{too\\_hot}\u0026amp;\\text{fan on}\u0026amp;\\text{heater}\u0026amp;\\text{aircon}\u0026amp;\\text{fan}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline \\end{array}\\) module top_module ( input too_cold, input too_hot, input mode, input fan_on, output heater, output aircon, output fan); assign heater = mode \u0026amp; too_cold; assign aircon = (~mode) \u0026amp; too_hot; assign fan = heater|aircon|fan_on; endmodule 3-bit population count A \u0026ldquo;population count\u0026rdquo; circuit counts the number of \u0026lsquo;1\u0026rsquo;s in an input vector. Build a population count circuit for a 3-bit input vector. module top_module( input [2:0] in, output [1:0] out ); always @(*) begin out = 0; for (int i = 0; i \u0026lt;= 2; i++) begin out += in[i]; end end endmodule 此解會產生鎖存器，不建議使用。 Gates and vectors You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are \u0026lsquo;1\u0026rsquo;. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don\u0026rsquo;t need to know out_both[3]. out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are \u0026lsquo;1\u0026rsquo;. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don\u0026rsquo;t need to know out_any[0]. out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]\u0026rsquo;s neighbour to the left is in[0]. module top_module( input [3:0] in, output [2:0] out_both, output [3:1] out_any, output [3:0] out_different ); assign out_both[2:0] = in[2:0] \u0026amp; in[3:1]; assign out_any[3:1] = in[3:1] | in[2:0]; assign out_different[3:0] = in[3:0] ^ {in[0], in[3:1]}; // always @(*) begin // out_different[3] = (in[3] != in[0]); // for (int i = 0; i \u0026lt;= 2; i++) begin // out_both[i] = in[i] \u0026amp; in[i+1]; // out_any[i+1] = in[i+1] | in[i]; // out_different[i] = (in[i] != in[i+1]); // end // end endmodule Even longer vectors You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are \u0026lsquo;1\u0026rsquo;. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don\u0026rsquo;t need to know out_both[99]. out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are \u0026lsquo;1\u0026rsquo;. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don\u0026rsquo;t need to know out_any[0]. out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]\u0026rsquo;s neighbour to the left is in[0]. module top_module( input [99:0] in, output [98:0] out_both, output [99:1] out_any, output [99:0] out_different ); assign out_both[98:0] = in[98:0] \u0026amp; in[99:1]; assign out_any[99:1] = in[99:1] | in[98:0]; assign out_different[99:0] = in[99:0] ^ {in[0], in[99:1]}; endmodule 3.1.2 Multiplexers 2-to-1 multiplexer Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b. module top_module( input a, b, sel, output out ); assign out = sel ? b : a; endmodule 2-to-1 bus multiplexer Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b. module top_module( input [99:0] a, b, input sel, output [99:0] out ); assign out = sel ? b : a; endmodule 9-to-1 multiplexer Create a 16-bit 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to \u0026lsquo;1\u0026rsquo;. module top_module( input [15:0] a, b, c, d, e, f, g, h, i, input [3:0] sel, output [15:0] out ); always @(*) begin case(sel) 4\u0026#39;d0: out = a; 4\u0026#39;d1: out = b; 4\u0026#39;d2: out = c; 4\u0026#39;d3: out = d; 4\u0026#39;d4: out = e; 4\u0026#39;d5: out = f; 4\u0026#39;d6: out = g; 4\u0026#39;d7: out = h; 4\u0026#39;d8: out = i; default: out = \u0026#39;1; // special literal syntax with all bits set to 1 endcase end endmodule 256-to-1 multiplexer Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should be select in[0], sel1 selectes bits in[1], sel=2 selects bits in[2], etc. module top_module( input [255:0] in, input [7:0] sel, output out ); assign out = in[sel]; endmodule 256-to-1 4-bit multiplexer Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0],sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc. module top_module( input [1023:0] in, input [7:0] sel, output [3:0] out ); assign out = in[sel*4+:4]; // special syntax // assign out = in[sel*4+3-:4]; // assign out = {in[sel*4+3],in[sel*4+2],in[sel*4+1],in[sel*4+0]}; endmodule 3.1.3 Arithmetic Circuits Half adder Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out. module top_module( input a, b, output cout, sum ); assign {cout, sum} = a + b; endmodule Full adder Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and a carry-out. module top_module( input a, b, cin, output cout, sum ); assign {cout, sum} = a + b + cin; endmodule 3-bit binary adder Now that you know how to build a full adder, make 3 instances of it to create a 3-bit binary ripple-carry adder. The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last full adder, and is the carry-out you usually see. module top_module( input [2:0] a, b, input cin, output [2:0] cout, output [2:0] sum ); fulladder f1(a[0], b[0], cin, cout[0], sum[0]); fulladder f2(a[1], b[1], cout[0], cout[1], sum[1]); fulladder f3(a[2], b[2], cout[1], cout[2], sum[2]); endmodule module fulladder( input a, b, cin, output cout, sum); assign {cout, sum} = a + b + cin; endmodule Adder Implement the following circuit: module top_module ( input [3:0] x, input [3:0] y, output [4:0] sum); // assign sum = x + y; wire [2:0] cout; FA f1(x[0], y[0], 0, cout[0], sum[0]); FA f2(x[1], y[1], cout[0], cout[1], sum[1]); FA f3(x[2], y[2], cout[1], cout[2], sum[2]); FA f4(x[3], y[3], cout[2], sum[4], sum[3]); endmodule module FA ( input a, b, cin, output cout, sum); assign {cout, sum} = a + b + cin; endmodule Signed addition overflow Assume that you have two 8-bit 2\u0026rsquo;s complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred. module top_module ( input [7:0] a, input [7:0] b, output [7:0] s, output overflow ); assign s = a + b; assign overflow = (a[7] == b[7] \u0026amp;\u0026amp; a[7] != s[7]) ? 1 : 0; endmodule 100-bit binary adder Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. module top_module( input [99:0] a, b, input cin, output cout, output [99:0] sum); assign {cout, sum} = cin + a + b; endmodule 4-digit BCD adder You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out. module bcd_fadd ( input [3:0] a, input [3:0] b, input cin, output cout, output [3:0] sum ); Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.\nmodule top_module ( input [15:0] a, b, input cin, output cout, output [15:0] sum ); wire [2:0] wl; bcd_fadd u0 (a[ 3: 0], b[ 3: 0], cin, wl[0], sum[ 3: 0]); bcd_fadd u1 (a[ 7: 4], b[ 7: 4], wl[0], wl[1], sum[ 7: 4]); bcd_fadd u2 (a[11: 8], b[11: 8], wl[1], wl[2], sum[11: 8]); bcd_fadd u3 (a[15:12], b[15:12], wl[2], cout, sum[15:12]); endmodule 3.1.4 Karnaugh Map to Circuit Kmap1 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, output out ); assign out = a | b | c; endmodule Kmap2 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); // a\u0026#39;d\u0026#39; + b\u0026#39;c\u0026#39; + acd + a\u0026#39;bc wire w1, w2, w3, w4; assign w1 = (~a)\u0026amp;(~d); assign w2 = (~b)\u0026amp;(~c); assign w3 = a\u0026amp;c\u0026amp;d; assign w4 = (~a)\u0026amp;b\u0026amp;c; assign out = w1|w2|w3|w4; endmodule Kmap3 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); // a + b\u0026#39;c assign out = a | (~b\u0026amp;c); endmodule Kmap4 Implement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); always @(*) begin if (a == b \u0026amp;\u0026amp; c != d) out = 1; else if (a != b \u0026amp;\u0026amp; c == d) out = 1; else out = 0; end endmodule Minimum SOP and POS A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form. module top_module ( input a, input b, input c, input d, output out_sop, output out_pos ); // f = d3 + m7 + d11 + m15 + m2 // f = cd + a\u0026#39;b\u0026#39;c assign out_sop = (c \u0026amp; d) | (~a \u0026amp; ~b \u0026amp; c); // f\u0026#39; = m0 + m1 + m4 + m5 + m6 + d8 + m9 + m10 + d11 + d12 + m13 + m14 // f\u0026#39; = c\u0026#39; + ab\u0026#39; + bd\u0026#39; // f = (c)(a\u0026#39;+b)(b\u0026#39;+d) assign out_pos = c \u0026amp; (~a | b) \u0026amp; (~b | d); endmodule Karnaugh map Consider the function f shown in the Karnaugh map below. Implement this function. d is don\u0026rsquo;t-care, which means you may choose to output whatever value is convenient. module top_module ( input [4:1] x, output f ); // x[2]x[4] + x[1]\u0026#39;x[3] assign f = (x[2] \u0026amp; x[4]) | (~x[1] \u0026amp; x[3]); endmodule Karnaugh map Consider the function f shown in the Karnaugh map below. Implement this function. (The original exam question asked for simplified SOP and POS forms of the function.) module top_module ( input [4:1] x, output f ); // x[2]\u0026#39;x[4]\u0026#39; + x[1]\u0026#39;x[3] + x[2]x[3]x[4] assign f = (~x[2] \u0026amp; ~x[4]) | (~x[1] \u0026amp; x[3]) | (x[2] \u0026amp; x[3] \u0026amp; x[4]); endmodule K-map implemented with a multiplexer For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below. You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map. (The requirement to use only 2-to-1 multiplexers exists because the original exam question also wanted to test logic function simplification using K-maps and how to synthesize logic functions using only multiplexers. If you wish to treat this as purely a Verilog exercise, you may ignore this constraint and write the module any way you wish.) module top_module ( input c, input d, output [3:0] mux_in ); assign mux_in[0] = c|d; // 0111 assign mux_in[1] = 1\u0026#39;b0; // 0000 assign mux_in[2] = ~d; // 1001 assign mux_in[3] = c\u0026amp;d; // 0010 endmodule 3.2 Sequential Logic 3.2.1 Latches and Flip-Flops D flip-flop A D flip-flop is a circuit that stores a bit and is updated periodically, at the (usually) positive edge of a clock signal. D flip-flops are created by the logic synthesizer when a clocked always block is used (See alwaysblock2). A D + flip-flop is the simplest form of \u0026ldquo;blob of combinational logic followed by a flip-flop\u0026rdquo; where the combinational logic portion is just a wire. Create a single D flip-flop. module top_module ( input clk, // Clocks are used in sequential circuits input d, output reg q ); always @(posedge clk) begin q \u0026lt;= d; end endmodule D flip-flops Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input [7:0] d, output [7:0] q ); always @(posedge clk) begin q \u0026lt;= d; end endmodule DFF with reset Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input reset, // Synchronous reset input [7:0] d, output [7:0] q ); always @(posedge clk) begin if (reset) begin q \u0026lt;= 8\u0026#39;b0; end else begin q \u0026lt;= d; end end endmodule DFF with reset value Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk. module top_module ( input clk, input reset, input [7:0] d, output [7:0] q ); always @(negedge clk) begin if (reset) begin q \u0026lt;= 8\u0026#39;h34; end else begin q \u0026lt;= d; end end endmodule DFF with asynchronous reset Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input areset, // active high asynchronous reset input [7:0] d, output [7:0] q ); always @(posedge clk or posedge areset) if (areset) q \u0026lt;= 0; else q \u0026lt;= d; endmodule In Verilog, the sensity list looks strange. The FF\u0026rsquo;s reset is sensitive to the level of areset, so why does using \u0026ldquo;posedge areset\u0026rdquo; work? To see why it works, consider the truth table for all events that change the input signals, assuming clk and areset do not swith at precisely the same time.\n\\(\\begin{array}{|c|c|c|l|}\\hline \\text{clk}\u0026amp;\\text{areset}\u0026amp;\\text{output}\u0026amp;\\text{comment}\\\\\\hline \\text{x}\u0026amp;\\text{0}\\rightarrow\\text{1}\u0026amp;\\text{q}\\leftarrow{0;}\u0026amp;\\text{because areset = 1}\\\\\\hline \\text{x}\u0026amp;\\text{1}\\rightarrow\\text{0}\u0026amp;\\text{no change}\u0026amp;\\text{always block not triggered}\\\\\\hline \\text{0}\\rightarrow\\text{1}\u0026amp;\\text{0}\u0026amp;\\text{q}\\leftarrow{d;}\u0026amp;\\text{not resetting}\\\\\\hline \\text{0}\\rightarrow\\text{1}\u0026amp;\\text{1}\u0026amp;\\text{q}\\leftarrow{0;}\u0026amp;\\text{still resetting, q was 0 before too}\\\\\\hline \\text{1}\\rightarrow\\text{0}\u0026amp;\\text{x}\u0026amp;\\text{no change}\u0026amp;\\text{always block not triggered}\\\\\\hline \\end{array}\\) DFF with byte enable Create 16 D flip-flops. It\u0026rsquo;s sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk. module top_module ( input clk, input resetn, input [1:0] byteena, input [15:0] d, output [15:0] q ); always @(posedge clk) begin if (resetn == 1\u0026#39;b0) begin q \u0026lt;= 16\u0026#39;d0; end else begin case(byteena) 0: q \u0026lt;= q; 1: q \u0026lt;= {q[15:8], d[7:0]}; 2: q \u0026lt;= {d[15:8], q[7:0]}; 3: q \u0026lt;= d; endcase end end endmodule D Latch Implement the following circuit: Note that this is a latch, so a Quartus warning about hvaing inferred a latch is expected. 對於組合邏輯，if 若沒有補全 else，case 條件不完全，可能會產生 latch。但是如果中間的信號有初值，就不會產生 latch。所以要盡量避免 latch 的產生，避免對時序的危害很大。 module top_module ( input d, input ena, output q); always @(*) begin if (ena == 1\u0026#39;b1) q = d; end endmodule DFFAR Implement the following circuit: module top_module ( input clk, input d, input ar, // asynchronous reset output q); always@(posedge clk or posedge ar) begin if (ar == 1) q \u0026lt;= 0; else q \u0026lt;= d; end endmodule DFFR Implement the following circuit: module top_module ( input clk, input d, input r, // synchronous reset output q); always@(posedge clk) begin if (r == 1) begin q \u0026lt;= 0; end else begin q \u0026lt;= d; end end endmodule DFF+gate Implement the following circuit: module top_module ( input clk, input in, output reg out); always@(posedge clk) begin out \u0026lt;= out ^ in; end endmodule 注意 output 需為 reg 型別。 Mux and DFF Consider the sequential circuit below: Assume that you want to implement hierarchical Verilog code for this circuit, using three instantiations of a submodule that has a flip-flop and multiplexer in it. Write a Verilog module (containing one flip-flop and multiplexer) named top_module for this submodule. module top_module ( input clk, input L, input r_in, input q_in, output reg Q); always@(posedge clk) begin if (L) Q \u0026lt;= r_in; else Q \u0026lt;= q_in; end endmodule Mux and DFF DFF+gate Mux and DFF Mux and DFF DFFs and gates Create circuit from truth table Detect an edge Detect both edges Edge capture register Dual-edge triggered flip-flop 3.2.2 Counters 3.2.3 Shift Registers 3.2.4 More Circuits 3.2.5 Finite State Machines 3.3 Building Larger Circuits ","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits3/","summary":"1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n3 Circuits 3.1 Combinational Logic 3.1.1 Basic Gates Wire module top_module ( input in, output out); assign out = in; endmodule GND module top_module ( output out); assign out = 1\u0026#39;b0; endmodule NOR module top_module ( input in1, input in2, output out); assign out = ~(in1|in2); endmodule Another Gate module top_module ( input in1, input in2, output out); assign out = in1 \u0026amp; (~in2); endmodule Two gates module top_module ( input in1, input in2, input in3, output out); wire w1; assign w1 = ~(in1^in2); assign out = w1^in3; endmodule More logic gates module top_module( input a, b, output out_and, output out_or, output out_xor, output out_nand, output out_nor, output out_xnor, output out_anotb ); assign out_and = a \u0026amp; b; assign out_or = a | b; assign out_xor = a ^ b; assign out_nand = ~(a \u0026amp; b); assign out_nor = ~(a | b); assign out_xnor = ~(a ^ b); assign out_anotb = a \u0026amp; (~b); // and(out_and, a, b); // or(out_or, a, b); // xor(out_xor, a, b); // nand(out_nand, a, b); // nor(out_nor, a, b); // xnor(out_xnor, a, b); // and(out_anotb, a , ~b); endmodule 7420 chip module top_module ( input p1a, p1b, p1c, p1d, output p1y, input p2a, p2b, p2c, p2d, output p2y ); assign p1y = ~(p1a \u0026amp; p1b \u0026amp; p1c \u0026amp; p1d); assign p2y = ~(p2a \u0026amp; p2b \u0026amp; p2c \u0026amp; p2d); endmodule\\ Truth tables \\(\\begin{array}{|c|ccc|c|}\\hline \\text{Row}\u0026amp;\u0026amp;\\text{Inputs}\u0026amp;\u0026amp;\\text{Outputs}\\\\\\hline \\text{number}\u0026amp;\\text{x3}\u0026amp;\\text{x2}\u0026amp;\\text{x1}\u0026amp;\\text{f}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\\\hline 2\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\\\hline 3\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline 4\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 5\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\\\hline 6\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\hline 7\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array module top_module( input x3, input x2, input x1, output f ); assign f = ((~x3)\u0026amp;x2)|(x3\u0026amp;x1); endmodule Two-bit equality Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z.","title":"[VHDL] HDLbits 3 - Circuits"},{"content":"4 Verification - Reading Simulations 4.1 Finding bugs in code 4.2 Build a circuit from a simulation waveform 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits4/","summary":"4 Verification - Reading Simulations 4.1 Finding bugs in code 4.2 Build a circuit from a simulation waveform 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450","title":"[VHDL] HDLbits 4 - Verification: Reading Simulations"},{"content":"5 Verification - Writing Testbenches 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits5/","summary":"5 Verification - Writing Testbenches 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450","title":"[VHDL] HDLbits 5 - Verification: Writing Testbenches"},{"content":"6 CS450 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450\n","permalink":"http://intervalrain.github.io/posts/verilog/hdlbits6/","summary":"6 CS450 1. Getting Started\n2. Verilog Language\n3. Circuits\n4. Verification: Reading Simulations\n5. Verification: Writing Testbenches\n6. CS450","title":"[VHDL] HDLbits 6 - CS450"},{"content":"TCAD 模擬收斂問題 收斂問題 Sentaurus Device 有非常多種可模擬大電場下之飽和遷移率的模型，而這主要是設定有效電場的模型。其中，最自然的選擇就是 Eparallel driving model。這種模型取總電場平行於電流方向上的分量。不過這通常會導致嚴重的收斂問題。主要是因為電場跟電流有著極為密切的關係，除此之外，以 MOSFET 通道為例，通常垂直與平行通道方向之電場數量級差很多，因為演算之數值誤差會「混合」這兩個分量，所以這種 Eparallel 模型會使得每個節點上的 driving force變化許多，進而改變電流方向，又接著改變電場分量，所以會造成極為不穩定的情況。\n其中一個折衷的辦法，就是只考慮平行於 silicon-oxide 界面上的電場，可以使用 HighFieldSaturation(EparallelToInterface) 指令來啟動這模型。只要大部分的電流都平行於界面，那基本上這就是個很好的模型。然而，目前最新科技通常會使得 source/drain 的電流以「向外散開，向內吸入」的方式進入與離開。例如說目前的 ultrashalow source and drain extensions。電流散開之後，電流就不再平行於界面，而這模型可能會帶來將近 5-15 % 的誤差。因此，如果你知道電流的方向，那麼你也可以設定用來計算平行電場分量之方向向量，而不再只是單純地與最鄰近的界面平行的方向。例如說，如果你覺得電流主要是沿著 x 軸在流動，那麼可以在 Math section 設定 EparallelToInterface (Direction = (1 0 0))。\n最常用的 driving force 是 quasi-Fermi potential 的梯度模型。通常這跟平行電場模型是一樣的，但它的演算法比較穩定。可以用 HighFieldSaturation(GradQuasiFermi) 選項來啟動它。不過，即便如此，還是可能會造成收斂問題。這是因為通常 quasi-Fermi potential 的梯度都非常的陡峭，變化得太過劇烈或是非常的不平滑，而這往往切得比較不好的網格所造成的。\n但在有些時候，即便網格切得很好，還是沒辦法收斂。有時是因為低載子濃度的區域的濃度相對誤差都滿高的，而這會進一步導致 quasi-Fermi potential 的誤差變得滿大的。因為這些區域通常對總電流的貢獻並不是很顯著，所以算得太準反而會讓模擬跑得更慢。不過，你確實需要確認一下這些低密度是不是導致發散。\n除此之外，也可藉由設定 RefDens_eGradQuasiFermi_EparallelToInterface 與 RefDens_hGradQuasiFermi_EparallelToInterface 來使用「內插 GradQuasiFermi 與 Eparallel」的 driving force 模型。該參數定義了 gradual transition 發生的局域載子濃度。例如說，如果設定為 1e12，那麼當載子濃度高於 1e12，就使用 GradQuasiFermi model，反之則使用 Eparallel model。通常 1e12 並不會影響到總電流，但仍能改善收斂問題。有時甚至需要用到 1e14 ～ 1e16 以獲得更好的收斂，但要留意不同設定所得到的電流是否一致，以確定 Eparallel driving force 帶來的誤差仍可接受。\n另一種內插法是 QausiGradFermi 與 電場本身，可使用 RefDens_eGradQuasiFermi_ElectricField 與 RefDens_eGradQuasiFermi_ElectricField 參數來設定。\n還有一種方法改善收斂，就是在低濃度的地方逐漸忽略 driving force。可以藉由 RefDens_eGradQuasiFermi_Zero (for electrons) and RefDens_hGradQuasiFermi_Zero (for holes) 設定，將它們設定為正值即可。例如說，如果設定為 1e10，那麼在 1e10 濃度以下的地方就不會用到 driving force。\n還有一個在物理上可行的做法，就是使用 hydrodynamic transport model。這時 sdevice 會計算局域載子溫度，接著並用來計算 driving force。可以藉由 HighFieldSaturation(CarrierTempDrive) 來開啟它。有時會因為有比較好的收斂而改善通常 HT model 算太慢的現象。總之，如果你在使用 GradQuasiFermi 時遇到了收斂問題。那麼你可以：\n確保通道的網格足夠細緻與均勻 考慮改成 EparallelToInterface 如果 terminal currents 誤差實在很大，那麼可考慮將 RefDens_e/hGradQuasiFermi_ElectricField 設定為 1e12 或者更高。 設定 RefDens_e/hGradQuasiFermi_Zero 到 1e10 或者更高以忽略在低於該濃度時的 driving force 計算 最後可以考慮改用 hydrodynamic transport model。 常見模擬參數之意義 HighFieldSaturation(GradQuasiFermi) RefDens_hGradQuasiFermi_Zero：低於其值則忽略 damp 有效電場 RefDens_eGradQuasiFermi_EparallelToInterface：高於其值則使用 GradQuasiFermi，低於則 EparallelToInterface。 RefDens_eGradQuasiFermi_ElectricField：高於其值則使用 GradQuasiFermi，低於則 Eparallel External resistor method 這方法很有用，但是非常慢。\n簡單來說，只是在元件上串聯一個電阻。\n但因為我們設定 \\(R=V_b/I_b\\)，所以在 InnerVoltage 到達 \\(V_b\\) 時，OuterVoltage 會是兩倍的崩潰電壓。而在那之前，因為電流實在是很小，所以外接電阻分配到的分壓並沒有追到元件分壓，使得大部分分壓都會正常地落在元件上。設定方法為，先在其中一個電極設定電阻，如下所示。\nElectrode { { Name= \u0026#34;substrate\u0026#34; Voltage= 0.0 } #if \u0026#34;@BVmethod@\u0026#34; == \u0026#34;resistor\u0026#34; { Name= \u0026#34;anode\u0026#34; Voltage= 0.0 Resistor= @R@} #else { Name= \u0026#34;anode\u0026#34; Voltage= 0.0 } #endif } 設定好之後其實就大功告成了。不過此時因為你只能夠控制某電極的電位，而在其中一個電極電位被設定為 Voltage=0.0 的情況下，這相當於設定兩電極（anode與substrate）之間的電壓，即「元件與電阻」的總跨壓。因此，倘若元件開始崩潰，電流開始爆增，那麼「元件與電阻」的總跨壓將會變得非常大。因此如果將後續的模擬目標電壓設定為-50V 或甚至是 -100V，那因為元件分到的跨壓一定比較小，所以很可能沒達到目標。因此這時需要將最後的目標電壓設定得高一點，通常我都設定-500到-1000。有時為了更加準確而會設定為-2000。\nTrap 設定(sdevice) Another available species is the fixed charge, which is a trap fully occupied by either electrons or holes. Therefore, its charge stays constant throughout the entire simulation and does not depend on electrical bias conditions. Electron–hole recombination through such a trap is not allowed. This type of trap uses the FixedCharge keyword for a trap specification.\nRecombination \u0026amp; Generation rate 基本上它們都遵守 SRH recombination rate:\n$$ R_{SRH}=\\frac{np-n_i^2}{\\tau_{p0}(n+n_1)+\\tau_{n_0}(p+p_1)} $$ 但是沒辦法在 sdevice 用 SRHRecombination( Integrate( Semiconductor ) ) 觀察到這些特地、額外設定的 trap 造成的 SHR recombination rate，反而必須使用：\nCurrentPlot { eGapStatesRecombination( Integrate( Semiconductor ) ) eGapStatesRecombination( Integrate( Region=\u0026#34;Absorption\u0026#34; ) ) eGapStatesRecombination( Integrate( Region=\u0026#34;Multiplication\u0026#34; ) ) hGapStatesRecombination( Integrate( Semiconductor ) ) hGapStatesRecombination( Integrate( Region=\u0026#34;Absorption\u0026#34; ) ) hGapStatesRecombination( Integrate( Region=\u0026#34;Multiplication\u0026#34; ) ) } 才能夠看見這些 trap 的貢獻。\nTrap-assisted tunneling 這些 Trap 預設並沒有 trap-assisted tunneling 效果。換言之，即便之前設定了 Physics{Recombination(SRH(ElectricField(Lifetime=Hurkx)))}，也不會讓 trap 有此效應。這需要額外設定：\nPhysics(Region=\u0026#34;Absorption\u0026#34;){ Traps(eNeutral Level fromMidBandGap EnergyMid=@Eti@ Conc=1e15 eXsection=@eXsec@ hXsection=@hXsec@ SpatialShape=Gaussian SpaceMid=(@PosX@, 1.5) SpaceSig=(@Lx@, 1e3) Tunneling(Hurkx) ) } 上面的Tunneling(Hurkx)就是 trap-assisted tunneling 效應。\nLifetime 雖然 lifetime 滿足底下公式：\n$$ \\tau_{n,p}=\\frac{1}{\\sigma_{n,p}v_{n,p}N_t} $$\n但是沒辦法直接使用eLifetime與hLifetime觀察，需要手動將上述數據相乘。\n","permalink":"http://intervalrain.github.io/posts/device/simulationconvergece/","summary":"TCAD 模擬收斂問題 收斂問題 Sentaurus Device 有非常多種可模擬大電場下之飽和遷移率的模型，而這主要是設定有效電場的模型。其中，最自然的選擇就是 Eparallel driving model。這種模型取總電場平行於電流方向上的分量。不過這通常會導致嚴重的收斂問題。主要是因為電場跟電流有著極為密切的關係，除此之外，以 MOSFET 通道為例，通常垂直與平行通道方向之電場數量級差很多，因為演算之數值誤差會「混合」這兩個分量，所以這種 Eparallel 模型會使得每個節點上的 driving force變化許多，進而改變電流方向，又接著改變電場分量，所以會造成極為不穩定的情況。\n其中一個折衷的辦法，就是只考慮平行於 silicon-oxide 界面上的電場，可以使用 HighFieldSaturation(EparallelToInterface) 指令來啟動這模型。只要大部分的電流都平行於界面，那基本上這就是個很好的模型。然而，目前最新科技通常會使得 source/drain 的電流以「向外散開，向內吸入」的方式進入與離開。例如說目前的 ultrashalow source and drain extensions。電流散開之後，電流就不再平行於界面，而這模型可能會帶來將近 5-15 % 的誤差。因此，如果你知道電流的方向，那麼你也可以設定用來計算平行電場分量之方向向量，而不再只是單純地與最鄰近的界面平行的方向。例如說，如果你覺得電流主要是沿著 x 軸在流動，那麼可以在 Math section 設定 EparallelToInterface (Direction = (1 0 0))。\n最常用的 driving force 是 quasi-Fermi potential 的梯度模型。通常這跟平行電場模型是一樣的，但它的演算法比較穩定。可以用 HighFieldSaturation(GradQuasiFermi) 選項來啟動它。不過，即便如此，還是可能會造成收斂問題。這是因為通常 quasi-Fermi potential 的梯度都非常的陡峭，變化得太過劇烈或是非常的不平滑，而這往往切得比較不好的網格所造成的。\n但在有些時候，即便網格切得很好，還是沒辦法收斂。有時是因為低載子濃度的區域的濃度相對誤差都滿高的，而這會進一步導致 quasi-Fermi potential 的誤差變得滿大的。因為這些區域通常對總電流的貢獻並不是很顯著，所以算得太準反而會讓模擬跑得更慢。不過，你確實需要確認一下這些低密度是不是導致發散。\n除此之外，也可藉由設定 RefDens_eGradQuasiFermi_EparallelToInterface 與 RefDens_hGradQuasiFermi_EparallelToInterface 來使用「內插 GradQuasiFermi 與 Eparallel」的 driving force 模型。該參數定義了 gradual transition 發生的局域載子濃度。例如說，如果設定為 1e12，那麼當載子濃度高於 1e12，就使用 GradQuasiFermi model，反之則使用 Eparallel model。通常 1e12 並不會影響到總電流，但仍能改善收斂問題。有時甚至需要用到 1e14 ～ 1e16 以獲得更好的收斂，但要留意不同設定所得到的電流是否一致，以確定 Eparallel driving force 帶來的誤差仍可接受。","title":"[TCAD] 模擬收斂問題"},{"content":"1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \\( \\boxed{\\text{Full Adder}} \\begin{cases} \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{OR}} \\end{cases}\\\\ \\text{設計目標}\\qquad\\qquad\\text{子模組}\\qquad\\text{元件} \\) 1.3 Verilog 語法詞彙 由一連串的標記(token)所組成 識別字(identifiers) 關鍵字(keywords) 字串(strings) 註解(comments) 空白(whitespace) 數值(numbers) 1.3.1 識別字(identifiers) 描述電路行為所使用的自訂物件 不違反命名規則，工程師自行定義的物件名稱 命名規則 字母、數字、底線_或是錢字號$所組合而成。 開頭只能使用字母或底線。 識別字是有大小寫之分的。 舉例 Shift_reg_b (Valid) _bus123 (Valid) $error_condition (Invalid) NT$899 (Valid) 3_bit_data (Invalid) 1.3.2 關鍵字(keywords) 描述電路語法所保留的一組特殊名稱的標記 定義語言的結構來描述電路 輸入(input)、輸出(output) 資料型態、電路行為 所有關鍵字都必須使用小寫表示 不可當作識別字使用 常見關鍵字 \\(\\begin{array}{|l|l|l|l|l|l|}\\hline \\text{always}\u0026amp;\\text{and}\u0026amp;\\text{assign}\u0026amp;\\text{begin}\u0026amp;\\text{buf}\u0026amp;\\text{bufif0}\\\\\\hline \\text{bufif1}\u0026amp;\\text{case}\u0026amp;\\text{casex}\u0026amp;\\text{casez}\u0026amp;\\text{cmos}\u0026amp;\\text{default}\\\\\\hline \\text{defparam}\u0026amp;\\text{else}\u0026amp;\\text{end}\u0026amp;\\text{endcase}\u0026amp;\\text{endfunction}\u0026amp;\\text{endmodule}\\\\\\hline \\text{endtask}\u0026amp;\\text{event}\u0026amp;\\text{for}\u0026amp;\\text{forever}\u0026amp;\\text{fork}\u0026amp;\\text{function}\\\\\\hline \\text{highz0}\u0026amp;\\text{highz1}\u0026amp;\\text{if}\u0026amp;\\text{initial}\u0026amp;\\text{inout}\u0026amp;\\text{input}\\\\\\hline \\text{integer}\u0026amp;\\text{join}\u0026amp;\\text{module}\u0026amp;\\text{nand}\u0026amp;\\text{negedge}\u0026amp;\\text{nmos}\\\\\\hline \\text{nor}\u0026amp;\\text{not}\u0026amp;\\text{notif0}\u0026amp;\\text{notif1}\u0026amp;\\text{or}\u0026amp;\\text{output}\\\\\\hline \\text{parameter}\u0026amp;\\text{pmos}\u0026amp;\\text{posedge}\u0026amp;\\text{pull0}\u0026amp;\\text{pull1}\u0026amp;\\text{pulldown}\\\\\\hline \\text{pullup}\u0026amp;\\text{rcmos}\u0026amp;\\text{real}\u0026amp;\\text{realtime}\u0026amp;\\text{reg}\u0026amp;\\text{repeat}\\\\\\hline \\text{rnmos}\u0026amp;\\text{rpmos}\u0026amp;\\text{rtran}\u0026amp;\\text{rtranif0}\u0026amp;\\text{rtranif1}\u0026amp;\\text{strong0}\\\\\\hline \\text{string1}\u0026amp;\\text{supply0}\u0026amp;\\text{supply1}\u0026amp;\\text{task}\u0026amp;\\text{time}\u0026amp;\\text{tran}\\\\\\hline \\text{tranif0}\u0026amp;\\text{tranif1}\u0026amp;\\text{tri}\u0026amp;\\text{tri0}\u0026amp;\\text{tri1}\u0026amp;\\text{triand}\\\\\\hline \\text{trior}\u0026amp;\\text{trireg}\u0026amp;\\text{wait}\u0026amp;\\text{wand}\u0026amp;\\text{weak0}\u0026amp;\\text{weak1}\\\\\\hline \\text{while}\u0026amp;\\text{wire}\u0026amp;\\text{wor}\u0026amp;\\text{xnor}\u0026amp;\\text{xor}\\\\\\hline \\end{array}\\) 1.3.3 字串(strings) 一連串字元(character)組成的單一個體 可含有字母、數字、及一些特殊字元 字串的所有字元必須在同一行上，並在雙引號之間 1.3.4 註解(comments) 程式碼中加入說明文字 可讀性(readability) 文件化(documentation) 版權宣告(license declaration) 以//開頭的單行註解(one-line comment) 以/*為開頭，並以*/為結尾的多行註解(multiple-line comment) 多行註解不支援巢狀結構 1.3.5 空白(whitespace) 區隔不同物件 空格(blank spaces，\\b) 欄位(tabs，\\t) 換行(newlines，\\n) 除字串內空白，註解與空白在編譯與合成時會被忽略 1.3.6 數值(numbers) Verilog 有兩種數值表示法 固定長度(\u0008sized): 定義位元寬度 \u0026lt;size\u0026gt;'\u0026lt;bsase format\u0026gt;\u0026lt;number\u0026gt; \u0026lt;size\u0026gt;：十進位來表示此數的位元數(bits) \u0026lt;base format\u0026gt;：定義進制 'H|'h：十六進制 'D|'d：十進制 'O|'p：八進制 'B|'b：二進制 \u0026lt;number\u0026gt;：用\u0026lt;base format\u0026gt;來表示數值 若為負號，將-放在\u0026lt;size\u0026gt;前面 舉例： 18'h47CB：18 bits 的十六進位數 47CB 13'h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB 12'd1023：12 bits 的十進位數 1023 9'o723：9 bits 的八進位數 723 5'b11101：5bits 的二進位數 11101 5'b1xx01：含有 unknown values 的表示法 不定長度(unsized): 未定義位元寬度 \u0026lsquo;\u0026lt;base format\u0026gt;\u0026lt;number 不使用\u0026lt;size\u0026gt;規定位元長度 使用 HDL 編譯器內定的長度(32bit的寬度) 沒有寫明\u0026lt;base format\u0026gt;，則內定為十進制 舉例： 'h47CB：32 bits 的十六進位數 47CB 1023：32 bits 的十進位數 1023 'o723：32 bits 的八進位數 723 'b11101：32 bits 的二進位數 11101 Verilog 有四種數值位準(value level) \\(\\begin{array}{|c|l|}\\hline \\text{數值位準}\u0026amp;\\text{實際電路狀態}\\\\\\hline \\text{0}\u0026amp;\\text{邏輯0，假(false)，接地}\\\\\\hline \\text{1}\u0026amp;\\text{邏輯1，真(true)，接壓電源}\\\\\\hline \\text{x}\u0026amp;\\text{不確定值(unknown value)}\\\\\\hline \\text{z}\u0026amp;\\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\\\\hline \\end{array} \\) 1.4 Verilog 資料物件與型態 資料物件(data objects) 描述行為過程中所使用的訊號載具 一個物件經過處理再傳到另一個物件 資料型態(data type) 定義資料物件的類型 接線、暫存器、參數等 1.4.1 接線(Nets) 接線(nets)是連接實體元件的連接線 要被驅動才能改變其內部的值 最主要的關鍵字是 wire 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 z(高阻抗、浮接) 宣告方式 wire w; // 宣告一條接線，命名為\u0008w，內定預設值為z wire x = 1\u0026#39;b0; // 宣告一條接線，命名為x，並指定x為邏輯0 wire a, b, c // 宣告三條接線，命名為a, b, c 1.4.2 暫存器(Registers) 抽象的資料儲存物件(有別於實體暫存器 D flip-flop) 保留一個數值直到下一次指定新值為止 觀念類似 C 語言中的變數 主要的關鍵字是 reg 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 x(未知) \\(\\begin{array}{|l|l|}\\hline \\text{reg}\u0026amp;\\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\\\\hline \\text{integer}\u0026amp;\\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\\\ \u0026amp;\\text{算術運算產生2補數結果(2\u0026rsquo;s complement results))}\\\\\\hline \\text{real}\u0026amp;\\text{雙倍精確度之有號浮點數}\\\\ \u0026amp;\\text{(signed floating-point variable with double precision)}\\\\\\hline \\text{time}\u0026amp;\\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\\\\hline \\end{array}\\) 設計電路請以reg為主，其他類型合成器可能不支援。 宣告方式 reg a; // 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x reg x, y; // 宣告 2 個宣存器，命名為 x, y integer count; // 宣告 1 個整數為 count，值可以為正負 real fraction; // 宣告 1 個浮點數為 fraction，值含小數點 1.4.3 純量與向量(scalar and vector) 純量(scalar) 一個位元的物件 向量(vector) 多個位元的物件 接線(ex. wire) 與 reg 內定一位元 [大數字:小數字]、[小數字:大數字]→[MSB:LSB] 宣告方式 wire a; // 宣告 1 個 1-bits 接線 wire [4:0] x; // 宣告 1 個 5-bits 接線 reg b; // 宣告 1 個 1-bits 暫存器 reg [0:7] y; // 宣告 1 個 8-bits 暫存器 reg [31:0] z; // 宣告 1 個 32-bits 暫存器 1.4.4 陣列(Array) 多個暫存器、接線的聚合體 索引值(index)定義聚合體中的個別物件 支援多維度的陣列 記憶體(memory)、暫存器檔案(register file) 陣列中暫存器、接線的個數 [大數字:小數字]、[小數字:大數字] 宣告方式 // mem_block 是一個包含 128 個暫存器的陣列， // 每個暫存器皆為 32 位元寬 reg [31:0] mem_block [127:0]; // mem_2D 是一個 2 維 4x64 的暫存器陣列， // 每個暫存器皆為 8 位元寬 reg [7:0] mem_2D [3:0][63:0]; 1.4.5 參數(parameter) 定義編譯合成電路時的常數 每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路 重複使用 關鍵字 parameter 宣告方式 parameter width = 4; wire [width-1:0] a, b; // 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動 reg [width-1:0] y; // 暫存器 y 的位元寬度，會隨著參數值的改變而變動 1.5 模組(Module)、埠(Port) 1.5.1 模組(Module) 一個電路區塊、可以由其他模組組成 連接模組時 考慮模組的輸入與輸出介面 不需要考慮模組內部的詳細電路 電路設計時 只修改模組內部電路 不會改變電路外部及周遭的模組 模組內部的電路描述可包含 訊號資料型態宣告 引用其他模組(邏輯閘) assign 資料處理模型之描述 always 行為模型之描述 函數(function) 與 任務(task) 除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為 模組宣告 以關鍵字 module 為開頭，在其後加一個識別用的模組名稱(module name) 再來是輸入與輸出埠列(module terminal list)和埠列宣告，接著是模組內部關於電路的描述 以關鍵字 endmodule 做為模組結尾 支援階層`式的設計概念 module module_name(terminal_list) port_declaration(...) param_declaration(optional) data_type_declaration(wire, reg) other_module(logic_gate) assign data_flow_model always behavior_model function, task endmodule 1.5.2 埠(port) 終端點、模組與外界溝通的介面接點(門) 一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通 若模組與外界不需要溝通，則埠列也就不存在(封閉系統) 測試環境(test bench) 埠的宣告 埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。 埠的宣告型態內定為接線(net)的 wire，若需要將訊號儲存起來則埠號型態須宣告成暫存器 reg。 輸入埠和雙向埠只能是接線(net)，不可宣告成暫存器。 輸出埠可以宣告成接線(net)或暫存器。 module full_adder(a, b, carry, sum); // 埠列 input [3:0] a, b; // 輸入埠(4位元向量) input carry // 輸入埠(1位元純量) output [4:0] sum; // 輸出埠(5位元向量) reg [4:0] sum; // 因輸出sum需儲存資料，故宣告成暫存器 ... endmodule 1.6 邏輯閘層次模型 利用關鍵字即可引用基本的邏輯閘元件 基本的邏輯閘關鍵字 and nand or nor not xor xnor 1.6.1 多個輸入邏輯閘(Multiple-Input Gates) and、nand、or、nor、xor、xnor 具有多個純量(scalar)的輸入，但是只有一個純量的輸出 多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面 輸出必須透過接線(wire)連接，輸入無規定 多個輸入邏輯閘的別名可以加或是不加 使用方法 gate_type instance(out, in_1, in_2, in_3, ..., in_n); gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n), inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n), inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n), ... inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn); \\(\\begin{array}{ccc} \\underbrace{\\text{a, b, c, d}}_{\\text{輸入}} \\rightarrow \\boxed{\\text{Multiple-Input Gate}} \\rightarrow \\underbrace{\\text{e}} _{\\text{輸出}} \\end{array} \\) \\(\\text{and\\quad a1(} \\underbrace{\\text{e}}_{\\text{輸出}} \\text{, } \\underbrace{\\text{a, b, c, d}} _{\\text{輸入}} \\text{);} \\) 1.6.2 多個輸出邏輯閘(Multiple-Output Gates) not、buf\n具有一個或是多個純量(scalar)的輸出，但是只有一個純量的輸入\n多個輸出邏輯閘的輸出是放在埠列(port list)的前面位置，而輸入則是放在列後面位置\n輸出必須透過接線(wire)連接，輸入無規定 多個輸出邏輯閘的別名可以加或是不加\n使用方法\ngate_type instance(out_1, out_2, out_3, ..., out_n, in); gate_type inst_1(out1_1, out1_2, out1_3, ..., out1_n, in1), inst_2(out2_1, out2_2, out2_3, ..., out2_n, in2), inst_3(out3_1, out3_2, out3_3, ..., out3_n, in3), ... inst_m(out_m1, out_m2, out_m3, ..., out_mn, in_m); \\(\\begin{array}{ccc} \\underbrace{\\text{d}}_{\\text{輸入}} \\rightarrow \\boxed{\\text{Multiple-Output Gate}} \\rightarrow \\underbrace{\\text{a, b, c}} _{\\text{輸出}} \\end{array} \\)\n\\(\\text{not\\quad n1(} \\underbrace{\\text{a, b, c}}_{\\text{輸出}} \\text{, } \\underbrace{\\text{d}} _{\\text{輸入}} \\text{);} \\)\n邏輯閘層次模型範例\nmodule and_or_gate(in1, in2, in3, in4, out; input in1, in2, in3, in4; output out; wire w1, w2; and a1(w1, in1, in2); and a2(w2, in3, in4); or o1(out, w1, w2); endmodule 2 實作 Implementation in Github\n1. HDLbits 2. Verilog 3. Circuits 4. Verification: Reading Simulations 5. Verification: Writing Testbenches 6. CS450 ","permalink":"http://intervalrain.github.io/posts/verilog/intro/","summary":"1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \\( \\boxed{\\text{Full Adder}} \\begin{cases} \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{OR}} \\end{cases}\\\\ \\text{設計目標}\\qquad\\qquad\\text{子模組}\\qquad\\text{元件} \\) 1.","title":"[VHDL] Verilog Hardware Description Language"},{"content":"前言 MVC MVC 是一種軟體架構模式。 模型 (Model) 視圖 (View) 控制器 (Controller) 目的是實現一種動態且有彈性的程式設計，使後續對程式設計的維護與擴充都變得更容易，另一方面也能使程式的某一部分被重複使用而提升設計效率。 SSH SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Struts Spring Hibernate SSM SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Spring-MVC Spring MyBatis SSH v.s. SSM Spring-MVC v.s. Struts Struts 和 Spring-MVC 都負責取轉發，但兩者針對 request 的請求上區別很大， Struts 是針對一個 Action class 來進行 request，即一個 Action 對應一個 request，屬於類攔截，請求的數據類共享。 Spring-MVC 則是針對 method 級別的 request，即一個 method 對應一個 request，屬於方法攔截，請求的數據方法不共享。 Spring-MVC 的配置文件相對較少，容易上手，方便開發。 Spring-MVC 的入口是 Servlet 級別的而 Struts 的級別是 Filter 級別的。 Hibernate v.s. MyBatis Hibernate 是一種 O/R 關係型，即完成資料庫和持久化類別之間的映射；而 MyBatis 是針對的 SQL-Mapping。猶如 Hibernate 是對資料庫封裝完成後，調用相對應的語句(HQL)來控制資料庫；而 MyBatis 是用原生的資料庫語法。 基於以上原因，Hibernate 的優化較 MyBatis 難，MyBatis 不需要額外學習新的語法，入門較快。 對於更高級的 Queuy，MyBatis 需要編寫 SQL 語句與 ResultMap。而 Hibernate 有因應的映射機制，無需關心 SQL 的生成與結果映射，可以專注於開發流程。 Hibernate 的資料庫移植性很好，MyBatis 的資料庫移植性不好，不同的資料庫需要寫不同的 SQL。 Spring Spring、Spring MVC、Spring Boot Spring 是一種框架，包含一系列的 IoC 容器的設計和依賴注入(DI) 及 整合AOP功能。 Spring MVC 是一種以 Spring 為核心的框架。 Spring Boot 是一種以 Spring 為核心的框架，同時又能簡化配置(configuration)。 Spring 的核心基礎 DI DI = 依賴注入 Dependency Injection 一種 coding style，為了未來在維護上能更加的靈活，概念類似： // 1 System.out.println(\u0026#34;This is Spring\u0026#34;); // 2 String str = \u0026#34;This is Spring\u0026#34;; System.out.println(str); IoC IoC = 控制反轉 Inversion of Control 將產生物件這件事交給IoC去做。簡單來說，IoC是一個xml檔，也可以是一個class(Bean class)。 IoC做的事情就是設定其他class(Bean class)的名稱，以及 Constructor 會用到的參數或物件。 public class User{ Family family = new Family(\u0026#34;Jason\u0026#34;, \u0026#34;Jocelyn\u0026#34;, \u0026#34;Mark\u0026#34;, \u0026#34;Eva\u0026#34;); public void showAll(){ family.showFamily(); } } public class Family{ String dad; String mom; String son; String dau; public Family(String dad, String mom, String son, String dau){ this.dad = dad; this.mom = mom; this.son = son; this.dau = dau; } public void showFamily(){ System.out.println(dad + \u0026#34; \u0026#34; + mom + \u0026#34; \u0026#34; + son + \u0026#34; \u0026#34; + dau); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;family\u0026#34; class=\u0026#34;Family\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dad\u0026#34; value=\u0026#34;Jason\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;mom\u0026#34; value=\u0026#34;Jocelyn\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;son\u0026#34; value=\u0026#34;Mike\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;dau\u0026#34; value=\u0026#34;Eva\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;allFamily\u0026#34; value=\u0026#34;family\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 實例 DI + IoC Dinner public class Diner{ Food food; public void getDinner(){ food.getFood(); } } xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;pork\u0026#34; class=\u0026#34;Pork\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;chicken\u0026#34; class=\u0026#34;Chicken\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;food\u0026#34; class=\u0026#34;Food\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;food\u0026#34; value=\u0026#34;chicken\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; classes public interface Food{ public void getFood(); } public class Chicken implements Food{ @override public void getFood(){ System.out.println(\u0026#34;Eat chicken\u0026#34;); } } public class Pork implements Food{ @override public void getFood(){ System.out.println(\u0026#34;Eat pork\u0026#34;); } } Spring Boot 由 Pivotal 團隊在 2013 年開始研發、2014年4月發布第一個版本。 是基於 Spring4.0 所設計的一種新型框架，繼承的 Spring 框架原有的優秀特性，還通過簡化配置來進一步簡化了 Spring 應用的整個搭建和開發過程。 通過集成大量的框架使得依賴包的版本衝突與引用的不穩定性得到很好的解決。 官方說明: Spring Boot makes it easy to create stand-alone, production-grade Spring baesd Applications that you can \u0026ldquo;just run\u0026rdquo;. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.\nString Boot 預設了各種合理的默認配置包括放棄了 XML，Spring Boot Web 應用程式使用了一個嵌入式 Tomcat 容器，可以自定義 Spring Boot 應用程式等。 簡而言之，Spring Boot 提供一組工具，可以快速構建且容易配置的 Spring 應用程式。同時不需要在重新定義基本的配置，從而成為可以達到快速開發的效果。 特色 創建獨立的 Spring 應用程式 嵌入式 Tomcat、Jetty; Undertow(不用部署 WAR 包) 提出自主的 starter 來簡化配置 隨時自動地配置 Spring 及相關的第三方庫 提供已隨時就緒的功能如 Metrics，程式的健檢及外部化配置 不會生成任何代碼及無任何 XML 配置的前設要求 ","permalink":"http://intervalrain.github.io/posts/java/java_mvc/","summary":"前言 MVC MVC 是一種軟體架構模式。 模型 (Model) 視圖 (View) 控制器 (Controller) 目的是實現一種動態且有彈性的程式設計，使後續對程式設計的維護與擴充都變得更容易，另一方面也能使程式的某一部分被重複使用而提升設計效率。 SSH SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Struts Spring Hibernate SSM SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Spring-MVC Spring MyBatis SSH v.s. SSM Spring-MVC v.s. Struts Struts 和 Spring-MVC 都負責取轉發，但兩者針對 request 的請求上區別很大， Struts 是針對一個 Action class 來進行 request，即一個 Action 對應一個 request，屬於類攔截，請求的數據類共享。 Spring-MVC 則是針對 method 級別的 request，即一個 method 對應一個 request，屬於方法攔截，請求的數據方法不共享。 Spring-MVC 的配置文件相對較少，容易上手，方便開發。 Spring-MVC 的入口是 Servlet 級別的而 Struts 的級別是 Filter 級別的。 Hibernate v.s. MyBatis Hibernate 是一種 O/R 關係型，即完成資料庫和持久化類別之間的映射；而 MyBatis 是針對的 SQL-Mapping。猶如 Hibernate 是對資料庫封裝完成後，調用相對應的語句(HQL)來控制資料庫；而 MyBatis 是用原生的資料庫語法。 基於以上原因，Hibernate 的優化較 MyBatis 難，MyBatis 不需要額外學習新的語法，入門較快。 對於更高級的 Queuy，MyBatis 需要編寫 SQL 語句與 ResultMap。而 Hibernate 有因應的映射機制，無需關心 SQL 的生成與結果映射，可以專注於開發流程。 Hibernate 的資料庫移植性很好，MyBatis 的資料庫移植性不好，不同的資料庫需要寫不同的 SQL。 Spring Spring、Spring MVC、Spring Boot Spring 是一種框架，包含一系列的 IoC 容器的設計和依賴注入(DI) 及 整合AOP功能。 Spring MVC 是一種以 Spring 為核心的框架。 Spring Boot 是一種以 Spring 為核心的框架，同時又能簡化配置(configuration)。 Spring 的核心基礎 DI DI = 依賴注入 Dependency Injection 一種 coding style，為了未來在維護上能更加的靈活，概念類似： // 1 System.","title":"[Java] 淺談 Java MVC"},{"content":"Microservices Definition Separate business logic functions. Instead of one big problem, several smaller applications. Communicative via well defined APIs - usually HTTP In demand Advantages and Disavantages Advantages Language independent Fast iterations Small teams Fault Isolation Pair well with containers Scalable Big plus Disavantages Complex networking Overhead Databases Servers Docker is an open platform for developers and sysadmins to build, ship, and run distributed applications, whether on laptops, data center VMs, or the cloud. Definition Containers are a way to package software in a format that can run isolated on a shared operating system. Unlike VMs, containers do not bundle a full operating system - only libraries and setting required to make the software work are needed. This makes for efficientm, lightweight, self-contained systems and guarantees that software will always run the same, regardless of where it\u0026rsquo;s deployed. Docker vs VM VM = App + Bins/Libs + guest OS Container = App + Bins/Libs + Docker Dockerfile Describes the build process for an image Can be run to automatically create an image Contains all the commands necessary to build the image and run your application. Kubernetes Components Node Kubelet Communicates with master Run Pods Pod Runs 1+ containers Exists on a node Service Handles requests Usually a load balancer Deployment Defines desired state - kubernetes handles the rest ","permalink":"http://intervalrain.github.io/posts/it/microservices_docker_kubernetes/","summary":"Microservices Definition Separate business logic functions. Instead of one big problem, several smaller applications. Communicative via well defined APIs - usually HTTP In demand Advantages and Disavantages Advantages Language independent Fast iterations Small teams Fault Isolation Pair well with containers Scalable Big plus Disavantages Complex networking Overhead Databases Servers Docker is an open platform for developers and sysadmins to build, ship, and run distributed applications, whether on laptops, data center VMs, or the cloud.","title":"[IT] Introduction to Microservices, Docker and Kubernetes"},{"content":"map 宣告 map \u0026lt;int, int\u0026gt; mp; // key和value都是整數 方法 mp[key] = value; 加入新的key-value pair mp.count(key); 檢查 key 是否存在 map 中 mp.erase(key); 刪除 key mp.clear(); 清空 map 中的所有元素： value = mp[key] 利用 key 取值 mp.empty() 判斷是否為空的map map 的遍歷 遍歷整個map時，利用iterator操作： 取key：it-\u0026gt;first 或 *(it).first 取value：it-\u0026gt;second 或 *(it).second for (auto it = mp.begin(); it != mp.end(); ++it){ cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (auto it = mp.begin(); it != mp.end(); ++it){ cout \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } ","permalink":"http://intervalrain.github.io/posts/c++/stl_map/","summary":"map 宣告 map \u0026lt;int, int\u0026gt; mp; // key和value都是整數 方法 mp[key] = value; 加入新的key-value pair mp.count(key); 檢查 key 是否存在 map 中 mp.erase(key); 刪除 key mp.clear(); 清空 map 中的所有元素： value = mp[key] 利用 key 取值 mp.empty() 判斷是否為空的map map 的遍歷 遍歷整個map時，利用iterator操作： 取key：it-\u0026gt;first 或 *(it).first 取value：it-\u0026gt;second 或 *(it).second for (auto it = mp.begin(); it != mp.end(); ++it){ cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; =\u0026gt; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } for (auto it = mp.begin(); it !","title":"[C++] The C++ Standard Template Library(STL) - map"},{"content":"程式碼 static final int hash(Object key){ int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } h \u0026raquo; 16 的用途 h是key.hashCode()，h \u0026gt;\u0026gt;\u0026gt; 16代表的是取其高位的16位 key.hashCode() ^ (h \u0026raquo; 16) 這與 Java1.8 中 tab[(n-1) \u0026amp; hash] 的原理有關 static int indexFor(int h, int length){ return h \u0026amp; (length - 1); } 返回的值即為陣列的下標。 大多數情況下，capacity 都小於2^16，所以在此的 \u0026amp; 運算，只會對 h 的低16位進行 \u0026amp; 運算。 若將高位16位也加入計算，可以增加下標的發散度，避免衝突的次數。 而使用 XOR 的原因是，更較於 AND 或 OR 均勻，因為 AND 會使結果趨向於 0，OR 會使結果趨向於 1。 ","permalink":"http://intervalrain.github.io/posts/java/hashmap/hashcode/","summary":"程式碼 static final int hash(Object key){ int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } h \u0026raquo; 16 的用途 h是key.hashCode()，h \u0026gt;\u0026gt;\u0026gt; 16代表的是取其高位的16位 key.hashCode() ^ (h \u0026raquo; 16) 這與 Java1.8 中 tab[(n-1) \u0026amp; hash] 的原理有關 static int indexFor(int h, int length){ return h \u0026amp; (length - 1); } 返回的值即為陣列的下標。 大多數情況下，capacity 都小於2^16，所以在此的 \u0026amp; 運算，只會對 h 的低16位進行 \u0026amp; 運算。 若將高位16位也加入計算，可以增加下標的發散度，避免衝突的次數。 而使用 XOR 的原因是，更較於 AND 或 OR 均勻，因為 AND 會使結果趨向於 0，OR 會使結果趨向於 1。 ","title":"[Java] HashMap中的hashCode設計原理"},{"content":"C++ 易錯題目收集 1. bit-format expression #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ unsigned int x = -1; int y = ~0; if (x==y) cout \u0026lt;\u0026lt; \u0026#34;same\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;not same\u0026#34;; return 0; } 結果 same 解析 unsigned int x = -1 相當於11111111 y = ~0 也相當於11111111 2. 如何使 C(n,3) 正確且 n 的有效值最大? 結果 return n*(n-1)/2*(n-2)/3; 解析 n*(n-1)必為基偶相乘 n*(n-1)*(n-2)必為3的倍數 故此題的作法可避免因整數除法而造成的小數位消去 3. register在C++中的用法 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ register int i = 10; int *ptr = \u0026amp;i; cout \u0026lt;\u0026lt; *ptr; return 0; } 選項 Prints 10 on all compilers Prints 0 on all compilers May generate Compilation Error May generate Runtime Error 結果 May generate Compilation Error 解析 register關鍵字用來分配變數儲存於CPU的register，以達到快速存取。所以對其提取有可能造成編譯錯誤，因為指標指向的位址不在在RAM上。 在大部分的C++編譯器，不推薦使用register關鍵字，因為沒有任何意義，儘管他會被默認成auto關鍵字，使得C++編譯器可能可能適用。 4. 有趣的 for loop 問題 int fun(){ static int num = 16; return num--; } int main(){ for(fun(); fun(); fun()) cout \u0026lt;\u0026lt; fun(); return 0; } 結果 14 11 8 5 2 解析 main()中的 for-loop 可以寫成等效的 while-loop 如下 int main(){ int num = 16; num--; // num = 15 while (num-- != 0){ // 先判斷後遞減 15 !=0, num = 14 cout \u0026lt;\u0026lt; (num--) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 先印出後遞減印出 14, num = 13 num--; // 遞減後回到while, num = 12 } return 0; } static int num = 16 設定初值為 16，並遞減，故 num = 15 判斷 num 是否為真，後遞減。15 != 0，遞減使 num = 14，進入迴圈 印出 num = 14 後，遞減，num = 13 迴圈結束前作遞減，num = 12，重新回到 step2 5. const 與 volatile Pick the correct statemewnt for const and volatile keywords. 選項 const is the opposite of volatile and vice versa const and volatile can\u0026rsquo;t be used for struct and union const and volatile can\u0026rsquo;t be used for enum const and volatile can\u0026rsquo;t be used for typedef const and volatile are independent i.e. it\u0026rsquo;s possible that a variable is defined as both const and volatile 結果 const and volatile are independent i.e. it\u0026#39;s possible that a variable is defined as both const and volatile 解析 const 是確保變數不會變修改，使其值變成唯讀。 volatile 通常用在具有最佳化或多執行緒相關的變數或物件，volatile用來阻止編譯器因誤認某段程式碼無法被程式碼本身所改變，而造成的過度優化。volatile會使得每次存取這個變數或物件時，都會直接從變數位址中取得資料，避免可能使用暫存器中的值，在變數可能被其他程式更新的狀況下，產生錯誤的值。 6. operator priority int main(){ cout \u0026lt;\u0026lt; (1 \u0026lt;\u0026lt; 2 + 3 \u0026lt;\u0026lt; 4); return 0 } 結果 512 解析 +優先於\u0026lt;\u0026lt; 故此段敘述等效於 cout \u0026lt;\u0026lt; (1 \u0026lt;\u0026lt; (2 + 3) \u0026lt;\u0026lt; 4); cout \u0026lt;\u0026lt; (1 \u0026lt;\u0026lt; 5 \u0026lt;\u0026lt; 4); cout \u0026lt;\u0026lt; (32 \u0026lt;\u0026lt; 4); cout \u0026lt;\u0026lt; 512; 7. floating constant Suppose a C++ program has floating constant 1.414, what\u0026#39;s the best way to convert this as \u0026#34;float\u0026#34; data type? 選項 (float)1.414 float(1.414) 1.414f or 1.414F 1.414 itself of \u0026ldquo;float\u0026rdquo; data type i.e. nothing else required 結果 `1.414f` or `1.414F` 解析 floating constant 被預設為 double 資料型態，故利用f或F的suffix，即可將之轉為 float 資料型態。 8. array pointer int main(){ int arr[5]; // Assume base address of arr is 2000 and size of integer is 32 bit printf(%u %u, arr+1, \u0026amp;arr+1); return 0; } 結果 2004 2020 解析 array 的名稱會傳回第一個元素的地址(除了使用 sizeof)。 對 array 加 1 會加上 sizeof(type)。 \u0026amp;array 代表整個 array 的地址，加 1 回加上 sizeof(while array)。 9. initialize array int main(){ int a[][] = {{1,2},{3,4}}; int i, j; for (int i = 0; i \u0026lt; 2; i++){ for (int j = 0; j \u0026lt; 2; j++){ printf(\u0026#34;%d \u0026#34;, a[i][j]); } } return 0; } 結果 Compilation Error 解析 Array 在記憶體中是以row-major的型式儲存的。 儘管 array 是多維陣列，他都是被儲存成單一線性的區塊 下列 assign 的方式是合法的，(第一個可被省略) int a[] = {...}; int a[][10] = {{...}, ...}; int a[][5][10] = {{{...},...},...}; ","permalink":"http://intervalrain.github.io/posts/c++/question/","summary":"C++ 易錯題目收集 1. bit-format expression #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ unsigned int x = -1; int y = ~0; if (x==y) cout \u0026lt;\u0026lt; \u0026#34;same\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;not same\u0026#34;; return 0; } 結果 same 解析 unsigned int x = -1 相當於11111111 y = ~0 也相當於11111111 2. 如何使 C(n,3) 正確且 n 的有效值最大? 結果 return n*(n-1)/2*(n-2)/3; 解析 n*(n-1)必為基偶相乘 n*(n-1)*(n-2)必為3的倍數 故此題的作法可避免因整數除法而造成的小數位消去 3. register在C++中的用法 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ register int i = 10; int *ptr = \u0026amp;i; cout \u0026lt;\u0026lt; *ptr; return 0; } 選項 Prints 10 on all compilers Prints 0 on all compilers May generate Compilation Error May generate Runtime Error 結果 May generate Compilation Error 解析 register關鍵字用來分配變數儲存於CPU的register，以達到快速存取。所以對其提取有可能造成編譯錯誤，因為指標指向的位址不在在RAM上。 在大部分的C++編譯器，不推薦使用register關鍵字，因為沒有任何意義，儘管他會被默認成auto關鍵字，使得C++編譯器可能可能適用。 4.","title":"[C++] 易錯題目收集"},{"content":"list Lists 是序列式容器，但其記憶體的分配並非連續的。 跟 vector 相比，其遍歷的速度會較慢\\(O(n)\\，但一旦位置確定後，其插入(insert)或移除(delete)元素的速度很快\\(O(1)\\)。 一般來說，List 指的是雙向鏈結陣列(doubly linked list)。 而單向鏈結陣列則為 forward_list 函式庫 #include \u0026lt;list\u0026gt; 宣告 list\u0026lt;data_type\u0026gt; list_name; 初始化 list\u0026lt;int\u0026gt; lst; // 宣告 函式 1. front() 2. back() 3. push_front() 4. push_back() 5. pop_front() 6. pop_back() 7. list::begin() 8. list::end() 9. list::rbegin() 10. list::rend() 11. list::cbegin() 12. list::cend() 13. list::crbegin() 14. list::crend() 15. empty() 16. insert() 17. erase() 18. assign() 19. remove() 20. list::remove_if() 21. reverse() 22. size() 23. list::resize() 24. sort() 25. list::max_size() 26. list::unique() 27. list::emplace_front() 28. list::emplace_back() 29. list::clear() 30. list::operator= 31. list::swap() 32. list::splice() 33. list::merge()4 34. list::emplace() 示例 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; void print(list\u0026lt;int\u0026gt; lst){ list\u0026lt;int\u0026gt;::iterator it; for (it = lst.begin(); it != lst.end(); ++it){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main(){ list\u0026lt;int\u0026gt; lst1, lst2; for (int i = 0; i \u0026lt; 10; ++i){ lst1.push_back(i); lst2.push_front(i); } cout \u0026lt;\u0026lt; \u0026#34;List1 is : \u0026#34;; print(lst1); cout \u0026lt;\u0026lt; \u0026#34;List2 is : \u0026#34;; print(lst2); cout \u0026lt;\u0026lt; \u0026#34;List1.front() : \u0026#34; \u0026lt;\u0026lt; lst1.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;List2.back() : \u0026#34; \u0026lt;\u0026lt; lst2.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;After List1.pop_front() : \u0026#34;; lst1.pop_front(); print(lst1); cout \u0026lt;\u0026lt; \u0026#34;After List2.pop_back() : \u0026#34;; lst2.pop_back(); print(lst2); cout \u0026lt;\u0026lt; \u0026#34;After List1.reverse() : \u0026#34;; lst1.reverse(); print(lst1); cout \u0026lt;\u0026lt; \u0026#34;After List2.sort() : \u0026#34;; lst2.sort(); print(lst2); return 0; } 函式(functions) 1. list.front() Returns the value of the first element in the list. 2. list.back() Returns the value of the last element in the list. 3. list.push_front(E val) Adds a new element val at the beginning of the list. 4. list.push_back(E val) Adds a new element val at the end of the list. 5. list.pop_front() Removes the first element of the list, and reduces size of the list by 1. Won\u0026rsquo;t return value. 6. list.pop_back() Removes the last element of the list, and reduces size of the list by 1. Won\u0026rsquo;t return value. 7. list.begin() Returns a iterator pointing to the first element of the list. 6. list.end() Returns a iterator pointing to the theoretical last element which follows the last element. 7. list.rbegin() Returns a reverse iterator which points to the last element of the list. 8. list.rend() Returns a reverse iterator which points to the position before the beginning of the list. 9. list.cbegin() Returns a constant random access iterator which points to the beginning of the list. 10. list.cend() Returns a constant random access iterator which points to the end of the list. 11. list.crbegin() Returns a constant reverse random access iterator which points to the beginning of the list. 12. list.crend() Returns a constant reverse random access iterator which points to the end of the list. 13. list.empty() Returns whether the list is empty or not. 14. list.insert(pos, n, val) pos: iterator, to point out the position to insert n: the numbers of val to insert (optional, default = 1) val: the insert elements Inserts new elements in the list before the element at a specified position. 15. list.erase(pos) pos: iterator, to point out the position to erase Removes a single element from the list. 16. list.erase(first, last) first: iterator, to point out the begining of the range. last: iterator, to point out the end of the range. Removes a range of elements from the list. 17. list.assign() 18. list.remove() 19. list.remove_if() 20. list.reverse() 21. list.size() 22. list.resize() 23. list.sort() 24. list.max_size() 25. list.unique() 26. list.emplace_front() 27. list.emplace_back() 28. list.clear() 29. list.swap() 30. list.splice() 31. list.merge() 32. list.emplace() 你可能會想繼續閱讀… 回到容器(Containers) vector deque arrays forward_list ","permalink":"http://intervalrain.github.io/posts/c++/stl_list/","summary":"list Lists 是序列式容器，但其記憶體的分配並非連續的。 跟 vector 相比，其遍歷的速度會較慢\\(O(n)\\，但一旦位置確定後，其插入(insert)或移除(delete)元素的速度很快\\(O(1)\\)。 一般來說，List 指的是雙向鏈結陣列(doubly linked list)。 而單向鏈結陣列則為 forward_list 函式庫 #include \u0026lt;list\u0026gt; 宣告 list\u0026lt;data_type\u0026gt; list_name; 初始化 list\u0026lt;int\u0026gt; lst; // 宣告 函式 1. front() 2. back() 3. push_front() 4. push_back() 5. pop_front() 6. pop_back() 7. list::begin() 8. list::end() 9. list::rbegin() 10. list::rend() 11. list::cbegin() 12. list::cend() 13. list::crbegin() 14. list::crend() 15. empty() 16. insert() 17. erase() 18. assign() 19. remove() 20. list::remove_if() 21. reverse() 22. size() 23. list::resize() 24.","title":"[C++] The C++ Standard Template Library(STL) - list, forward_list"},{"content":"vector Vectors 是一動態陣列，可以自動的調整其容器的容量。 Vector 的元素被儲存在連續的記憶體空間，所以可以使用迭代器(iterators)來進行存取。 在 vectors 中，元素是被插入在尾端的，插入尾端的時間取決於是否須進行容量的調整。 在 vectors 中，刪除尾端元素的時間複雜度則是固定的\\(O(1)\\)，因為不會發生容量調整。 在 vectors 的前端或中間插入元素或是清除元素，時間的複雜度都是\\(O(n)\\)。 迭代器(Iterators) 1. vec.begin() 回傳指向 vector 中第一個元素的迭代器 (vec[0]) 2. vec.end() 回傳指向 vector 中最後一個元素之後一個的迭代器 (vec[n+1]) 3. vec.rbegin() 回傳指向 vector 中最後一個元素的反向迭代器 (vec[n]) 4. vec.rend() 回傳指向 vector 中第一個元素之前一個的反向迭代器 (vec[-1]) 5. vec.cbegin() 回傳指向 vector 中第一個元素的常數迭代器 (vec[0]) 6. vec.cend() 回傳指向 vector 中最後一個元素之後一個的常數迭代器 (vec[n+1]) 7. vec.crbegin() 回傳指向 vector 中最後一個元素的反向常數迭代器 (vec[n]) 8. vec.crend() 回傳指向 vector 中第一個元素之前一個的反向常數迭代器 (vec[-1]) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int arr[] = {1,1,2,3,5,8,13,21,34,55}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // initialize with array cout \u0026lt;\u0026lt; \u0026#34;Output of begin() and end(): \u0026#34;; for (auto i = vec.begin(); i != vec.end(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\nOutput of rbegin() and rend(): \u0026#34;; for (auto i = vec.rbegin(); i != vec.rend(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\nOutput of cbegin() and cend(): \u0026#34;; for (auto i = vec.cbegin(); i != vec.cend(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;\\nOutput of crbegin() and crend(): \u0026#34;; for (auto i = vec.crbegin(); i != vec.crend(); ++i) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 結果：\nOutput of begin() and end(): 1 1 2 3 5 8 13 21 34 55 Output of rbegin() and rend(): 55 34 21 13 8 5 3 2 1 1 Output of cbegin() and cend(): 1 1 2 3 5 8 13 21 34 55 Output of crbegin() and crend(): 55 34 21 13 8 5 3 2 1 1 容量(capacity) 1. vec.size() 回傳 vector 的元素數量 2. vec.max_size() 回傳 vector 可以持有的最大元素數量 3. vec.capacity() 回傳 vector 當前被分配到的儲存空間，以元素數目表示 4. vec.empty() 回傳容器是否沒有元素的 5. vec.shrink_to_fit() 將容器的容量縮減到剛好符合它的元素數量，並丟棄所有超出容量的元素 6. vec.resize(int n) 將容器的容量重新調整到 n 個元素的大小 7. vec.reserve(int n) 將容器的容量重新調整到至少可以容納 n 個元素的大小。 #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026#34;print.cc\u0026#34; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec; for (int i = 0; i \u0026lt;= 12; ++i) vec.push_back(i); cout \u0026lt;\u0026lt; \u0026#34;Max_size: \u0026#34; \u0026lt;\u0026lt; vec.max_size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Initial\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; print(vec); cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; vec.resize(8); cout \u0026lt;\u0026lt; \u0026#34;After resize(8)\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; print(vec); cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; vec.shrink_to_fit(); cout \u0026lt;\u0026lt; \u0026#34;After fitting\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; print(vec); cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; vec.reserve(20); cout \u0026lt;\u0026lt; \u0026#34;After reserve(20)\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Size: \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Capacity: \u0026#34; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; print(vec); cout \u0026lt;\u0026lt; \u0026#34;==================================\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;If the vector is empty: \u0026#34;; vec.empty() ? (cout \u0026lt;\u0026lt; \u0026#34;Empty\u0026#34;) : (cout \u0026lt;\u0026lt; \u0026#34;Not empty\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 結果：\nMax_size: 4611686018427387903 ================================== Initial Size: 13 Capacity: 16 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] ================================== After resize(8) Size: 8 Capacity: 16 [0, 1, 2, 3, 4, 5, 6, 7] ================================== After fitting Size: 8 Capacity: 8 [0, 1, 2, 3, 4, 5, 6, 7] ================================== After reserve(20) Size: 8 Capacity: 20 [0, 1, 2, 3, 4, 5, 6, 7] ================================== If the vector is empty: Not empty 存取元素(access elements) 1. vec[int n] 回傳 n 指標位置的值 2. at(int n) 回傳 n 指標位置的位 3. front() 回傳第一個元素的值 4. back() 回傳最後一個元素的值 5. data() 回傳一個直接的指標指向 vector 的記憶體位置 #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026#34;print.cc\u0026#34; using namespace std; int main(){ int arr[] = {0, 1, 2, 3, 4, 5, 6, 7}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); print(vec); cout \u0026lt;\u0026lt; \u0026#34;vec[2]: \u0026#34; \u0026lt;\u0026lt; vec[2] \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;vec.at(4): \u0026#34; \u0026lt;\u0026lt; vec.at(4) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;vec.front(): \u0026#34; \u0026lt;\u0026lt; vec.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;vec.back(): \u0026#34; \u0026lt;\u0026lt; vec.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; int* pos = vec.data(); for (int* i = pos; i != pos + vec.size(); i++){ cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 結果\n[0, 1, 2, 3, 4, 5, 6, 7] vec[2]: 2 vec.at(4): 4 vec.front(): 0 vec.back(): 7 0 1 2 3 4 5 6 7 修改元素(modify elements) 1. assign(int n, E val) 指派新的值到 vector 中，並取代舊的值 2. push_back(E val) 將新的值加到 vector 的尾端 3. pop_back() 將 vector 的尾端的值取出並移除 4. insert(iterator it, E val) 在 vector 的指定位置加入新的值 5. erase(iterator it) 移除 vector 指定位置的移 6. v1.swap(v2) 交換兩個 vector 的值 7. vec.clear() 清除 vector 的所有值 #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026#34;print.cc\u0026#34; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec; cout \u0026lt;\u0026lt; \u0026#34;After assign(5, 10): \\n\u0026#34;; vec.assign(5, 10); print(vec); cout \u0026lt;\u0026lt; \u0026#34;After push_back(15): \\n\u0026#34;; vec.push_back(15); print(vec); int n = vec.size(); cout \u0026lt;\u0026lt; \u0026#34;The last element is: \u0026#34; \u0026lt;\u0026lt; vec.back() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;After pop_back(): \\n\u0026#34;; vec.pop_back(); print(vec); cout \u0026lt;\u0026lt; \u0026#34;After insert(vec.begin(), 5): \\n\u0026#34;; vec.insert(vec.begin(), 5); print(vec); cout \u0026lt;\u0026lt; \u0026#34;After erase(vec.begin()): \\n\u0026#34;; vec.erase(vec.begin()); print(vec); vec.clear(); cout \u0026lt;\u0026lt; \u0026#34;Vector size after clear(): \u0026#34; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; vector\u0026lt;int\u0026gt; v1, v2; v1.push_back(1); v1.push_back(2); v2.push_back(3); v2.push_back(4); cout \u0026lt;\u0026lt; \u0026#34;Vector 1: \u0026#34;; print(v1); cout \u0026lt;\u0026lt; \u0026#34;Vector 2: \u0026#34;; print(v2); // Swaps v1 and v2 v1.swap(v2); cout \u0026lt;\u0026lt; \u0026#34;After Swap \\nVector 1: \u0026#34;; print(v1); cout \u0026lt;\u0026lt; \u0026#34;Vector 2: \u0026#34;; print(v2); return 0; } 結果\nAfter assign(5, 10): [10, 10, 10, 10, 10] After push_back(15): [10, 10, 10, 10, 10, 15] The last element is: 15 After pop_back(): [10, 10, 10, 10, 10] After insert(vec.begin(), 5): [5, 10, 10, 10, 10, 10] After erase(vec.begin()): [10, 10, 10, 10, 10] Vector size after clear(): 0 Vector 1: [1, 2] Vector 2: [3, 4] After Swap Vector 1: [3, 4] Vector 2: [1, 2] 你可能會想繼續閱讀… 回到容器(Containers) list deque arrays forward_list ","permalink":"http://intervalrain.github.io/posts/c++/stl_vector/","summary":"vector Vectors 是一動態陣列，可以自動的調整其容器的容量。 Vector 的元素被儲存在連續的記憶體空間，所以可以使用迭代器(iterators)來進行存取。 在 vectors 中，元素是被插入在尾端的，插入尾端的時間取決於是否須進行容量的調整。 在 vectors 中，刪除尾端元素的時間複雜度則是固定的\\(O(1)\\)，因為不會發生容量調整。 在 vectors 的前端或中間插入元素或是清除元素，時間的複雜度都是\\(O(n)\\)。 迭代器(Iterators) 1. vec.begin() 回傳指向 vector 中第一個元素的迭代器 (vec[0]) 2. vec.end() 回傳指向 vector 中最後一個元素之後一個的迭代器 (vec[n+1]) 3. vec.rbegin() 回傳指向 vector 中最後一個元素的反向迭代器 (vec[n]) 4. vec.rend() 回傳指向 vector 中第一個元素之前一個的反向迭代器 (vec[-1]) 5. vec.cbegin() 回傳指向 vector 中第一個元素的常數迭代器 (vec[0]) 6. vec.cend() 回傳指向 vector 中最後一個元素之後一個的常數迭代器 (vec[n+1]) 7. vec.crbegin() 回傳指向 vector 中最後一個元素的反向常數迭代器 (vec[n]) 8. vec.crend() 回傳指向 vector 中第一個元素之前一個的反向常數迭代器 (vec[-1]) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int arr[] = {1,1,2,3,5,8,13,21,34,55}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // initialize with array cout \u0026lt;\u0026lt; \u0026#34;Output of begin() and end(): \u0026#34;; for (auto i = vec.","title":"[C++] The C++ Standard Template Library(STL) - vector"},{"content":"容器(Containers) C++ container 基本上分為四大類： Sequence containers Container adaptors Associative containers Unordered associative containers 還有兩個特殊 containers: valarray, bitset \\(\\begin{array}{|l|l|l|l|l|l|}\\hline \\text{Name}\u0026amp;\\text{Iterators}\u0026amp;\\text{Capacity}\u0026amp;\\text{Access}\u0026amp;\\text{Modifiers}\u0026amp;\\text{Others} \\\\\\hline \\text{array}\u0026amp;\\text{begin}\u0026amp;\\text{size}\u0026amp;\\text{[]}\u0026amp;\\text{swap} \\\\\u0026amp;\\text{end}\u0026amp;\\text{empty}\u0026amp;\\text{at} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{front} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{back} \\\\\\hline \\text{vector}\u0026amp;\\text{begin}\u0026amp;\\text{size}\u0026amp;\\text{[]}\u0026amp;\\text{push\\_back}\u0026amp;\\text{} \\\\\u0026amp;\\text{end}\u0026amp;\\text{empty}\u0026amp;\\text{at}\u0026amp;\\text{pop\\_back} \\\\\u0026amp;\u0026amp;\\text{capacity}\u0026amp;\\text{front}\u0026amp;\\text{insert} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{back}\u0026amp;\\text{erase} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{swap} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{clear} \\\\\\hline \\text{deque}\u0026amp;\\text{begin}\u0026amp;\\text{size}\u0026amp;\\text{[]}\u0026amp;\\text{push\\_back}\u0026amp;\\text{} \\\\\u0026amp;\\text{end}\u0026amp;\\text{empty}\u0026amp;\\text{at}\u0026amp;\\text{pop\\_back} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{front}\u0026amp;\\text{insert} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{back}\u0026amp;\\text{erase} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{swap} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{clear} \\\\\\hline \\text{list}\u0026amp;\\text{begin}\u0026amp;\\text{size}\u0026amp;\\text{front}\u0026amp;\\text{push\\_back}\u0026amp;\\text{sort} \\\\\u0026amp;\\text{end}\u0026amp;\\text{empty}\u0026amp;\\text{back}\u0026amp;\\text{pop\\_back}\u0026amp;\\text{reverse} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{insert} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{erase} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{swap} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{clear} \\\\\\hline \\text{forward\\_list}\u0026amp;\\text{begin}\u0026amp;\\text{empty}\u0026amp;\\text{front}\u0026amp;\\text{push\\_front}\u0026amp;\\text{sort} \\\\\u0026amp;\\text{end}\u0026amp;\u0026amp;\u0026amp;\\text{pop\\_back}\u0026amp;\\text{reverse} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{insert\\_after} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{erase\\_after} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{swap} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{clear} \\\\\\hline \\end{array} \\)\n基礎容器 pair 序列式容器(Sequence Containers) 特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。 vector list, forward_list deque arrays 容器適配器(Container Adaptors) 用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。 queue priority_queue stack 關聯性容器(Associative Containers) 又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。 set multiset map multimap 無序關聯容器(Unordered Associative Containers(C++11)) 通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。 unordered_set unordered_multiset unordered_map unordered_mutlimap 你可能會想繼續閱讀… 演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library ","permalink":"http://intervalrain.github.io/posts/c++/stl_container/","summary":"容器(Containers) C++ container 基本上分為四大類： Sequence containers Container adaptors Associative containers Unordered associative containers 還有兩個特殊 containers: valarray, bitset \\(\\begin{array}{|l|l|l|l|l|l|}\\hline \\text{Name}\u0026amp;\\text{Iterators}\u0026amp;\\text{Capacity}\u0026amp;\\text{Access}\u0026amp;\\text{Modifiers}\u0026amp;\\text{Others} \\\\\\hline \\text{array}\u0026amp;\\text{begin}\u0026amp;\\text{size}\u0026amp;\\text{[]}\u0026amp;\\text{swap} \\\\\u0026amp;\\text{end}\u0026amp;\\text{empty}\u0026amp;\\text{at} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{front} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{back} \\\\\\hline \\text{vector}\u0026amp;\\text{begin}\u0026amp;\\text{size}\u0026amp;\\text{[]}\u0026amp;\\text{push\\_back}\u0026amp;\\text{} \\\\\u0026amp;\\text{end}\u0026amp;\\text{empty}\u0026amp;\\text{at}\u0026amp;\\text{pop\\_back} \\\\\u0026amp;\u0026amp;\\text{capacity}\u0026amp;\\text{front}\u0026amp;\\text{insert} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{back}\u0026amp;\\text{erase} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{swap} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{clear} \\\\\\hline \\text{deque}\u0026amp;\\text{begin}\u0026amp;\\text{size}\u0026amp;\\text{[]}\u0026amp;\\text{push\\_back}\u0026amp;\\text{} \\\\\u0026amp;\\text{end}\u0026amp;\\text{empty}\u0026amp;\\text{at}\u0026amp;\\text{pop\\_back} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{front}\u0026amp;\\text{insert} \\\\\u0026amp;\u0026amp;\u0026amp;\\text{back}\u0026amp;\\text{erase} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{swap} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{clear} \\\\\\hline \\text{list}\u0026amp;\\text{begin}\u0026amp;\\text{size}\u0026amp;\\text{front}\u0026amp;\\text{push\\_back}\u0026amp;\\text{sort} \\\\\u0026amp;\\text{end}\u0026amp;\\text{empty}\u0026amp;\\text{back}\u0026amp;\\text{pop\\_back}\u0026amp;\\text{reverse} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{insert} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{erase} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{swap} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{clear} \\\\\\hline \\text{forward\\_list}\u0026amp;\\text{begin}\u0026amp;\\text{empty}\u0026amp;\\text{front}\u0026amp;\\text{push\\_front}\u0026amp;\\text{sort} \\\\\u0026amp;\\text{end}\u0026amp;\u0026amp;\u0026amp;\\text{pop\\_back}\u0026amp;\\text{reverse} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{insert\\_after} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{erase\\_after} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{swap} \\\\\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\text{clear} \\\\\\hline \\end{array} \\)\n基礎容器 pair 序列式容器(Sequence Containers) 特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。 vector list, forward_list deque arrays 容器適配器(Container Adaptors) 用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。 queue priority_queue stack 關聯性容器(Associative Containers) 又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。 set multiset map multimap 無序關聯容器(Unordered Associative Containers(C++11)) 通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。 unordered_set unordered_multiset unordered_map unordered_mutlimap 你可能會想繼續閱讀… 演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library ","title":"[C++] The C++ Standard Template Library(STL) - Container"},{"content":"前言 在做 WAT 量測後的資料處理時，IDAS 老舊的 VBA macro 執行時間實在過於久，且佔用大量的記憶體，於是就下了一個命題，想減少產生報表的時間。 想法 通常量測多片 wafer 的狀況下，不同 wafer 的排列順序是一致的，如果可以加入 Java 中 HashMap 的資料結構來處理 VBA 中 Lookup()，便可大幅減少 summary table 時，對 rawdata 做搜尋的時間。 令時間複雜度從\\(O(n)\\)進步到\\(O(1)\\)。 做法 產生 Dictionary 物件 由於 VBA 預設並沒有 Dictionary 的物，所以需要用 CreateObject(\u0026quot;Scritping.Dictionary\u0026quot;) 的程式碼，引入 Dictionary。 其 Dictionary 物件的 method 可參考 Microsoft 的文件：點此 在此先預先定義一個 function setDict() 可以對初始化 Dictionary。 接著宣告兩個 Dictionary 物件來存取 spec 和 data 工作頁的列數(\u0008row)。 Dim SpecDict As Object \u0026#39; Claim a dict to store spec rows in worksheet SPEC. Dim DataDict As Object \u0026#39; Claim a dict to store rawdata rows in worksheet Data. Set SpecDict = CreateObject(\u0026#34;Scripting.Dictionary\u0026#34;) Set DataDict = CreateObject(\u0026#34;Scripting.Dictionary\u0026#34;) Call setDict(\u0026#34;SPEC\u0026#34;, 3, SpecDict, Worksheets(\u0026#34;SPEC\u0026#34;).UsedRange, True) Call setDict(\u0026#34;Data\u0026#34;, 2, DataDict, Range(Worksheets(\u0026#34;Data\u0026#34;).Names(1)), True) 實作 setDict() 函數 利用 HashTable 的概念對不同的 parameter 列數先做一次記錄，因為只需一次迴圈，故時間複雜度是 \\(O(n)\\)，其中 n = SPEC 的列數 或是 量測的 parameter 數。 在此設計了五個 arguments，方便在未來如果還有使用到 Dictionary 的需求時，可以方便使用。 sheetName 字串，需要作儲存的工作頁(worksheet)。 Target 要儲存的列數(row)或欄數(column)。 Dict 要存放的 Dictionary 物件。 mRange 要做儲存的資料範圍，若表頭並是在第一列或第一欄時可指定。 若表頭是第一列或第一欄時，可直接代入 Worksheets(\u0026quot;工作頁名稱\u0026quot;).UsedRange byRows 看要儲存的對象是列(row)或是欄(column)，預設是以列來搜尋。 Public Function setDict(ByVal sheetName As String, ByVal Target As Integer, ByRef Dict As Object, ByVal mRange As Range, Optional ByVal byRows As Boolean = True) Dim nowSheet As Worksheet If Not IsExistSheet(sheetName) Then Exit Function Set nowSheet = Worksheets(sheetName) Dim i As Long Dim n As Long On Error Resume Next If byRows = True Then For i = 1 To mRange.Rows.Count If Not Trim(mRange.Cells(i, Target).Value) = \u0026#34;\u0026#34; Then Dict.Add mRange.Cells(i, Target).Value, i End If Next i Else For i = 1 To mRange.Columns.Count If Not Trim(mRange.Cells(Target, i).Value) = \u0026#34;\u0026#34; Then Dict.Add mRange.Cells(Target, i).Value, i End If Next i End If End Function 對 getSPECByPara() 做重製 將 parameter or SPEC 做 hashing 的處理後，可以用 Dictionary 物件來查值，時間複雜度為 \\(O(1)\\)。 在此不對原本的設計做更動，只做單純的 implement。 nowPara 要搜尋的 parameter 字串。 n 要搜尋的欄數(column)，specColumn是原作者預設的 enum，存放工作頁 SPEC 的每一欄的表頭。 \u0008sheetName 要搜尋的工作頁，預設為 SPECTEMP，是按完 initial，從 SPEC 工作頁複製出來的隱藏工作頁。 Public Function getSPECByPara(ByVal nowPara As String, ByVal n As specColumn, Optional sheetName As String = \u0026#34;SPECTEMP\u0026#34;) Dim reValue Dim nowRange As Range Dim TargetSheet As Worksheet If Left(nowPara, 1) = \u0026#34;\u0026#39;\u0026#34; Then nowPara = Mid(nowPara, 2) Set TargetSheet = Worksheets(sheetName) Set nowRange = TargetSheet.UsedRange On Error Resume Next reValue = TargetSheet.Cells(SpecDict(nowPara), n) If Not IsEmpty(reValue) Then If Trim(reValue) = \u0026#34;\u0026#34; Then Set reValue = Nothing End If getSPECByPara = reValue End Function 對 getRangeByPara() 做重製 將 parameter or SPEC 做 hashing 的處理後，可以用 Dictionary 物件來查值，時間複雜度為 \\(O(1)\\)。 Public Function getRangeByPara(nowWafer As String, nowPara As String, Optional dieNum As Integer = 0) Dim nowRow As Long Dim nowRange As Range Set nowRange = Worksheets(\u0026#34;Data\u0026#34;).Range(\u0026#34;wafer_\u0026#34; \u0026amp; nowWafer) Set getRangeByPara = Nothing If DataDict.Exists(nowPara) Then nowRow = DataDict(nowPara) Set getRangeByPara = nowRange.Range(N2L(4) \u0026amp; CStr(nowRow) \u0026amp; \u0026#34;:\u0026#34; \u0026amp; N2L(dieNum + 3) \u0026amp; CStr(nowRow)) End If End Function 解析 優點：較快的執行速度。經測試可以將 2~3 分鐘的執行時間縮短到 30 秒內。 缺點：若修改 rawdata，會發生錯誤。但若針對每一片 wafer 都做 setDict()的話，會浪費太多 memory。 ","permalink":"http://intervalrain.github.io/posts/vba/idas+_record/","summary":"前言 在做 WAT 量測後的資料處理時，IDAS 老舊的 VBA macro 執行時間實在過於久，且佔用大量的記憶體，於是就下了一個命題，想減少產生報表的時間。 想法 通常量測多片 wafer 的狀況下，不同 wafer 的排列順序是一致的，如果可以加入 Java 中 HashMap 的資料結構來處理 VBA 中 Lookup()，便可大幅減少 summary table 時，對 rawdata 做搜尋的時間。 令時間複雜度從\\(O(n)\\)進步到\\(O(1)\\)。 做法 產生 Dictionary 物件 由於 VBA 預設並沒有 Dictionary 的物，所以需要用 CreateObject(\u0026quot;Scritping.Dictionary\u0026quot;) 的程式碼，引入 Dictionary。 其 Dictionary 物件的 method 可參考 Microsoft 的文件：點此 在此先預先定義一個 function setDict() 可以對初始化 Dictionary。 接著宣告兩個 Dictionary 物件來存取 spec 和 data 工作頁的列數(\u0008row)。 Dim SpecDict As Object \u0026#39; Claim a dict to store spec rows in worksheet SPEC.","title":"[IDAS+] Optimize Summary Table Function"},{"content":"cout Functions 設定顯示小數點位數 setprecision(int n) and fixed #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main(){ double a = 5.43/2.653; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.04674 cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; fixed; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.047 return 0; } 顯示 Boolean 值 std::boolalpha #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ bool a = true; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; std::boolalpha; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // true return 0; } ","permalink":"http://intervalrain.github.io/posts/c++/cout/","summary":"cout Functions 設定顯示小數點位數 setprecision(int n) and fixed #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main(){ double a = 5.43/2.653; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.04674 cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; fixed; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.047 return 0; } 顯示 Boolean 值 std::boolalpha #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ bool a = true; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; std::boolalpha; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // true return 0; } ","title":"[C++] Cout functions"},{"content":"演算法(Algorithms) Non-Manupulating Algorithms 1. sort() sort(first_iterator, last_iterator) 對 vector 作排序 2. reverse() reverse(first_iterator, last_iterator) 反轉 vector 的排序 3. *max_element() *max_element(first_iterator, last_iterator) 找出 vector 的最大值 4. *min_element() *min_element(first_iterator, last_iterator)` 找出 vector 的最小值 5. accumulate accumulate(first_iterator, last_iterator, initial value of sum) 計算 vector 的總和 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; using namespace std; void print(vector\u0026lt;int\u0026gt;\u0026amp; vec){ for (vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it != vec.end(); it++){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main(){ int arr[] = {10, 20, 5, 23, 42, 15}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // print initial vector print(vec); // [10, 20, 5, 23, 42, 15] // sort sort(vec.begin(), vec.end()); // [5, 10, 15, 20, 23, 42] print(vec); // reverse reverse(vec.begin(), vec.end()); // [42, 23, 20, 15, 10, 5] print(vec); // max \u0026amp; min cout \u0026lt;\u0026lt; *max_element(vec.begin(), vec.end()) \u0026lt;\u0026lt; endl; // 42 cout \u0026lt;\u0026lt; *min_element(vec.begin(), vec.end()) \u0026lt;\u0026lt; endl; // 5 // accumulate cout \u0026lt;\u0026lt; accumulate(vec.begin(), vec.end(), 0) \u0026lt;\u0026lt; endl; // 115 return 0; } 6. count() count(first_iterator, last_iterator, x) 計算 vector 中 x 的數量 7. find() find(fist_iterator, last_iterator, x) 回傳 vector 中第一個符合的 iterator，若無則傳回 v.end()。 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int arr[] = {10, 20, 5, 23 ,42, 20, 15}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); cout \u0026lt;\u0026lt; count(vec.begin(), vec.end(), 20); // 2 find(vec.begin(), vec.end(),5) != vec.end() ? // Element found cout \u0026lt;\u0026lt; \u0026#34;\\nElement found\u0026#34;: cout \u0026lt;\u0026lt; \u0026#34;\\nElement not found\u0026#34;; return 0; } 8. binary_search() binary_search(first_iterator, last_iterator, x) 測試 x 是否存在已排序的 vector 中 9. lower_bound() lower_bound(first_iterator, last_iterator, x) 傳回指向不大於 x 的元素的 iterator 10. upper_bound() upper_bound(first_iterator, last_iterator, x) 傳回指向大於 x 的元素的 iterator #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ int arr[] = {5, 10, 15, 20, 20, 23, 42, 45}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); sort(vec.begin(), vec.end()); cout \u0026lt;\u0026lt; binary_search(vec.begin(), vec.end(), 20) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; (lower_bound(vec.begin(), vec.end(), 20) - vec.begin()) \u0026lt;\u0026lt; endl; // 3 cout \u0026lt;\u0026lt; (upper_bound(vec.begin(), vec.end(), 20) - vec.begin()) \u0026lt;\u0026lt; endl; // 5 return 0; } Manipulating Algorithms 1. vec.erase() arr.erase(position_to_be_deleted) 移除指定位置的元素 2. vec.erase(unique()) arr.erase(unique(arr.begin(), arr.end()), arr.end()) 移除已排序的 vector 中重複的元素 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ int arr[] = {5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // [5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20] vec.erase(vec.begin() + 1); // [5, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20] sort(vec.begin(), vec.end()); // [5, 15, 20, 20, 20, 20, 20, 20, 20, 23, 42, 45] vec.erase(unique(vec.begin(), vec.end()), vec.end()); // [5, 15, 20, 23, 42, 45] return 0; } 3. next_permutation() next_permutation(first_iterator, last_iterator) 對 vector 作動成下一個字典排序 4. prev_permutation() prev_permutation(first_iterator, last_iterator) 對 vector 作動成上一個字典排序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ int arr[] = {1,2,3,4,5,6,7}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // [1,2,3,4,5,6,7] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,5,7,6] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,5,7] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5] next_permutation(vec.begin(), vec.end()); // [1,2,3,4,7,5,6] prev_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5] return 0; } 5. distance() distance(first_iterator, last_iterator) #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026#34;print.cc\u0026#34; using namespace std; int main(){ int arr[] = {5\u0008,10,15,20,20,23,42,45}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); cout \u0026lt;\u0026lt; distance(vec.begin(), max_element(vec.begin(), vec.end())) \u0026lt;\u0026lt; endl; // 7 // == max_element(vec.begin(), vec.end()) - vec.begin(); return 0; } Array algorithms 1. any_of() any_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否有任何元素滿足條件 2. all_of() all(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否有全部元素滿足條件 3 none_of() none_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; vector 中是否沒有元素滿足條件 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec1 {1,3,7,9,11,17,23}; all_of(vec1.begin(), vec1.end(), [](int x) { return (x \u0026amp; 1) == 1;}) ? cout \u0026lt;\u0026lt; \u0026#34;All odds\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;Not all odds\\n\u0026#34;; vector\u0026lt;int\u0026gt; vec2 {1,3,6,8,9,11,13}; any_of(vec2.begin(), vec2.end(), [](int x) { return (x \u0026amp; 1) == 0;}) ? cout \u0026lt;\u0026lt; \u0026#34;There are at least one even\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;There are no any even\\n\u0026#34;; none_of(vec1.begin(), vec1.end(), [](int x) { return (x \u0026amp; 1) == 0;}) ? cout \u0026lt;\u0026lt; \u0026#34;There are no any even\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;There are at least one even\\n\u0026#34;; return 0; } 4. copy_n() copy_n(source_array, array_size, target_array) 複製陣列 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main(){ int arr[] = {1,2,3,4,5,6}; int arr2[6]; copy_n(arr, 6, arr2); for (int i : arr2){ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 5. iota() iota(array_name, array_size, starting_number) 逐一增加並寫入指定大小的陣列 // C++ code to demonstrate working of iota() #include\u0026lt;iostream\u0026gt; #include\u0026lt;numeric\u0026gt; // for iota() using namespace std; int main(){ // Initializing array with 0 values int ar[6] = {0}; // Using iota() to assign values iota(ar, ar+6, 20); // Displaying the new array cout \u0026lt;\u0026lt; \u0026#34;The new array after assigning values is : \u0026#34;; for (int i=0; i\u0026lt;6 ; i++) cout \u0026lt;\u0026lt; ar[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } Partition operations C++ 在標準模板資料庫(STL)中有一個 class 可以來做 partition 的演算法。 Partition 就是用來將容器裡面的元素依指定的條件做分隔。 1. partition() partition(begin, end, conditon) 依照指定條件做分隔。 2. is_partition() is_partitioned(begin, end, condition 判斷元素是否依照條件分開。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec = {2,1,5,6,8,7}; is_partitioned(vec.begin(), vec.end(), [](int x){ return x % 2 == 0; }) ? cout \u0026lt;\u0026lt; \u0026#34;Vector is partitioned\u0026#34;: cout \u0026lt;\u0026lt; \u0026#34;Vector is not partitioned\u0026#34;; cout \u0026lt;\u0026lt; endl; partition(vec.begin(), vec.end(), [](int x){ return x % 2 == 0; }) ? cout \u0026lt;\u0026lt; \u0026#34;The partitioned vector is : \u0026#34;; for (int \u0026amp;x : vec) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 3. stable_partition() stable_partition(begin, end, condition) 依指定條件作分隔，同時保留元素的相對位置。 4. partition_point() partition_point(begin, end, condition) 返回指向分隔位置的迭代器，也就是在 [begin, end] 範圍內的第一個元素。 This function returns an iterator pointing to the partition point of container i.e. the first element in the partitioned range [beg,end) for which condition is not true. The container should already be partitioned for this function to work. // C++ code to demonstrate the working of // stable_partition() and partition_point() #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; // for partition algorithm #include\u0026lt;vector\u0026gt; // for vector using namespace std; int main() { // Initializing vector vector\u0026lt;int\u0026gt; vect = { 2, 1, 5, 6, 8, 7 }; // partitioning vector using stable_partition() // in sorted order stable_partition(vect.begin(), vect.end(), [](int x) { return x%2 == 0;\t}); // Displaying partitioned Vector cout \u0026lt;\u0026lt; \u0026#34;The partitioned vector is : \u0026#34;; for (int \u0026amp;x : vect) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // Declaring iterator vector\u0026lt;int\u0026gt;::iterator it1; // using partition_point() to get ending position of partition auto it = partition_point(vect.begin(), vect.end(), [](int x) { return x%2==0; }); // Displaying partitioned Vector cout \u0026lt;\u0026lt; \u0026#34;The vector elements returning true for condition are : \u0026#34;; for ( it1= vect.begin(); it1!=it; it1++) cout \u0026lt;\u0026lt; *it1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 5. partition_copy() partition_copy(begin, end, begin1, begin2, condition) This function copies the partitioned elements in the different containers mentioned in its arguments. It takes 5 arguments. Beginning and ending position of container, beginning position of new container where elements have to be copied (elements returning true for condition), beginning position of new container where other elements have to be copied (elements returning false for condition) and the condition. Resizing new containers is necessary for this function. // C++ code to demonstrate the working of // partition_copy() #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; // for partition algorithm #include\u0026lt;vector\u0026gt; // for vector using namespace std; int main() { // Initializing vector vector\u0026lt;int\u0026gt; vect = { 2, 1, 5, 6, 8, 7 }; // Declaring vector1 vector\u0026lt;int\u0026gt; vect1; // Declaring vector1 vector\u0026lt;int\u0026gt; vect2; // Resizing vectors to suitable size using count_if() and resize() int n = count_if (vect.begin(), vect.end(), [](int x) { return x%2==0; } ); vect1.resize(n); vect2.resize(vect.size()-n); // Using partition_copy() to copy partitions partition_copy(vect.begin(), vect.end(), vect1.begin(), vect2.begin(), [](int x) { return x%2==0; }); // Displaying partitioned Vector cout \u0026lt;\u0026lt; \u0026#34;The elements that return true for condition are : \u0026#34;; for (int \u0026amp;x : vect1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // Displaying partitioned Vector cout \u0026lt;\u0026lt; \u0026#34;The elements that return false for condition are : \u0026#34;; for (int \u0026amp;x : vect2) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } Numeric algorithms 1. apply() apply([](int x){return operation;}) 對陣列所有元素做運算 2. arr.sum() arr.sum() 計算陣列所有元素的總合 // C++ code to demonstrate the working of // apply() and sum() #include\u0026lt;iostream\u0026gt; #include\u0026lt;valarray\u0026gt; // for valarray functions using namespace std; int main() { // Initializing valarray valarray\u0026lt;int\u0026gt; varr = { 10, 2, 20, 1, 30 }; // Declaring new valarray valarray\u0026lt;int\u0026gt; varr1 ; // Using apply() to increment all elements by 5 varr1 = varr.apply([](int x){return x=x+5;}); // Displaying new elements value cout \u0026lt;\u0026lt; \u0026#34;The new valarray with manipulated values is : \u0026#34;; for (int \u0026amp;x: varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // Displaying sum of both old and new valarray cout \u0026lt;\u0026lt; \u0026#34;The sum of old valarray is : \u0026#34;; cout \u0026lt;\u0026lt; varr.sum() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;The sum of new valarray is : \u0026#34;; cout \u0026lt;\u0026lt; varr1.sum() \u0026lt;\u0026lt; endl; return 0; } 3. arr.min() arr.min() 傳回陣列中最小的元素 4. arr.max() arr.max() 傳回陣列中最大的元素 // C++ code to demonstrate the working of // max() and min() #include\u0026lt;iostream\u0026gt; #include\u0026lt;valarray\u0026gt; // for valarray functions using namespace std; int main() { // Initializing valarray valarray\u0026lt;int\u0026gt; varr = { 10, 2, 20, 1, 30 }; // Displaying largest element of valarray cout \u0026lt;\u0026lt; \u0026#34;The largest element of valarray is : \u0026#34;; cout \u0026lt;\u0026lt; varr.max() \u0026lt;\u0026lt; endl; // Displaying smallest element of valarray cout \u0026lt;\u0026lt; \u0026#34;The smallest element of valarray is : \u0026#34;; cout \u0026lt;\u0026lt; varr.min() \u0026lt;\u0026lt; endl; return 0; } 5. arr.shift() \u0008arr.shift(int n) 對陣列做 n 個位的移動，正為向右移，負為向左移，缺位補零。 6. cshift() arr.cshift(int n) 對陣列做 n 個位的移動，正為向右移，負為向左移，缺位使用循環補位。 // C++ code to demonstrate the working of // shift() and cshift() #include\u0026lt;iostream\u0026gt; #include\u0026lt;valarray\u0026gt; // for valarray functions using namespace std; int main() { // Initializing valarray valarray\u0026lt;int\u0026gt; varr = { 10, 2, 20, 1, 30 }; // Declaring new valarray valarray\u0026lt;int\u0026gt; varr1; // using shift() to shift elements to left // shifts valarray by 2 position varr1 = varr.shift(2); // Displaying elements of valarray after shifting cout \u0026lt;\u0026lt; \u0026#34;The new valarray after shifting is : \u0026#34;; for ( int\u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // using cshift() to circulary shift elements to right // rotates valarray by 3 position varr1 = varr.cshift(-3); // Displaying elements of valarray after circular shifting cout \u0026lt;\u0026lt; \u0026#34;The new valarray after circular shifting is : \u0026#34;; for ( int\u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0; } 7. arr1.swap(arr2) arr1.swap(arr2) 陣列做交換 // C++ code to demonstrate the working of // swap() #include\u0026lt;iostream\u0026gt; #include\u0026lt;valarray\u0026gt; // for valarray functions using namespace std; int main(){ // Initializing 1st valarray valarray\u0026lt;int\u0026gt; varr1 = {1, 2, 3, 4}; // Initializing 2nd valarray valarray\u0026lt;int\u0026gt; varr2 = {2, 4, 6, 8}; // Displaying valarrays before swapping cout \u0026lt;\u0026lt; \u0026#34;The contents of 1st valarray \u0026#34; \u0026#34;before swapping are : \u0026#34;; for (int \u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;The contents of 2nd valarray \u0026#34; \u0026#34;before swapping are : \u0026#34;; for (int \u0026amp;x : varr2) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; // Use of swap() to swap the valarrays varr1.swap(varr2); // Displaying valarrays after swapping cout \u0026lt;\u0026lt; \u0026#34;The contents of 1st valarray \u0026#34; \u0026#34;after swapping are : \u0026#34;; for (int \u0026amp;x : varr1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;The contents of 2nd valarray \u0026#34; \u0026#34;after swapping are : \u0026#34;; for (int \u0026amp;x : varr2) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; return 0;\t} 你可能會想繼續閱讀… 容器(Containers) 函式(Functions) 迭代器(Iterators) Utility Library ","permalink":"http://intervalrain.github.io/posts/c++/stl_algo/","summary":"演算法(Algorithms) Non-Manupulating Algorithms 1. sort() sort(first_iterator, last_iterator) 對 vector 作排序 2. reverse() reverse(first_iterator, last_iterator) 反轉 vector 的排序 3. *max_element() *max_element(first_iterator, last_iterator) 找出 vector 的最大值 4. *min_element() *min_element(first_iterator, last_iterator)` 找出 vector 的最小值 5. accumulate accumulate(first_iterator, last_iterator, initial value of sum) 計算 vector 的總和 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; using namespace std; void print(vector\u0026lt;int\u0026gt;\u0026amp; vec){ for (vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it != vec.end(); it++){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } int main(){ int arr[] = {10, 20, 5, 23, 42, 15}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vec(arr, arr + n); // print initial vector print(vec); // [10, 20, 5, 23, 42, 15] // sort sort(vec.","title":"[C++] The C++ Standard Template Library(STL) - Algorithm"},{"content":"STL \u0008標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。\nSTL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。\nSTL 的四大組成 演算法(Algorithms) 容器(Containers) 函式(Functions) 迭代器(Iterators) 補充 Utility Library ","permalink":"http://intervalrain.github.io/posts/c++/stl/","summary":"STL \u0008標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。\nSTL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。\nSTL 的四大組成 演算法(Algorithms) 容器(Containers) 函式(Functions) 迭代器(Iterators) 補充 Utility Library ","title":"[C++] The C++ Standard Template Library(STL)"},{"content":"vector 的介紹 vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include \u0026lt;vector\u0026gt; vector 的使用 建構式 constructor vector\u0026lt;int\u0026gt; v1; // 不進行初始化 vector\u0026lt;int\u0026gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector\u0026lt;int\u0026gt; v3(v2); // 利用vector初始化 vector\u0026lt;int\u0026gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector\u0026lt;int\u0026gt; v5(3, 0); // 含有3個0的vector 談一下特殊的二維vector，其實就是二維矩陣，寫法為 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vv(3, vector\u0026lt;int\u0026gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse 遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。 vector\u0026lt;int\u0026gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3}; // 1. iterator vector\u0026lt;int\u0026gt;::iterator it = v.begin(); while (it != v.end()){ cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; it++; } cout \u0026lt;\u0026lt; endl; // 2. for loop for (int e : v){ cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } // 3. [] for (size_t i = 0; i \u0026lt; v.size(); ++i){ cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } 資料的資刪查改 \\( \\def\\arraystrecth{1.4}\\begin{array}{|l|l|}\\hline \\text{methods}\u0026amp;\\text{description}\\\\\\hline\\hline \\text{push\\_back}\u0026amp;\\text{Add element at the end}\\\\\\hline \\text{pop\\_back}\u0026amp;\\text{Delete last element}\\\\\\hline \\text{insert}\u0026amp;\\text{Insert elements}\\\\\\hline \\text{erase}\u0026amp;\\text{Erase elements}\\\\\\hline \\end{array} \\)\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vec; vec.push_back(0); [0] vec.push_back(1); [0,1] vec.push_back(3); [0,1,3] vec.push_back(4); [0,1,3,4] vec.pop_back(); [0,1,3] vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); vec.insert(it + 2, 2); // 在下標為1的位置，插入2 [0,1,2,3] vec.erase(it); [1,2,3] return 0; } resize 和 reserve int main(){ cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 0 cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 0 v.resize(30); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30 cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30 v.reservse(50); cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30 cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 50 } vector 的實作 member variables template \u0026lt;class T\u0026gt; class myVector{ private: size_t _size; // 儲存現有 elements 的數目 size_t _capacity; // 此時陣列所有的最大容量 public: T* arr; // 儲存 elements 的陣列指標 }; 建構式 constructor public: // 無引數的初始化 myVector(){ this-\u0026gt;_size = 0; this-\u0026gt;_capacity = DEFAULT_CAPACITY; this-\u0026gt;arr = new int[this-\u0026gt;_capacity]; } // 指定容量的初始化 myVector(int capacity){ this-\u0026gt;_size = 0; this-\u0026gt;_capacity = capacity; this-\u0026gt;arr = new int[this-\u0026gt;capacity]; } // 以另一個 myVector 初始化 myVector(const myVector\u0026lt;T\u0026gt;\u0026amp; v): _size(v.size), _capacity(v._capacity) { this-\u0026gt;reserve(v.capacity); for (size_t i = 0; i \u0026lt; v._size; ++i){ this-\u0026gt;push_back(v[i]); } } // 填滿 n 個 val 的初始化 myVector(size_t n, T val): _size(n), _capacity(n) { this-\u0026gt;arr = new int[this-\u0026gt;_capacity]; for (size_t i = 0; i \u0026lt; n; ++i){ this-\u0026gt;arr[i] = val; } } 解構式 destructor public: ~myVector(){ // 將原有的陣列丟棄 delete[] this-\u0026gt;arr; } 運算子多載 operator overload public: // 令 myVector 可讀可寫 T\u0026amp; operator[](size_t i){ assert (i \u0026lt; this-\u0026gt;_size); return this-\u0026gt;arr[i]; } 函式 Methods public: // 回傳 vector 元素的數目 size_t size(){ return this-\u0026gt;_size; } // 回傳當前 vector 的容量 size_t capacity(){ return this-\u0026gt;_capacity; } // 回傳指向陣列的下標 0 位置 T* begin(){ return this-\u0026gt;arr; } // 回傳指向陣列的最末位 + 1 T* end(){ return this-\u0026gt;arr + this-\u0026gt;_size; } const T* begin() const{ return this-\u0026gt;arr; } const T* end() const{ return this-\u0026gt;arr + this-\u0026gt;_size; } // 回傳此 myVector 是否含有元素 bool isEmpty(){ return this-\u0026gt;_size == 0; } reserve 和 resize public: // force to resize with a n capacity void reserve(size_t n){ if (n \u0026gt; this-\u0026gt;_capacity){ T* tmp = new T[n]; if (arr != nullptr){ for (size_t i = 0; i \u0026lt; this-\u0026gt;_size; ++i){ tmp[i] = this-\u0026gt;arr[i]; } delete[] this-\u0026gt;arr; } this-\u0026gt;arr = tmp; _capacity = n; } } // expand the capacity while adding elements void resize(){ this-\u0026gt;_capacity *= 2; int* tmp = new int[this-\u0026gt;_capacity]; for (size_t i = 0; i \u0026lt; this-\u0026gt;_size; ++i){ tmp[i] = this-\u0026gt;arr[i]; } delete[] this-\u0026gt;arr; this-\u0026gt;arr = tmp; } 資料的增刪查改 public: // adding elements in the last of vector void push_back(T val){ if (this-\u0026gt;_capacity \u0026lt; this-\u0026gt;_size + 1) resize(); this-\u0026gt;arr[this-\u0026gt;_size] = val; this-\u0026gt;_size++; } // remove elements in the last of vector T pop_back(){ assert(!this-\u0026gt;isEmpty()); T tmp = *(this-\u0026gt;end()-1); this-\u0026gt;_size--; return tmp; } // insert element by the index. void insert(size_t i, T val){ assert (i \u0026lt;= this-\u0026gt;_size); if (this-\u0026gt;_size + 1 \u0026gt; this-\u0026gt;capacity()) resize(); int* ptr = this-\u0026gt;begin() + i; for (int* it = this-\u0026gt;end(); it != ptr; --it) *it = *(it - 1); *ptr = val; this-\u0026gt;_size++; } //erase element by the index T erase(size_t i){ assert(i \u0026lt; this-\u0026gt;_size); int* it = this-\u0026gt;begin() + i; T tmp = *it; for (; it != this-\u0026gt;end(); ++it){ *it = *(it + 1); } this-\u0026gt;_size--; return tmp; } Reference: 有解無憂 UJ5U.com\n","permalink":"http://intervalrain.github.io/posts/c++/vector/","summary":"vector 的介紹 vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include \u0026lt;vector\u0026gt; vector 的使用 建構式 constructor vector\u0026lt;int\u0026gt; v1; // 不進行初始化 vector\u0026lt;int\u0026gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector\u0026lt;int\u0026gt; v3(v2); // 利用vector初始化 vector\u0026lt;int\u0026gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector\u0026lt;int\u0026gt; v5(3, 0); // 含有3個0的vector 談一下特殊的二維vector，其實就是二維矩陣，寫法為 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vv(3, vector\u0026lt;int\u0026gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse 遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。 vector\u0026lt;int\u0026gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3}; // 1.","title":"[C++] STL: Vector 的使用與實作"},{"content":"TCAD 常用的三種程式語言 工具語言 用於操作 Sentaurus 工具的指令，例如： snmesh sdevice 預處理語言 Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro) 例如： #define __x__ 1 // 將所有 __x__ 字串取代成字串 1 TCL 公用語言，通常用來處理字串與數據。 範例 SPP 語言：@...@、#開頭的敘述都是 SPP 語言 #if \u0026#34;@tunneling@ == \u0026#34;Hurkx\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1_5\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E2\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif TCL 語言：set 與 puts 其中 @\u0026hellip;@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 .cmd 檔。 set A [expr -@BF_Thick@-@AB_Thick@-@GR_Thick@-@CH_Thick@-@ML_Thick@] puts \u0026#34;DOE: Xmin [format %.2f $A]\u0026#34; ","permalink":"http://intervalrain.github.io/posts/device/tcad/","summary":"TCAD 常用的三種程式語言 工具語言 用於操作 Sentaurus 工具的指令，例如： snmesh sdevice 預處理語言 Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro) 例如： #define __x__ 1 // 將所有 __x__ 字串取代成字串 1 TCL 公用語言，通常用來處理字串與數據。 範例 SPP 語言：@...@、#開頭的敘述都是 SPP 語言 #if \u0026#34;@tunneling@ == \u0026#34;Hurkx\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1_5\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E2\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif TCL 語言：set 與 puts 其中 @\u0026hellip;@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 .","title":"[TCAD] 工具語言"},{"content":"計算機的抽象化與科技 1.1 簡介 有賴於科技高速的成長，計算機工業出現了嶄新的型態，計算機導致了文明的第三次革命-資訊革命，與農業革命和工業革命並駕齊驅。如科幻電影般的生活應用，也如雨後出筍般的出現。 汽車 手機 人類基因組計劃(Human genome project) 全球網路(World Wide Web) 搜尋引擎 計算機的應用分類與其特性 個人電腦(Personal Computer, PCs) 伺服器(Servers) 通過網路連接其它的工作站或電腦，通常面向單一且複雜大型的科學或工程應用，也可能是多而小的工作。 成本和功能的差異性也最廣，可以是沒有螢幕沒有鍵盤的桌電，也可以是如超級計算機(supercomputers)這樣的極端。 嵌入式計算機(Embedded Computers) 最大的計算機類別，也涵蓋最廣泛的應用和性能。 通常具有獨特的應用要求，這些要求將最低效能發揮的淋漓盡致，使成本與功耗成為很重要的指標。 後PC時代 個人行動裝置(Poersonal Mobile Device, PMD) 如智慧型手機與平板的出現，取代的 PC 的地位。 雲端計算(Cloud Computing) 取代了傳統伺服器，這些雲端計算建構在「倉庫規模計算機」(Warehouse Scale Computer, WSC)。 企業如Google、Amazon，提供了 WSC 的租借服務，這類通過雲端佈署的「軟體即服務」(Software as a Service, SaaS)，正在改變軟體業。 學習目標 過去在硬體的限制下，程式設計師需要嚴格的考慮程式的效能：減少記憶體空間以使程式更快。 在計算機設計與記憶體科技的進步下，取而代之程式設計師要考量的事情變成：處理器的並行性和記憶體的分層，或諸如在 PMD 或雲端上運行的程式的能源效率問題。 以下是我們將要學習的目標： 用高級語言編寫的程式如何翻譯成硬體語言，以及硬體如何執行生成的程式？藉此可以理解硬體與軟體的關係，也與程式的性能有關聯。 軟體和硬體間的介面是什麼，軟體如何指示硬體執行所需的工作？這些概念對於理解如何編寫多種軟體至關重要。 什麼決定了一個程式的性能，程式設計師如何提高性能？這關係了源始碼編譯成電腦的語言時，硬體執行程式的效率。 硬體設計人員可以使用哪些技術來提高性能(Performance)？ 硬體設計人員可以使用哪些技術來提升能源效率(Energy Efficiency)？程式設計師又如何協助改善？ 什麼理由導致了循序處理(Sequential processing)轉變成了平行處理(Parallel processing)？ 自第一台商用計算機問世以來，計算機架構師提出了哪些想法來奠定現代計算的基礎？ 1.2 計結中八個重要的思想 摩爾定律(Moore\u0026rsquo;s Law)之於設計 摩爾定律源於 Intel 創辦人之一的 Gordon Moore 對 IC 容量增長的預測。 由於計算機設計需耗時數年，而晶片的成長使得計算機架構師在設計時，必須將眼光放到設計完成時的技術狀態，而非當下。 用抽象化(Abstraction)來簡化設計 程式設計師與計算機架構師都必須要不斷發明新的技術以面對日益更新的科技， 抽象化是一種分層設計的概念。對程式設計師而言，低階的細節被忽略，只需要遵從簡單的模型或規範去進行設計。而硬體工程師則是要去實現出這個定義好的模型的硬體、細節部分。 快速處理常見情況 將常使用的指令進行優化(common case fast)，比起其它不常使用的指令，更能提升效能。 何者為最常使用的指令，必須透過嚴密的實驗與測量才以得知。 平行處理(parallelism) Pipeline 預測 某些情況下，將硬體的效能預測的高一點，好過於等到效能滿足才開始設計。 記憶體的結構化(hierarchy) 透過將記憶體分層，將最快、最小、最昂貴的部分置於層狀結構的頂層；而最慢、最大、最便宜的記憶體置於層狀結構的底層。 用多餘創造可靠性(dependability) 計算機不只要速度快，還要具有可靠性。任何物理設備都可能發生故障，此時可以透過引入冗餘的元件來使系統變的更可靠，這些冗餘的元件可以在發生故障時接管工作並協助檢測故障。 1.3 抽象化 從高階語言編譯或轉譯成簡單的計算機指令，這樣的分層結構，即是一種抽象化的呈現。 應用軟體-系統軟體-硬體，從外而內，即是現代計算機的基本架構。 計算機系統中最重要的兩個系統軟體： 作業系統(Operating System, OS) 處理基本的輸入與輸出操作。 分配儲存空間與記憶體。 在同時使用多個應用程式時提供保護的功能。 編譯器(Compiler) 將高階語言如 C, C++, Java, Visual Basic 轉換成硬體可以執行的指令(機器碼)。 高階語言到硬體語言 二進制 電訊號是與電子硬體進行溝通的唯一橋樑。即是所謂的二進制(Binary digit)。在電子硬體的世界，位元(bit) 即為最基本的單位。 從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 電晶體(Transistor) 電晶體的特性，可以作為一個電子開關。 現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。 電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機 彙編語言(Assebly Language) 最早人們使用二進位與電子設備溝通，但效率太慢了，於是發明了更貼近人類思維的符號。 而**彙編程式(Assembler)**即是第一個用來翻譯這些符號的程式。 彙編語言(Assembly Language) add A,B 機器語言(Machine Language) 1000110010100000 高階語言(High-level Language) 高階語言的出現使得計算機的發展更進一步的突破，而高階與言、編譯器與彙編程式即是另一個抽象化的呈現。 好處 高階語言使程式設計師能用更自然的思考，使用英文單字與代數進行程式設計。 高階語言允許語言根據其預期用途設計： Fortran 專為科學計算設計 Cobol 用於業務數據處理 Lisp 用於符號操作 …等等 提升了程式設計的效率，減少了軟體開發的時間，滿足軟體開發的通則「簡潔」。 高階語言是獨立於計算機的，因為編譯器與彙編程式可以在任何電腦上進行編譯。 1.4 計算機結構 任何計算機底層的硬體都執行相同的基本功能： 輸入數據(inputing data) 輸出數據(outputing data) 處理數據(processing data) 儲存數據(storing data) 計算機組織(organization) 輸入(Input)、輸出(Output) 記憶體(Memory) 處理器(Processor) 資料流(Datapath) 控制器(Control) 計算機架構(architecture) 計算機架構 = 指令集架構 + 計算機組織 積體電路(integrated circuits, IC, chips)包含了大部分的計算機組織，包含了 輸入、輸出裝置 液晶顯示器(Liquid crystal displays, LCDs) 觸控面板(touchscreen) 前鏡頭、後鏡頭 麥克風 喇叭 加速度傳感計(accelerometer) 陀螺儀(gyroscope) Wi-Fi 網路、藍芽網路 處理器，或稱中央處理器(central processor unit, CPU)。 資料流，用來處理算術、邏輯運算。 控制器，根據程式的指令告訴資料流、記憶體、I/O裝置要做什麼事。 記憶體 用來儲存程式、程式所需的資料。 由動態隨機存取記憶體 DRAM(dynamic random access memory)組成，相較於循序存取記憶體 sequential access memories，RAM 訪問不同的區域花費的時間基本相同。 快取記憶體(Cache) 是由小型、快速的記憶體所組成，作為 DRAM 的緩衝區。由靜態隨機存取記憶體 SRAM(static random access memory)所組成，SRAM 速度快但密度較低、成本較高。 又分為揮發式(volatile)的與非揮發式(non-volatile)的，通常主記憶體(main memory, primary memory)使用揮發式的(如 DRAM)，而次級的記憶體使用非揮發式的(如磁碟、flash)。 flash 雖比 DRAM 慢，但它具有非揮發式且較便宜的性質，相較於磁碟，flash 更小、更堅固、也更高效，儘管 flash memory 大約會在 寫入 100,000 到 1,000,000 次後磨損，所以文件系統必須要追蹤，並制定記憶體全部磨損的策略。 指令集架構(Instruction Set Architecture, ISA) 包含了所有使二進制機器語言正常工作的內容，包括指令、IO 設備。 通常作業系統會裝這些細節封裝好，使程式設計師只需專心於設計。 由基本指令集與作業系統介面組合而成的介面稱為應用程式二進制介面(Application binary interface, ABI) 指令集架構是為軟體與硬體間提供的一個抽象化架構。 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) 指令集(Instruction Set) 指令形式(Instruction Formats) 讀寫資料的模式與指令 例外狀況 網路 Network 1.5 科技推動處理器與記憶體 1.6 效能 1.7 The Power Wall 1.8 從單處理器到多處理器 1.9 Benchmark 1.10 Fallacles and Pitfalls 1.11 小結 1.12 歷史觀點與未來展望 1.13 習題 前言 計算機結構 vs. 計算機組織 計算機結構 Computer Architecture 處理器(processor) 控制器(Control) 資料路徑(Datapath) 記憶體(memory) 裝置(Devices) 輸入(Input): 鍵盤、滑鼠、磁碟 輸出(Output): 磁碟、顯示器、影印機 計算機組織 Computer Organization(架構) 功能元件的性能: 暫存器(registers)、算術邏輯單元(ALU)、移位器(shifters) 結構(Structure) 資料流(Dataflow) 控制邏輯(Control logic) 暫存器傳輸階層(Register Transfer Level, RTL) 描述 計算機結構\n軟體與硬體間的介面。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。 選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置 指令集架構 Instruction Set Architecture(ISA) 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) 指令集(Instruction Set) 指令形式(Instruction Formats) 讀寫資料的模式與指令 例外狀況 計算機的發展 電腦的分類與市場：歸因於行動裝置的崛起和技術的進步(CMOS、SoC、CAD tools等)。 桌上型電腦(Desktop computers) 伺服器電腦(Server computers) 嵌入式電腦(Embedded computers) 依指令集的長度、複雜度分為 複雜指令集電腦(Complex Instruction Set Computer, CISC) 精簡指令集電腦(Reduced Instruction Set Computer, RISC) 微處理器(Microprocessor) 的分類與市場：主要有兩大架構 ARM 架構： 過去稱為進階精簡指令集機器(Advanced RISC Machine)。 32 位元 RISC 處理器架構。 低成本、高效能、低耗電。 廣泛使用在嵌入式系統設計。 適用於行動通訊領域。 MIPS 架構： Microprocessor without Interlocked Pipeline Stages RISC 處理器架構，早年使用 32 位元，最新版本已變成 64 位元。 廣泛使用於電子產品、網路設備、個人娛樂裝置與商業裝置。 在 MIPS 架構中，指令被分為 R型、I型、J型，三種類型的指令的最高 6 位均為 6 位的 opcode 碼。 瓶頸 摩爾定律(Moore\u0026rsquo;s Law) 積體電路晶片上所整合的電路數目，每隔 18 個月就增加一倍。 摩爾定律的時代將會結束，因為研究和實驗室的成本需求十分高昂，而有財力投資在建立和維護晶片工廠的企業很少。而且製程也愈來愈接近半導體的物理極限，將會難以再縮小下去。 能耗限制(The power wall) 微處理器的效能提升一直仰賴提高處理器的操作頻率，但在提升操作步率的同時，也會帶來龐大的功耗，故形成 Power Wall。 散熱問題愈趨嚴重、電壓無法再下降。 \\(\\text{P}_\\text{dynamic} = \\text{IV} = \\frac{1}{2}\\text{CV}^2\\times\\frac{1}{\\text{T}} = \\frac{1}{2}\\text{CVF}\\) 多處理器(Multi-processor)開始發展 反應時間(Response Time)不增加，但吞吐量(Throughput)增加。 程式設計師要開始考量平行運算程式設計。 阿姆達爾定律(Amdahl\u0026rsquo;s Law) 它代表了處理器平行運算之後效率提升的能力，無論如何提升處理器的數目，加速比將會達到一個極限。(比方說導線的電導率決定電子傳遞速度的上限) \\(\\text{T} _\\text{improved}=\\frac{\\text{T} _\\text{affected} }{\\text{improvement facetor}}+\\text{T} _\\text{unaffected}\\) \\(\\text{T} _\\text{improved} \\rightarrow 0 + \\text{T} _\\text{unaffected}\\) unaffected term 會決定速度的上限 效能(Performance) 效能的表示法 吞吐量(Throughput)：單位時間的工作量。適用於大型主機。 反應時間(Response time)：任務完成所需的時間。適用於個人電腦。 I/O time CPU time：任務的處理(processing)時間 系統 CPU 使用者 CPU Elapsed time = Total Response time，包含處理器、I/O、OS overhaed、閒置時間 CPU time \\(\\boxed{\\text{CPU Time} = \\text{n}_ \\text{clock}\\times\\text{t}_ \\text{clock}}\\) \\(\\text{n}_\\text{clock}\\)：clock 的數目 \\(\\text{t}_\\text{clock}\\)：單位 clock 的時間 \\(\\boxed{\\text{CPI}=\\frac{\\text{n}_\\text{clock}}{\\text{n} _\\text{IC}}}\\) \\(\\text{n}_\\text{IC}\\)：指令數目(Instruction Count, IC) \\(\\text{CPI}\\)：Cycle per instruction \\(\\boxed{\\text{CPU Time} = \\text{n}_ \\text{IC}\\times\\text{CPI}\\times\\text{t}_ \\text{clock}}\\) \\(\\boxed{\\text{Clock Rate} = \\frac{1}{\\text{t}_\\text{clock}} = \\frac{\\text{n} _\\text{clock}}{\\text{CPU time}}}\\) 影響效能的因素 \\(\\boxed{\\begin{array}{ccccccc} \\text{CPU Time}\u0026amp;=\u0026amp;\\frac{\\text{Instruct.}}{\\text{{Program}}}\u0026amp;\\times\u0026amp;\\frac{\\text{Clock cycles}}{\\text{Instruct.}}\u0026amp;\\times\u0026amp;\\frac{\\text{Seconds}}{\\text{Clock cycle}}\\\\ \u0026amp;=\u0026amp;\\text{n}_ \\text{IC}\u0026amp;\\times\u0026amp;\\text{CPI}\u0026amp;\\times\u0026amp;\\text{t}_ \\text{clock} \\end{array}}\\) \\(\\begin{array}{|l|c|c|c|}\\hline \u0026amp;\\text{Instruction Count}\u0026amp;\\text{CPI}\u0026amp;\\text{Clock Rate}\\\\\\hline \\text{程式、演算法}\u0026amp;\\checkmark\u0026amp;\\checkmark\u0026amp;\\\\\\hline \\text{程式語言、編譯器}\u0026amp;\\checkmark\u0026amp;\\checkmark\u0026amp;\\\\\\hline \\text{指令集}\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\\\hline \\text{計算機結構(ISA已定義好)}\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\\\hline \\text{科技}\u0026amp;\u0026amp;\u0026amp;\\checkmark\\\\\\hline \\end{array}\\) 效能的測量 不同程式需求，在不同的硬體設計架構上，會有不同的效能呈現。 如矩陣相乘的程式，對有處理矩陣相乘的 ISA，workload 必定會比較小。 如數字相乘的程式，有乘法器的 ISA，必定優於只有加法器的 ISA。 Benchmarks 為不同程式需求，產生不同的標準程式。 Standard Performance Evaluation Corporation(SPEC) SPEC CPU performance benchmark High-performance computing Client-server models Mail systems File systems Web servers SPEC Power benchmark 在不同 workload level 下測量功耗。 \\(\\sum\\text{ssj\\_ops} _\\text{i}/\\sum\\text{power} _\\text{i}\\) MIPS 成為效能的指標 MIPS(Millions of Instructions Per Second) 注意這裡不是 Microprocessor without Interlocked Pipeline Stages \\(\\boxed{\\text{MIPS}=\\frac{\\text{Instruct. count}}{\\text{Execution time}\\times10^6} =\\frac{\\text{Instruct. count}}{\\frac{\\text{Instruct. count}\\times\\text{CPI}}{\\text{Clock rate}}\\times10^6} =\\frac{\\text{Clock rate}}{\\text{CPI}\\times10^6}}\\) 電腦的定義 一種可以進行計算的裝置，特指可編程(programmable) 且可執行高速的數學或邏輯的運算，或可收集、儲存、處理資料的電子器械。 一般用途 or 特別用途 可編程 or 不可編程 科學用 or 商務 機械械 or 電子式 or 電機 \u0026hellip; Instruction 與 data 分開儲存的結構稱為 哈佛架構Harvard Architecture\u0008 電腦的歷史 ENIAC (Electronic Numberical Integrator and Calculator) 1943 - 1946 at the University of Pennsylvania 約 25 公尺長、2.5 公尺高 由真空管製成: 耗能、易燒壞KJKKI 1900個加法/每秒 商業化、電晶體的發現 in 1947 使用電晶體的電腦 (IBM 14001, Big Blue) in 1959 IC(Integrated Circuit) in 1958 at 德儀 微處理器(Intel 4004) in 1971 Apple II in 1977 個人電腦(IBM PC) in 1981 IBM 開放式系統(open system)使得周邊設備大量的發展 Xerox PARC Alto: 具備滑鼠、以太網路、點陣圖、按鍵、菜單、WYSIWYG編輯器 區域網路 雷射列印 client / server 分散式計算 應用程式 VisiCalc for Applie II in 1979 超大型積體電路 VLSI(Very-Large-Scale Integration) RISC(Reduced Instruction Set Computer) 的出現，對應於 CISC(Complex Instruction Set Computer) RISC: MIPS CISC: Intel x86 processor Post PC Era: Embedded Computer 冰箱、手機、手錶… 電腦的發展 應用 行動電腦 手機 人類基因體計畫 世界網路 搜尋引擎 摩爾定律 Moore\u0026rsquo;s Law Line Width/Feature Size: 電晶體的 Source 與 Drain 的距離，約是 gate length。 電腦的分類 通用電腦 特性： 軟體相容性 產品生命週期短 更好的效能(more transistors)與人機介面 個人電腦 Personal Computers 一般用途、軟體多樣性 取決於成本與效能的權衡 伺服器電腦 Server Computers 基於網路的 高容量、效能、可靠度 範圍可小至伺服，大至建築 超級電腦 Supercomputers 高端的科學與工程計算 最高的效能，但小的市佔 特殊用途電腦 特性： 通常沒有浮點數、記憶體管理 會與各種功能的外部裝置(peripherals)協作 e.g. DSP 多元的 ISA、效能、外部裝置 較不需考量相容性(通常是 pre-determined program)，ISA更簡單、低功耗 更多元的結構、生命週期更長 高產低銷 (Large volume sale and low price) 趨勢：低成本、更多功 SoC(system-on-chip)、micro P core on ASIC 嵌入式電腦 Embedded Computers 隱身在系統中 嚴格的功耗、效能、成本考量 ","permalink":"http://intervalrain.github.io/posts/cs/ca/abstraction/","summary":"計算機的抽象化與科技 1.1 簡介 有賴於科技高速的成長，計算機工業出現了嶄新的型態，計算機導致了文明的第三次革命-資訊革命，與農業革命和工業革命並駕齊驅。如科幻電影般的生活應用，也如雨後出筍般的出現。 汽車 手機 人類基因組計劃(Human genome project) 全球網路(World Wide Web) 搜尋引擎 計算機的應用分類與其特性 個人電腦(Personal Computer, PCs) 伺服器(Servers) 通過網路連接其它的工作站或電腦，通常面向單一且複雜大型的科學或工程應用，也可能是多而小的工作。 成本和功能的差異性也最廣，可以是沒有螢幕沒有鍵盤的桌電，也可以是如超級計算機(supercomputers)這樣的極端。 嵌入式計算機(Embedded Computers) 最大的計算機類別，也涵蓋最廣泛的應用和性能。 通常具有獨特的應用要求，這些要求將最低效能發揮的淋漓盡致，使成本與功耗成為很重要的指標。 後PC時代 個人行動裝置(Poersonal Mobile Device, PMD) 如智慧型手機與平板的出現，取代的 PC 的地位。 雲端計算(Cloud Computing) 取代了傳統伺服器，這些雲端計算建構在「倉庫規模計算機」(Warehouse Scale Computer, WSC)。 企業如Google、Amazon，提供了 WSC 的租借服務，這類通過雲端佈署的「軟體即服務」(Software as a Service, SaaS)，正在改變軟體業。 學習目標 過去在硬體的限制下，程式設計師需要嚴格的考慮程式的效能：減少記憶體空間以使程式更快。 在計算機設計與記憶體科技的進步下，取而代之程式設計師要考量的事情變成：處理器的並行性和記憶體的分層，或諸如在 PMD 或雲端上運行的程式的能源效率問題。 以下是我們將要學習的目標： 用高級語言編寫的程式如何翻譯成硬體語言，以及硬體如何執行生成的程式？藉此可以理解硬體與軟體的關係，也與程式的性能有關聯。 軟體和硬體間的介面是什麼，軟體如何指示硬體執行所需的工作？這些概念對於理解如何編寫多種軟體至關重要。 什麼決定了一個程式的性能，程式設計師如何提高性能？這關係了源始碼編譯成電腦的語言時，硬體執行程式的效率。 硬體設計人員可以使用哪些技術來提高性能(Performance)？ 硬體設計人員可以使用哪些技術來提升能源效率(Energy Efficiency)？程式設計師又如何協助改善？ 什麼理由導致了循序處理(Sequential processing)轉變成了平行處理(Parallel processing)？ 自第一台商用計算機問世以來，計算機架構師提出了哪些想法來奠定現代計算的基礎？ 1.2 計結中八個重要的思想 摩爾定律(Moore\u0026rsquo;s Law)之於設計 摩爾定律源於 Intel 創辦人之一的 Gordon Moore 對 IC 容量增長的預測。 由於計算機設計需耗時數年，而晶片的成長使得計算機架構師在設計時，必須將眼光放到設計完成時的技術狀態，而非當下。 用抽象化(Abstraction)來簡化設計 程式設計師與計算機架構師都必須要不斷發明新的技術以面對日益更新的科技， 抽象化是一種分層設計的概念。對程式設計師而言，低階的細節被忽略，只需要遵從簡單的模型或規範去進行設計。而硬體工程師則是要去實現出這個定義好的模型的硬體、細節部分。 快速處理常見情況 將常使用的指令進行優化(common case fast)，比起其它不常使用的指令，更能提升效能。 何者為最常使用的指令，必須透過嚴密的實驗與測量才以得知。 平行處理(parallelism) Pipeline 預測 某些情況下，將硬體的效能預測的高一點，好過於等到效能滿足才開始設計。 記憶體的結構化(hierarchy) 透過將記憶體分層，將最快、最小、最昂貴的部分置於層狀結構的頂層；而最慢、最大、最便宜的記憶體置於層狀結構的底層。 用多餘創造可靠性(dependability) 計算機不只要速度快，還要具有可靠性。任何物理設備都可能發生故障，此時可以透過引入冗餘的元件來使系統變的更可靠，這些冗餘的元件可以在發生故障時接管工作並協助檢測故障。 1.","title":"[CA] 計算機的抽象化與科技"},{"content":"題目 題目描述 設計一個類似 stack 的資料結構，實行 push() 跟 pop() 的功能，其中 pop() 會丟出 stack 中出現最多次的元素。 FreqStack class 必須實現： FreqStack() 建構子必須初始化一個空的 FreqStack。 void push(int val) 將 val 推至 stack 的頂端。 int pop() 將 stack 中最頻繁出現的元素移除，並返回。 如果 stack 中最頻繁出現的元素出現平手的狀況，則返回平手的元素中最接近 stack 頂端的元素。 題目範例 輸入\n[\u0026ldquo;FreqStack\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n輸出\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n說明\nFreqStack freqStack = new FreqStack(); freqStack.push(5); // The stack is [5] freqStack.push(7); // The stack is [5,7] freqStack.push(5); // The stack is [5,7,5] freqStack.push(7); // The stack is [5,7,5,7] freqStack.push(4); // The stack is [5,7,5,7,4] freqStack.push(5); // The stack is [5,7,5,7,4,5] freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. freqStack.pop(); // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,4]. freqStack.pop(); // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]. 解題 想法 在解題時，我打算在 push 時動手腳，將 push 的元素直接 push 到對的位置後，執行 pop 的動作時，就只要將最頂端的元素取出即可。 FreqStack freqStack = new FreqStack(); freqStack.push(5); // [5] freqStack.push(7); // [5,7] freqStack.push(5); // [5,7,5] freqStack.push(7); // [5,7,5,7] freqStack.push(4); // [5,7,5,7,4] // 此時 4 因為並非最頻繁的元素，所以要將 4 往下推，即變成 [5,7,4,5,7] freqStack.push(5); // [5,7,4,5,7,5] freqStack.pop(); // return 5, [5,7,4,5,7] freqStack.pop(); // return 7, [5,7,4,5] freqStack.pop(); // return 5, [5,7,4] freqStack.pop(); // return 4, [5,7] 為了實現以上的想法，我試想將出現次數相同的元素放在同一個 stack，取出時則從頻率最高的 stack 開始取，即為： freqStack[0] = [5,7,4] // 檢查元素是否出現在 freqStack[0] 否則則往freqStack[1] 移動 freqStack[1] = [5,7] freqStack[2] = [5] // pop 的時候，從freqStack[2] 開始取，空了則將 freqStack[2] 移除 實作1: List of Stacks public class freqStack{ // Field List\u0026lt;Stack\u0026lt;Integer\u0026gt;\u0026gt; stacks; // Constructor public freqStack(){ stacks = new ArrayList\u0026lt;\u0026gt;(); } // Methods public void push(int val){ push(val, 0); } private void push(int val, int freq){ // 當 stacks[freq] 是空的時候，則新建一個 stack。 Stack\u0026lt;Integer\u0026gt; stack; if (freq \u0026gt;= stacks.size()){ stack = new Stack\u0026lt;\u0026gt;(); stacks.add(stack); } else { stack = stacks.get(freq); } // 當該 stacks[freq] 已經有該元素，則往下一個 stacks 找 if (stack.contains(val)){ push(val, freq + 1); } else { stack.push(val); } } public int pop(){ // 直接找到最高的 stack，然後把頂端的元素 pop 出。 Stack\u0026lt;Integer\u0026gt; stack = stacks.get(stacks.size() - 1); int top = stack.pop(); if (stack.isEmpty()){ stacks.remove(stacks.size() - 1); } return top; } } 然而，此時 push 的 \u0008complexity 與欲 push 的元素的出現次數 n 有關，元素出現 n 次，則需要往下找 n 個 stack，也就是 \\(O(n)\\)。 實作2: Use HashMap to record freqency 為了優化，我們可以加入一個 HashMap 來記錄出現的次數，再下次要 push 此元素時，只需要到 HashMap 中查詢出現的次數即可。 public class freqStack{ // Field List\u0026lt;Stack\u0026lt;Integer\u0026gt;\u0026gt; stacks; Map\u0026lt;Integer, Integer\u0026gt; map; // 用來記錄出現次數 // Constructor public freqStack(){ stacks = new ArrayList\u0026lt;\u0026gt;(); map = new HashMap(); } // Methods public void push(int val){ Stack\u0026lt;Integer\u0026gt; stack; // 還沒有此出現次數的元素出現，則新增此 stack if (stacks.size() \u0026lt; map.getOrDefault(val, 0) + 1){ stack = new Stack\u0026lt;\u0026gt;(); } else { // 取得此元素出現的次數，若沒出現過則取得 stacks[0] stack = stacks.get(map.getOrDefault(val, 0)); } stack.push(val); map.put(val, map.getOrDefault(val, 0) + 1); // 更新出現次數 } public int pop(){ // 直接找到最高的 stack，然後把頂端的元素 pop 出。 Stack\u0026lt;Integer\u0026gt; stack = stacks.get(stacks.size() - 1); int top = stack.pop(); map.put(val, map.get(val) - 1); // 更新出現次數 if (stack.isEmpty()){ stacks.remove(stacks.size() - 1); } return top; } } 程式碼 題解：請點此 測試檔：請點此 Reference: Leetcode: 895. Maximum Frequency Stack\n","permalink":"http://intervalrain.github.io/posts/leetcode/freqstack/","summary":"題目 題目描述 設計一個類似 stack 的資料結構，實行 push() 跟 pop() 的功能，其中 pop() 會丟出 stack 中出現最多次的元素。 FreqStack class 必須實現： FreqStack() 建構子必須初始化一個空的 FreqStack。 void push(int val) 將 val 推至 stack 的頂端。 int pop() 將 stack 中最頻繁出現的元素移除，並返回。 如果 stack 中最頻繁出現的元素出現平手的狀況，則返回平手的元素中最接近 stack 頂端的元素。 題目範例 輸入\n[\u0026ldquo;FreqStack\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n輸出\n[null, null, null, null, null, null, null, 5, 7, 5, 4]","title":"[Leetcode] Maximum Frequency Stack 最大頻率堆疊"},{"content":"1. 請說明 Final, Finally, Finalize 三者不同? Final: 一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。 Finally: 例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。 Finalize: 是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。 2. 請說明 String 字串中 == 與 .equals() 哪裡不同? ==:\n比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。 equals():\n是 String 覆寫後的 equals 方法，比較值。 補充：\nJava 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。 若使用 String s1 = \u0026quot;Hello World\u0026quot;; 來宣告，則會透過字串池。 若使用 String s2 = new String(\u0026quot;Hello World\u0026quot;) 來宣告，則字串會存在 Heap 中，與上者的址不同。 3. 使用 \u0026ldquo;abc\u0026rdquo;.equals(s) 比較好還是 s.equals(\u0026ldquo;abc\u0026rdquo;)? 等效。 前者不會出現 NullPointerException。 4. Arrays 與 ArrayList 的差異? Arrays 可包含原始(primitive)及物件(object)，ArrayList只允許物件。 Arrays 大小固定，ArrayList 可動態調整。 ArrayList 提供許多方法，如 removeAll、iterator等。 5. stack 與 heap 的區別? stack: 可被預測生命週期的變數或函數資訊都放在 stack，例如：區域變數(local variable)、物件或陣列的返回位址(function/method return address)等資訊。 heap: 動態配置的記憶體空間，放置被 new 出來的物件以及內含的成員變數。 6. Arrays 與 String 的大小 Arrays 有 length 這個屬性。 String 有 legnth() 這個方法。 7. throw 與 throws 的區別 throws: throws 關鍵字通常被應用在聲明方法時，放在方法的大括號前，用來拋出異常，多個異常可以使用逗號隔開。後續使用者要調用方法時必須要拋出異常或者使用 try-catch 語句處理異常。 throw: throw 關鍵字通常用在設計方法時，預先宣告可能會產生的例外，後續方法使用者需要使用 try-catch 處理例外，或者使用 throws 關鍵字再拋出例外。 補充： throw 用於方法內，throws 用於方法的聲明。 throw 用於方法內拋出異常，throws 用於方法聲明上拋出異常。 throw 後面只能有一個異常，throws 可以聲明多個異常。 8. int 和 Integer 何者會占用更多記憶體? Integer，Integer 是一個物件，會在 heap 中儲存，並儲存址的值到 stack 中，而 int 只會保存值在 stack 中。 9. 是否能將 int 強制轉型為 byte? 可以，可以使用 b = (byte) a 來進行強制轉換，但是超過範圍的部分會被丟棄。 10. 是否能保證 gc 的執行? 否，垃報回收機制程式設計師無法保證，但可以透過 System.gc() 呼叫。 11. abstract class 與 interface 的區別? abstract class 可以宣告抽象方法，提供子類別實作。 interface 的方法必定是抽象方法。 一個類別可以繼承多個介面，但只能繼承一個抽象類別。 12. List 與 Set 區別? List: 有順序性(索引值)。 可重複。 ArrayList 實作了 List 介面。 ArrayList: 插入、刪除速度 \\(O(n)\\)，走訪速度\\(O(1)\\)。 \u0008LinkedList: 插入、刪除速度 \\O(1)\\)，走訪速度\\(O(n)\\)。 Set 無順序性(配合 iterator) 不可重複，走訪速度\\(O(1)\\)。 HashSet 實作了 Set 介面。 HashSet: 無順序性，查找速度快。 LinkedHashSet: 有順序性 TreeSet: 有排序性(依字母) Map 1.有元素鍵值(Key-Value)，搜尋快 2.元素可重複，鍵值如果重複新加入值會覆蓋舊有值 3.HashMap: 查找速度慢，插入刪除速度快 4.TreeMap: 有排序性 ","permalink":"http://intervalrain.github.io/posts/java/interviewq/","summary":"1. 請說明 Final, Finally, Finalize 三者不同? Final: 一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。 Finally: 例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。 Finalize: 是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。 2. 請說明 String 字串中 == 與 .equals() 哪裡不同? ==:\n比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。 equals():\n是 String 覆寫後的 equals 方法，比較值。 補充：\nJava 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。 若使用 String s1 = \u0026quot;Hello World\u0026quot;; 來宣告，則會透過字串池。 若使用 String s2 = new String(\u0026quot;Hello World\u0026quot;) 來宣告，則字串會存在 Heap 中，與上者的址不同。 3.","title":"[Java] 面試常見問題"},{"content":"C 當我們要去評價程式碼的品質時，我們會考慮以下元素： 正確性(correctness): 程式碼是否有正確的解決我們的問題 設計(design): 程式碼的好壞決定於它的效率與可讀性 風格(style): 程式碼在視覺上是否有良好的format 我們的第一個 C 語言程式： #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello, world\\n\u0026#34;); } 整合開發環境、編譯器、介面 IDEs, compilers, interfaces 在執行程式前，我們必須將程式碼轉變成電腦可讀的 binary codes，也就是 0 與 1。 IDE(integrated development environments) 可以協助我們開發、編譯程式碼。如Visual Studio Code 我們撰寫的程式碼為開源碼(source code)，我們必須將他轉變成機器碼(machine code)，才能被電腦執行。 編譯器(compiler)是將一種語言轉變成另一種語言的程式，例如將開源碼編譯成機器碼。 在 IDE 中，我們可以在一個叫作 terminal 的視窗中輸入指令。 terminal 提供了 command-line interface(CLI) 當我們輸入 make hello，會產生一個叫作 hello 的檔案，我們可以透過輸入 ./hello 執行它。 . 代表當下的目錄，上面的指令代表我們要執行當下目錄中叫作 hello 的檔案。 hello 即是內含機器碼的檔案。 欲刪除檔案可以用 rm 指令。 輸入 ls 列出當下目錄所包含的檔案。 若源碼檔經過修過，則必須重新編譯，才能對執行檔進行修改。 函式、引數、傳回值、變數 Functions, Arguments, Return Values, Variables printf(\u0026#34;Hello, world\u0026#34;); 此處，介紹一個叫作 printf 的函數 f 代表 formatted 的字串。字串是多個字元(characters)組成的字詞，在 C 中，我們需要用雙引號(\u0026quot;\u0026quot;)來包住它。 括號 () 使我們可以輸入引數，也就是 printf 函數的 input。 最後，我們需要分號 ;，來宣告述句的結束。 其中，函式的一種產物叫作 side effect，也就是我們可以觀察到的變化，如螢幕印出字樣，或是發出聲響。 相比與 **side effects，我們也可以將函式的回傳值用於程式中，回傳值通被儲存於變數中。 string answer = get_string(\u0026#34;What\u0026#39;s your name? \u0026#34;); 此處，示範 CS50 IDE 中的一個函數。 這裡的 get_string為函式，而What's your name? 為引數。 然後，我們可以將回傳值存入到變數中，以上例，我們可利用賦值運算子(=)將右值(r_value)傳給左值(l_value)的answer。 最後，我們宣告變數的變數型別(type)。 如果我們嘗試將上述的變數改為其他變數型別，編譯器會顯示錯誤。 printf(\u0026#34;Hello, world\\n\u0026#34;); 我們此處為了換行，而使用了 escape sequence \\n。 ","permalink":"http://intervalrain.github.io/posts/cs50/lec1/","summary":"C 當我們要去評價程式碼的品質時，我們會考慮以下元素： 正確性(correctness): 程式碼是否有正確的解決我們的問題 設計(design): 程式碼的好壞決定於它的效率與可讀性 風格(style): 程式碼在視覺上是否有良好的format 我們的第一個 C 語言程式： #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello, world\\n\u0026#34;); } 整合開發環境、編譯器、介面 IDEs, compilers, interfaces 在執行程式前，我們必須將程式碼轉變成電腦可讀的 binary codes，也就是 0 與 1。 IDE(integrated development environments) 可以協助我們開發、編譯程式碼。如Visual Studio Code 我們撰寫的程式碼為開源碼(source code)，我們必須將他轉變成機器碼(machine code)，才能被電腦執行。 編譯器(compiler)是將一種語言轉變成另一種語言的程式，例如將開源碼編譯成機器碼。 在 IDE 中，我們可以在一個叫作 terminal 的視窗中輸入指令。 terminal 提供了 command-line interface(CLI) 當我們輸入 make hello，會產生一個叫作 hello 的檔案，我們可以透過輸入 ./hello 執行它。 . 代表當下的目錄，上面的指令代表我們要執行當下目錄中叫作 hello 的檔案。 hello 即是內含機器碼的檔案。 欲刪除檔案可以用 rm 指令。 輸入 ls 列出當下目錄所包含的檔案。 若源碼檔經過修過，則必須重新編譯，才能對執行檔進行修改。 函式、引數、傳回值、變數 Functions, Arguments, Return Values, Variables printf(\u0026#34;Hello, world\u0026#34;); 此處，介紹一個叫作 printf 的函數 f 代表 formatted 的字串。字串是多個字元(characters)組成的字詞，在 C 中，我們需要用雙引號(\u0026quot;\u0026quot;)來包住它。 括號 () 使我們可以輸入引數，也就是 printf 函數的 input。 最後，我們需要分號 ;，來宣告述句的結束。 其中，函式的一種產物叫作 side effect，也就是我們可以觀察到的變化，如螢幕印出字樣，或是發出聲響。 相比與 **side effects，我們也可以將函式的回傳值用於程式中，回傳值通被儲存於變數中。 string answer = get_string(\u0026#34;What\u0026#39;s your name?","title":"[CS50] Lec 1 - C"},{"content":"1. transient 的作用及使用方法 當一個物件繼承(implements)了 Serializable 介面，這個物件就可以被序列化，Java 的序列化模式為開發者提供了許多便利，開發者可以不必關心具體序列化的過程，只要繼承了 Serializable 介面，該類別(class)的所有屬性(property)和方法(method)都會自動序列化。 然而在實際開發過程中，有些屬性需要序列化，有些屬性則不需要。 用戶的私密訊息如密碼、銀行帳號等，通常不希望在網路操作時被傳輸。 此時，便可在這些對應的變數前加上 transient。 如此一來，這些私密訊息的生命週期只會存在於調用者的記憶體(memory)中，不會寫到磁碟(disk)裡。 注意讀取時，讀取數據的順序一定要和存放數據的順序保持一致。\n範例： import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; import java.io.Serializable; public class TransientExample { public static void main(String[] args){ User user = new User(); user.setUsername(\u0026#34;Rain\u0026#34;); user.setPassword(\u0026#34;12345678\u0026#34;); System.out.println(\u0026#34;Read before Serializable: \u0026#34;); System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername()); System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword()); try { ObjectOutput os = new ObjectOutputStream(new FileOutputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;)); os.writeObject(user); os.flush(); os.close(); } catch (FileNotFoundException e){ e.printStackTrace(); } catch (IOException e){ e.printStackTrace(); } try { ObjectInputStream is = new ObjectInputStream(new FileInputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;)); user = (User) is.readObject(); is.close(); System.out.println(\u0026#34;Read after Serializable: \u0026#34;); System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername()); System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword()); } catch (FileNotFoundException e){ e.printStackTrace(); } catch (IOException e){ e.printStackTrace(); } catch (ClassNotFoundException e){ e.printStackTrace(); } } } class User implements Serializable{ private static final long serialVersionID = 8294180014912103005L; private String username; private transient String password; public String getUsername(){ return username; } public void setUsername(String username){ this.username = username; } public String getPassword(){ return password; } public void setPassword(String password){ this.password = password; } } 輸出的結果是： Read before Serializable:\nUsername: Rain\nPassword: 12345678\nRead after Serializable:\nUsername: Rain\nPassword: null\n也就是說反序列化並沒有成功從文件獲取到訊息。 2. transient 的小結 一旦變數被 transient 修飾，變數將不再是物件持久化的一部分，該變敗內容將在序列化後無法再次訪問。 transient 關鍵字只能飾飾變數(variable)，不能修飾方法(method)和類別(class)。注意，區域變數是無法被 transient 修飾的。 被 transient 修飾的變數不能再被序列化，一個靜態變數不管是否被 transient 修飾，都不能被序列化。 其中，在上例中的 username 帶有 static 關鍵字，實際上是沒有被序列化的，也就是說我們在讀取之前改變 username 的值，讀取完並不會改變 username 的值，而是 JVM 中對應靜態變數的值。 3. 當遇上了 Externalizable 當被 transient 修飾的變數在存於一個繼承了 Externalizable 的介面，則代表沒有任何東西被自動序列化。 需要在 writeExternal方法中手工指定所要序列化的變數，這與是否被 transient 修飾無關。 ","permalink":"http://intervalrain.github.io/posts/java/transient/","summary":"1. transient 的作用及使用方法 當一個物件繼承(implements)了 Serializable 介面，這個物件就可以被序列化，Java 的序列化模式為開發者提供了許多便利，開發者可以不必關心具體序列化的過程，只要繼承了 Serializable 介面，該類別(class)的所有屬性(property)和方法(method)都會自動序列化。 然而在實際開發過程中，有些屬性需要序列化，有些屬性則不需要。 用戶的私密訊息如密碼、銀行帳號等，通常不希望在網路操作時被傳輸。 此時，便可在這些對應的變數前加上 transient。 如此一來，這些私密訊息的生命週期只會存在於調用者的記憶體(memory)中，不會寫到磁碟(disk)裡。 注意讀取時，讀取數據的順序一定要和存放數據的順序保持一致。\n範例： import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; import java.io.Serializable; public class TransientExample { public static void main(String[] args){ User user = new User(); user.setUsername(\u0026#34;Rain\u0026#34;); user.setPassword(\u0026#34;12345678\u0026#34;); System.out.println(\u0026#34;Read before Serializable: \u0026#34;); System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername()); System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword()); try { ObjectOutput os = new ObjectOutputStream(new FileOutputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;)); os.writeObject(user); os.flush(); os.","title":"[Java] transient 關鍵字"},{"content":"Mismatch 的重要性 Mismatch 就是當元件的結構設計相同，且尺寸相等，發生性質差異的一種行為。 當尺寸漸縮，變異(viriability)的程度會愈來愈大。 變異(viriability)變大會影響到類比邏輯應用的表現。 Variability/Fluctuation 變異度/誤差定義 元件的單體量測值到整體的 Stardard Target 或 Median 的差距。 可分為系統誤差與隨機誤差。 Systematic variability 系統誤差 (Global) 外質特性(extrinsic) 可以透過製程改良或控制來改善 W2W: 裝置穩定度 equipment stability Wafer level: 裝置均勻度 equipment uniformity、黃光穩定度 Litho. stability Die level: 黃光均勻度 Litho. uniformity、溫度均勻度 temp. non-uniformity pattern density like poly gate density might impact temperature uniformity Layout-Dependent: 光學偏移效應 Optical proximity effect、機械應力 Mechanical stress Random variability 隨機誤差 (Local/Mismatch) 本質特性(intrinsic) 較難被改善 沒有空間相關性 尺寸漸縮，比例可能被放大 微擾動: 參雜 dopant, LER, \u0026hellip; random dopant fluctuation(RDF): dopant diffuse randomly gate dieletric roughness line edge roughness(LER) grain irregularity 統計手法 常態分佈 大部分的元件特性都呈常態分布(normal distribution) 中央極限定理 Advanced Central Limit Therem: 相互獨立的隨機變數, 其均值以常態分佈為極限 Sum of normally distributed random variables: 常態分佈的線性組合依然是常態分布 可簡單透過 median 與 sigma 來描述一組數據, 並用來預測數據 常態分布的函數式為 \\(f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}}\\) 分析手法 透過刪減 outlier 使 rawdata 盡量接近常態分布 (刪除 3倍 sigma 以外的 outlier，重複 6 次) 通常 Full mapping 量測(66pts) 會有 0~2 點的 outliers 數學公式: A = B + C 且 B 與 C 為不相依的變數時 \\((\\sigma_A)^2=(\\sigma_B)^2+(\\sigma_C)^2\\) $$(\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2$$ Total: \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in wafer Global: \\((\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2\\) \\(\\text{Median(Vt1,Vt2,\u0026hellip;Vtn)}\\) \\(\\sigma(\\text{Med1,Med2,\u0026hellip;Medn})\\) Local: \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in die local = \\(\\sqrt{\\frac{\\sum\\sigma_i}{n}})\\) mismatch = \\(\\sigma(\\Delta\\text{Vt1},\\Delta\\text{Vt2},\u0026hellip;\\Delta\\text{Vtn})\\) Mismatch量測 量測 Full mapping data 將同個 die 裡面的 device pair(the same W \u0026amp; L) 計算差值 \\(\\Delta\\text{Vt}=Vt1-Vt2\\) \\(\\Delta\\text{Ion}=\\frac{2\\times(\\text{Ion}_1-\\text{Ion}_2)}{\\text{Ion}_1+\\text{Ion}_2}\\) Normalization 同一組 device pair 內，去除 outlier，使數據接近常態分佈 因為 mismatch 受 sacle 影響，故須對 scale 做正常化 1/sqrt(WL)，Standard variation of mismatch is proportional to inverse of square root of area. Draw \\(\\Delta\\text{Vt}-\\frac{1}{\\sqrt{W/L}}\\)圖 斜率即為 Mismatch ","permalink":"http://intervalrain.github.io/posts/device/mismatch/","summary":"Mismatch 的重要性 Mismatch 就是當元件的結構設計相同，且尺寸相等，發生性質差異的一種行為。 當尺寸漸縮，變異(viriability)的程度會愈來愈大。 變異(viriability)變大會影響到類比邏輯應用的表現。 Variability/Fluctuation 變異度/誤差定義 元件的單體量測值到整體的 Stardard Target 或 Median 的差距。 可分為系統誤差與隨機誤差。 Systematic variability 系統誤差 (Global) 外質特性(extrinsic) 可以透過製程改良或控制來改善 W2W: 裝置穩定度 equipment stability Wafer level: 裝置均勻度 equipment uniformity、黃光穩定度 Litho. stability Die level: 黃光均勻度 Litho. uniformity、溫度均勻度 temp. non-uniformity pattern density like poly gate density might impact temperature uniformity Layout-Dependent: 光學偏移效應 Optical proximity effect、機械應力 Mechanical stress Random variability 隨機誤差 (Local/Mismatch) 本質特性(intrinsic) 較難被改善 沒有空間相關性 尺寸漸縮，比例可能被放大 微擾動: 參雜 dopant, LER, \u0026hellip; random dopant fluctuation(RDF): dopant diffuse randomly gate dieletric roughness line edge roughness(LER) grain irregularity 統計手法 常態分佈 大部分的元件特性都呈常態分布(normal distribution) 中央極限定理 Advanced Central Limit Therem: 相互獨立的隨機變數, 其均值以常態分佈為極限 Sum of normally distributed random variables: 常態分佈的線性組合依然是常態分布 可簡單透過 median 與 sigma 來描述一組數據, 並用來預測數據 常態分布的函數式為 \\(f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}}\\) 分析手法 透過刪減 outlier 使 rawdata 盡量接近常態分布 (刪除 3倍 sigma 以外的 outlier，重複 6 次) 通常 Full mapping 量測(66pts) 會有 0~2 點的 outliers 數學公式: A = B + C 且 B 與 C 為不相依的變數時 \\((\\sigma_A)^2=(\\sigma_B)^2+(\\sigma_C)^2\\) $$(\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2$$ Total: \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in wafer Global: \\((\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2\\) \\(\\text{Median(Vt1,Vt2,\u0026hellip;Vtn)}\\) \\(\\sigma(\\text{Med1,Med2,\u0026hellip;Medn})\\) Local: \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in die local = \\(\\sqrt{\\frac{\\sum\\sigma_i}{n}})\\) mismatch = \\(\\sigma(\\Delta\\text{Vt1},\\Delta\\text{Vt2},\u0026hellip;\\Delta\\text{Vtn})\\) Mismatch量測 量測 Full mapping data 將同個 die 裡面的 device pair(the same W \u0026amp; L) 計算差值 \\(\\Delta\\text{Vt}=Vt1-Vt2\\) \\(\\Delta\\text{Ion}=\\frac{2\\times(\\text{Ion}_1-\\text{Ion}_2)}{\\text{Ion}_1+\\text{Ion}_2}\\) Normalization 同一組 device pair 內，去除 outlier，使數據接近常態分佈 因為 mismatch 受 sacle 影響，故須對 scale 做正常化 1/sqrt(WL)，Standard variation of mismatch is proportional to inverse of square root of area.","title":"[Device] Mismatch Introduction"},{"content":"如何初始化 vector 事先準備 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; 1. 利用 push_back() 函式 vector\u0026lt;int\u0026gt; A; A.push_back(1); A.push_back(2); A.push_back(3); // A = [1,2,3] 2. 利用重載建構子(overloaded constructor) int size = 5; int fill = 2; vector\u0026lt;int\u0026gt; B(size, fill); // B = [2,2,2,2,2] 3. 將 array 傳給 vector 的建構子(-std=c++11) vector\u0026lt;int\u0026gt; C{1, 2, 3, 4, 5}; // C = [1,2,3,4,5] 4. 利用既有的 array int array[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; D(array, array+4); // D = [1,2,3,4] 5. 利用既有的 vector vector\u0026lt;int\u0026gt; E(C.begin()+1, C.end()-3); // E = [2] 6. 利用 fill 函式 vector\u0026lt;int\u0026gt; F(6); fill(F.begin(), F.end(), 3); // F = [3,3,3,3,3,3] Reference\n","permalink":"http://intervalrain.github.io/posts/c++/newvector/","summary":"如何初始化 vector 事先準備 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; 1. 利用 push_back() 函式 vector\u0026lt;int\u0026gt; A; A.push_back(1); A.push_back(2); A.push_back(3); // A = [1,2,3] 2. 利用重載建構子(overloaded constructor) int size = 5; int fill = 2; vector\u0026lt;int\u0026gt; B(size, fill); // B = [2,2,2,2,2] 3. 將 array 傳給 vector 的建構子(-std=c++11) vector\u0026lt;int\u0026gt; C{1, 2, 3, 4, 5}; // C = [1,2,3,4,5] 4. 利用既有的 array int array[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; D(array, array+4); // D = [1,2,3,4] 5.","title":"[C++] How to Initialize vector in C++"},{"content":"Integer.bitCount 的函式解析 要計算整數以二進制的方式表示時，所有 bit 位為 1 的總和。 雛形 從低位開始，檢查是否為 1。 public static int bitCount(int i){ int count = 0; while (i \u0026gt; 0) { if ((i \u0026amp; 1) == 1) // 如果最低位為 1，count就加 1 count++; i \u0026gt;\u0026gt;= 1; // 向右推進 1 位，等同於 num /= 2; } return count; } 時間複雜度為 \\(O(n)\\)，\\(n\\) 為整數的位數(bit 數)。 優化 利用(i - 1) \u0026amp; i 可以消除最低位數的 1 的性質來計算。 public static bitCount(int i){ int count = 0; while (i \u0026gt; 0){ i = i \u0026amp; (i - 1); // 0b0101_1100 - 1 = 0b0101_1011, 且 0b0101_1100 \u0026amp; 0b0101_1011 = 0b0101_1000; count++; } return count; } 時間複雜度為 \\(O(n))\\)，\\(n\\) 為位數為 1 的個數。 利用 int 的特性再優化 \u0008因為 int 的最大正整數為 2^31，故我們可以兩兩錯位相加來求和 private static int bitCount(int i){ i = (i \u0026amp; 0x55555555) + ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); // 0b0101_0101_0101_0101_0101_0101_0101_0101 i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); // 0b0011_0011_0011_0011_0011_0011_0011_0011 i = (i \u0026amp; 0x0f0f0f0f) + ((i \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); // 0b0000_1111_0000_1111_0000_1111_0000_1111 i = (i \u0026amp; 0x00ff00ff) + ((i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); // 0b0000_0000_1111_1111_0000_0000_1111_1111 i = (i \u0026amp; 0x0000ffff) + ((i \u0026gt;\u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff); // 0b0000_0000_0000_0000_1111_1111_1111_1111 return i; } 時間複雜度為 \\(O(1))\\)。 Source Code(final) public static int bitCount(int i) { // HD, Figure 5-2 i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f; i = i + (i \u0026gt;\u0026gt;\u0026gt; 8); i = i + (i \u0026gt;\u0026gt;\u0026gt; 16); return i \u0026amp; 0x3f; } 一、三、四、五步不進行消位，在最後再利用 i \u0026amp; 0x3f 消去不必要的位數 ","permalink":"http://intervalrain.github.io/posts/java/bitcount/","summary":"Integer.bitCount 的函式解析 要計算整數以二進制的方式表示時，所有 bit 位為 1 的總和。 雛形 從低位開始，檢查是否為 1。 public static int bitCount(int i){ int count = 0; while (i \u0026gt; 0) { if ((i \u0026amp; 1) == 1) // 如果最低位為 1，count就加 1 count++; i \u0026gt;\u0026gt;= 1; // 向右推進 1 位，等同於 num /= 2; } return count; } 時間複雜度為 \\(O(n)\\)，\\(n\\) 為整數的位數(bit 數)。 優化 利用(i - 1) \u0026amp; i 可以消除最低位數的 1 的性質來計算。 public static bitCount(int i){ int count = 0; while (i \u0026gt; 0){ i = i \u0026amp; (i - 1); // 0b0101_1100 - 1 = 0b0101_1011, 且 0b0101_1100 \u0026amp; 0b0101_1011 = 0b0101_1000; count++; } return count; } 時間複雜度為 \\(O(n))\\)，\\(n\\) 為位數為 1 的個數。 利用 int 的特性再優化 \u0008因為 int 的最大正整數為 2^31，故我們可以兩兩錯位相加來求和 private static int bitCount(int i){ i = (i \u0026amp; 0x55555555) + ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); // 0b0101_0101_0101_0101_0101_0101_0101_0101 i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); // 0b0011_0011_0011_0011_0011_0011_0011_0011 i = (i \u0026amp; 0x0f0f0f0f) + ((i \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); // 0b0000_1111_0000_1111_0000_1111_0000_1111 i = (i \u0026amp; 0x00ff00ff) + ((i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); // 0b0000_0000_1111_1111_0000_0000_1111_1111 i = (i \u0026amp; 0x0000ffff) + ((i \u0026gt;\u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff); // 0b0000_0000_0000_0000_1111_1111_1111_1111 return i; } 時間複雜度為 \\(O(1))\\)。 Source Code(final) public static int bitCount(int i) { // HD, Figure 5-2 i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f; i = i + (i \u0026gt;\u0026gt;\u0026gt; 8); i = i + (i \u0026gt;\u0026gt;\u0026gt; 16); return i \u0026amp; 0x3f; } 一、三、四、五步不進行消位，在最後再利用 i \u0026amp; 0x3f 消去不必要的位數 ","title":"[Java] Integer.bitCount 解析"},{"content":"一、OS 簡介 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：\n資源分配者 監控使用者程式的執行，以防止不正常的運作造成對系統的危害。 一個標準 PC 的作業系統應該提供以下功能： 行程管理 (processing management) 記憶體管理 (memory management) 檔案系統 (file system) 網路通訊 (networking) 安全機制 (security) 使用者介面 (user integerface) 驅動程式 (device drivers) OS 系統依大小來區分： 大型電腦：IBM OS/360 個人電腦：Windows、Linux、BSD、Mac OS X 嵌入式：VxWorks、eCos、Sysbian OS、Palm OS 依品牌來區分： 類 Unix 家族：包含 System V、BSD 與 Linux。 微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。 蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統 Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。 二、常見的系統類型 Multiprogramming System 系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel)) Multiprogramming Degree：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 Thrashing 現象) 當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。 [方法1] 降低 Multiprogramming Degree [方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 [方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。 分時系統 Time Sharing System Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。 常見配置： 行程排程採用 RR 排程(Round-robin scheduling) 記憶體空間所有使用者分享 使用虛擬記憶體技術 I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。 分散式系統 Distributed System 須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：\nClient-Server System Peer-to-peer 舉例：志願計算，使用志願者電腦的閒置計算力，透過網際網路進行資料傳輸(如 Folding@home 蛋白質摺疊研究計畫)\n分散式系統的好處：\n資源共享 (Resource sharing) 加快計算速度 (Speed up) 可靠性 (Reliability)：指不容易因為一台電腦 shut down 而全部崩潰 通訊需求 (Coummunication Need) 補充：勿將 Multiprocessor 與分散式系統混為一談\nSymmetric Multiprocessing (SMP)：對稱式多元處理，每一個處理器具有相同的功能，可靠度高，強調負載平衡。 Asymmetric Multiprocessing (ASMP)：非對稱式多元處理，Master/Slave 架構。 即時系統 Real Time System 定義嚴謹的固定時間限制，電腦在處理工作時必須在這個定義的時間內完成，否則工作就算失效。 硬性即時系統(Hard Real Time Sydstem)：對於完成工作的時間有極嚴格的限制。若 Prcess 未能於規定的時間內完成，則 Process 即屬失效。(意義同即時系統之定義) 工廠自動化系統、軍事系統、核能安控等。 Application Program 設計上非常重要。 Data 及 Program 皆存在 ROM 或 RAM 中。 不使用虛擬記憶體，因為 Page Fault 的處理時間過長。 減少 os 的干預以降低 Dispatch Latency。 軟性即時系統(Soft Real Time System)：保證高優先權的 Process 必須先於所有低優先權的 Process 完成。 Multimedia System、Virtual Reality等。(影音多媒體的緩衝時間) CPU 的 Scheduling 應能支援 Priority Scheduling 且不能提供類似 Aging 技術。 可和分時系統、virtual memory 共存。 叢集系統 Clustered System 叢集系統共享儲存裝置，集合許多 CPU 並且經由 LAN 連線緊密地連結以完成工作。 叢集系統主要是利用多台獨立的電腦系統或是工作站來共同完成大型數值的平行計算。 Batch 較好的耐用度、安全性 常用於大量數據分析 常用於醫院、金融業 計算機一次只執行一件事 使用者與計算機的執行沒有互動性 CPU 時常處在閒置的狀態(因為 I/O speed 遠小於 CPU speed) OS 處理完一件事後，才將控制權交給下一個工作 Multi-programming 讓 I/O 與計算的工作可以同時進行，減少 CPU 閒置的時間。\nSpooling(Simultaneous Peripheral Operation On-Line)。\n但仍是一次執行一件事。 OS 的工作包含：\n記憶體管控。 系統必須分配記憶體給不同的程式 CPU 排程。 系統必須決定哪些程式要執行 I/O 系統。 系統提供 I/O 的排程與裝置的分配 Time-sharing System 使用者與系統間具有互動性\nCPU 頻繁的切換不同的工作，所以會有很多時間點可以接收 I/O。 使用者可以及時看到結果。 使用者感受像是同時進行的，但其實是很快速的切換在不同的工作之間。 OS 的工作包含：\nVirtual memory，從硬碟中借儲存空間出來，當作 memory 來使用。 檔案系統和硬碟管理。 同步化(Synchronization) 和 死鎖(deadlock)。 \\( \\def\\arraystretch{1.5}\\begin{array}{|c|c|c|c|}\\hline \u0026amp;\\text{Batch}\u0026amp;\\text{Multi-programming}\u0026amp;\\text{Time-sharing}\\\\\\hline \\text{系統模型}\u0026amp;\\text{單一使用者、單一作業}\u0026amp;\\text{單一使用者、多作業排程}\u0026amp;\\text{多使用者、作業平行處理}\\\\\\hline \\text{目的}\u0026amp;\\text{簡單}\u0026amp;\\text{增加資源利用效率(機本)}\u0026amp;\\text{提升反應速度(人本)}\\\\\\hline \\text{特徵}\u0026amp;\\text{N.A.}\u0026amp;\\text{CPU 排程、記憶體管理、I/O系統}\u0026amp;\\text{檔案系統、虛擬記憶體、同步化、死鎖}\\\\\\hline \\end{array} \\)\n電腦系統結構 桌面系統(Desktop Systems)：單處理器(single processor) PC(personal computer) GUI I/O devices: 鍵盤、滑書、螢幕、印表機… 多元的 OS Window, MacOS, Unix, Linux 缺乏檔案與作業系統的保護 木馬、病毒 平行系統(Parallel Systems)：多處理器(multiprocessor/tightly couplde system) 多核、或多 CPU。 通常共享記憶體 優點： Throughput: 提升計算能力 Economical: 很多裝置可以共用、節省成本 Reliability: 當其中一個 CPU 壞掉時，不會使得電腦完全無法操作。 分類： 對稱式多處理器系統 Symmetric multiprocessor system(SMP) 作業系統控制的每個處理器都扮演相同角色 大多 CPU 屬於這種 需要額外處理 synchronization 非對稱式多處理器系統Asymmetric multiprocessor system 每個處理器被指派處理不同的特殊工作 一個主要的 master CPU 與多個 slave CPUs 常見於極大的系統 多核處理器 Multi-Core Processor 在單一的 CPU 有多核 On-chip communication 比 between-chip communication 還快 One chip with multiple core 比 multiple single-core chips 還節能 Many-Core Processor Nvidia General-Purpose GPU 圖形處理器 Single Instruction Multiple Data 處理矩陣更快 Intel Xeon Phi TILE64 記憶體存取結構(Memory Access Architecture) 統一記憶體存取架構 Uniform memory access(UMA) 非統一記憶體存取架構 Non-uniform memory access(NUMA) 分散式系統(Distributed Systems)： ","permalink":"http://intervalrain.github.io/posts/os/lec1/","summary":"一、OS 簡介 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：\n資源分配者 監控使用者程式的執行，以防止不正常的運作造成對系統的危害。 一個標準 PC 的作業系統應該提供以下功能： 行程管理 (processing management) 記憶體管理 (memory management) 檔案系統 (file system) 網路通訊 (networking) 安全機制 (security) 使用者介面 (user integerface) 驅動程式 (device drivers) OS 系統依大小來區分： 大型電腦：IBM OS/360 個人電腦：Windows、Linux、BSD、Mac OS X 嵌入式：VxWorks、eCos、Sysbian OS、Palm OS 依品牌來區分： 類 Unix 家族：包含 System V、BSD 與 Linux。 微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。 蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統 Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。 二、常見的系統類型 Multiprogramming System 系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel)) Multiprogramming Degree：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 Thrashing 現象) 當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。 [方法1] 降低 Multiprogramming Degree [方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 [方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。 分時系統 Time Sharing System Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。 常見配置： 行程排程採用 RR 排程(Round-robin scheduling) 記憶體空間所有使用者分享 使用虛擬記憶體技術 I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。 分散式系統 Distributed System 須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：","title":"[OS] Lec 1 - Introduction"},{"content":"HashMap.comparableClassFor(Object x) 的函式解讀 原文敘述\nReturns x\u0026rsquo;s Class if it is of the form \u0026ldquo;class C implements Comparable\u0026rdquo;, else null.\n我的翻譯 當x的類別為Comparable的實作時，返回x的類別；否則返回 null。\n藉由這個函式實例的解讀，可以了解一下類別、泛型的相關概念。 Source Code static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) { if (x instanceof Comparable) { Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) { for (Type t : ts) { if ((t instanceof ParameterizedType) \u0026amp;\u0026amp; ((p = (ParameterizedType) t).getRawType() == Comparable.class) \u0026amp;\u0026amp; (as = p.getActualTypeArguments()) != null \u0026amp;\u0026amp; as.length == 1 \u0026amp;\u0026amp; as[0] == c) // type arg is c return c; } } } return null; } instanceof insanceof 可理解成某類別的實作，無論是執行期時的類別，或是父類別，或是它實現的介面，或父類別實現的介面…，總之只要在繼承鏈上有這個類別就可以了。 getClass() 與instanceof相對應的是getClass()函式，無論該物件如果轉型，getClass()都會返回它執行時期的類別，可以簡單理解成實際類別\u0008，換言之也就是我們 new 出來物件時使用的類別。 有一種例外情形是匿名物件，當匿名物件調用getClass()時，返回的是依賴它的物件在執行期的類別，並以1,2,3\u0026hellip;的index區分。 getGenericInterfaces() getGenericInterfaces()方法返回的是該物件在執行期時直接實作的介面。必然是該類別自己實作的介面，繼承的則不可。 getGenericSuperclass()和getSuperclass() 這兩個函式雖然沒有出現在 comparableClassFor(Object x)中，但也順帶一提。\ngetSuperclass()返回的是直接父類的類別，不包括泛型參數。 \u0008getGenericSuperclass()返回的是包括泛型參數在內的直接父類別。 注意如果父類別聲明了泛型，但子類別繼承時沒有為父類別實作該泛型，這時候也是沒有泛型參數的 ParameterizedType ParameterizedType 是 Type 介面的子介面，表示參數化的類別，亦即實作了泛型參數的類型。 注意如果直接用 bean 物件 instanceof ParameterizedType，结果都是 false。 Class 物件只能是 instanceof ParameterizedType，否則編譯會報錯。 只有用 Type 物件 instanceof ParameterizedType 才能得到想要的比較结果。可以這麼理解：一個 Bean 類別不會是 ParameterizedType，只有代表這個Bean類的類型（Type）才可能是ParameterizedType。 實現泛型參數，可以是給泛型傳入了一個真實的類別，或者傳入另一個新聲明的泛型參數，只聲明泛型而不實作，則 instanceof ParameterizedType 為 false。 getRawType() getRawType()方法返回聲明了這個類別的類或介面，也就是去掉了泛型参数部分的類別物件。 getActualTypeArguments() 與getRawType()相對應，getActualTypeArguments()以數組的形式返回泛型參數列表。 當傳入的是真實類別時，印出來的是全類名 當傳入的是另一個聲明的泛型參數時滿印出來的是代表該泛型參數的符號。 getOwnerType() ParameterizedType介面還有一個getOwnerType()函式，如果該類別是一个內部類別/介面，返回它的外部類別/介面。如果該類型不是內部類型不是内部類別/介面，返回null。 comparableClassFor(Object x) 總結 static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) { if (x instanceof Comparable) { // 判斷是否實作了 Comparable 介面 Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p; if ((c = x.getClass()) == String.class) // 如果是String類別，直接返回String.class return c; if ((ts = c.getGenericInterfaces()) != null) { // 檢查是否有直接實現的介面 for (Type t : ts) { // 遍歷介面 if ((t instanceof ParameterizedType) \u0026amp;\u0026amp; // 當介面實現了泛型 ((p = (ParameterizedType) t).getRawType() == // 取得介面不帶參數時的類別對象 Comparable.class) \u0026amp;\u0026amp; // 且為 Comparable (as = p.getActualTypeArguments()) != null \u0026amp;\u0026amp; // 取得該介面的泛型參數 as.length == 1 \u0026amp;\u0026amp; as[0] == c) // type arg is c // 只帶有一種泛型且是實作類別為其本身 return c; // 返回該類別 } } } return null; // 皆否則回傳 null } ","permalink":"http://intervalrain.github.io/posts/java/hashmap/hashmap/","summary":"HashMap.comparableClassFor(Object x) 的函式解讀 原文敘述\nReturns x\u0026rsquo;s Class if it is of the form \u0026ldquo;class C implements Comparable\u0026rdquo;, else null.\n我的翻譯 當x的類別為Comparable的實作時，返回x的類別；否則返回 null。\n藉由這個函式實例的解讀，可以了解一下類別、泛型的相關概念。 Source Code static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) { if (x instanceof Comparable) { Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) { for (Type t : ts) { if ((t instanceof ParameterizedType) \u0026amp;\u0026amp; ((p = (ParameterizedType) t).","title":"[Java] Java 的中 HashMap.comparableClassFor(Object x) 的函式解讀"},{"content":"什麼是 Computer Science(CS)? CS 意在解決問題，更精準地說，是將問題 (input) 轉換成答案 (output) 的過程。 在計算機的世界，為了表達 inputs 和 outputs，我們必須將資訊標準化來儲存與操作它們，因為計算機只讀得懂 0 與 1 (開路/通路)。 如何表達數字? 在人類的世界，人們使用十進制(Decimal)。 在計算機的世界，用的是二進制(Binary)，也就是 0 與 1。 \\(1+1=10\\) \\((1,2,3,4,5,6,7,\u0026hellip;)_{10}=(001,010,011,100,101,110,111,\u0026hellip;)_2\\) 每個二進制的位元(digit)稱為 bit。 在現代計算機結構中，是由數以億計的電晶體(transistors)所組成的。 電晶體是一種具有開關(switch)性質的邏輯元件。 大部分的計算機一次用 8 個 bits，或稱 1 bytes，來表達數字。 \\(8 \\text{bits}=1 \\text{bytes}\\) 如何表達文字? 要表達文字，只需將不同的字元定義到對應的數字即可。 ASCII，American Standard Code for Information Interchange，即是一種基於拉丁字母的編碼系統，可應用顯示現代英語。 A-\u0026gt;65, B-\u0026gt;66, \u0026hellip;etc a-\u0026gt;97, b-\u0026gt;98, \u0026hellip;etc H-\u0026gt;72, I-\u0026gt;73, !-\u0026gt;33, so HI!=72, 73, 33 在不同語言，有不同的字符，就必須定義新的編碼系統，來容納更多的字符。 如 Unicode。 如 emojo 顏文字也是一種字符。 如何表達顏色? 同理，可以把不同的數字定義給不同的顏色，其中最常見的就是 RGB 系統。 由紅綠藍色塊所組成。 紅、綠、藍又個別以 8 bits 儲存的 256 種不同層度的顏色強度表示。 一共由 24 bits 來表達，超過1百萬種顏色。 那圖案、影片、音樂呢? 圖案是由數以萬計的色塊(dots)所組成，在螢幕顯示器上我們稱作畫素(pixels)。 影片則是由連續的圖案經由連續播放所建構而成的。 音樂同樣可以用 bits 來表達，其中 MIDI 是一種用數字來表達音符的形式。 All are composed by 0 and 1 in the computer world.\n演算法 (Algorithms) 我們現在可以表達 inputs 和 outputs 了，接下來要開始解決問題。 演算法就是將 inputs 經過一連串系統性、且有邏輯的指令(instructions)轉化成 outpus 的過程。 試想我們要從電話簿中查朋友的電話，電話簿是按照名字排序的。 我們可以從第一頁往後找到最後一頁，只有名字與電話是存在的，我們就會在電話簿中找到，所以這個方法是無誤的。 我們也可以兩頁兩頁找，但我們有可能因此錯失我們要查的號碼。 我們也可以一次翻到當前電話簿的一半，利用電話簿的排序規則，決定往左半邊找或右半邊找，並且持續這個步驟直到找到。 將上述的演算法效率視覺化如下： 從上圖可見，當我們處理的樣本數很大時(電話簿頁數很多)，那麼我們用方法1解決問題的時間(找到號碼的時間)就會大的很多。而利用方法3解決問題的時間則會呈對數成長。 因此，好的演算法設計，會大大的影響計算機的操作效率。 Pseudocode 我們可以用英文(或人類語言)來表達我們的演算法，這種寫作方式叫作 Pseudocode。 Pick up phone book Open to middle of phone book Look at page If person is on page Call person Else if person is earlier in book Open to middle of left half to book Go back to line 3 Else if person is later in book Open to middle of right half to book Go back to line 3 Else Quit 其中像Pick up、Open to、Look at、Quit這些動作，在計算機中我們稱作函式(functions)。 其中分枝的部分If、Else，稱作條件(conditions)。 而我們需要決定的判斷式如person is on page、person is earlier than book、person is later in book稱為布林邏輯值(Boolean expressions)，也就是Yes or No，是或否。 最後，不斷地重覆Go back to line 3的動作，稱作迴圈(loops)。 接下來我們會繼續遇到各種玩意： function 引數 arguments, 傳回值 return values conditionals Boolean expressions loops variables 和 David 的第一個程式：將 \u0026ldquo;hello, world\u0026rdquo; 印到螢幕上。 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello, world\\n\u0026#34;); } Scratch 試試看到 Scratch(https://scratch.mit.edu/) 這套圖像化軟體語言操作看看吧！ Reference: https://cs50.harvard.edu/college/2021/fall/notes/0/\n","permalink":"http://intervalrain.github.io/posts/cs50/lec0/","summary":"什麼是 Computer Science(CS)? CS 意在解決問題，更精準地說，是將問題 (input) 轉換成答案 (output) 的過程。 在計算機的世界，為了表達 inputs 和 outputs，我們必須將資訊標準化來儲存與操作它們，因為計算機只讀得懂 0 與 1 (開路/通路)。 如何表達數字? 在人類的世界，人們使用十進制(Decimal)。 在計算機的世界，用的是二進制(Binary)，也就是 0 與 1。 \\(1+1=10\\) \\((1,2,3,4,5,6,7,\u0026hellip;)_{10}=(001,010,011,100,101,110,111,\u0026hellip;)_2\\) 每個二進制的位元(digit)稱為 bit。 在現代計算機結構中，是由數以億計的電晶體(transistors)所組成的。 電晶體是一種具有開關(switch)性質的邏輯元件。 大部分的計算機一次用 8 個 bits，或稱 1 bytes，來表達數字。 \\(8 \\text{bits}=1 \\text{bytes}\\) 如何表達文字? 要表達文字，只需將不同的字元定義到對應的數字即可。 ASCII，American Standard Code for Information Interchange，即是一種基於拉丁字母的編碼系統，可應用顯示現代英語。 A-\u0026gt;65, B-\u0026gt;66, \u0026hellip;etc a-\u0026gt;97, b-\u0026gt;98, \u0026hellip;etc H-\u0026gt;72, I-\u0026gt;73, !-\u0026gt;33, so HI!=72, 73, 33 在不同語言，有不同的字符，就必須定義新的編碼系統，來容納更多的字符。 如 Unicode。 如 emojo 顏文字也是一種字符。 如何表達顏色? 同理，可以把不同的數字定義給不同的顏色，其中最常見的就是 RGB 系統。 由紅綠藍色塊所組成。 紅、綠、藍又個別以 8 bits 儲存的 256 種不同層度的顏色強度表示。 一共由 24 bits 來表達，超過1百萬種顏色。 那圖案、影片、音樂呢?","title":"[CS50] Lec 0 - Introduction to Computer Science"},{"content":"0. 前言 以往寫筆記通常是使用 Notion，簡單的 Markdown 語法搭配支援 LaTex，使得在撰寫學習筆記時，可以達到快速且美觀的呈現。 雖說 GitHub Pages 支援了 Markdown 的語法，但卻不支援 LaTex，這使得想將筆記從 Notion 移轉到 GitHub Pages，成為一個小缺點。 而此處介紹的是在網頁上顯示較為輕便的 KaTex。 1. 解決方法 利用 KaTex，在靜態頁面掛載 JavaScript 程式碼。 其在官網的描述是： Beautilful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works.\nStep 1. 創建一個可常駐的靜態頁面 在 \\layouts\\partials\\ 下創建一個叫作 math.html 的頁面。 注意是 global 的 layouts 文件夾中不是 hugo themes 中的文件夾 開啟頁面之後，在 \u0026lt;head\u0026gt; 與 \u0026lt;/head\u0026gt; 之間加入下一步驟內的 JavaScript 程式碼。 Step 2. 將 JavaScript 程式碼貼入 math.html \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 上面的程式碼是將 KaTex 的渲染程式碼寫到 math.html 中。 Step 3. 將 Hugo theme 中的 header.html 複製出來 同樣將 header.html 複製到 global 下的 \\layout\\partials，並貼入 {{- /* Head custom content area start */ -}} {{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} {{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} {{- /* Head custom content area end */ -}} 上面的程式碼的功能將 math.html 嵌進 header.html 中，並以 config.yml 中的 .param.math 指令來控制。 Step 4. 開始撰寫 KaTex 一開始先將標頭的定義區將 math: true，即可開啟該頁面的 KaTex 渲染功能。 在 \\\\( 符號與 \\\\) 符號間進行 inline equation 插入。 或在 $ $ 符號與 $ $ 間進行 block equation 的插入。 LaTex 的語法可以參考https://www.cs.pu.edu.tw/~wckuo/doc/latex123/node11.html 參考來源：\nhttps://bend1031.github.io/ https://teddygood.github.io/posts/blog/katex/ ","permalink":"http://intervalrain.github.io/posts/it/latexrendering/","summary":"0. 前言 以往寫筆記通常是使用 Notion，簡單的 Markdown 語法搭配支援 LaTex，使得在撰寫學習筆記時，可以達到快速且美觀的呈現。 雖說 GitHub Pages 支援了 Markdown 的語法，但卻不支援 LaTex，這使得想將筆記從 Notion 移轉到 GitHub Pages，成為一個小缺點。 而此處介紹的是在網頁上顯示較為輕便的 KaTex。 1. 解決方法 利用 KaTex，在靜態頁面掛載 JavaScript 程式碼。 其在官網的描述是： Beautilful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works.\nStep 1. 創建一個可常駐的靜態頁面 在 \\layouts\\partials\\ 下創建一個叫作 math.html 的頁面。 注意是 global 的 layouts 文件夾中不是 hugo themes 中的文件夾 開啟頁面之後，在 \u0026lt;head\u0026gt; 與 \u0026lt;/head\u0026gt; 之間加入下一步驟內的 JavaScript 程式碼。 Step 2.","title":"[IT] 在 GitHub Pages 中渲染 KaTex 公式"},{"content":"前言 2022/3/3 更新\n此篇為筆者以工作經驗為背景寫下的筆記，如有錯誤煩請指教。點此聯絡我。 Ring Oscillator 環形振盪器(RO) 簡介 在 IC 電路設計中，除了 metal routing 會造成訊號的延遲，邏輯閘從高電位轉換到低電位、或從低電位轉換到高電位(switch)，也會造成相對應的 Gate Delay，然而 Gate Delay 非常小，很難以測量，故 RO 是一個便於測量 Gate Delay 的電路設計。 在 IC 電路設計中，除了考慮速度，還會考慮功耗，而邏輯閘開關所造成的動態功耗(dynamic power consumption)佔比非常大，故 Ring Oscillator 也可以用來計算閘開關的功耗。 1. Time Delay 為了方便測量 Time Delay，RO 是一種用奇數 n 個 inverter(NOT Gate) 串接成的電路。透過在輸入端振盪產生方波，經過奇數個 inverter 之後，在輸出端產生反向的方波訊號，其時間差為經過 n 個 inverter 的 time delay。利用 time delay 會透過串接 inverter 累加(或稱propagation)的性質，故可以算出單個閘極的 gate delay(\\(T_p\\), propagation time) \\(t_{HtoL}\\sim t_{LtoH}=t_p=\\Delta T/2n\\) [註] 圖為一個由3個反向器組成的環形振盪器，其輸出頻率為 \\(\\frac{1}{6}t_p\\)(Gate Delay)。 由偶數個 inverter 組成的環形電路無法構成環形振盪器，因為其輸入與輸出相同。然而這種配置可以被用作記憶體的基本單元，它是建構靜態隨機存取記憶體 SRAM (static random access memory)的基本組成。 環形振盪器通常全部由 inverter 所組成，較能抵抗環境影響。事實上也可以用 non-inverter 與 inverter 混合組成，前提是 inverter 的總數要是奇數。其振蕩器的週期等於兩倍的閘延遲(Gate delay)， 為了增加振盪頻率，通常有兩種方法 減少環形電路中的 inverter 數量。 提升電壓，但同時會有較大的電流與功耗。 2. Power consumption 分為 Dynamic Power Consumption 與 Static Power Consumption。 \\(P_{total}=a\\times f\\times(\\frac{1}{2}CV_{DD}^2+V_{DD}I_{SC})+V_{DD}I_{off}+V_{DD}I_{Diode}+V_{DD}I_{Gate}\\) a 為 activity，每個 clock cycle 的平均開關切換數目。 故在電路設計上減少開關的次數也能有效降低功耗。 f 為頻率，代表一秒內可以完成幾次開關(switch)。 Dynamic Power(Switching Power) 為現今 CMOS 振盪器的主要功耗來源。 Dynamic Power 為 RO 在固定方波頻率為 \\(f\\) 時的平均功率(一組方波歷時為 \\(1/f\\))。 每一次開或關(switch)所耗的能為 \\(\\frac{1}{2}CV^2\\) 推導： \\(C=\\frac{Q}{V}\\) \\(I=\\frac{dQ}{dt}=C\\frac{dV}{dt}\\) \\(W=IV=\\int_{0}^{t}CV\\frac{dV}{dt}=\\frac{1}{2}CV^2\\) 故功耗為\\(P_{dynamic}=I_{active}V=CV^2\\) 如何降低功耗? 降低 Activity Clock Gating: 避免不必要的 flip-flop 避免 transition downstream logic 加入 enable 來控制邏輯複雜度 Data Gating: 利用 gating off inputs 來避免不必要的 toggling Bus Encodings Freeze \u0026ldquo;Don\u0026rsquo;t cares\u0026rdquo; Remove Glitches 降低\\(C_{Load}\\) 降低\\(f\\) 降低\\(V_{DD}\\) 平行結構 可降低相同 Throughput 時的功耗 Trade off performance Short-Circuit current 當 NMOS 與 PMOS 同時在切換開關時發生(NMOS尚未完全關閉，但PMOS已經部分啟動或是兩者相反)。 Kept to \u0026lt; 10% of capacitor charging current by making edges fast Static Power 因為 subthreshold leakage，MOS並未完全關閉所造成的漏電流致使的功耗。 在小尺寸(\u0026lt;180nm)元件中，因為 short channel effect 的加劇，此功耗的比例會加劇，甚至達 10~40%。 Diode Leakage Drain 端與 Source 端的 Diode junction 產生的 junction leakage。 通常很小可忽略。 Gate Leakage 因為電子穿隧穿過閘極氧化層(gate oxide)造成的漏電，通常在極薄的閘極氧化層發生，可忽略。 Reference reference1_Eletrical Engineering and Computer Science by MIT\n","permalink":"http://intervalrain.github.io/posts/device/ringoscillator/","summary":"前言 2022/3/3 更新\n此篇為筆者以工作經驗為背景寫下的筆記，如有錯誤煩請指教。點此聯絡我。 Ring Oscillator 環形振盪器(RO) 簡介 在 IC 電路設計中，除了 metal routing 會造成訊號的延遲，邏輯閘從高電位轉換到低電位、或從低電位轉換到高電位(switch)，也會造成相對應的 Gate Delay，然而 Gate Delay 非常小，很難以測量，故 RO 是一個便於測量 Gate Delay 的電路設計。 在 IC 電路設計中，除了考慮速度，還會考慮功耗，而邏輯閘開關所造成的動態功耗(dynamic power consumption)佔比非常大，故 Ring Oscillator 也可以用來計算閘開關的功耗。 1. Time Delay 為了方便測量 Time Delay，RO 是一種用奇數 n 個 inverter(NOT Gate) 串接成的電路。透過在輸入端振盪產生方波，經過奇數個 inverter 之後，在輸出端產生反向的方波訊號，其時間差為經過 n 個 inverter 的 time delay。利用 time delay 會透過串接 inverter 累加(或稱propagation)的性質，故可以算出單個閘極的 gate delay(\\(T_p\\), propagation time) \\(t_{HtoL}\\sim t_{LtoH}=t_p=\\Delta T/2n\\) [註] 圖為一個由3個反向器組成的環形振盪器，其輸出頻率為 \\(\\frac{1}{6}t_p\\)(Gate Delay)。 由偶數個 inverter 組成的環形電路無法構成環形振盪器，因為其輸入與輸出相同。然而這種配置可以被用作記憶體的基本單元，它是建構靜態隨機存取記憶體 SRAM (static random access memory)的基本組成。 環形振盪器通常全部由 inverter 所組成，較能抵抗環境影響。事實上也可以用 non-inverter 與 inverter 混合組成，前提是 inverter 的總數要是奇數。其振蕩器的週期等於兩倍的閘延遲(Gate delay)， 為了增加振盪頻率，通常有兩種方法 減少環形電路中的 inverter 數量。 提升電壓，但同時會有較大的電流與功耗。 2.","title":"[Device] Ring Oscillator 環形振盪器"},{"content":"List of Generics equality Case In leetcode no. 39 Combination Sum gives\nGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nIt is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be use mutiple times. 7 is a candidate, and 7 = 7. These are the only two combinations.\nList Equality Consider the following case:\nList\u0026lt;Integer\u0026gt; a = Arrays.asList(1,2,3,4); List\u0026lt;Integer\u0026gt; b = Arrays.asList(4,3,2,1); List\u0026lt;Integer\u0026gt; c = Arrays.asList(4,4,3,2,1); If we apply containsAll methods to test List equality in any order, it might work. But it might not test size of List, so it might go wrong when there is repeated items.\nSystem.out.println(b.containsAll(a)) // true System.out.println(c.containsAll(a)) // true How about applying equals methods after sorting the List?\n// apply sort to all to-be-check items. Collections.sort(a); Collections.sort(b); Collections.sort(c); System.out.println(a.equals(b)); // true System.out.println(a.equals(c)); // false Luckily, List can easily to test elements equality rathan than strict equality of the same object.\nSo, We can see if we want to test List Equality in any order, we can just simply sort List, and apply a.equals(b).\nList of List Equality But in case leetcode no. 39 Combination Sum, list of list of Integer in any order is considered acceptable answer. How do we test list of list of Integer equality?\nclass Solution{ public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target){..} @Test public void test(){ Solution sol = new Solution(); expected = List.of(List.of(2,2,3), List.of(7)) // [[2,2,3],[7]] actual = sol.combinationSum(new int[]{2,3,6,7} Collections.sort(expected); // fail Collections.sort(actual); // fail assertEquals(expected, acutal) } } The code will fail, and the description shows below.\nThe method sort(List) in the type Collections is not applicable for the arguments (List\u0026lt;List\u0026gt;)Java(67108979)\nThus, we have to turns List of Integers in the List into some other type like String, by using toString(). So, we can do like this:\npublic boolean equalsAnyOrder(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; expected, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; actual){ // First we have to check size of list equaltiy if (expected == null \u0026amp;\u0026amp; actual == null) return false; if ((expected == null \u0026amp;\u0026amp; actual != null) || (expected != null \u0026amp;\u0026amp; actual == null) || expected.size() != actual.size()) return false; // Create List of string to turn List of Integer into strings. List\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; d = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; expected.size(); i++){ c.add(expected.get(i).toString()); d.add(actual.get(i).toString()); } // Sort List of strings Collections.sort(c); Collections.sort(d); // Apply simple list equaltiy (We have known List.equals() just test equality of elements in order.) return c.equals(d); } More materials Leetcode no.39 Solution Test List of List Equality Implementation Test cases for no.39 by Junit ","permalink":"http://intervalrain.github.io/posts/java/listequal/","summary":"List of Generics equality Case In leetcode no. 39 Combination Sum gives\nGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.","title":"[Java] List of list of something equality"},{"content":"Rain Hu / intervalrain / 陣雨 Rain Hu 既是 intervalrain 也是陣雨。\nRain Hu /\n是我的英文名，象徵著我在生命的道路上，不斷的學習新知且努力向上的我。是 leetcode 相關文章與技術文件的作者。\nintervalrain /\n是我的帳號，象徵虛擬世界中的我，寫的可能是我的日常，可能是我的抱負，也可能是我的自喃。\n陣雨 /\n是我的筆名，象徵倘佯在音樂世界的我，寫的是我的音樂作品，詞或曲，或是一首歌。踟躕不如笑一個，然後繼續。\nAbout me 本名：胡鎮宇 生日：1991/12/3 血型：O型 星座：射手座 生肖：羊 專長：半導體物理、材料科學(金屬、電子)、資料結構與演算法 嗜好：彈吉他、喝咖啡、看劇、刷Leetcode(?) 學歷：國立清華大學 材料工程學系 Resume 簡歷：\n2018 Aug. - 2022 Aug. 半導體元件開發工程師 Semiconductor Devcie Engineer (UMC) 在特殊技術開發部門中針對 eHV(embedded High Voltage) 製程進行開發\n參與 eHV 40nm、28nm、22nm 開發、經歷過 Poly Gate、HKMG 製程。\n工作內容包含元件特性分析、WAT 程式設置、testkey layout design、DRC coding 等。 專案： (1) NWR Project (Achieve yield rate enhancement from 88% to 94% @28eHV Mass Production) (2) 22eHV Compact Platform Project (Reduce cost of 22eHV Process closed to 28eHV Process) LV Share Implant Project IO Mask Reduction Project (3) Co-cut methodology (Reduce 30% and more cost on shuttle for aging/qual) 自行開發工具： (1) IDAS+ (2) U2C (3) IV_Cur (4) KPlug 2022 Sep. - Present. 深度開發工程師 Deep Learning Engineer (UMC) 在 SMG (Department of Smart Manufacturing) 擔任 DL Engineer，幫助產線乃至研發單位開始工具、有效率的解決方案。 專案： (1) UEDA 5.0 使用語言：\n跟人的部分：中文、英文、韓文 跟電腦的部分：C++、Java、VBA、C#、Oracle SQL、Verilog 等等 八年級，青年期的最後一個梯次，三十歲的男子。\n當過吉他老師，組過樂團，當過鼓手，曾在西餐廳駐唱表演。\n喜歡寫程式處理繁瑣重覆的事，然後拿空出來的時間作白日夢。\n喜歡唱歌、彈吉他、聽歌、看書，寫憤世嫉俗的歌，解Leetcode，吃東西。\n喜歡的食物有台南的牛肉湯、壽司、拉麵、鹹蛋苦瓜、菜脯蛋、魚香茄子、香菇雞湯。\n最喜歡的甜點有肉桂捲、可麗露、檸檬塔、藍莓塔。\n喜歡所有切好的水果。不能吃楊桃。\nCoffeholic，淺中焙，耶加雪菲、西達摩。\n不喜毛、不喜草、不喜昆蟲、討厭KMT。\n如果明天就要死亡，我想去看看地中海。\nMore about me Music\nStreetvoice Youtube Coding\nLeetcode Algorithm Contact Email Facebook Instagram Twitter LinkedIn ","permalink":"http://intervalrain.github.io/posts/aboutme/","summary":"Rain Hu / intervalrain / 陣雨 Rain Hu 既是 intervalrain 也是陣雨。\nRain Hu /\n是我的英文名，象徵著我在生命的道路上，不斷的學習新知且努力向上的我。是 leetcode 相關文章與技術文件的作者。\nintervalrain /\n是我的帳號，象徵虛擬世界中的我，寫的可能是我的日常，可能是我的抱負，也可能是我的自喃。\n陣雨 /\n是我的筆名，象徵倘佯在音樂世界的我，寫的是我的音樂作品，詞或曲，或是一首歌。踟躕不如笑一個，然後繼續。\nAbout me 本名：胡鎮宇 生日：1991/12/3 血型：O型 星座：射手座 生肖：羊 專長：半導體物理、材料科學(金屬、電子)、資料結構與演算法 嗜好：彈吉他、喝咖啡、看劇、刷Leetcode(?) 學歷：國立清華大學 材料工程學系 Resume 簡歷：\n2018 Aug. - 2022 Aug. 半導體元件開發工程師 Semiconductor Devcie Engineer (UMC) 在特殊技術開發部門中針對 eHV(embedded High Voltage) 製程進行開發\n參與 eHV 40nm、28nm、22nm 開發、經歷過 Poly Gate、HKMG 製程。\n工作內容包含元件特性分析、WAT 程式設置、testkey layout design、DRC coding 等。 專案： (1) NWR Project (Achieve yield rate enhancement from 88% to 94% @28eHV Mass Production) (2) 22eHV Compact Platform Project (Reduce cost of 22eHV Process closed to 28eHV Process) LV Share Implant Project IO Mask Reduction Project (3) Co-cut methodology (Reduce 30% and more cost on shuttle for aging/qual) 自行開發工具： (1) IDAS+ (2) U2C (3) IV_Cur (4) KPlug 2022 Sep.","title":"About me"},{"content":"How to say hello to the world?\nJava class Hello{ public static void main(String[] args){ System.out.println(\u0026#34;Hello World!\u0026#34;); } } C #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } C++ #include \u0026lt;iostream\u0026gt; int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ###C#\nnamespace HelloWorld{ class Hello{ static void Main(String[] args){ System.Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } } Python print(\u0026#34;Hello World!\u0026#34;) Ruby puts \u0026#39;Hello World!\u0026#39; TCL Language puts \u0026#34;Hello World!\u0026#34; JavaScript console.log(\u0026#34;Hello World!\u0026#34;); TypeScript console.log \u0026#39;Hello World!\u0026#39; Perl print \u0026#34;Hello World!\u0026#34;; R cat(\u0026#39;Hello World!\u0026#39;); Swift println(\u0026#39;Hello World!\u0026#39;); Kotlin fun main(args: Array\u0026lt;String\u0026gt;){ println(\u0026#34;Hello World!\u0026#34;) } Go println(\u0026#39;Hello World!\u0026#39;); PHP echo \u0026#34;Hello World!\u0026#34;; VBA msgbox \u0026#34;Hello World\u0026#34; Assembly Language global _main extern _printf section .text _main: push message call _printf add esp, 4 message: db \u0026#39;Hello World!\u0026#39;, 11, 0 Me Hello the fucking world ","permalink":"http://intervalrain.github.io/posts/helloworld/","summary":"How to say hello to the world?\nJava class Hello{ public static void main(String[] args){ System.out.println(\u0026#34;Hello World!\u0026#34;); } } C #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } C++ #include \u0026lt;iostream\u0026gt; int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } ###C#\nnamespace HelloWorld{ class Hello{ static void Main(String[] args){ System.Console.WriteLine(\u0026#34;Hello World!\u0026#34;); } } } Python print(\u0026#34;Hello World!\u0026#34;) Ruby puts \u0026#39;Hello World!\u0026#39; TCL Language puts \u0026#34;Hello World!\u0026#34; JavaScript console.","title":"Hello World"},{"content":"數位系統與開關電路 在現實世界中，資訊是以類比(Analog)的方式傳遞的，換言之，資訊是連續的 在電腦世界中，資訊是以數位(Digital)的方式傳遞的，也就是開與關或是0或1。 A/D \u0026lt;-\u0026gt; DSP(digital signal processor) \u0026lt;-\u0026gt; D/A Switching Circuit 可分為三個層級： System: 模組Modules、算術運算單元 ALU(Arithmetic logic unit)、記憶體 Memory Logic：邏輯閘(gates) Circuit：電晶體(transistors) 經由 switching network 的設計，可將輸入轉成合乎 spec 的輸出。其中 switching network 的種類包含： Combinational network 輸出是輸入的函數，且表達當下的值。 Sequential network 輸出是輸入的函數，可以表達當下的值或是過去的值。 具有記憶體的行為 Switches 由電晶體來實現 transistor level, gate level, module level\u0026hellip; 數字系統與轉換 在現實世界中，最普遍使用的數字系統為十進制(Decimal) 然而在電腦世界中，因為只有代表開與關的 0 與 1，故使用的數字系統是以二進制(Binary)為基礎。 \\(N=(a_2a_1a_0)_R=a_2\\times R^2+a_1\\times R^1+a_0\\times R^0\\) 負數 N 正數表示 -N 正數加負號 1的補數 2的補數 +0 0000 -0 1000 1111 N/A +1 0001 -1 1001 1110 1111 +2 0010 -2 1010 1101 1110 +3 0011 -3 1011 1100 1101 +4 0100 -4 1100 1011 1100 +5 0101 -5 1101 1010 1011 +6 0110 -6 1110 1001 1010 +7 0111 -7 1111 1000 1001 +8 N/A -8 N/A N/A 1000 二進制算數 當兩數相加或兩數相減時，超過可用bits數時會發生overflow， 例如-3+-4=-4是OK的 但-5+-6=-11會產生溢位 二進制的表達方式 Binary codes Decimal Digit 8421 Code(BCD) 6311 Code Excess-3 Code 2-out-of-5 Code Gray Code 0 0000 0000 0011 00011 0000 1 0001 0001 0100 00101 0001 2 0010 0011 0101 00110 0011 3 0011 0100 0110 01001 0010 4 0100 0101 0111 01010 0110 5 0101 0111 1000 01100 1110 6 0110 1000 1001 10001 1010 7 0111 1001 1010 10010 1011 8 1000 1011 1011 10100 1001 9 1001 1100 1100 11000 1000 Weighted Codes 8421 Code 與 6311 都是 Weighted Code，代表每4個bit，各自代表的數字， 例：1011 for 8421 = 8 + 0 + 2 + 1 = 11 例：1011 for 6311 = 6 + 0 + 1 + 1 = 8 Excess-3 Codes Excess-3 是以 8421 Code 為基礎下，額外加 3。 使得 i 與 10-i 互為 1 的補數， 0 與 9 為補數。(0011 與 1100) 1 與 8 為補數。(0100 與 1011) 2 與 7 為補數。(0101 與 1010) 3 與 6 為補數。(0110 與 1001) 4 與 5 為補數。(0111 與 1000) Gray Codes 兩相鄰的數只會相差一個 bit 又名 Reflected Binary Codes(RBC)、Unit distance code、Minimum error code 可以減少 switching operation 如何轉換 Gray Code? 參考Leetcode no.89 ASCII table ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec1/","summary":"數位系統與開關電路 在現實世界中，資訊是以類比(Analog)的方式傳遞的，換言之，資訊是連續的 在電腦世界中，資訊是以數位(Digital)的方式傳遞的，也就是開與關或是0或1。 A/D \u0026lt;-\u0026gt; DSP(digital signal processor) \u0026lt;-\u0026gt; D/A Switching Circuit 可分為三個層級： System: 模組Modules、算術運算單元 ALU(Arithmetic logic unit)、記憶體 Memory Logic：邏輯閘(gates) Circuit：電晶體(transistors) 經由 switching network 的設計，可將輸入轉成合乎 spec 的輸出。其中 switching network 的種類包含： Combinational network 輸出是輸入的函數，且表達當下的值。 Sequential network 輸出是輸入的函數，可以表達當下的值或是過去的值。 具有記憶體的行為 Switches 由電晶體來實現 transistor level, gate level, module level\u0026hellip; 數字系統與轉換 在現實世界中，最普遍使用的數字系統為十進制(Decimal) 然而在電腦世界中，因為只有代表開與關的 0 與 1，故使用的數字系統是以二進制(Binary)為基礎。 \\(N=(a_2a_1a_0)_R=a_2\\times R^2+a_1\\times R^1+a_0\\times R^0\\) 負數 N 正數表示 -N 正數加負號 1的補數 2的補數 +0 0000 -0 1000 1111 N/A +1 0001 -1 1001 1110 1111 +2 0010 -2 1010 1101 1110 +3 0011 -3 1011 1100 1101 +4 0100 -4 1100 1011 1100 +5 0101 -5 1101 1010 1011 +6 0110 -6 1110 1001 1010 +7 0111 -7 1111 1000 1001 +8 N/A -8 N/A N/A 1000 二進制算數 當兩數相加或兩數相減時，超過可用bits數時會發生overflow， 例如-3+-4=-4是OK的 但-5+-6=-11會產生溢位 二進制的表達方式 Binary codes Decimal Digit 8421 Code(BCD) 6311 Code Excess-3 Code 2-out-of-5 Code Gray Code 0 0000 0000 0011 00011 0000 1 0001 0001 0100 00101 0001 2 0010 0011 0101 00110 0011 3 0011 0100 0110 01001 0010 4 0100 0101 0111 01010 0110 5 0101 0111 1000 01100 1110 6 0110 1000 1001 10001 1010 7 0111 1001 1010 10010 1011 8 1000 1011 1011 10100 1001 9 1001 1100 1100 11000 1000 Weighted Codes 8421 Code 與 6311 都是 Weighted Code，代表每4個bit，各自代表的數字， 例：1011 for 8421 = 8 + 0 + 2 + 1 = 11 例：1011 for 6311 = 6 + 0 + 1 + 1 = 8 Excess-3 Codes Excess-3 是以 8421 Code 為基礎下，額外加 3。 使得 i 與 10-i 互為 1 的補數， 0 與 9 為補數。(0011 與 1100) 1 與 8 為補數。(0100 與 1011) 2 與 7 為補數。(0101 與 1010) 3 與 6 為補數。(0110 與 1001) 4 與 5 為補數。(0111 與 1000) Gray Codes 兩相鄰的數只會相差一個 bit 又名 Reflected Binary Codes(RBC)、Unit distance code、Minimum error code 可以減少 switching operation 如何轉換 Gray Code?","title":"[Logic Design] Lec 01 - 數字系統與轉換"},{"content":"基本邏輯運算 Logic Gates Not Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|}\\hline \\text{X}\u0026amp;\\overline{\\text{X}}\\text{or}\\text{X\u0026rsquo;}\\\\\\hline 0\u0026amp;1\\\\\\hline 1\u0026amp;0\\\\\\hline \\end{array} \\) And Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\cdot\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) Or Gates Symbol Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X+Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) 布林表達式與真值表(Boolean Expression and Truth Table) Boolean expression 用 ' 代表 NOT 用 + 代表 OR 用 . 代表 AND 將輸入用上面的運算子表示成算式，如：\\((A+C)(B\u0026rsquo;+C)\\) Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{ccc|cccccc} A\u0026amp;B\u0026amp;C\u0026amp;B\u0026rsquo;\u0026amp;AB\u0026rsquo;\u0026amp;AB\u0026rsquo;+C\u0026amp;A+C\u0026amp;B\u0026rsquo;+C\u0026amp;(A+C)(B\u0026rsquo;+C)\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} \\) 基本運算定理 NOT gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x\u0026rsquo;)\u0026rsquo;\u0026amp;=\u0026amp;x \\end{array} } \\)\nAND gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x+0\u0026amp;=\u0026amp;x\\\\ x+1\u0026amp;=\u0026amp;1\\\\ x+x\u0026amp;=\u0026amp;x\\\\ x+x\u0026rsquo;\u0026amp;=\u0026amp;1 \\end{array} } \\)\nOR gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\cdot 0\u0026amp;=\u0026amp;0\\\\ x\\cdot 1\u0026amp;=\u0026amp;x\\\\ x\\cdot x\u0026amp;=\u0026amp;x\\\\ x\\cdot x\u0026rsquo;\u0026amp;=\u0026amp;0 \\end{array} } \\)\n進階運算定理 交換律 Commutative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} xy\u0026amp;=\u0026amp;yx\\\\ x+y\u0026amp;=\u0026amp;y+x \\end{array} } \\)\n結合律 Associative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (xy)z\u0026amp;=\u0026amp;x(yz)\\\\ (x+y)+z\u0026amp;=\u0026amp;x+(y+z) \\end{array} } \\)\n分配律 Distributive Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026amp;=\u0026amp;xy+xz\\\\ x+yz\u0026amp;=\u0026amp;(x+y)(x+z) \\end{array} } \\)\nMultiplying out and factoring Sum of Product(SOP) form 將算式化整成各個輸入端先 AND 後再 OR 例： \\(ABC+AB\u0026rsquo;C+AB\u0026rsquo;C\u0026rsquo;\\) Product of Sum(POS) form 將算式化整成各個輸入端先 OR 後再 AND 例： \\((A+B+C)(A+B\u0026rsquo;+C)(A+B\u0026rsquo;+C\u0026rsquo;)\\) Multiplying out： 將算式化簡成 SOP form 善用\\(\\boxed{(A+B)(A+C)=A+BC}\\) 範例：\n\\((A+BC)(A+D+E)\\)\n\\(=(A+x)(A+y)\\)\n\\(=A+xy\\)\n\\(=A+BC(D+E)\\)\n\\(=A+BCD+BCE\\) Factoring： 將算式化簡成 POS form 善用\\(\\boxed{A+BC=(A+B)(A+C)}\\) 範例：\n\\(AB\u0026rsquo;+C\u0026rsquo;D\\)\n\\(=(AB\u0026rsquo;+C\u0026rsquo;)(AB\u0026rsquo;+D)\\)\n\\(=(A+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;)(A+D)(B\u0026rsquo;+D))\\) 2-level realization 利用 Multiplying out 與 Factoring 可以將電路簡化成 2-level circuit 因為減少了 Delay propagation 可以減少 Total Time Delay DeMorgan\u0026rsquo;s Laws and Duality DeMorgan\u0026rsquo;s Laws 方法： \\(AND\\leftrightarrow OR\\) \\(A\\leftrightarrow A\u0026rsquo;\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x+y+z+\u0026hellip;)\u0026rsquo;\u0026amp;=\u0026amp;x\u0026rsquo; y\u0026rsquo; z\u0026rsquo;\u0026hellip;\\\\ (xyz\u0026hellip;)\u0026rsquo;\u0026amp;=\u0026amp;x\u0026rsquo;+y\u0026rsquo;+z\u0026rsquo;\u0026hellip; \\end{array} } \\) Truth Table 證明\n\\( \\def\\arraystretch{1.5}\\begin{array}{ccc|ccc|c|c|c} x\u0026amp;y\u0026amp;z\u0026amp;x\u0026rsquo;\u0026amp;y\u0026rsquo;\u0026amp;z\u0026rsquo;\u0026amp;x+y+z\u0026amp;(x+y+z)\u0026rsquo;\u0026amp;x\u0026rsquo; y\u0026rsquo; z\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ \\end{array} \\) 範例\n\\([(A\u0026rsquo; B+C\u0026rsquo;)(D\u0026rsquo;+EF\u0026rsquo;)+GH+W]\u0026rsquo;\\)\n\\(=[(A+B\u0026rsquo;)C+D(E\u0026rsquo;+F)] (G\u0026rsquo;+H\u0026rsquo;)W\u0026rsquo;\\) Duality 方法\n\\(AND\\leftrightarrow OR\\) \\(0\\leftrightarrow 1\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{cccccccccc} [f(\u0026amp;x_1,\u0026amp;x_2,\u0026amp;\u0026hellip;,\u0026amp;x_n,\u0026amp;0,\u0026amp;1,\u0026amp;+,\u0026amp;\\cdot\u0026amp;)]^D\\\\ =f(\u0026amp;x_1,\u0026amp;x_2,\u0026amp;\u0026hellip;,\u0026amp;x_n,\u0026amp;1,\u0026amp;0,\u0026amp;\\cdot,\u0026amp;+\u0026amp;) \\end{array} } \\) 性質\n\\(\\boxed{F=G\\rightarrow F^D=G^D}\\) 範例\n\\((x+y\u0026rsquo;)y=xy\\rightarrow x\\cdot y\u0026rsquo;+y=x+y\\)\n回顧分配律 Distributive Law，即為 Duality 的表現。\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026amp;=\u0026amp;xy+xz\\\\ x+yz\u0026amp;=\u0026amp;(x+y)(x+z) \\end{array} } \\)\nExclusive-OR and equivalence operations Exlusive-OR(XOR,\\(\\oplus\\)) Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\oplus\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;0\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\oplus 0\u0026amp;=\u0026amp;x\\\\ x\\oplus 1\u0026amp;=\u0026amp;x\u0026rsquo;\\\\ x\\oplus x\u0026amp;=\u0026amp;0\\\\ x\\oplus x\u0026rsquo;\u0026amp;=\u0026amp;1\\\\ x\\oplus y\u0026amp;=\u0026amp;y\\oplus x\\\\ (x\\oplus y)\\oplus z\u0026amp;=\u0026amp;x\\oplus (y\\oplus z)\\\\ x(y\\oplus z)\u0026amp;=\u0026amp;xy\\oplus xz\\\\ x\\oplus y\u0026amp;=\u0026amp;xy+x\u0026rsquo; y' \\end{array} } \\) Equivalence(\\(\\equiv\\)) Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\equiv{Y}\\\\\\hline 0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\equiv 0\u0026amp;=\u0026amp;x\u0026rsquo;\\\\ x\\equiv 1\u0026amp;=\u0026amp;x\\\\ x\\equiv x\u0026amp;=\u0026amp;1\\\\ x\\equiv x\u0026rsquo;\u0026amp;=\u0026amp;0\\\\ x\\equiv y\u0026amp;=\u0026amp;y\\equiv x\\\\ (x\\equiv y)\\equiv z\u0026amp;=\u0026amp;x\\equiv (y\\equiv z)\\\\ x(y\\equiv z)\u0026amp;=\u0026amp;xy\\equiv xz\\\\ x\\equiv y\u0026amp;=\u0026amp;xy\u0026rsquo;+x\u0026rsquo; y \\end{array} } \\) 連鎖律 The consensus thorem 公式： \\(\\boxed{xy+x\u0026rsquo; z+yz=xy+x\u0026rsquo; z}\\) \\(\\boxed{(x+y)(x\u0026rsquo;+z)(y+z)=(x+y)(x\u0026rsquo;+z)}\\) 證明：\n\\(xy+x\u0026rsquo; z+yz\\)\n\\(=xy+x\u0026rsquo; z + (x+x\u0026rsquo;)yz\\)\n\\(=xy+xyz+x\u0026rsquo; z+x\u0026rsquo; yz\\)\n\\(=xy(1+z)+x\u0026rsquo; z(1+y)\\)\n\\(=xy+x\u0026rsquo; z\\) 簡化布林表達式的流程 利用 \\(\\boxed{xy+xy\u0026rsquo;=x(y+y\u0026rsquo;)=x}\\)(AND性質) 利用 \\(\\boxed{x+xy+\u0026hellip;=x(1+y+\u0026hellip;)=x}\\)(OR性質) 利用 \\(\\boxed{xy+x\u0026rsquo; z+yz=xy+x\u0026rsquo;z }\\)(連鎖律) 利用 \\(\\boxed{x+x\u0026rsquo;y=x(y+y\u0026rsquo;)+x\u0026rsquo;y=xy+xy\u0026rsquo;+x\u0026rsquo; y=x+y}\\) 必要時加入 redundant terms Lec3會使用圖表法，較不容易出錯。 如何證明布林表達式的正確性? 建構 Truth Table 簡化 LHS 和 RHS ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec2/","summary":"基本邏輯運算 Logic Gates Not Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|}\\hline \\text{X}\u0026amp;\\overline{\\text{X}}\\text{or}\\text{X\u0026rsquo;}\\\\\\hline 0\u0026amp;1\\\\\\hline 1\u0026amp;0\\\\\\hline \\end{array} \\) And Gates Symbol Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\cdot\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) Or Gates Symbol Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X+Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) 布林表達式與真值表(Boolean Expression and Truth Table) Boolean expression 用 ' 代表 NOT 用 + 代表 OR 用 . 代表 AND 將輸入用上面的運算子表示成算式，如：\\((A+C)(B\u0026rsquo;+C)\\) Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{ccc|cccccc} A\u0026amp;B\u0026amp;C\u0026amp;B\u0026rsquo;\u0026amp;AB\u0026rsquo;\u0026amp;AB\u0026rsquo;+C\u0026amp;A+C\u0026amp;B\u0026rsquo;+C\u0026amp;(A+C)(B\u0026rsquo;+C)\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} \\) 基本運算定理 NOT gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.","title":"[Logic Design] Lec 02 - 布林代數"},{"content":"布林表達式的轉換 將文字敘述轉換成布林表達式： \\( \\def\\arraystrecth{1.5}\\begin{array}{l} \\underbrace{\\text{The alarm will ring}}_ {Z} \\text{ iff } \\underbrace{\\text{the power of alarm is on}} _{A} \\text{ and } \\underbrace{\\text{the door is not closed}} _{B\u0026rsquo;} \\\\ \\text{ or } \\underbrace{\\text{it is after 6 p.m.}} _{C} \\text{ and } \\underbrace{\\text{the window is not closed}} _{D\u0026rsquo;} \\end{array} \\)\n\\(Z=AB\u0026rsquo;+CD\u0026rsquo;\\) 由真值表開始建構邏輯電路 Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|c|c} A\u0026amp;B\u0026amp;C\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array} } \\) 利用 1\u0026rsquo;s 的函數\n\\(f=A\u0026rsquo; BC+AB\u0026rsquo; C\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo;+ABC\\)\n\\(=A\u0026rsquo; BC+AB\u0026rsquo;+AB\\)\n\\(=A\u0026rsquo; BC+A\\)\n\\(=A+BC\\) 利用 0\u0026rsquo;s 的函數\n\\(f=(A+B+C)(A+B+C\u0026rsquo;)(A+B\u0026rsquo;+C)\\)\n\\(=(A+B)(A+B\u0026rsquo;+C)\\)\n\\(=A+B(B\u0026rsquo;+C)\\)\n\\(=A+BC\\) Minterm 與 maxterm 展開 以 \\(F=A\u0026rsquo; BC+A\\) 為範例 \\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{c|ccc|c|c|cc} \\text{Row No.}\u0026amp;A\u0026amp;B\u0026amp;C\u0026amp;\\text{Minterns}\u0026amp;\\text{Maxterms}\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;\\text{A\u0026rsquo;B\u0026rsquo;C\u0026rsquo;}=\\text{m}_0\u0026amp;\\text{A+B+C}=\\text{M}_0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;\\text{A\u0026rsquo;B\u0026rsquo;C}=\\text{m}_1\u0026amp;\\text{A+B+C\u0026rsquo;}=\\text{M}_1\u0026amp;0\u0026amp;1\\\\ 2\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;\\text{A\u0026rsquo;BC\u0026rsquo;}=\\text{m}_2\u0026amp;\\text{A+B\u0026rsquo;+C}=\\text{M}_2\u0026amp;0\u0026amp;1\\\\ 3\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;\\text{A\u0026rsquo;BC}=\\text{m}_3\u0026amp;\\text{A+B\u0026rsquo;+C\u0026rsquo;}=\\text{M}_3\u0026amp;1\u0026amp;0\\\\ 4\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;\\text{AB\u0026rsquo;C\u0026rsquo;}=\\text{m}_4\u0026amp;\\text{A\u0026rsquo;+B+C}=\\text{M}_4\u0026amp;1\u0026amp;0\\\\ 5\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;\\text{AB\u0026rsquo;C}=\\text{m}_5\u0026amp;\\text{A\u0026rsquo;+B+C\u0026rsquo;}=\\text{M}_5\u0026amp;1\u0026amp;0\\\\ 6\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;\\text{ABC\u0026rsquo;}=\\text{m}_6\u0026amp;\\text{A\u0026rsquo;+B\u0026rsquo;+C}=\\text{M}_6\u0026amp;1\u0026amp;0\\\\ 7\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\text{ABC}=\\text{m}_7\u0026amp;\\text{A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;}=\\text{M}_7\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\)\n\\(m_i\u0026rsquo;=M_i\\)\n\\(\\text{f=A\u0026rsquo;BC+A=1}\\)\n\\(\\text{=A\u0026rsquo;BC+AB\u0026rsquo;C\u0026rsquo;+AB\u0026rsquo;C+ABC\u0026rsquo;+ABC}\\)\n\\(=m_3+m_4+m_5+m_6+m_7\\)\n\\(=\\sum m(3,4,5,6,7)\\)\n\\(\\text{f=(A+B+C)(A+B+C\u0026rsquo;)(A+B\u0026rsquo;+C)=0}\\)\n\\(=M_0M_1M_2\\)\n\\(=\\prod M(0,1,2)\\)\nMaxterm 與 minterm 的轉換\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{rcl} g\u0026amp;=\u0026amp;\\sum m(2,3,4,6,7)\\\\ \u0026amp;=\u0026amp;\\prod M(0,1,5)\\\\ g\u0026rsquo;\u0026amp;=\u0026amp;\\sum m(0,1,5)\\\\ g\u0026amp;=\u0026amp;[\\sum m(0,1,5)]\u0026rsquo;\\\\ \u0026amp;=\u0026amp;\\prod m\u0026rsquo;(0,1,5)\\\\ \u0026amp;=\u0026amp;\\prod M(0,1,5) \\end{array} } \\)\n性質：\n\\(\\boxed{\\text{m}_i\\text{m}_j=0\\text{ if i}\\neq j}\\) 未完整定義的函式(Don\u0026rsquo;t Care) Truth table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{lll|l} A\u0026amp;B\u0026amp;C\u0026amp;F\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;X\\leftarrow \\text{Don\u0026rsquo;t care}\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;X\\leftarrow \\text{Don\u0026rsquo;t care}\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\) 表達式： \\(F=\\sum m(0,3,7)+\\sum d(1,6)=\\prod M(2,4,5)\\cdot \\prod(1,6)\\) Binary adders and subtracters Half Adder 半加器 \\(X,Y_{\\text{in}}\\rightarrow{\\boxed{\\text{Half Adder}}\\rightarrow \\text{Sum}}\\) Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{cc|c} X\u0026amp;Y\u0026amp;Sum\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\) 表達式： \\(\\text{Sum}=X\u0026rsquo; Y+XY\u0026rsquo;\\) Full Adder 全加器 \\(X,Y,C_{\\text{in}}\\rightarrow{\\boxed{\\text{Full Adder}}\\rightarrow C_{out}, \\text{Sum}}\\) Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|cc} X\u0026amp;Y\u0026amp;C_{\\text{in}}\u0026amp;C_{\\text{out}}\u0026amp;\\text{Sum}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\) 表達式： \\(\\text{Sum}=X\\oplus Y\\oplus C_{\\text{in}}\\) \\(C_\\text{out}=YC_{\\text{in}}+XC_{\\text{in}}+XY\\) 邏輯電路 4-Bit Parallel Adder (Ripple Carry Adder 漣波加法器) 四個平行串接的全加器 (Full Adder) Binary Subtracter using Full Adders 用全加器來實現減法器 Full Subtracter \\(x_i,y_i,b_i\\rightarrow\\boxed{\\text{Full Subtracter}}\\rightarrow b_{i+1},d_i\\)\nTruth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|cc} x_i\u0026amp;y_i\u0026amp;b_i\u0026amp;b_{i+1}\u0026amp;d_i\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\)\n示意\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{c|cc} \u0026amp;\\text{Column i Before Borrow}\u0026amp;\\text{Column i After Borrow}\\\\\\hline x_i\u0026amp;0\u0026amp;10\u0026amp;\\\\ -b_i\u0026amp;-1\u0026amp;-1\\\\ -y_i\u0026amp;-1\u0026amp;-1\\\\\\hline d_i\u0026amp;\u0026amp;0(b_{i+1}=1)\\\\ \\end{array} } \\)\nParallel Subtracter Speeding up integer additions Ripple Carry Adder 一般的漣波進位加法器 設計簡單、規律 有較大的 Time Delay 一個 Full Adder 為\\(C_\\text{out}=YC_{\\text{in}}+XC_{\\text{in}}+XY\\) 也就是先 AND 再 OR，兩個 gate delay 故 n-bit adder 的 time delay 是 2n Carry Lockahead Adder(CLA) \\(\\text{Sum}=A\\oplus B\\oplus C_{in}\\) \\(C_{out}=AB+(A+B)C_{in}\\) \\(C_{i+1}=A_iB_i+(A_i+B_i)C_i\\) \\(C_{i+1}=g_i+p_iC_i\\) \\(g_i=A_iB_i\\) generate function \\(p_i=A_i+B_i\\) propagate function \\(C_2=g_1+p_1C_1\\) \\(C_2=g_1+p_1p_0g_0+p_1p_0C_0\\) \\(C_n=g_{n-1}+p_{n-1}g_{n-2}+p_{n-1}p_{n-2}g_{n-3}+\u0026hellip;+p_{n-1}p_{n-2}\u0026hellip;p_1g_0+p_{n-1}p_{n-2}\u0026hellip;p_0C_0\\) 換句話說，\\(C_n\\)可以藉由 \\(C_0\\)運算出來，以 4-bit 為例，可以從漣波的 8 次降到 5 次的 Gate delay。 Carry Select Adder 將兩個加法作平行處理 預先假設 carry-in 的值，待前一級的 carry-in 算出後再用 selector 選擇正確的 carry-in，減去收到前級 carry-in 再開始運算的時間。 Binary multiplication 用邏輯閘模擬一般十進制進位法的乘法 示意\n\\( \\def\\arraystretch{1}\\begin{array}{rcccc} \\text{Multiplicand}\u0026amp;\u0026amp;\u0026amp;B_1\u0026amp;B_0\\\\ \\text{Multiplier}\u0026amp;\u0026amp;\u0026amp;A_1\u0026amp;A_0\\\\\\hline \\text{Partial products}\u0026amp;\u0026amp;\u0026amp;A_0B_1\u0026amp;A_0B_0\\\\ \\text{shift one bit left}\u0026amp;\u0026amp;A_1B_1\u0026amp;A_1B_0\\\\ \\text{Sum of partial products}\u0026amp;C1\u0026amp;C2\u0026amp;C3\u0026amp;C4\\\\ \\end{array} \\) ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec3/","summary":"布林表達式的轉換 將文字敘述轉換成布林表達式： \\( \\def\\arraystrecth{1.5}\\begin{array}{l} \\underbrace{\\text{The alarm will ring}}_ {Z} \\text{ iff } \\underbrace{\\text{the power of alarm is on}} _{A} \\text{ and } \\underbrace{\\text{the door is not closed}} _{B\u0026rsquo;} \\\\ \\text{ or } \\underbrace{\\text{it is after 6 p.m.}} _{C} \\text{ and } \\underbrace{\\text{the window is not closed}} _{D\u0026rsquo;} \\end{array} \\)\n\\(Z=AB\u0026rsquo;+CD\u0026rsquo;\\) 由真值表開始建構邏輯電路 Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|c|c} A\u0026amp;B\u0026amp;C\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array} } \\) 利用 1\u0026rsquo;s 的函數","title":"[Logic Design] Lec 03 - Minterm 與 Maxterm 展開"},{"content":"布林邏輯式的簡化 卡諾圖(Karnaugh Maps, K-maps)是一種簡單、快速的簡化布林邏輯的方法。 SOP 將布林邏輯化簡成最簡SOP(Minimum Sum of products) \\(F=A\u0026rsquo; B\u0026rsquo; C\u0026rsquo;+A\u0026rsquo; B\u0026rsquo; C+A\u0026rsquo; BC\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo; +ABC\\) \\(F=A\u0026rsquo; B\u0026rsquo;+B\u0026rsquo; C+BC\u0026rsquo;+AB\\) \\(F=A\u0026rsquo; B\u0026rsquo;+BC\u0026rsquo;+AC\\) POS 將布林邏輯化簡成最簡POS(Minimum Product of Sums) \\(F=(A+B\u0026rsquo;+C+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D)(A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;+D)(A+B+C\u0026rsquo;+D)(A\u0026rsquo;+B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;+D)(B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D)(A+B\u0026rsquo;+C\u0026rsquo;)(C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(C\u0026rsquo;+D)\\) 2或3個變數的卡諾圖 簡化2個變數的布林邏輯式 \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B\\) 布林代數： \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B=A\u0026rsquo;(B\u0026rsquo;+B)=A\u0026rsquo;\\) 卡諾圖： \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow B\\rightarrow A\u0026amp;0\u0026amp;1\u0026amp;\\\\\\hline 0\u0026amp;\\text{A=0,B=0}\u0026amp;\\text{A=1,B=0}\\\\\\hline 1\u0026amp;\\text{A=0,B=1}\u0026amp;\\text{A=1,B=1}\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\rightarrow A' \\) 簡化3個變數的布林邏輯式 \\(F=\\sum m(2,3,6)=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;\\) 布林代數： \\(F=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;=A\u0026rsquo; B+BC\u0026rsquo;\\) 卡諾圖：*注意相鄰以grey code排列 \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow BC\\rightarrow A\u0026amp;0\u0026amp;1\u0026amp;\\\\\\hline 00\u0026amp;m_0(000)\u0026amp;m_4(100)\\\\\\hline 01\u0026amp;m_1(001)\u0026amp;m_5(101)\\\\\\hline 11\u0026amp;m_3(011)\u0026amp;m_7(111)\\\\\\hline 10\u0026amp;m_2(010)\u0026amp;m_6(110)\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;0\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;0\u0026amp;0\\\\\\hline B C \u0026amp;1\u0026amp;0\\\\\\hline B C\u0026rsquo; \u0026amp;1\u0026amp;1\\\\ \\end{array} } \\rightarrow A\u0026rsquo; B+BC' \\) 相鄰(Adjacency)的定義 最上面可以與最下面相接，視為相鄰 最左邊可以與最右邊相接，視為相鄰 \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;0\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;0\u0026amp;0\\\\\\hline B C \u0026amp;1\u0026amp;1\\\\\\hline B C\u0026rsquo; \u0026amp;0\u0026amp;0\\\\ \\end{array} } \\rightarrow BC \\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;0\u0026amp;0\\\\\\hline B C \u0026amp;0\u0026amp;0\\\\\\hline B C\u0026rsquo; \u0026amp;1\u0026amp;0\\\\ \\end{array} } \\rightarrow A\u0026rsquo; C' \\) 組合的規則 以組合相鄰且以2為倍數為規則 組合的元素愈多愈好 可以重複選(cover) 等效最簡式 \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo; C\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026rsquo; C \u0026amp;1\u0026amp;1\\\\\\hline B C \u0026amp;0\u0026amp;1\\\\\\hline B C\u0026rsquo; \u0026amp;1\u0026amp;1\\\\ \\end{array}} \\rightarrow F=A\u0026rsquo; B\u0026rsquo;+BC\u0026rsquo;+AC=A\u0026rsquo; C\u0026rsquo;+B\u0026rsquo;C+AB \\) 4個變數的卡諾圖 \\(F=ACD+A\u0026rsquo; B+D\u0026rsquo;\\) 以卡諾圖表示 \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;A\u0026rsquo; B\u0026rsquo;\u0026amp;A\u0026rsquo; B\u0026amp;AB\u0026amp;AB\u0026rsquo;\\\\\\hline C\u0026rsquo; D\u0026rsquo;\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline C\u0026rsquo; D \u0026amp; \u0026amp;1\u0026amp; \u0026amp; \\\\\\hline C D \u0026amp; \u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline C D\u0026rsquo; \u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array}} \\quad \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;m_0\u0026amp;m_4\u0026amp;m_{12}\u0026amp;m_8\\\\\\hline 01\u0026amp;m_1\u0026amp;m_5\u0026amp;m_{13}\u0026amp;m_9\\\\\\hline 11\u0026amp;m_3\u0026amp;m_7\u0026amp;m_{15}\u0026amp;m_{11}\\\\\\hline 10\u0026amp;m_2\u0026amp;m_6\u0026amp;m_{14}\u0026amp;m_{10}\\\\ \\end{array}} \\) 以 min-term expression 方式解題 解 \\(F(a,b,c,d)=\\sum m(1,3,4,5,10,12,13)\\) \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp; \u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; \u0026amp;1\\\\ \\end{array}} \\rightarrow F=bc\u0026rsquo;+a\u0026rsquo; b\u0026rsquo; d+ab\u0026rsquo; c\u0026rsquo;d \\) 考慮 Don\u0026rsquo;t care 的情況 解 \\(F(a,b,c,d)=\\sum m(1,3,5,7,9)+\\sum d(6,12,13)\\) \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;X\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;X\u0026amp;1\\\\\\hline 11\u0026amp;1\u0026amp;1\u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp;X\u0026amp; \u0026amp; \\\\ \\end{array}} \\rightarrow F=a\u0026rsquo;d+c\u0026rsquo;d \\) 以 max-term expression 方式解題 解 \\(F(a,b,c,d)=\\sum m(0,2,3,4,8,10,11,15)=\\prod M(1,5,6,7,9,12,13,14)\\) \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;0\u0026amp; \\\\\\hline 01\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\\\hline 11\u0026amp; \u0026amp;0\u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp;0\u0026amp;0\u0026amp; \\\\ \\end{array}} \\)\n\\(\\rightarrow F\u0026rsquo;=c\u0026rsquo; d+a\u0026rsquo; bc+abd\u0026rsquo;\\)\n\\(\\rightarrow F=(c+d)(a+b\u0026rsquo;+c\u0026rsquo;)(a\u0026rsquo;+b\u0026rsquo;+d)\\) 基本質函項(essential prime implicants) 名詞定義 蘊函項(Implicant) 任何可以被組合的單一或群元素(意指為 \\(F\\)的子集。) 質函項(Prime Implicant) 已不能再被組合更多的函項。(意指最大的、框選最多的子集) 基本質函項(Essential Prime Implicant) 一個帶有只能被單一質函項框選到的元素的質函項 \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;1\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline 10\u0026amp; \u0026amp;1\u0026amp; \u0026amp; \\\\ \\end{array}} \\) 蘊函項：\\(A\u0026rsquo; C\u0026rsquo; D, ABC\u0026rsquo;, ACD, A\u0026rsquo; BC, BD, m_1, m_5, m_6, m_7\u0026hellip;. \\) 質函項：\\(A\u0026rsquo; C\u0026rsquo; D, ABC\u0026rsquo;, ACD, A\u0026rsquo; BC, BD \\) 基本質函項：\\(A\u0026rsquo; C\u0026rsquo; D,ABC\u0026rsquo;,A\u0026rsquo; BC, ACD\\) 簡化原則 因為有可能存在多個等效的最簡式，所以： 盡可能將式子展開成質函項(Prime implicants)。 用盡可能最少的質函項來表式布林函式。 例題 \\( \\boxed{\\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp; \u0026amp;1\u0026amp;1\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp;1\u0026amp;1\\\\ \\end{array}} \\rightarrow F=A\u0026rsquo; B\u0026rsquo; D+BC\u0026rsquo;+AC \\) 5個變數的卡諾圖 表示法1 表示法2 ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec4/","summary":"布林邏輯式的簡化 卡諾圖(Karnaugh Maps, K-maps)是一種簡單、快速的簡化布林邏輯的方法。 SOP 將布林邏輯化簡成最簡SOP(Minimum Sum of products) \\(F=A\u0026rsquo; B\u0026rsquo; C\u0026rsquo;+A\u0026rsquo; B\u0026rsquo; C+A\u0026rsquo; BC\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo; +ABC\\) \\(F=A\u0026rsquo; B\u0026rsquo;+B\u0026rsquo; C+BC\u0026rsquo;+AB\\) \\(F=A\u0026rsquo; B\u0026rsquo;+BC\u0026rsquo;+AC\\) POS 將布林邏輯化簡成最簡POS(Minimum Product of Sums) \\(F=(A+B\u0026rsquo;+C+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;+D)(A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;+D)(A+B+C\u0026rsquo;+D)(A\u0026rsquo;+B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(A+B\u0026rsquo;+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;+D)(B+C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D)(A+B\u0026rsquo;+C\u0026rsquo;)(C\u0026rsquo;+D)\\) \\(F=(A+B\u0026rsquo;+D\u0026rsquo;)(C\u0026rsquo;+D)\\) 2或3個變數的卡諾圖 簡化2個變數的布林邏輯式 \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B\\) 布林代數： \\(F=A\u0026rsquo; B\u0026rsquo;+A\u0026rsquo; B=A\u0026rsquo;(B\u0026rsquo;+B)=A\u0026rsquo;\\) 卡諾圖： \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \\downarrow B\\rightarrow A\u0026amp;0\u0026amp;1\u0026amp;\\\\\\hline 0\u0026amp;\\text{A=0,B=0}\u0026amp;\\text{A=1,B=0}\\\\\\hline 1\u0026amp;\\text{A=0,B=1}\u0026amp;\\text{A=1,B=1}\\\\ \\end{array} } \\rightarrow \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c} \u0026amp;A\u0026rsquo;\u0026amp;A\u0026amp;\\\\\\hline B\u0026rsquo;\u0026amp;1\u0026amp;0\\\\\\hline B\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\rightarrow A' \\) 簡化3個變數的布林邏輯式 \\(F=\\sum m(2,3,6)=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;\\) 布林代數： \\(F=A\u0026rsquo; BC\u0026rsquo;+A\u0026rsquo; BC+ABC\u0026rsquo;=A\u0026rsquo; B+BC\u0026rsquo;\\) 卡諾圖：*注意相鄰以grey code排列 \\( \\boxed{ \\def\\arraystretch{1.","title":"[Logic Design] Lec 04 - 卡諾圖 Karnaugh Maps"},{"content":"概要 當變數愈來愈多時，很難依靠人眼判斷，所以必須計設系統化的簡化過程讓電腦運行。 系統化的簡化過程 輸入：minterm expansion 輸出：minimum SOP 步驟： 找出所有質函項，並試著將和項消除到不能再消，利用\\(XY+XY\u0026rsquo;=X\\) \u0008利用質函項圖找出最小解 範例：\\(F(a,b,c)=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; + ab\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; c+ abc\\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo;\u0026amp;1\u0026amp;\u0026amp;\u0026amp;1\\\\\\hline c\u0026amp;\u0026amp;\u0026amp;1\u0026amp;1 \\end{array} } \\) 所有蘊函項：\\(a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c, abc, ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 質函項：\\(ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 基本質函項：\\(b\u0026rsquo; c\u0026rsquo;, ac\\) Min SOP：\\(F(a,b,c)=b\u0026rsquo; c\u0026rsquo;+ac\\) 決定質函項(prime implicants) 找出所有質函項 將每個 minterm 以二進制表示。 統計每個項的1的數量作為 index 並分群。 將分完群的 minterm 以 index 排列。 從 index 最小開始，往 index + 1 的群，尋找可以用\\(XY+XY\u0026rsquo;=X\\)簡化的組合 檢查所有的項都合併成組合，留下來的項即為質函項。 重複步驟 4 到 步驟 5 直到沒有函項可以合併。\n被打勾表示不是質函項(prime implicants) 範例：\\(f(a,b,c,d)=\\sum m(0,1,2,5,6,7,8,9,10,14)\\) \\(f(a,b,c,d)=P1+P2+P3+P4+P5+P6\\) \\(f(a,b,c,d)=a\u0026rsquo; c\u0026rsquo; d+a\u0026rsquo; bd+a\u0026rsquo; bc+cd\u0026rsquo;+b\u0026rsquo; d\u0026rsquo;+b\u0026rsquo; c\u0026rsquo;\\) \\(\\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|cc} \u0026amp;\\text{Column I}\\\\\\hline m_0\u0026amp;0000\u0026amp;\\checkmark\\\\\\hline m_1\u0026amp;0001\u0026amp;\\checkmark\\\\ m_2\u0026amp;0010\u0026amp;\\checkmark\\\\ m_8\u0026amp;1000\u0026amp;\\checkmark\\\\\\hline m_5\u0026amp;0101\u0026amp;\\checkmark\\\\ m_6\u0026amp;0110\u0026amp;\\checkmark\\\\ m_9\u0026amp;1001\u0026amp;\\checkmark\\\\ m_{10}\u0026amp;1010\u0026amp;\\checkmark\\\\\\hline m_7\u0026amp;0111\u0026amp;\\checkmark\\\\ m_{14}\u0026amp;1110\u0026amp;\\checkmark \\end{array} }\\) \\(\\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|cc} \u0026amp;\\text{Column II}\\\\\\hline m_0,m_1\u0026amp;000.\u0026amp;\\checkmark\\\\ m_0,m_2\u0026amp;00.0\u0026amp;\\checkmark\\\\ m_0,m_8\u0026amp;.000\u0026amp;\\checkmark\\\\\\hline m_1,m_5\u0026amp;0.01\u0026amp;\\text{P1}\\\\ m_1,m_9\u0026amp;.001\u0026amp;\\checkmark\\\\ m_2,m_6\u0026amp;0.10\u0026amp;\\checkmark\\\\ m_2,m_{10}\u0026amp;.010\u0026amp;\\checkmark\\\\ m_8,m_9\u0026amp;100.\u0026amp;\\checkmark\\\\ m_8,m_{10}\u0026amp;10.0\u0026amp;\\checkmark\\\\\\hline m_5,m_7\u0026amp;01.1\u0026amp;\\text{P2}\\\\ m_6,m_7\u0026amp;011.\u0026amp;\\text{P3}\\\\ m_6,m_{14}\u0026amp;.110\u0026amp;\\checkmark\\\\ m_{10},m_{14}\u0026amp;1.10\u0026amp;\\checkmark \\end{array} }\\) \\(\\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|cc} \u0026amp;\\text{Column III}\\\\\\hline m_0,m_1,m_8,m_9\u0026amp;.00.\u0026amp;\\text{P4}\\\\ m_0,m_2,m_8,m_{10}\u0026amp;.0.0\u0026amp;\\text{P5}\\\\ \\sout{m_0,m_8,m_1,m_9}\u0026amp;\\sout{.00.}\\\\ \\sout{m_0,m_8,m_2,m_{10}}\u0026amp;\\sout{.0.0}\\\\\\hline m_2,m_6,m_{10},m_{14}\u0026amp;..10\u0026amp;\\text{P6}\\\\ \\sout{m_2,m_{10},m_6,m_{14}}\u0026amp;\\sout{..10}\\\\ \\end{array} } \\) 質函項圖(表) 範例 \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{r|l|c|cccccccccc} \u0026amp; \u0026amp; \u0026amp;0\u0026amp;1\u0026amp;2\u0026amp;5\u0026amp;6\u0026amp;7\u0026amp;8\u0026amp;9\u0026amp;10\u0026amp;14\\\\\\hline 0, 1, 8, 9\u0026amp;b\u0026rsquo; c\u0026rsquo; \u0026amp;P6\u0026amp;\\checkmark\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\oplus\\\\ 0, 2, 8,10\u0026amp;b\u0026rsquo; d\u0026rsquo; \u0026amp;P5\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ 2, 6,10,14\u0026amp;c d\u0026rsquo; \u0026amp;P4\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\oplus\\\\ 1, 5\u0026amp;a\u0026rsquo; c\u0026rsquo; d\u0026amp;P1\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ 5, 7\u0026amp;a\u0026rsquo; bd \u0026amp;P2\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ 6, 7\u0026amp;a\u0026rsquo; bc \u0026amp;P3\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ \\end{array} } \\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{r|l|c|cccccccccc} \u0026amp;\u0026amp;\u0026amp;5\u0026amp;7\\\\\\hline 1,5\u0026amp;a\u0026rsquo; c\u0026rsquo;d\u0026amp;P1\u0026amp;\\checkmark\\\\ 5,7\u0026amp;a\u0026rsquo; bd \u0026amp;P2\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ 6,7\u0026amp;a\u0026rsquo; bc \u0026amp;P3\u0026amp;\u0026amp;\\checkmark\\\\ \\end{array} } \\) 優先選 \\(\\oplus\\)的質函項(只出現過一次，代表是基本質函項)，如範例\\(P6與P4\\)。 刪除選出的質函項後化簡成更簡化的質函項圖。 選可以同時照顧到最多函項的質函項。 \\(\\rightarrow f(a,b,c)=P2+P4+P6=a\u0026rsquo; bd+cd\u0026rsquo;+b\u0026rsquo; c\u0026rsquo;\\) (若沒有基本質函項時，有可以有多個最佳解) Petrick\u0026rsquo;s method 用來解出質函項圖的所有 min SOP 解。 在使用 Petrick 法前，需將所有基本質函項與其函蓋的 minterms 從表上劃掉。 範例：\\(F=\\sum m(0,1,2,5,6,7)\\)\n\\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{r|l|c|cccccc} P1\u0026amp;0,1\u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ P2\u0026amp;0,2\u0026amp;a\u0026rsquo; c\u0026rsquo;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P3\u0026amp;1,5\u0026amp;b\u0026rsquo; c \u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P4\u0026amp;2,6\u0026amp;b c\u0026rsquo;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P5\u0026amp;5,7\u0026amp;a c \u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\\\\ P6\u0026amp;6,7\u0026amp;a b \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ \\end{array} } \\) \\(\\def\\arraystretch{1.4}\\begin{array}{l} 0\\rightarrow P1+P2\\\\ 1\\rightarrow P1+P3\\\\ 2\\rightarrow P2+P4\\\\ 5\\rightarrow P3+P5\\\\ 6\\rightarrow P4+P6\\\\ 7\\rightarrow P5+P6\\\\ \\end{array}\\) \\(P=(P1+P2)(P1+P3)(P2+P4)(P3+P5)(P4+P6)(P5+P6)=1\\) \\(P=(P1+P2P3)(P4+P2P6)(P5+P3P6)\\) \\(P=P1P4P5+P1P2P5P6+P2P3P4P5+P2P3P5P6+P1P3P4P6+P1P2P3P6+P2P3P4P6+P2P3P6\\) 刪掉含有\\(P2P3P6\\)的和項 \\(P=P1P4P5+P1P2P5P6+P2P3P4P5+P1P3P4P6+P2P3P6\\) \\(\\text{min Sol:}\\) \\(F=P1+P4+P5=a\u0026rsquo; b\u0026rsquo;+bc\u0026rsquo;+ac\\) \\(F=P2+P3+P6=a\u0026rsquo; c\u0026rsquo;+b\u0026rsquo; c+ab\\) 考慮 Don\u0026rsquo;t Care 的情形 稍微修改一下 Quine-McClusky 方法 找出所有質函項：將DC視為minterms 建構出質函項表：DC不必列在表頭 範例：\\(F(A,B,C,D)=\\sum m(2,3,7,9,11,13)+\\sum d(1,10,15)\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{rrl} 1\u0026amp;0001\u0026amp;\\checkmark\\\\ 2\u0026amp;0010\u0026amp;\\checkmark\\\\\\hline 3\u0026amp;0011\u0026amp;\\checkmark\\\\ 9\u0026amp;1001\u0026amp;\\checkmark\\\\ 10\u0026amp;1010\u0026amp;\\checkmark\\\\\\hline 7\u0026amp;0111\u0026amp;\\checkmark\\\\ 11\u0026amp;1011\u0026amp;\\checkmark\\\\ 13\u0026amp;1101\u0026amp;\\checkmark\\\\\\hline 15\u0026amp;1111\u0026amp;\\checkmark \\end{array}}\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{rrl} 1,3\u0026amp;00.1\u0026amp;\\checkmark\\\\ 1,9\u0026amp;.001\u0026amp;\\checkmark\\\\ 2,3\u0026amp;001.\u0026amp;\\checkmark\\\\ 2,10\u0026amp;.01.\u0026amp;\\checkmark\\\\\\hline 3,7\u0026amp;0.11\u0026amp;\\checkmark\\\\ 3,11\u0026amp;.011\u0026amp;\\checkmark\\\\ 9,11\u0026amp;10.1\u0026amp;\\checkmark\\\\ 9,13\u0026amp;1.01\u0026amp;\\checkmark\\\\ 10,11\u0026amp;101.\u0026amp;\\checkmark\\\\\\hline 7,15\u0026amp;.111\u0026amp;\\checkmark\\\\ 11,15\u0026amp;1.11\u0026amp;\\checkmark\\\\ 13,15\u0026amp;11.1\u0026amp;\\checkmark\\\\ \\end{array}}\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{rrl} 1,3,9,11\u0026amp;.0.1\\\\ 2,3,10,11,\u0026amp;.01.\\\\ 3,7,11,15\u0026amp;..11\\\\ 9,11,13,15\u0026amp;1..1\\\\ \\end{array}}\\) \\(\\boxed{\\def\\arraystretch{1.4}\\begin{array}{r|cccccc} \u0026amp;2\u0026amp;3\u0026amp;7\u0026amp;9\u0026amp;11\u0026amp;13\\\\\\hline 1,3,9,11\u0026amp;\u0026amp;\\checkmark\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\\\\ *2,3,10,11\u0026amp;\\oplus\u0026amp;\\checkmark\u0026amp;\u0026amp;\u0026amp;\\checkmark\\\\ *3,7,11,15\u0026amp;\u0026amp;\\checkmark\u0026amp;\\oplus\u0026amp;\u0026amp;\\checkmark\\\\ *9,11,13,15\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\checkmark\u0026amp;\\checkmark\u0026amp;\\oplus\\\\ \\end{array}}\\) \\(F=B\u0026rsquo; C+CD+AD\\) 其中 1 被當作 0，10、15當作1。 ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec5/","summary":"概要 當變數愈來愈多時，很難依靠人眼判斷，所以必須計設系統化的簡化過程讓電腦運行。 系統化的簡化過程 輸入：minterm expansion 輸出：minimum SOP 步驟： 找出所有質函項，並試著將和項消除到不能再消，利用\\(XY+XY\u0026rsquo;=X\\) \u0008利用質函項圖找出最小解 範例：\\(F(a,b,c)=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; + ab\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; c+ abc\\) \\( \\boxed{ \\def\\arraystretch{1.4}\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo;\u0026amp;1\u0026amp;\u0026amp;\u0026amp;1\\\\\\hline c\u0026amp;\u0026amp;\u0026amp;1\u0026amp;1 \\end{array} } \\) 所有蘊函項：\\(a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c\u0026rsquo;, ab\u0026rsquo; c, abc, ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 質函項：\\(ab\u0026rsquo;, b\u0026rsquo; c\u0026rsquo;, ac\\) 基本質函項：\\(b\u0026rsquo; c\u0026rsquo;, ac\\) Min SOP：\\(F(a,b,c)=b\u0026rsquo; c\u0026rsquo;+ac\\) 決定質函項(prime implicants) 找出所有質函項 將每個 minterm 以二進制表示。 統計每個項的1的數量作為 index 並分群。 將分完群的 minterm 以 index 排列。 從 index 最小開始，往 index + 1 的群，尋找可以用\\(XY+XY\u0026rsquo;=X\\)簡化的組合 檢查所有的項都合併成組合，留下來的項即為質函項。 重複步驟 4 到 步驟 5 直到沒有函項可以合併。","title":"[Logic Design] Lec 05 - Quine-McClusky Method"},{"content":"Multi-level gate circuits 如何決定 level 數： Gate input number \u0026amp; Delay determine level Factoring to accomplish different level AND-OR: 2-level SOP OR-AND: 2-level POS OR-AND-OR: 3-level circuit of AND and OR → no particular ordering 4 level gates: \\(\\text{Z=(AB+C)(FG+D+E)+H}\\) 3 level gates: (case fan out) \\(\\text{AB(D+E)+C(D+E)+ABFG+CFG+H}\\) Factoring 可變成 4-level \\(\\text{(AB+C)(D+E+FG)+H}\\) level \u0026amp; gate \u0026amp; gate inputs 的關係會隨之變化，可根據電路設計的需求改變 範例： \\( \\begin{array}{llll} f(a,b,c,d)=\\sum(1,5,6,10,13,14)\\\\ f=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]\u0026amp;\\text{4 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;)\u0026amp;\\text{3 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=c\u0026rsquo; d(a\u0026rsquo;+b)+cd\u0026rsquo;(a+b)\u0026amp;\\text{3 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{12 gate inputs} \\end{array} \\) \\( \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;m_0\u0026amp;m_4\u0026amp;m_{12}\u0026amp;m_{8}\\\\\\hline 01\u0026amp;m_1\u0026amp;m_5\u0026amp;m_{13}\u0026amp;m_{9}\\\\\\hline 11\u0026amp;m_3\u0026amp;m_7\u0026amp;m_{15}\u0026amp;m_{11}\\\\\\hline 10\u0026amp;m_2\u0026amp;m_6\u0026amp;m_{14}\u0026amp;m_{10} \\end{array}}\\rightarrow \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline 11\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 10\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\) \\(\\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo; d\u0026rsquo;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline c\u0026rsquo; d\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline cd\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline cd\u0026rsquo;\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\\\ =a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;=(a\u0026rsquo;+b)c\u0026rsquo; d+(a+b)cd\u0026rsquo;\\\\ =(c\u0026rsquo; d\u0026rsquo;+ab\u0026rsquo; c\u0026rsquo;+cd+a\u0026rsquo; b\u0026rsquo; c)\u0026rsquo;=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\\\\ =[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;) \\) NAND and NOR gates NAND 符號 真值表\n\\(\\boxed{\\begin{array}{cc|cc} A\u0026amp;B\u0026amp;AB\u0026amp;\\overline{AB}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array}} \\) 布林表達式：\n\\(F=(ABC)\u0026rsquo;=A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;\\) NOR 符號 真值表\n\\(\\boxed{\\begin{array}{cc|cc} A\u0026amp;B\u0026amp;AB\u0026amp;\\overline{AB}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array}} \\) 布林表達式： \\(F=(A+B+C)\u0026rsquo;=A\u0026rsquo; B\u0026rsquo; C\u0026rsquo;\\) Functionally Complete Sets of Gates 定義：當所有的布林式皆可以被這組邏輯閘組合而成，則這組邏輯閘為 Functionally Complete \\(\\lbrace{\\text{AND, OR, NOT}}\\rbrace\\) \\(\\lbrace{\\text{AND, NOT}}\\rbrace\\rightarrow \\text{OR}=X+Y=(X\u0026rsquo; Y\u0026rsquo;)\u0026rsquo;\\) \\(\\lbrace{\\text{OR, NOT}}\\rbrace\\rightarrow \\text{AND}=XY=(X\u0026rsquo;+Y\u0026rsquo;)\u0026rsquo;\\) \\(\\lbrace{\\text{NAND}}\\rbrace\\) \\(\\lbrace{\\text{NOR}}\\rbrace\\) \\(\\lbrace{\\text{3-input Minority Gate}}\\rbrace\\) Majority Gate and Minority Gate 真值表\n\\(\\boxed{\\begin{array}{ccc|cc} A\u0026amp;B\u0026amp;C\u0026amp;F_M\u0026amp;F_m\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array}}\\) \\(\\text{(0, B, C)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{NAND}=\\text{(BC)\u0026rsquo;=\\text{B\u0026rsquo;+C\u0026rsquo;}}\\) \\(\\text{(1, B, C)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{NOR}=\\text{(B+C)\u0026rsquo;=\\text{B\u0026rsquo;C\u0026rsquo;}}\\) \\(\\text{(A, A, A)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{NOT}=\\text{A\u0026rsquo;}\\) \\(\\text{(0, B\u0026rsquo;, C\u0026rsquo;)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{AND}=\\text{BC}\\) \\(\\text{(1, B\u0026rsquo;, C\u0026rsquo;)}\\rightarrow\\boxed{\\text{Minority Gate}}=\\text{OR}=\\text{B+C}\\) 2-level NAND and NOR gates DeMorgon\u0026rsquo;s Law 等效邏輯閘： \\((A+B)\u0026rsquo;=A\u0026rsquo; B\u0026rsquo;\\) \\((AB)\u0026rsquo;=A\u0026rsquo;+B\u0026rsquo;\\) \\(A+B=(A\u0026rsquo; B\u0026rsquo;)\u0026rsquo;\\) \\(AB=(A\u0026rsquo;+B\u0026rsquo;)\u0026rsquo;\\) \\(\\text{Ex1: AND/OR}\\rightarrow\\text{NAND/NAND}\\) \\(\\text{Ex2: AND/OR}\\rightarrow\\text{NOR/NOR}\\) Multi-level NAND and NOR circuits Multi-level NAND and NOR circuits \\(\\text{to NAND gate}\\)\n\\(\\text{to NOR gate}\\) Multi-output circuit realization 實際一個多工器(multiplexer)內的電路實現，可以用 fan out 的方式達到最佳化。 整體最佳不一定代表個別都為最佳。 實作1: \\(F_1(A,B,C,D)=\\sum m(11,12,13,14,15) =AB+ACD \\\\ F_2(A,B,C,D)=\\sum m(3,7,11,12,13,15)=ABC\u0026rsquo;+CD\\\\ F_3(A,B,C,D)=\\sum m(3,7,12,13,14,15)=A\u0026rsquo; CD+AB\\\\ \\) \\( \\begin{array}{|c|c|c|c|c|}\\hline F_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; 1\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline F_2\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 11\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; 1\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline F_3\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp;1 \u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp;1 \u0026amp; \\\\\\hline 11\u0026amp; 1\u0026amp;1 \u0026amp;1 \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; \u0026amp;1 \u0026amp; \\\\\\hline \\end{array} \\) \\(\\text{9 Gates, 21 Gate inputs}\\rightarrow\\text{7 Gates, 18 Gate inputs}\\) \\(\\text{Share AB(fan out)}\\) \\(\\text{A\u0026rsquo;CD+ACD=CD}\\) \\(F_1(A,B,C,D)=AB+ACD \\\\ F_2(A,B,C,D)=ABC\u0026rsquo;+ACD+A\u0026rsquo; CD\\\\ F_3(A,B,C,D)=A\u0026rsquo; CD+AB\\\\ \\lbrace{AB,A\u0026rsquo; CD,ACD,ABC\u0026rsquo;}\\rbrace \\) 實作2: \\(f_1=\\sum m(2,3,5,7,8,9,10,11,13,15)=bd+b\u0026rsquo; c+ab\u0026rsquo;\\\\ f_2=\\sum m(2,3,5,6,7,10,11,14,15)=a\u0026rsquo; bd+c\\\\ f_3=\\sum m(6,7,8,9,13,14,15)=bc+ab\u0026rsquo; c\u0026rsquo;+abd\\\\ \\rightarrow\\text{10 Gates, 25 Gate inputs} \\) \\( \\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp;1 \\\\\\hline 01\u0026amp; \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline 11\u0026amp;1 \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline 10\u0026amp;1 \u0026amp; \u0026amp; \u0026amp;1 \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_2\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 01\u0026amp; \u0026amp;1 \u0026amp; \u0026amp; \\\\\\hline 11\u0026amp;1 \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline 10\u0026amp;1 \u0026amp;1 \u0026amp;1 \u0026amp;1 \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_3\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp;1 \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp;1 \u0026amp;1 \\\\\\hline 11\u0026amp; \u0026amp;1 \u0026amp;1 \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp;1 \u0026amp;1 \u0026amp; \\\\\\hline \\end{array} \\) \\( \\text{(1) } b\u0026rsquo; c+bc = c\\\\ \\text{(2) } a\u0026rsquo; bd+abd = bd\\\\ \\text{用}\\lbrace{b\u0026rsquo; c, bc, a\u0026rsquo;bd, abd, ab\u0026rsquo; c\u0026rsquo;}\\rbrace\\text{組合上例} \\) \\( f_1=b\u0026rsquo; c+(abd+a\u0026rsquo; bd)+ab\u0026rsquo; c\u0026rsquo;\\\\ f_2=(b\u0026rsquo; c+ bc)+a\u0026rsquo; bd\\\\ f_3=bc+abd+ab\u0026rsquo; c\u0026rsquo;\\\\ \\lbrace {b\u0026rsquo; c,bc,abd,a\u0026rsquo; bd,ab\u0026rsquo; c\u0026rsquo;}\\rbrace\\\\ \\rightarrow\\text{8 Gates, 23 Gate inputs} \\) 實作3: \\( f_1=\\sum m(1,5,9,13,15)=c\u0026rsquo; d+abd\\\\ f_2=\\sum m(4,6,12,14,15)=bd\u0026rsquo;+abc\\\\ \\rightarrow\\text{6 Gates, 14 Gate inputs} \\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 01\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; 1\\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_2\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; 1\u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline \\end{array}\\) 使上面兩式共用 \\(abcd\\) \\( f_1=c\u0026rsquo; d+abcd\\\\ f_2=bd\u0026rsquo;+abcd\\\\ \\rightarrow\\text{5 Gates, 12 Gate inputs} \\) 實作4: \\( f_1=\\sum m(0,3,4,5,6,14)=a\u0026rsquo; c\u0026rsquo; d\u0026rsquo;+a\u0026rsquo; bc\u0026rsquo;+a\u0026rsquo; cd\u0026rsquo;+bcd\u0026rsquo;\\\\ f_2=\\sum m(0,1,4,6,8,10)=a\u0026rsquo; c\u0026rsquo; d\u0026rsquo;+bc\u0026rsquo; d\u0026rsquo;+a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;+bcd\u0026rsquo;\\\\ \\rightarrow\\text{8 Gates, 26 Gate inputs} \\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; \u0026amp; \\\\\\hline 01\u0026amp; \u0026amp; 1\u0026amp; \u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|c|c|}\\hline f_1\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline 01\u0026amp; 1\u0026amp; \u0026amp; \u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; \u0026amp; \\\\\\hline 10\u0026amp; \u0026amp; 1\u0026amp; 1\u0026amp; \\\\\\hline \\end{array} \\) 不 combine 各自做最佳化 \\( f_1=a\u0026rsquo; d\u0026rsquo;+a\u0026rsquo; bc\u0026rsquo;+bcd\u0026rsquo;\\\\ f_2=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;+bd\u0026rsquo;\\\\ \\rightarrow\\text{7 Gates, 18 Gate Inputs} \\) 多輸出電路的基本質函項 參考實作3，若基本質函項可通過多工器中其他的輸入共用的話，則對多輸出電路而言並非基本質函項(Essential prime terms)。 參考實作4，\\(a\u0026rsquo; d\u0026rsquo;(m_2),a\u0026rsquo; bc\u0026rsquo;(m_5), a\u0026rsquo; b\u0026rsquo; c\u0026rsquo;(m_1), bd\u0026rsquo;(m_{12})\\)皆為基本質函項。 一般而言，不會為了共享而把基本質函項拆開。 和項共用(Shared by sum terms) 真值表\n\\(\\begin{array}{|cccc|cccc:c|}\\hline a\u0026amp;b\u0026amp;c\u0026amp;d\u0026amp;w\u0026amp;x\u0026amp;y\u0026amp;z\u0026amp;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;2\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;3\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;4\\\\\\hline 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;5\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;6\\\\\\hline 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;7\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;8\\\\\\hline 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;9\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;\\\\\\hline \\end{array}\\) k-map\n\\(\\begin{array}{|c|c|c|c|c||}\\hline w\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; \u0026amp; X\u0026amp; 1\\\\\\hline 01\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; 1\\\\\\hline 11\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline \\end{array} \\begin{array}{|c|c|c|c|c||}\\hline x\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; \u0026amp; 1\u0026amp; X\u0026amp; \\\\\\hline 01\u0026amp; 1\u0026amp; \u0026amp; X\u0026amp; 1\\\\\\hline 11\u0026amp; 1\u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; 1\u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline \\end{array} \\begin{array}{|c|c|c|c|c||}\\hline y\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; 1\\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; X\u0026amp; \\\\\\hline 11\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; \u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline \\end{array} \\begin{array}{|c|c|c|c|c|}\\hline z\u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; 1\\\\\\hline 01\u0026amp; \u0026amp; \u0026amp; X\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp; \u0026amp; X\u0026amp; X\\\\\\hline 10\u0026amp; 1\u0026amp; 1\u0026amp; X\u0026amp; X\\\\\\hline \\end{array}\\) \\(w=a+bc+bd=a+b(c+d)\\\\ x=bc\u0026rsquo; d\u0026rsquo;+b\u0026rsquo; d+b\u0026rsquo; c=bc\u0026rsquo; d\u0026rsquo;+b\u0026rsquo;(c+d)\\\\ y=c\u0026rsquo; d\u0026rsquo;+cd\\\\ z=d' \\) Sum terms 也可以 share Multi-output circuits 也可以只用 \\(\\text{NAND/NOR}\\) 表示 Multi-Output NAND/NOR circuits 範例 \\(\\text{to NAND}\\) \\(\\text{to NOR}\\) ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec6/","summary":"Multi-level gate circuits 如何決定 level 數： Gate input number \u0026amp; Delay determine level Factoring to accomplish different level AND-OR: 2-level SOP OR-AND: 2-level POS OR-AND-OR: 3-level circuit of AND and OR → no particular ordering 4 level gates: \\(\\text{Z=(AB+C)(FG+D+E)+H}\\) 3 level gates: (case fan out) \\(\\text{AB(D+E)+C(D+E)+ABFG+CFG+H}\\) Factoring 可變成 4-level \\(\\text{(AB+C)(D+E+FG)+H}\\) level \u0026amp; gate \u0026amp; gate inputs 的關係會隨之變化，可根據電路設計的需求改變 範例： \\( \\begin{array}{llll} f(a,b,c,d)=\\sum(1,5,6,10,13,14)\\\\ f=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]\u0026amp;\\text{4 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{14 gate inputs}\\\\ f=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;)\u0026amp;\\text{3 levels}\u0026amp;\\text{7 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;\u0026amp;\\text{2 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{16 gate inputs}\\\\ f=c\u0026rsquo; d(a\u0026rsquo;+b)+cd\u0026rsquo;(a+b)\u0026amp;\\text{3 levels}\u0026amp;\\text{5 gates}\u0026amp;\\text{12 gate inputs} \\end{array} \\) \\( \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;m_0\u0026amp;m_4\u0026amp;m_{12}\u0026amp;m_{8}\\\\\\hline 01\u0026amp;m_1\u0026amp;m_5\u0026amp;m_{13}\u0026amp;m_{9}\\\\\\hline 11\u0026amp;m_3\u0026amp;m_7\u0026amp;m_{15}\u0026amp;m_{11}\\\\\\hline 10\u0026amp;m_2\u0026amp;m_6\u0026amp;m_{14}\u0026amp;m_{10} \\end{array}}\\rightarrow \\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 01\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline 11\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline 10\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\) \\(\\boxed{\\begin{array}{c|c|c|c|c} \u0026amp;a\u0026rsquo; b\u0026rsquo;\u0026amp;a\u0026rsquo; b\u0026amp;ab\u0026amp;ab\u0026rsquo;\\\\\\hline c\u0026rsquo; d\u0026rsquo;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline c\u0026rsquo; d\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\\\\\hline cd\u0026amp;\u0026amp;\u0026amp;\u0026amp;\\\\\\hline cd\u0026rsquo;\u0026amp;\u0026amp;1\u0026amp;1\u0026amp;1 \\end{array}}\\\\ =a\u0026rsquo; c\u0026rsquo; d+bc\u0026rsquo; d+bcd\u0026rsquo;+acd\u0026rsquo;=(a\u0026rsquo;+b)c\u0026rsquo; d+(a+b)cd\u0026rsquo;\\\\ =(c\u0026rsquo; d\u0026rsquo;+ab\u0026rsquo; c\u0026rsquo;+cd+a\u0026rsquo; b\u0026rsquo; c)\u0026rsquo;=(c+d)(a\u0026rsquo;+b+c)(c\u0026rsquo;+d\u0026rsquo;)(a+b+c\u0026rsquo;)\\\\ =[c+d(a\u0026rsquo;+b)][c\u0026rsquo;+d\u0026rsquo;(a+b)]=(c+a\u0026rsquo; d+bd)(c\u0026rsquo;+ad\u0026rsquo;+bd\u0026rsquo;) \\) NAND and NOR gates NAND 符號 真值表","title":"[Logic Design] Lec 06 - Multi-Level Gate Circuits / NAND and NOR Gates"},{"content":"Review 組合電路設計 建構真值表將輸出表示成輸入的函式 \\(\\text{Inputs}\\rightarrow\\boxed{\\text{MUX}}\\rightarrow\\text{Outputs}\\) 用 K-map, Q-M method 等方法得到簡化的布林表達式 多層、多輸出的電路(Multi-level \u0026amp; Multi-outputs) Mininum SOP 起點 Minimum two-level \\(\\text{AND-OR, NAND-NAND, OR-NAND, NOR-OR}\\) Minimum POS 起點 Minimum two-level \\(\\text{OR-AND, NOR-NOR, AND-NOR, NAND-AND}\\) 限制 fan-in 數的電路設計 Ex1 \\(\\text{用 3 pin 的 NOR Gate 實現}f(a,b,c,d)=\\sum m(0,3,4,5,8,9,10,14,15)\\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 01\u0026amp; 0\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 11\u0026amp; 1\u0026amp; 0\u0026amp; 1\u0026amp; 0\\\\\\hline 10\u0026amp; 0\u0026amp; 0\u0026amp; 1\u0026amp; 1\\\\\\hline \\end{array}\\) 從 POS 開始 \\(f\u0026rsquo;=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; d+ab\u0026rsquo; cd+abc\u0026rsquo; + a\u0026rsquo; bc+a\u0026rsquo; cd\u0026rsquo;\\\\ \\quad=b\u0026rsquo; d(a\u0026rsquo; c\u0026rsquo;+ac)+a\u0026rsquo; c(b+d\u0026rsquo;)+abc\u0026rsquo;\\) Ex2 Multiple-Output \\(\\text{用 2 pin 的 NAND 與 NOT 實現}\\) \\(f_1=\\sum m(0,2,3,4,5)=b\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; +a\u0026rsquo; b\\\\ f_2=\\sum m(0,2,3,4,7)=b\u0026rsquo; c\u0026rsquo;+bc+a\u0026rsquo; b\\\\ f_3=\\sum m(1,2,6,7)=a\u0026rsquo; b\u0026rsquo; c+ab+bc\u0026rsquo;\\) \\(\\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp;1\\\\\\hline 11\u0026amp;1\u0026amp; \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp;1 \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp; \u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp;1\\\\\\hline 10\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) \\(f_1=b\u0026rsquo;(a+c\u0026rsquo;)+a\u0026rsquo; b\\\\ f_2=(b\u0026rsquo;+c)(b+c\u0026rsquo;)+b\u0026rsquo; c\u0026rsquo;\\\\ f_3=b(a+c\u0026rsquo;)+a\u0026rsquo; b\u0026rsquo; c\\) 閘延遲與時序圖 邏輯閘必然存在延遲，固然小，但存在。 組合電路 延遲亦可能來自電線，電線愈長則延遲可能愈久。 Control value \\(\\text{AND gate}\\) 的 control value 是 \\(0\\) \\(\\text{OR gate}\\) 的 control value 是 \\(1\\) \\(\\text{AND=2ns}\\\\ \\text{NOR=3ns}\\) 若 X 訊號相反時， Z 要到 5ns 訊號才有意義。 組合邏輯中的 Hazards Hazard 是在切換輸入時，因閘延遲而產生的錯誤訊號。 種類 若相鄰兩個 1 不來自同一個邏輯閘(在 K-map 上沒有被框在一起)則會存在 hazard。 \\((A,B,C)=(1,0,1)\\rightarrow (1,1,1)\\) \u0008可將相鄰的所有蘊函項框在一起，避免「一個bit切換」的 hazard 發生。 邏輯電路的模擬與測試 對模擬邏輯電路來說 有明確的電路元素與連線 決定輸入 觀察輸出 輸入值 有四種，分別為： 0 (low) 1 (high) X (unknown) Z (don\u0026rsquo;t care, High impedence) \\(\\text{AND } \\\u0026amp; \\text{ OR } \\text{function for 4-value simulation}\\) \\(\\begin{array}{c|cccc} \\text{AND}\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;Z\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\\\\ X\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\\\\ Z\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\\\\ \\end{array} \\qquad \\begin{array}{c|cccc} \\text{OR}\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;Z\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ X\u0026amp;X\u0026amp;1\u0026amp;X\u0026amp;X\\\\ Z\u0026amp;X\u0026amp;1\u0026amp;X\u0026amp;X\\\\ \\end{array} \\) 驗證(verification)與測試(testing) 邏輯電路的輸出錯誤，可以由下面兩種方式偵錯： 驗證(Verification) 錯誤的電路設計 邏輯閘接線錯誤 輸入訊號錯誤 測試(Testing) 邏輯閘缺陷 金屬接線缺陷 已知 \\(A=B=C=D=1時，F=0\\) ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec7/","summary":"Review 組合電路設計 建構真值表將輸出表示成輸入的函式 \\(\\text{Inputs}\\rightarrow\\boxed{\\text{MUX}}\\rightarrow\\text{Outputs}\\) 用 K-map, Q-M method 等方法得到簡化的布林表達式 多層、多輸出的電路(Multi-level \u0026amp; Multi-outputs) Mininum SOP 起點 Minimum two-level \\(\\text{AND-OR, NAND-NAND, OR-NAND, NOR-OR}\\) Minimum POS 起點 Minimum two-level \\(\\text{OR-AND, NOR-NOR, AND-NOR, NAND-AND}\\) 限制 fan-in 數的電路設計 Ex1 \\(\\text{用 3 pin 的 NOR Gate 實現}f(a,b,c,d)=\\sum m(0,3,4,5,8,9,10,14,15)\\) \\(\\begin{array}{|c|c|c|c|c|}\\hline f \u0026amp;00\u0026amp;01\u0026amp;11\u0026amp;10\\\\\\hline 00\u0026amp; 1\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 01\u0026amp; 0\u0026amp; 1\u0026amp; 0\u0026amp; 1\\\\\\hline 11\u0026amp; 1\u0026amp; 0\u0026amp; 1\u0026amp; 0\\\\\\hline 10\u0026amp; 0\u0026amp; 0\u0026amp; 1\u0026amp; 1\\\\\\hline \\end{array}\\) 從 POS 開始 \\(f\u0026rsquo;=a\u0026rsquo; b\u0026rsquo; c\u0026rsquo; d+ab\u0026rsquo; cd+abc\u0026rsquo; + a\u0026rsquo; bc+a\u0026rsquo; cd\u0026rsquo;\\\\ \\quad=b\u0026rsquo; d(a\u0026rsquo; c\u0026rsquo;+ac)+a\u0026rsquo; c(b+d\u0026rsquo;)+abc\u0026rsquo;\\) Ex2 Multiple-Output \\(\\text{用 2 pin 的 NAND 與 NOT 實現}\\) \\(f_1=\\sum m(0,2,3,4,5)=b\u0026rsquo; c\u0026rsquo;+ab\u0026rsquo; +a\u0026rsquo; b\\\\ f_2=\\sum m(0,2,3,4,7)=b\u0026rsquo; c\u0026rsquo;+bc+a\u0026rsquo; b\\\\ f_3=\\sum m(1,2,6,7)=a\u0026rsquo; b\u0026rsquo; c+ab+bc\u0026rsquo;\\) \\(\\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp;1\\\\\\hline 11\u0026amp;1\u0026amp; \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp;1\u0026amp;1\\\\\\hline 01\u0026amp; \u0026amp; \\\\\\hline 11\u0026amp;1\u0026amp;1 \\\\\\hline 10\u0026amp;1\u0026amp; \\\\\\hline \\end{array}\\quad \\begin{array}{|c|c|c|}\\hline f_1\u0026amp;0\u0026amp;1\\\\\\hline 00\u0026amp; \u0026amp; \\\\\\hline 01\u0026amp;1\u0026amp; \\\\\\hline 11\u0026amp; \u0026amp;1\\\\\\hline 10\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) \\(f_1=b\u0026rsquo;(a+c\u0026rsquo;)+a\u0026rsquo; b\\\\ f_2=(b\u0026rsquo;+c)(b+c\u0026rsquo;)+b\u0026rsquo; c\u0026rsquo;\\\\ f_3=b(a+c\u0026rsquo;)+a\u0026rsquo; b\u0026rsquo; c\\) 閘延遲與時序圖 邏輯閘必然存在延遲，固然小，但存在。 組合電路 延遲亦可能來自電線，電線愈長則延遲可能愈久。 Control value \\(\\text{AND gate}\\) 的 control value 是 \\(0\\) \\(\\text{OR gate}\\) 的 control value 是 \\(1\\) \\(\\text{AND=2ns}\\\\ \\text{NOR=3ns}\\) 若 X 訊號相反時， Z 要到 5ns 訊號才有意義。 組合邏輯中的 Hazards Hazard 是在切換輸入時，因閘延遲而產生的錯誤訊號。 種類 若相鄰兩個 1 不來自同一個邏輯閘(在 K-map 上沒有被框在一起)則會存在 hazard。 \\((A,B,C)=(1,0,1)\\rightarrow (1,1,1)\\) \u0008可將相鄰的所有蘊函項框在一起，避免「一個bit切換」的 hazard 發生。 邏輯電路的模擬與測試 對模擬邏輯電路來說 有明確的電路元素與連線 決定輸入 觀察輸出 輸入值 有四種，分別為： 0 (low) 1 (high) X (unknown) Z (don\u0026rsquo;t care, High impedence) \\(\\text{AND } \\\u0026amp; \\text{ OR } \\text{function for 4-value simulation}\\) \\(\\begin{array}{c|cccc} \\text{AND}\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;Z\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\\\\ X\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\\\\ Z\u0026amp;0\u0026amp;X\u0026amp;X\u0026amp;X\\\\ \\end{array} \\qquad \\begin{array}{c|cccc} \\text{OR}\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;Z\\\\\\hline 0\u0026amp;0\u0026amp;1\u0026amp;X\u0026amp;X\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ X\u0026amp;X\u0026amp;1\u0026amp;X\u0026amp;X\\\\ Z\u0026amp;X\u0026amp;1\u0026amp;X\u0026amp;X\\\\ \\end{array} \\) 驗證(verification)與測試(testing) 邏輯電路的輸出錯誤，可以由下面兩種方式偵錯： 驗證(Verification) 錯誤的電路設計 邏輯閘接線錯誤 輸入訊號錯誤 測試(Testing) 邏輯閘缺陷 金屬接線缺陷 已知 \\(A=B=C=D=1時，F=0\\) ","title":"[Logic Design] Lec 07 - 組合電路設計與模擬"},{"content":"多工器(Multiplexer, MUX) 一個 \\(2^n\\text{ to }1\\) 多工器，需要有 n 個控制項(選項器) \\(\\begin{array}{c|c|l} \\text{MUX}\u0026amp;\\text{sel}\u0026amp;\\text{Output}\\\\\\hline \\text{2 to 1}\u0026amp;1\u0026amp;A\u0026rsquo; I_0+AI_1\\\\\\hline \\text{4 to 1}\u0026amp;2\u0026amp;A\u0026rsquo; B\u0026rsquo; I_0+A\u0026rsquo; BI_1+AB\u0026rsquo; I_2+ABI_3\\\\\\hline \\text{8 to 1}\u0026amp;3\u0026amp;A\u0026rsquo; B\u0026rsquo; C\u0026rsquo; I_0+A\u0026rsquo; B\u0026rsquo; CI_1+\u0026hellip;\\\\\\hline 2^n\\text{ to 1}\u0026amp;n\u0026amp;\\sum_{k=0}^{2^n-1}m_kI_k \\end{array}\\) quad multiplexer 多了一個致能(enable, en)來控制多工器 用 4-1 多工器實現三個變數函式 代數展開\n\\(\\begin{array}{rl} F(A,B,C)\u0026amp;=A\u0026rsquo; B\u0026rsquo;+AC\\\\ \u0026amp;=A\u0026rsquo; B\u0026rsquo;(C+C\u0026rsquo;)+A(B+B\u0026rsquo;)C\\\\ \u0026amp;=A\u0026rsquo; B\u0026rsquo;\\cdot1+A\u0026rsquo; B\\cdot0+AB\u0026rsquo; C+ABC \\end{array}\\) 真值表法\n\\(\\begin{array}{|cccc:cc|}\\hline \u0026amp;A\u0026amp;B\u0026amp;C\u0026amp;F\\\\\\hline \u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ I_0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline \u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ I_1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\hline \u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ I_2\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;C\\\\\\hline \u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ I_3\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;C\\\\\\hline \\end{array}\\) Verilog 4-to-1 MUX implements 3-var function test bench 三態緩衝器(Three state buffer) 緩衝器(Buffers)的用途: 用來增加閘輸出的趨動力(driving force) 因為閘並聯而造成電容增加(fan out)，電容增加充電變慢，使電路變慢 總體而言，可用來調節電路的速度。 三態緩衝器: Three-state buffer 或 tri-state buffer 真值表\n\\(\\begin{array}{|cc|c|}\\hline B\u0026amp;A\u0026amp;C\\\\\\hline 0\u0026amp;0\u0026amp;Z\\\\\\hline 0\u0026amp;1\u0026amp;Z\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array}\\) 利用 tri-state buffer 實現 2-to-1 MUX tri-state buffer 並聯 真值表\n\\(\\begin{array}{|c|c|c|c|c|}\\hline \u0026amp;X\u0026amp;0\u0026amp;1\u0026amp;Z\\\\\\hline X\u0026amp;X\u0026amp;X\u0026amp;X\u0026amp;X\\\\\\hline 0\u0026amp;X\u0026amp;0\u0026amp;X\u0026amp;0\\\\\\hline 1\u0026amp;X\u0026amp;X\u0026amp;1\u0026amp;1\\\\\\hline Z\u0026amp;X\u0026amp;0\u0026amp;1\u0026amp;Z\\\\\\hline \\end{array}\\) 應用 Bus 匯流排 Chip I/O 解碼器(Decoder) \\(n 個 \\text{input} 可以對應到 2^n 個 \\text{output}\\) 事實上，n 個 input 在編碼器前成生各種 minterm 的組合，後面面編碼器就是將 minterm \\(OR\\) 起來。 7442 編碼器，數字 1 到 9 產生對應位置的輸出為 0。 這樣的設計可以使雜訊的干擾變輕。 配合 \\(\\text{NAND Gate}\\)，其實就跟前面的編碼器一樣，是產生 minterm 再 \\(OR\\) 起來的過程。 \\(F_1=m_1+m_2+m_4 \\qquad F_2=m_4+m_7+m_9\\) Verilog 7442 f124 f479 編碼器(Encoder) Priority Encoder 8-to-3 編碼，將輸入將對應的數字編到 abc 中。 若 input 端有兩個以上為 1，則輸出數字較高的數(MSB)。 d 的作用，用來表示輸入是否含有 1，否則為 0。 唯讀記憶體(Read only memories, ROMs) 唯讀記憶體就是一個編寫好的編碼器，輸入就像是位址(address)。 General Form \\(\\text{n inputs}\\rightarrow 2^n 個 \\text{words} \\rightarrow \\text{m outputs}\\) 可以把 ROM 看成 decoder 加上 memory array 用二極體形成 \\(OR\\) 的效果，一般也會將二極體極化成黑點。 二極體在這邊使電流為單向流動，一般二極體的壓降為 0.7V。 整個矩陣稱為 OR-plane。 word line 用於控制儲存單元與 bit line 的連通 bit line 用於讀寫儲存單元。(此處只有讀) ROM 的變形 PROM (prgrammable ROM): 使用光罩定義金屬線 OTP (one time program ROM): 利用 fuse 熔斷機制，一次性 EPROM(Erasable Programmable ROM) EEPROM(Electrically Erasable Programmable ROM) 可程式化邏輯元件(programmable logic devices) 可程式化邏輯矩陣(Programmable Logic Array, PLA) 可程式化矩陣邏輯(Programmable Array Logic, PAL) 現場可程式化邏輯閘陣列(Field programmable gate arrays, FPGAs) ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec8/","summary":"多工器(Multiplexer, MUX) 一個 \\(2^n\\text{ to }1\\) 多工器，需要有 n 個控制項(選項器) \\(\\begin{array}{c|c|l} \\text{MUX}\u0026amp;\\text{sel}\u0026amp;\\text{Output}\\\\\\hline \\text{2 to 1}\u0026amp;1\u0026amp;A\u0026rsquo; I_0+AI_1\\\\\\hline \\text{4 to 1}\u0026amp;2\u0026amp;A\u0026rsquo; B\u0026rsquo; I_0+A\u0026rsquo; BI_1+AB\u0026rsquo; I_2+ABI_3\\\\\\hline \\text{8 to 1}\u0026amp;3\u0026amp;A\u0026rsquo; B\u0026rsquo; C\u0026rsquo; I_0+A\u0026rsquo; B\u0026rsquo; CI_1+\u0026hellip;\\\\\\hline 2^n\\text{ to 1}\u0026amp;n\u0026amp;\\sum_{k=0}^{2^n-1}m_kI_k \\end{array}\\) quad multiplexer 多了一個致能(enable, en)來控制多工器 用 4-1 多工器實現三個變數函式 代數展開\n\\(\\begin{array}{rl} F(A,B,C)\u0026amp;=A\u0026rsquo; B\u0026rsquo;+AC\\\\ \u0026amp;=A\u0026rsquo; B\u0026rsquo;(C+C\u0026rsquo;)+A(B+B\u0026rsquo;)C\\\\ \u0026amp;=A\u0026rsquo; B\u0026rsquo;\\cdot1+A\u0026rsquo; B\\cdot0+AB\u0026rsquo; C+ABC \\end{array}\\) 真值表法\n\\(\\begin{array}{|cccc:cc|}\\hline \u0026amp;A\u0026amp;B\u0026amp;C\u0026amp;F\\\\\\hline \u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ I_0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\\\hline \u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ I_1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\hline \u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ I_2\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;C\\\\\\hline \u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ I_3\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;C\\\\\\hline \\end{array}\\) Verilog 4-to-1 MUX implements 3-var function test bench 三態緩衝器(Three state buffer) 緩衝器(Buffers)的用途: 用來增加閘輸出的趨動力(driving force) 因為閘並聯而造成電容增加(fan out)，電容增加充電變慢，使電路變慢 總體而言，可用來調節電路的速度。 三態緩衝器: Three-state buffer 或 tri-state buffer 真值表","title":"[Logic Design] Lec 08 - 多工器、編碼器、可程式化邏輯元件"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec9/","summary":"準備中 ","title":"[Logic Design] Lec 09 - Flips-FLops"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec10/","summary":"準備中 ","title":"[Logic Design] Lec 10 - 暫存器與計數器"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec11/","summary":"準備中 ","title":"[Logic Design] Lec 11 - 創建圖表與設計電路"},{"content":"準備中 ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec12/","summary":"準備中 ","title":"[Logic Design] Lec 12 - 電路實現與簡化"},{"content":"Coding Interview University John Washam:\nI originally created this as a short to-do list of study topics for becoming a software engineer, but it grew to the large list you see today. After going through this study plan, I got hired as a Software Development Engineer at Amazon! You probably won\u0026rsquo;t have to study as much as I did. Anyway, everything you need is here.\nI studied about 8-12 hours a day, for several months. This is my story: Why I studied full-time for 8 months for a Google interview\nPlease Note: You won\u0026rsquo;t need to study as much as I did. I wasted a lot of time on things I didn\u0026rsquo;t need to know. More info about that below. I\u0026rsquo;ll help you get there without wasting your precious time.\nThe items listed here will prepare you well for a technical interview at just about any software company, including the giants: Amazon, Facebook, Google, and Microsoft.\nBest of luck to you!\nWhat is it? This is my multi-month study plan for becoming a software engineer for a large company.\nRequired:\nA little experience with coding (variables, loops, methods/functions, etc) Patience Time Note this is a study plan for software engineering, not web development. Large software companies like Google, Amazon, Facebook and Microsoft view software engineering as different from web development. For example, Amazon has Frontend Engineers (FEE) and Software Development Engineers (SDE). These are 2 separate roles and the interviews for them will not be the same, as each has its own competencies. These companies require computer science knowledge for software development/engineering roles.\nTable of Contents The Study Plan What is it? Why use it? How to use it Don\u0026rsquo;t feel you aren\u0026rsquo;t smart enough A Note About Video Resources Choose a Programming Language Books for Data Structures and Algorithms Interview Prep Books Don\u0026rsquo;t Make My Mistakes What you Won\u0026rsquo;t See Covered The Daily Plan Coding Question Practice Coding Problems Topics of Study Algorithmic complexity / Big-O / Asymptotic analysis Data Structures Arrays Linked Lists Stack Queue Hash table More Knowledge Binary search Bitwise operations Trees Trees - Notes \u0026amp; Background Binary search trees: BSTs Heap / Priority Queue / Binary Heap balanced search trees (general concept, not details) traversals: preorder, inorder, postorder, BFS, DFS Sorting selection insertion heapsort quicksort merge sort Graphs directed undirected adjacency matrix adjacency list traversals: BFS, DFS Even More Knowledge Recursion Dynamic Programming Design Patterns Combinatorics (n choose k) \u0026amp; Probability NP, NP-Complete and Approximation Algorithms How computers process a program Caches Processes and Threads Testing String searching \u0026amp; manipulations Tries Floating Point Numbers Unicode Endianness Networking Final Review Getting the Job Update Your Resume Find a Job Interview Process \u0026amp; General Interview Prep Be thinking of for when the interview comes Have questions for the interviewer Once You\u0026rsquo;ve Got The Job \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- Everything below this point is optional \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\nOptional Extra Topics \u0026amp; Resources Additional Books System Design, Scalability, Data Handling (if you have 4+ years experience) Additional Learning Compilers Emacs and vi(m) Unix command line tools Information theory Parity \u0026amp; Hamming Code Entropy Cryptography Compression Computer Security Garbage collection Parallel Programming Messaging, Serialization, and Queueing Systems A* Fast Fourier Transform Bloom Filter HyperLogLog Locality-Sensitive Hashing van Emde Boas Trees Augmented Data Structures Balanced search trees AVL trees Splay trees Red/black trees 2-3 search trees 2-3-4 Trees (aka 2-4 trees) N-ary (K-ary, M-ary) trees B-Trees k-D Trees Skip lists Network Flows Disjoint Sets \u0026amp; Union Find Math for Fast Processing Treap Linear Programming Geometry, Convex hull Discrete math Machine Learning Additional Detail on Some Subjects Video Series Computer Science Courses Papers Why use it? If you want to work as a software engineer for a large company, these are the things you have to know.\nIf you missed out on getting a degree in computer science, like I did, this will catch you up and save four years of your life.\nWhen I started this project, I didn\u0026rsquo;t know a stack from a heap, didn\u0026rsquo;t know Big-O anything, or anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it would have been terrible. Every data structure I had ever used was built into the language, and I didn\u0026rsquo;t know how they worked under the hood at all. I never had to manage memory unless a process I was running would give an \u0026ldquo;out of memory\u0026rdquo; error, and then I\u0026rsquo;d have to find a workaround. I used a few multidimensional arrays in my life and thousands of associative arrays, but I never created data structures from scratch.\nIt\u0026rsquo;s a long plan. It may take you months. If you are familiar with a lot of this already it will take you a lot less time.\nHow to use it Everything below is an outline, and you should tackle the items in order from top to bottom.\nI\u0026rsquo;m using GitHub\u0026rsquo;s special markdown flavor, including tasks lists to track progress.\nCreate a new branch so you can check items like this, just put an x in the brackets: [x]\nFork a branch and follow the commands below Fork the GitHub repo https://github.com/jwasham/coding-interview-university by clicking on the Fork button.\nClone to your local repo:\ngit clone git@github.com:\u0026lt;your_github_username\u0026gt;/coding-interview-university.git git checkout -b progress git remote add jwasham https://github.com/jwasham/coding-interview-university git fetch --all Mark all boxes with X after you completed your changes:\ngit add . git commit -m \u0026quot;Marked x\u0026quot; git rebase jwasham/main git push --set-upstream origin progress git push --force More about GitHub-flavored markdown\nDon\u0026rsquo;t feel you aren\u0026rsquo;t smart enough Successful software engineers are smart, but many have an insecurity that they aren\u0026rsquo;t smart enough. The myth of the Genius Programmer It\u0026rsquo;s Dangerous to Go Alone: Battling the Invisible Monsters in Tech A Note About Video Resources Some videos are available only by enrolling in a Coursera or EdX class. These are called MOOCs. Sometimes the classes are not in session so you have to wait a couple of months, so you have no access.\nIt would be great to replace the online course resources with free and always-available public sources, such as YouTube videos (preferably university lectures), so that you people can study these anytime, not just when a specific online course is in session.\nChoose a Programming Language You\u0026rsquo;ll need to choose a programming language for the coding interviews you do, but you\u0026rsquo;ll also need to find a language that you can use to study computer science concepts.\nPreferably the language would be the same, so that you only need to be proficient in one.\nFor this Study Plan When I did the study plan, I used 2 languages for most of it: C and Python\nC: Very low level. Allows you to deal with pointers and memory allocation/deallocation, so you feel the data structures and algorithms in your bones. In higher level languages like Python or Java, these are hidden from you. In day to day work, that\u0026rsquo;s terrific, but when you\u0026rsquo;re learning how these low-level data structures are built, it\u0026rsquo;s great to feel close to the metal. C is everywhere. You\u0026rsquo;ll see examples in books, lectures, videos, everywhere while you\u0026rsquo;re studying. The C Programming Language, Vol 2 This is a short book, but it will give you a great handle on the C language and if you practice it a little you\u0026rsquo;ll quickly get proficient. Understanding C helps you understand how programs and memory work. You don\u0026rsquo;t need to go super deep in the book (or even finish it). Just get to where you\u0026rsquo;re comfortable reading and writing in C. Answers to questions in the book Python: Modern and very expressive, I learned it because it\u0026rsquo;s just super useful and also allows me to write less code in an interview. This is my preference. You do what you like, of course.\nYou may not need it, but here are some sites for learning a new language:\nExercism Codewars Codility HackerEarth Sphere Online Judge (spoj) Codechef Codeforces For your Coding Interview You can use a language you are comfortable in to do the coding part of the interview, but for large companies, these are solid choices:\nC++ Java Python You could also use these, but read around first. There may be caveats:\nJavaScript Ruby Here is an article I wrote about choosing a language for the interview: Pick One Language for the Coding Interview. This is the original article my post was based on: http://blog.codingforinterviews.com/best-programming-language-jobs/\nYou need to be very comfortable in the language and be knowledgeable.\nRead more about choices:\nChoose the Right Language for Your Coding Interview See language-specific resources here\nBooks for Data Structures and Algorithms This book will form your foundation for computer science.\nJust choose one, in a language that you will be comfortable with. You\u0026rsquo;ll be doing a lot of reading and coding.\nC Algorithms in C, Parts 1-5 (Bundle), 3rd Edition Fundamentals, Data Structures, Sorting, Searching, and Graph Algorithms Python Data Structures and Algorithms in Python by Goodrich, Tamassia, Goldwasser I loved this book. It covered everything and more. Pythonic code my glowing book report: https://startupnextdoor.com/book-report-data-structures-and-algorithms-in-python/ Java Your choice:\nGoodrich, Tamassia, Goldwasser Data Structures and Algorithms in Java Sedgewick and Wayne: Algorithms Free Coursera course that covers the book (taught by the authors!): Algorithms I Algorithms II C++ Your choice:\nGoodrich, Tamassia, and Mount Data Structures and Algorithms in C++, 2nd Edition Sedgewick and Wayne Algorithms in C++, Parts 1-4: Fundamentals, Data Structure, Sorting, Searching Algorithms in C++ Part 5: Graph Algorithms Interview Prep Books You don\u0026rsquo;t need to buy a bunch of these. Honestly \u0026ldquo;Cracking the Coding Interview\u0026rdquo; is probably enough, but I bought more to give myself more practice. But I always do too much.\nI bought both of these. They gave me plenty of practice.\nProgramming Interviews Exposed: Coding Your Way Through the Interview, 4th Edition Answers in C++ and Java This is a good warm-up for Cracking the Coding Interview Not too difficult. Most problems may be easier than what you\u0026rsquo;ll see in an interview (from what I\u0026rsquo;ve read) Cracking the Coding Interview, 6th Edition answers in Java If you have tons of extra time: Choose one:\nElements of Programming Interviews (C++ version) Elements of Programming Interviews in Python Elements of Programming Interviews (Java version) - Companion Project - Method Stub and Test Cases for Every Problem in the Book Don\u0026rsquo;t Make My Mistakes This list grew over many months, and yes, it got out of hand.\nHere are some mistakes I made so you\u0026rsquo;ll have a better experience. And you\u0026rsquo;ll save months of time.\n1. You Won\u0026rsquo;t Remember it All I watched hours of videos and took copious notes, and months later there was much I didn\u0026rsquo;t remember. I spent 3 days going through my notes and making flashcards, so I could review. I didn\u0026rsquo;t need all of that knowledge.\nPlease, read so you won\u0026rsquo;t make my mistakes:\nRetaining Computer Science Knowledge.\n2. Use Flashcards To solve the problem, I made a little flashcards site where I could add flashcards of 2 types: general and code. Each card has different formatting. I made a mobile-first website, so I could review on my phone or tablet, wherever I am.\nMake your own for free:\nFlashcards site repo I DON\u0026rsquo;T RECOMMEND using my flashcards. There are too many and many of them are trivia that you don\u0026rsquo;t need.\nBut if you don\u0026rsquo;t want to listen to me, here you go:\nMy flash cards database (1200 cards): My flash cards database (extreme - 1800 cards): Keep in mind I went overboard and have cards covering everything from assembly language and Python trivia to machine learning and statistics. It\u0026rsquo;s way too much for what\u0026rsquo;s required.\nNote on flashcards: The first time you recognize you know the answer, don\u0026rsquo;t mark it as known. You have to see the same card and answer it several times correctly before you really know it. Repetition will put that knowledge deeper in your brain.\nAn alternative to using my flashcard site is Anki, which has been recommended to me numerous times. It uses a repetition system to help you remember. It\u0026rsquo;s user-friendly, available on all platforms and has a cloud sync system. It costs $25 on iOS but is free on other platforms.\nMy flashcard database in Anki format: https://ankiweb.net/shared/info/25173560 (thanks @xiewenya).\nSome students have mentioned formatting issues with white space that can be fixed by doing the following: open deck, edit card, click cards, select the \u0026ldquo;styling\u0026rdquo; radio button, add the member \u0026ldquo;white-space: pre;\u0026rdquo; to the card class.\n3. Do Coding Interview Questions While You\u0026rsquo;re Learning THIS IS VERY IMPORTANT.\nStart doing coding interview questions while you\u0026rsquo;re learning data structures and algorithms.\nYou need to apply what you\u0026rsquo;re learning to solving problems, or you\u0026rsquo;ll forget. I made this mistake.\nOnce you\u0026rsquo;ve learned a topic, and feel somewhat comfortable with it, for example, linked lists:\nOpen one of the coding interview books (or coding problem websites, listed below) Do 2 or 3 questions regarding linked lists. Move on to the next learning topic. Later, go back and do another 2 or 3 linked list problems. Do this with each new topic you learn. Keep doing problems while you\u0026rsquo;re learning all this stuff, not after.\nYou\u0026rsquo;re not being hired for knowledge, but how you apply the knowledge.\nThere are many resources for this, listed below. Keep going.\n4. Focus There are a lot of distractions that can take up valuable time. Focus and concentration are hard. Turn on some music without lyrics and you\u0026rsquo;ll be able to focus pretty well.\nWhat you won\u0026rsquo;t see covered These are prevalent technologies but not part of this study plan:\nSQL Javascript HTML, CSS, and other front-end technologies The Daily Plan This course goes over a lot of subjects. Each will probably take you a few days, or maybe even a week or more. It depends on your schedule.\nEach day, take the next subject in the list, watch some videos about that subject, and then write an implementation of that data structure or algorithm in the language you chose for this course.\nYou can see my code here:\nC C++ Python You don\u0026rsquo;t need to memorize every algorithm. You just need to be able to understand it enough to be able to write your own implementation.\nCoding Question Practice Why is this here? I'm not ready to interview. Then go back and read this.\nWhy you need to practice doing programming problems:\nProblem recognition, and where the right data structures and algorithms fit in Gathering requirements for the problem Talking your way through the problem like you will in the interview Coding on a whiteboard or paper, not a computer Coming up with time and space complexity for your solutions (see Big-O below) Testing your solutions There is a great intro for methodical, communicative problem solving in an interview. You\u0026rsquo;ll get this from the programming interview books, too, but I found this outstanding: Algorithm design canvas\nWrite code on a whiteboard or paper, not a computer. Test with some sample inputs. Then type it and test it out on a computer.\nIf you don\u0026rsquo;t have a whiteboard at home, pick up a large drawing pad from an art store. You can sit on the couch and practice. This is my \u0026ldquo;sofa whiteboard\u0026rdquo;. I added the pen in the photo just for scale. If you use a pen, you\u0026rsquo;ll wish you could erase. Gets messy quick. I use a pencil and eraser.\nCoding question practice is not about memorizing answers to programming problems.\nCoding Problems Don\u0026rsquo;t forget your key coding interview books here.\nSolving Problems:\nHow to Find a Solution How to Dissect a Topcoder Problem Statement Coding Interview Question Videos:\nIDeserve (88 videos) Tushar Roy (5 playlists) Super for walkthroughs of problem solutions Nick White - LeetCode Solutions (187 Videos) Good explanations of solution and the code You can watch several in a short time FisherCoder - LeetCode Solutions Challenge sites:\nLeetCode My favorite coding problem site. It\u0026rsquo;s worth the subscription money for the 1-2 months you\u0026rsquo;ll likely be preparing. See Nick White and FisherCoder Videos above for code walk-throughs. HackerRank TopCoder Geeks for Geeks InterviewBit Project Euler Let\u0026rsquo;s Get Started Alright, enough talk, let\u0026rsquo;s learn!\nBut don\u0026rsquo;t forget to do coding problems from above while you learn!\nAlgorithmic complexity / Big-O / Asymptotic analysis Nothing to implement here, you\u0026rsquo;re just watching videos and taking notes! Yay! There are a lot of videos here. Just watch enough until you understand it. You can always come back and review. Don\u0026rsquo;t worry if you don\u0026rsquo;t understand all the math behind it. You just need to understand how to express the complexity of an algorithm in terms of Big-O. Harvard CS50 - Asymptotic Notation (video) Big O Notations (general quick tutorial) (video) Big O Notation (and Omega and Theta) - best mathematical explanation (video) Skiena: video slides UC Berkeley Big O (video) Amortized Analysis (video) TopCoder (includes recurrence relations and master theorem): Computational Complexity: Section 1 Computational Complexity: Section 2 Cheat sheet Well, that\u0026rsquo;s about enough of that.\nWhen you go through \u0026ldquo;Cracking the Coding Interview\u0026rdquo;, there is a chapter on this, and at the end there is a quiz to see if you can identify the runtime complexity of different algorithms. It\u0026rsquo;s a super review and test.\nData Structures Arrays About Arrays: Arrays (video) UC Berkeley CS61B - Linear and Multi-Dim Arrays (video) (Start watching from 15m 32s) Dynamic Arrays (video) Jagged Arrays (video) Implement a vector (mutable array with automatic resizing): Practice coding using arrays and pointers, and pointer math to jump to an index instead of using indexing. New raw data array with allocated memory can allocate int array under the hood, just not use its features start with 16, or if starting number is greater, use power of 2 - 16, 32, 64, 128 size() - number of items capacity() - number of items it can hold is_empty() at(index) - returns item at given index, blows up if index out of bounds push(item) insert(index, item) - inserts item at index, shifts that index\u0026rsquo;s value and trailing elements to the right prepend(item) - can use insert above at index 0 pop() - remove from end, return value delete(index) - delete item at index, shifting all trailing elements left remove(item) - looks for value and removes index holding it (even if in multiple places) find(item) - looks for value and returns first index with that value, -1 if not found resize(new_capacity) // private function when you reach capacity, resize to double the size when popping an item, if size is 1/4 of capacity, resize to half Time O(1) to add/remove at end (amortized for allocations for more space), index, or update O(n) to insert/remove elsewhere Space contiguous in memory, so proximity helps performance space needed = (array capacity, which is \u0026gt;= n) * size of item, but even if 2n, still O(n) Linked Lists Description: Singly Linked Lists (video) CS 61B - Linked Lists 1 (video) CS 61B - Linked Lists 2 (video) C Code (video) - not the whole video, just portions about Node struct and memory allocation Linked List vs Arrays: Core Linked Lists Vs Arrays (video) In The Real World Linked Lists Vs Arrays (video) why you should avoid linked lists (video) Gotcha: you need pointer to pointer knowledge: (for when you pass a pointer to a function that may change the address where that pointer points) This page is just to get a grasp on ptr to ptr. I don\u0026rsquo;t recommend this list traversal style. Readability and maintainability suffer due to cleverness. Pointers to Pointers Implement (I did with tail pointer \u0026amp; without): size() - returns number of data elements in list empty() - bool returns true if empty value_at(index) - returns the value of the nth item (starting at 0 for first) push_front(value) - adds an item to the front of the list pop_front() - remove front item and return its value push_back(value) - adds an item at the end pop_back() - removes end item and returns its value front() - get value of front item back() - get value of end item insert(index, value) - insert value at index, so current item at that index is pointed to by new item at index erase(index) - removes node at given index value_n_from_end(n) - returns the value of the node at nth position from the end of the list reverse() - reverses the list remove_value(value) - removes the first item in the list with this value Doubly-linked List Description (video) No need to implement Stack Stacks (video) Will not implement. Implementing with array is trivial Queue Queue (video) Circular buffer/FIFO Implement using linked-list, with tail pointer: enqueue(value) - adds value at position at tail dequeue() - returns value and removes least recently added element (front) empty() Implement using fixed-sized array: enqueue(value) - adds item at end of available storage dequeue() - returns value and removes least recently added element empty() full() Cost: a bad implementation using linked list where you enqueue at head and dequeue at tail would be O(n) because you\u0026rsquo;d need the next to last element, causing a full traversal each dequeue enqueue: O(1) (amortized, linked list and array [probing]) dequeue: O(1) (linked list and array) empty: O(1) (linked list and array) Hash table Videos:\nHashing with Chaining (video) Table Doubling, Karp-Rabin (video) Open Addressing, Cryptographic Hashing (video) PyCon 2010: The Mighty Dictionary (video) PyCon 2017: The Dictionary Even Mightier (video) (Advanced) Randomization: Universal \u0026amp; Perfect Hashing (video) (Advanced) Perfect hashing (video) Online Courses:\nCore Hash Tables (video) Data Structures (video) Phone Book Problem (video) distributed hash tables: Instant Uploads And Storage Optimization In Dropbox (video) Distributed Hash Tables (video) Implement with array using linear probing\nhash(k, m) - m is size of hash table add(key, value) - if key already exists, update value exists(key) get(key) remove(key) More Knowledge Binary search Binary Search (video) Binary Search (video) detail Implement: binary search (on sorted array of integers) binary search using recursion Bitwise operations Bits cheat sheet - you should know many of the powers of 2 from (2^1 to 2^16 and 2^32) Get a really good understanding of manipulating bits with: \u0026amp;, |, ^, ~, \u0026raquo;, \u0026laquo; words Good intro: Bit Manipulation (video) C Programming Tutorial 2-10: Bitwise Operators (video) Bit Manipulation Bitwise Operation Bithacks The Bit Twiddler The Bit Twiddler Interactive Bit Hacks (video) Practice Operations 2s and 1s complement Binary: Plusses \u0026amp; Minuses (Why We Use Two\u0026rsquo;s Complement) (video) 1s Complement 2s Complement Count set bits 4 ways to count bits in a byte (video) Count Bits How To Count The Number Of Set Bits In a 32 Bit Integer Swap values: Swap Absolute value: Absolute Integer Trees Trees - Notes \u0026amp; Background Series: Trees (video) basic tree construction traversal manipulation algorithms BFS(breadth-first search) and DFS(depth-first search) (video) BFS notes: level order (BFS, using queue) time complexity: O(n) space complexity: best: O(1), worst: O(n/2)=O(n) DFS notes: time complexity: O(n) space complexity: best: O(log n) - avg. height of tree worst: O(n) inorder (DFS: left, self, right) postorder (DFS: left, right, self) preorder (DFS: self, left, right) Binary search trees: BSTs Binary Search Tree Review (video) Introduction (video) MIT (video) C/C++: Binary search tree - Implementation in C/C++ (video) BST implementation - memory allocation in stack and heap (video) Find min and max element in a binary search tree (video) Find height of a binary tree (video) Binary tree traversal - breadth-first and depth-first strategies (video) Binary tree: Level Order Traversal (video) Binary tree traversal: Preorder, Inorder, Postorder (video) Check if a binary tree is binary search tree or not (video) Delete a node from Binary Search Tree (video) Inorder Successor in a binary search tree (video) Implement: insert // insert value into tree get_node_count // get count of values stored print_values // prints the values in the tree, from min to max delete_tree is_in_tree // returns true if given value exists in the tree get_height // returns the height in nodes (single node\u0026rsquo;s height is 1) get_min // returns the minimum value stored in the tree get_max // returns the maximum value stored in the tree is_binary_search_tree delete_value get_successor // returns next-highest value in tree after given value, -1 if none Heap / Priority Queue / Binary Heap visualized as a tree, but is usually linear in storage (array, linked list) Heap Introduction (video) Naive Implementations (video) Binary Trees (video) Tree Height Remark (video) Basic Operations (video) Complete Binary Trees (video) Pseudocode (video) Heap Sort - jumps to start (video) Heap Sort (video) Building a heap (video) MIT: Heaps and Heap Sort (video) CS 61B Lecture 24: Priority Queues (video) Linear Time BuildHeap (max-heap) Implement a max-heap: insert sift_up - needed for insert get_max - returns the max item, without removing it get_size() - return number of elements stored is_empty() - returns true if heap contains no elements extract_max - returns the max item, removing it sift_down - needed for extract_max remove(x) - removes item at index x heapify - create a heap from an array of elements, needed for heap_sort heap_sort() - take an unsorted array and turn it into a sorted array in-place using a max heap or min heap Sorting Notes:\nImplement sorts \u0026amp; know best case/worst case, average complexity of each: no bubble sort - it\u0026rsquo;s terrible - O(n^2), except when n \u0026lt;= 16 Stability in sorting algorithms (\u0026ldquo;Is Quicksort stable?\u0026rdquo;) Sorting Algorithm Stability Stability In Sorting Algorithms Stability In Sorting Algorithms Sorting Algorithms - Stability Which algorithms can be used on linked lists? Which on arrays? Which on both? I wouldn\u0026rsquo;t recommend sorting a linked list, but merge sort is doable. Merge Sort For Linked List For heapsort, see Heap data structure above. Heap sort is great, but not stable\nSedgewick - Mergesort (5 videos)\n1. Mergesort 2. Bottom up Mergesort 3. Sorting Complexity 4. Comparators 5. Stability Sedgewick - Quicksort (4 videos)\n1. Quicksort 2. Selection 3. Duplicate Keys 4. System Sorts UC Berkeley:\nCS 61B Lecture 29: Sorting I (video) CS 61B Lecture 30: Sorting II (video) CS 61B Lecture 32: Sorting III (video) CS 61B Lecture 33: Sorting V (video) Bubble Sort (video)\nAnalyzing Bubble Sort (video)\nInsertion Sort, Merge Sort (video)\nInsertion Sort (video)\nMerge Sort (video)\nQuicksort (video)\nSelection Sort (video)\nMerge sort code:\nUsing output array (C) Using output array (Python) In-place (C++) Quick sort code:\nImplementation (C) Implementation (C) Implementation (Python) Implement:\nMergesort: O(n log n) average and worst case Quicksort O(n log n) average case Selection sort and insertion sort are both O(n^2) average and worst case For heapsort, see Heap data structure above Not required, but I recommended them:\nSedgewick - Radix Sorts (6 videos) 1. Strings in Java 2. Key Indexed Counting 3. Least Significant Digit First String Radix Sort 4. Most Significant Digit First String Radix Sort 5. 3 Way Radix Quicksort 6. Suffix Arrays Radix Sort Radix Sort (video) Radix Sort, Counting Sort (linear time given constraints) (video) Randomization: Matrix Multiply, Quicksort, Freivalds\u0026rsquo; algorithm (video) Sorting in Linear Time (video) As a summary, here is a visual representation of 15 sorting algorithms. If you need more detail on this subject, see \u0026ldquo;Sorting\u0026rdquo; section in Additional Detail on Some Subjects\nGraphs Graphs can be used to represent many problems in computer science, so this section is long, like trees and sorting were.\nNotes:\nThere are 4 basic ways to represent a graph in memory: objects and pointers adjacency matrix adjacency list adjacency map Familiarize yourself with each representation and its pros \u0026amp; cons BFS and DFS - know their computational complexity, their trade offs, and how to implement them in real code When asked a question, look for a graph-based solution first, then move on if none MIT(videos):\nBreadth-First Search Depth-First Search Skiena Lectures - great intro:\nCSE373 2012 - Lecture 11 - Graph Data Structures (video) CSE373 2012 - Lecture 12 - Breadth-First Search (video) CSE373 2012 - Lecture 13 - Graph Algorithms (video) CSE373 2012 - Lecture 14 - Graph Algorithms (con\u0026rsquo;t) (video) CSE373 2012 - Lecture 15 - Graph Algorithms (con\u0026rsquo;t 2) (video) CSE373 2012 - Lecture 16 - Graph Algorithms (con\u0026rsquo;t 3) (video) Graphs (review and more):\n6.006 Single-Source Shortest Paths Problem (video) 6.006 Dijkstra (video) 6.006 Bellman-Ford (video) 6.006 Speeding Up Dijkstra (video) Aduni: Graph Algorithms I - Topological Sorting, Minimum Spanning Trees, Prim\u0026rsquo;s Algorithm - Lecture 6 (video) Aduni: Graph Algorithms II - DFS, BFS, Kruskal\u0026rsquo;s Algorithm, Union Find Data Structure - Lecture 7 (video) Aduni: Graph Algorithms III: Shortest Path - Lecture 8 (video) Aduni: Graph Alg. IV: Intro to geometric algorithms - Lecture 9 (video) CS 61B 2014 (starting at 58:09) (video) CS 61B 2014: Weighted graphs (video) Greedy Algorithms: Minimum Spanning Tree (video) Strongly Connected Components Kosaraju\u0026rsquo;s Algorithm Graph Algorithm (video) Full Coursera Course:\nAlgorithms on Graphs (video) I\u0026rsquo;ll implement:\nDFS with adjacency list (recursive) DFS with adjacency list (iterative with stack) DFS with adjacency matrix (recursive) DFS with adjacency matrix (iterative with stack) BFS with adjacency list BFS with adjacency matrix single-source shortest path (Dijkstra) minimum spanning tree DFS-based algorithms (see Aduni videos above): check for cycle (needed for topological sort, since we\u0026rsquo;ll check for cycle before starting) topological sort count connected components in a graph list strongly connected components check for bipartite graph Even More Knowledge Recursion Stanford lectures on recursion \u0026amp; backtracking: Lecture 8 | Programming Abstractions (video) Lecture 9 | Programming Abstractions (video) Lecture 10 | Programming Abstractions (video) Lecture 11 | Programming Abstractions (video) When it is appropriate to use it? How is tail recursion better than not? What Is Tail Recursion Why Is It So Bad? Tail Recursion (video) Dynamic Programming You probably won\u0026rsquo;t see any dynamic programming problems in your interview, but it\u0026rsquo;s worth being able to recognize a problem as being a candidate for dynamic programming. This subject can be pretty difficult, as each DP soluble problem must be defined as a recursion relation, and coming up with it can be tricky. I suggest looking at many examples of DP problems until you have a solid understanding of the pattern involved. Videos: the Skiena videos can be hard to follow since he sometimes uses the whiteboard, which is too small to see Skiena: CSE373 2012 - Lecture 19 - Introduction to Dynamic Programming (video) Skiena: CSE373 2012 - Lecture 20 - Edit Distance (video) Skiena: CSE373 2012 - Lecture 21 - Dynamic Programming Examples (video) Skiena: CSE373 2012 - Lecture 22 - Applications of Dynamic Programming (video) Simonson: Dynamic Programming 0 (starts at 59:18) (video) Simonson: Dynamic Programming I - Lecture 11 (video) Simonson: Dynamic programming II - Lecture 12 (video) List of individual DP problems (each is short): Dynamic Programming (video) Yale Lecture notes: Dynamic Programming Coursera: The RNA secondary structure problem (video) A dynamic programming algorithm (video) Illustrating the DP algorithm (video) Running time of the DP algorithm (video) DP vs. recursive implementation (video) Global pairwise sequence alignment (video) Local pairwise sequence alignment (video) Design patterns Quick UML review (video) Learn these patterns: strategy singleton adapter prototype decorator visitor factory, abstract factory facade observer proxy delegate command state memento iterator composite flyweight Series of videos (27 videos) Book: Head First Design Patterns I know the canonical book is \u0026ldquo;Design Patterns: Elements of Reusable Object-Oriented Software\u0026rdquo;, but Head First is great for beginners to OO. Handy reference: 101 Design Patterns \u0026amp; Tips for Developers Combinatorics (n choose k) \u0026amp; Probability Math Skills: How to find Factorial, Permutation and Combination (Choose) (video) Make School: Probability (video) Make School: More Probability and Markov Chains (video) Khan Academy: Course layout: Basic Theoretical Probability Just the videos - 41 (each are simple and each are short): Probability Explained (video) NP, NP-Complete and Approximation Algorithms Know about the most famous classes of NP-complete problems, such as traveling salesman and the knapsack problem, and be able to recognize them when an interviewer asks you them in disguise. Know what NP-complete means. Computational Complexity (video) Simonson: Greedy Algs. II \u0026amp; Intro to NP Completeness (video) NP Completeness II \u0026amp; Reductions (video) NP Completeness III (Video) NP Completeness IV (video) Skiena: CSE373 2012 - Lecture 23 - Introduction to NP-Completeness (video) CSE373 2012 - Lecture 24 - NP-Completeness Proofs (video) CSE373 2012 - Lecture 25 - NP-Completeness Challenge (video) Complexity: P, NP, NP-completeness, Reductions (video) Complexity: Approximation Algorithms (video) Complexity: Fixed-Parameter Algorithms (video) Peter Norvig discusses near-optimal solutions to traveling salesman problem: Jupyter Notebook Pages 1048 - 1140 in CLRS if you have it. How computers process a program How CPU executes a program (video) How computers calculate - ALU (video) Registers and RAM (video) The Central Processing Unit (CPU) (video) Instructions and Programs (video) Caches LRU cache: The Magic of LRU Cache (100 Days of Google Dev) (video) Implementing LRU (video) LeetCode - 146 LRU Cache (C++) (video) CPU cache: MIT 6.004 L15: The Memory Hierarchy (video) MIT 6.004 L16: Cache Issues (video) Processes and Threads Computer Science 162 - Operating Systems (25 videos): for processes and threads see videos 1-11 Operating Systems and System Programming (video) What Is The Difference Between A Process And A Thread? Covers: Processes, Threads, Concurrency issues Difference between processes and threads Processes Threads Locks Mutexes Semaphores Monitors How they work? Deadlock Livelock CPU activity, interrupts, context switching Modern concurrency constructs with multicore processors Paging, segmentation and virtual memory (video) Interrupts (video) Process resource needs (memory: code, static storage, stack, heap, and also file descriptors, i/o) Thread resource needs (shares above (minus stack) with other threads in the same process but each has its own pc, stack counter, registers, and stack) Forking is really copy on write (read-only) until the new process writes to memory, then it does a full copy. Context switching How context switching is initiated by the operating system and underlying hardware? threads in C++ (series - 10 videos) CS 377 Spring \u0026lsquo;14: Operating Systems from University of Massachusetts concurrency in Python (videos): Short series on threads Python Threads Understanding the Python GIL (2010) reference David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015 Keynote David Beazley - Topics of Interest (Python Asyncio) Mutex in Python Testing To cover: how unit testing works what are mock objects what is integration testing what is dependency injection Agile Software Testing with James Bach (video) Open Lecture by James Bach on Software Testing (video) Steve Freeman - Test-Driven Development (that’s not what we meant) (video) slides Dependency injection: video Tao Of Testing How to write tests String searching \u0026amp; manipulations Sedgewick - Suffix Arrays (video) Sedgewick - Substring Search (videos) 1. Introduction to Substring Search 2. Brute-Force Substring Search 3. Knuth-Morris Pratt 4. Boyer-Moore 5. Rabin-Karp Search pattern in text (video) If you need more detail on this subject, see \u0026ldquo;String Matching\u0026rdquo; section in Additional Detail on Some Subjects.\nTries Note there are different kinds of tries. Some have prefixes, some don\u0026rsquo;t, and some use string instead of bits to track the path I read through code, but will not implement Sedgewick - Tries (3 videos) 1. R Way Tries 2. Ternary Search Tries 3. Character Based Operations Notes on Data Structures and Programming Techniques Short course videos: Introduction To Tries (video) Performance Of Tries (video) Implementing A Trie (video) The Trie: A Neglected Data Structure TopCoder - Using Tries Stanford Lecture (real world use case) (video) MIT, Advanced Data Structures, Strings (can get pretty obscure about halfway through) (video) Floating Point Numbers simple 8-bit: Representation of Floating Point Numbers - 1 (video - there is an error in calculations - see video description) 32 bit: IEEE754 32-bit floating point binary (video) Unicode The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text Endianness Big And Little Endian Big Endian Vs Little Endian (video) Big And Little Endian Inside/Out (video) Very technical talk for kernel devs. Don\u0026rsquo;t worry if most is over your head. The first half is enough. Networking if you have networking experience or want to be a reliability engineer or operations engineer, expect questions Otherwise, this is just good to know Khan Academy UDP and TCP: Comparison of Transport Protocols (video) TCP/IP and the OSI Model Explained! (video) Packet Transmission across the Internet. Networking \u0026amp; TCP/IP tutorial. (video) HTTP (video) SSL and HTTPS (video) SSL/TLS (video) HTTP 2.0 (video) Video Series (21 videos) (video) Subnetting Demystified - Part 5 CIDR Notation (video) Sockets: Java - Sockets - Introduction (video) Socket Programming (video) Final Review This section will have shorter videos that you can watch pretty quickly to review most of the important concepts. It's nice if you want a refresher often. Series of 2-3 minutes short subject videos (23 videos) Videos Series of 2-5 minutes short subject videos - Michael Sambol (18 videos): Videos Sedgewick Videos - Algorithms I Sedgewick Videos - Algorithms II Update Your Resume See Resume prep information in the books: \u0026ldquo;Cracking The Coding Interview\u0026rdquo; and \u0026ldquo;Programming Interviews Exposed\u0026rdquo; I don\u0026rsquo;t know how important this is (you can do your own research) but here is an article on making your resume ATS Compliant: How to Create or Check if your Resume is ATS Compliant \u0026ldquo;This Is What A GOOD Resume Should Look Like\u0026rdquo; by Gayle McDowell (author of Cracking the Coding Interview), Note by the author: \u0026ldquo;This is for a US-focused resume. CVs for India and other countries have different expectations, although many of the points will be the same.\u0026rdquo; Find a Job Sites for Finding Jobs Interview Process \u0026amp; General Interview Prep How to Pass the Engineering Interview in 2021 Demystifying Tech Recruiting How to Get a Job at the Big 4: How to Get a Job at the Big 4 - Amazon, Facebook, Google \u0026amp; Microsoft (video) How to Get a Job at the Big 4.1 (Follow-up video) Cracking The Coding Interview Set 1: Gayle L McDowell - Cracking The Coding Interview (video) Cracking the Coding Interview with Author Gayle Laakmann McDowell (video) Cracking the Facebook Coding Interview: The Approach Problem Walkthrough Prep Courses: Software Engineer Interview Unleashed (paid course): Learn how to make yourself ready for software engineer interviews from a former Google interviewer. Python for Data Structures, Algorithms, and Interviews (paid course): A Python centric interview prep course which covers data structures, algorithms, mock interviews and much more. Intro to Data Structures and Algorithms using Python (Udacity free course): A free Python centric data structures and algorithms course. Data Structures and Algorithms Nanodegree! (Udacity paid Nanodegree): Get hands-on practice with over 100 data structures and algorithm exercises and guidance from a dedicated mentor to help prepare you for interviews and on-the-job scenarios. Grokking the Behavioral Interview (Educative free course): Many times, it’s not your technical competency that holds you back from landing your dream job, it’s how you perform on the behavioral interview. Mock Interviews:\nGainlo.co: Mock interviewers from big companies - I used this and it helped me relax for the phone screen and on-site interview Pramp: Mock interviews from/with peers - peer-to-peer model of practice interviews interviewing.io: Practice mock interview with senior engineers - anonymous algorithmic/systems design interviews with senior engineers from FAANG anonymously Be thinking of for when the interview comes Think of about 20 interview questions you\u0026rsquo;ll get, along with the lines of the items below. Have at least one answer for each. Have a story, not just data, about something you accomplished.\nWhy do you want this job?\nWhat\u0026rsquo;s a tough problem you\u0026rsquo;ve solved?\nBiggest challenges faced?\nBest/worst designs seen?\nIdeas for improving an existing product\nHow do you work best, as an individual and as part of a team?\nWhich of your skills or experiences would be assets in the role and why?\nWhat did you most enjoy at [job x / project y]?\nWhat was the biggest challenge you faced at [job x / project y]?\nWhat was the hardest bug you faced at [job x / project y]?\nWhat did you learn at [job x / project y]?\nWhat would you have done better at [job x / project y]?\nIf you find it hard to come up with good answers of these types of interview questions, here are some ideas:\nGeneral Interview Questions and their Answers Have questions for the interviewer Some of mine (I already may know the answers, but want their opinion or team perspective):\nHow large is your team? What does your dev cycle look like? Do you do waterfall/sprints/agile? Are rushes to deadlines common? Or is there flexibility? How are decisions made in your team? How many meetings do you have per week? Do you feel your work environment helps you concentrate? What are you working on? What do you like about it? What is the work life like? How is the work/life balance? Once You\u0026rsquo;ve Got The Job Congratulations!\nKeep learning.\nYou\u0026rsquo;re never really done.\n***************************************************************************************************** ***************************************************************************************************** Everything below this point is optional. It is NOT needed for an entry-level interview. However, by studying these, you'll get greater exposure to more CS concepts, and will be better prepared for any software engineering job. You'll be a much more well-rounded software engineer. ***************************************************************************************************** ***************************************************************************************************** Additional Books These are here so you can dive into a topic you find interesting. The Unix Programming Environment An oldie but a goodie The Linux Command Line: A Complete Introduction A modern option TCP/IP Illustrated Series Head First Design Patterns A gentle introduction to design patterns Design Patterns: Elements of Reusable Object-Oriente​d Software AKA the \u0026ldquo;Gang Of Four\u0026rdquo; book, or GOF The canonical design patterns book Algorithm Design Manual (Skiena) As a review and problem recognition The algorithm catalog portion is well beyond the scope of difficulty you\u0026rsquo;ll get in an interview This book has 2 parts: Class textbook on data structures and algorithms Pros: Is a good review as any algorithms textbook would be Nice stories from his experiences solving problems in industry and academia Code examples in C Cons: Can be as dense or impenetrable as CLRS, and in some cases, CLRS may be a better alternative for some subjects Chapters 7, 8, 9 can be painful to try to follow, as some items are not explained well or require more brain than I have Don\u0026rsquo;t get me wrong: I like Skiena, his teaching style, and mannerisms, but I may not be Stony Brook material Algorithm catalog: This is the real reason you buy this book. This book is better as an algorithm reference, and not something you read cover to cover. Can rent it on Kindle Answers: Solutions Solutions Errata Write Great Code: Volume 1: Understanding the Machine The book was published in 2004, and is somewhat outdated, but it\u0026rsquo;s a terrific resource for understanding a computer in brief The author invented HLA, so take mentions and examples in HLA with a grain of salt. Not widely used, but decent examples of what assembly looks like These chapters are worth the read to give you a nice foundation: Chapter 2 - Numeric Representation Chapter 3 - Binary Arithmetic and Bit Operations Chapter 4 - Floating-Point Representation Chapter 5 - Character Representation Chapter 6 - Memory Organization and Access Chapter 7 - Composite Data Types and Memory Objects Chapter 9 - CPU Architecture Chapter 10 - Instruction Set Architecture Chapter 11 - Memory Architecture and Organization Introduction to Algorithms Important: Reading this book will only have limited value. This book is a great review of algorithms and data structures, but won\u0026rsquo;t teach you how to write good code. You have to be able to code a decent solution efficiently AKA CLR, sometimes CLRS, because Stein was late to the game Computer Architecture, Sixth Edition: A Quantitative Approach For a richer, more up-to-date (2017), but longer treatment System Design, Scalability, Data Handling You can expect system design questions if you have 4+ years of experience.\nScalability and System Design are very large topics with many topics and resources, since there is a lot to consider when designing a software/hardware system that can scale. Expect to spend quite a bit of time on this Considerations: Scalability Distill large data sets to single values Transform one data set to another Handling obscenely large amounts of data System design features sets interfaces class hierarchies designing a system under certain constraints simplicity and robustness tradeoffs performance analysis and optimization START HERE: The System Design Primer System Design from HiredInTech How Do I Prepare To Answer Design Questions In A Technical Interview? 8 Things You Need to Know Before a System Design Interview Database Normalization - 1NF, 2NF, 3NF and 4NF (video) System Design Interview - There are a lot of resources in this one. Look through the articles and examples. I put some of them below How to ace a systems design interview Numbers Everyone Should Know How long does it take to make a context switch? Transactions Across Datacenters (video) A plain English introduction to CAP Theorem MIT 6.824: Distributed Systems, Spring 2020 (20 videos) Consensus Algorithms: Paxos - Paxos Agreement - Computerphile (video) Raft - An Introduction to the Raft Distributed Consensus Algorithm (video) Easy-to-read paper Infographic Consistent Hashing NoSQL Patterns Scalability: You don\u0026rsquo;t need all of these. Just pick a few that interest you. Great overview (video) Short series: Clones Database Cache Asynchronism Scalable Web Architecture and Distributed Systems Fallacies of Distributed Computing Explained Jeff Dean - Building Software Systems At Google and Lessons Learned (video) Introduction to Architecting Systems for Scale Scaling mobile games to a global audience using App Engine and Cloud Datastore (video) How Google Does Planet-Scale Engineering for Planet-Scale Infra (video) The Importance of Algorithms Sharding Engineering for the Long Game - Astrid Atkinson Keynote(video) 7 Years Of YouTube Scalability Lessons In 30 Minutes video How PayPal Scaled To Billions Of Transactions Daily Using Just 8VMs How to Remove Duplicates in Large Datasets A look inside Etsy\u0026rsquo;s scale and engineering culture with Jon Cowie (video) What Led Amazon to its Own Microservices Architecture To Compress Or Not To Compress, That Was Uber\u0026rsquo;s Question When Should Approximate Query Processing Be Used? Google\u0026rsquo;s Transition From Single Datacenter, To Failover, To A Native Multihomed Architecture The Image Optimization Technology That Serves Millions Of Requests Per Day A Patreon Architecture Short Tinder: How Does One Of The Largest Recommendation Engines Decide Who You\u0026rsquo;ll See Next? Design Of A Modern Cache Live Video Streaming At Facebook Scale A Beginner\u0026rsquo;s Guide To Scaling To 11 Million+ Users On Amazon\u0026rsquo;s AWS A 360 Degree View Of The Entire Netflix Stack Latency Is Everywhere And It Costs You Sales - How To Crush It What Powers Instagram: Hundreds of Instances, Dozens of Technologies Salesforce Architecture - How They Handle 1.3 Billion Transactions A Day ESPN\u0026rsquo;s Architecture At Scale - Operating At 100,000 Duh Nuh Nuhs Per Second See \u0026ldquo;Messaging, Serialization, and Queueing Systems\u0026rdquo; way below for info on some of the technologies that can glue services together Twitter: O\u0026rsquo;Reilly MySQL CE 2011: Jeremy Cole, \u0026ldquo;Big and Small Data at @Twitter\u0026rdquo; (video) Timelines at Scale For even more, see \u0026ldquo;Mining Massive Datasets\u0026rdquo; video series in the Video Series section Practicing the system design process: Here are some ideas to try working through on paper, each with some documentation on how it was handled in the real world: review: The System Design Primer System Design from HiredInTech cheat sheet flow: Understand the problem and scope: Define the use cases, with interviewer\u0026rsquo;s help Suggest additional features Remove items that interviewer deems out of scope Assume high availability is required, add as a use case Think about constraints: Ask how many requests per month Ask how many requests per second (they may volunteer it or make you do the math) Estimate reads vs. writes percentage Keep 80/20 rule in mind when estimating How much data written per second Total storage required over 5 years How much data read per second Abstract design: Layers (service, data, caching) Infrastructure: load balancing, messaging Rough overview of any key algorithm that drives the service Consider bottlenecks and determine solutions Exercises: Design a random unique ID generation system Design a key-value database Design a picture sharing system Design a recommendation system Design a URL-shortener system: copied from above Design a cache system Additional Learning I added them to help you become a well-rounded software engineer, and to be aware of certain technologies and algorithms, so you'll have a bigger toolbox. Compilers How a Compiler Works in ~1 minute (video) Harvard CS50 - Compilers (video) C++ (video) Understanding Compiler Optimization (C++) (video) Emacs and vi(m) Familiarize yourself with a unix-based code editor vi(m): Editing With vim 01 - Installation, Setup, and The Modes (video) VIM Adventures set of 4 videos: The vi/vim editor - Lesson 1 The vi/vim editor - Lesson 2 The vi/vim editor - Lesson 3 The vi/vim editor - Lesson 4 Using Vi Instead of Emacs emacs: Basics Emacs Tutorial (video) set of 3 (videos): Emacs Tutorial (Beginners) -Part 1- File commands, cut/copy/paste, cursor commands Emacs Tutorial (Beginners) -Part 2- Buffer management, search, M-x grep and rgrep modes Emacs Tutorial (Beginners) -Part 3- Expressions, Statements, ~/.emacs file and packages Evil Mode: Or, How I Learned to Stop Worrying and Love Emacs (video) Writing C Programs With Emacs (maybe) Org Mode In Depth: Managing Structure (video) Unix command line tools I filled in the list below from good tools. bash cat grep sed awk curl or wget sort tr uniq strace tcpdump Information theory (videos) Khan Academy More about Markov processes: Core Markov Text Generation Core Implementing Markov Text Generation Project = Markov Text Generation Walk Through See more in MIT 6.050J Information and Entropy series below Parity \u0026amp; Hamming Code (videos) Intro Parity Hamming Code: Error detection Error correction Error Checking Entropy Also see videos below Make sure to watch information theory videos first Information Theory, Claude Shannon, Entropy, Redundancy, Data Compression \u0026amp; Bits (video) Cryptography Also see videos below Make sure to watch information theory videos first Khan Academy Series Cryptography: Hash Functions Cryptography: Encryption Compression Make sure to watch information theory videos first Computerphile (videos): Compression Entropy in Compression Upside Down Trees (Huffman Trees) EXTRA BITS/TRITS - Huffman Trees Elegant Compression in Text (The LZ 77 Method) Text Compression Meets Probabilities Compressor Head videos (optional) Google Developers Live: GZIP is not enough! Computer Security MIT (23 videos) Introduction, Threat Models Control Hijacking Attacks Buffer Overflow Exploits and Defenses Privilege Separation Capabilities Sandboxing Native Code Web Security Model Securing Web Applications Symbolic Execution Network Security Network Protocols Side-Channel Attacks Garbage collection GC in Python (video) Deep Dive Java: Garbage Collection is Good! Deep Dive Python: Garbage Collection in CPython (video) Parallel Programming Coursera (Scala) Efficient Python for High Performance Parallel Computing (video) Messaging, Serialization, and Queueing Systems Thrift Tutorial Protocol Buffers Tutorials gRPC gRPC 101 for Java Developers (video) Redis Tutorial Amazon SQS (queue) Amazon SNS (pub-sub) RabbitMQ Get Started Celery First Steps With Celery ZeroMQ Intro - Read The Manual ActiveMQ Kafka MessagePack Avro A* A Search Algorithm A* Pathfinding Tutorial (video) A* Pathfinding (E01: algorithm explanation) (video) Fast Fourier Transform An Interactive Guide To The Fourier Transform What is a Fourier transform? What is it used for? What is the Fourier Transform? (video) Divide \u0026amp; Conquer: FFT (video) Understanding The FFT Bloom Filter Given a Bloom filter with m bits and k hashing functions, both insertion and membership testing are O(k) Bloom Filters (video) Bloom Filters | Mining of Massive Datasets | Stanford University (video) Tutorial How To Write A Bloom Filter App HyperLogLog How To Count A Billion Distinct Objects Using Only 1.5KB Of Memory Locality-Sensitive Hashing Used to determine the similarity of documents The opposite of MD5 or SHA which are used to determine if 2 documents/strings are exactly the same Simhashing (hopefully) made simple van Emde Boas Trees Divide \u0026amp; Conquer: van Emde Boas Trees (video) MIT Lecture Notes Augmented Data Structures CS 61B Lecture 39: Augmenting Data Structures Balanced search trees Know at least one type of balanced binary tree (and know how it\u0026rsquo;s implemented):\n\u0026ldquo;Among balanced search trees, AVL and 2/3 trees are now passé, and red-black trees seem to be more popular. A particularly interesting self-organizing data structure is the splay tree, which uses rotations to move any accessed key to the root.\u0026rdquo; - Skiena\nOf these, I chose to implement a splay tree. From what I\u0026rsquo;ve read, you won\u0026rsquo;t implement a balanced search tree in your interview. But I wanted exposure to coding one up and let\u0026rsquo;s face it, splay trees are the bee\u0026rsquo;s knees. I did read a lot of red-black tree code\nSplay tree: insert, search, delete functions If you end up implementing red/black tree try just these: Search and insertion functions, skipping delete I want to learn more about B-Tree since it\u0026rsquo;s used so widely with very large data sets\nSelf-balancing binary search tree\nAVL trees\nIn practice: From what I can tell, these aren\u0026rsquo;t used much in practice, but I could see where they would be: The AVL tree is another structure supporting O(log n) search, insertion, and removal. It is more rigidly balanced than red–black trees, leading to slower insertion and removal but faster retrieval. This makes it attractive for data structures that may be built once and loaded without reconstruction, such as language dictionaries (or program dictionaries, such as the opcodes of an assembler or interpreter) MIT AVL Trees / AVL Sort (video) AVL Trees (video) AVL Tree Implementation (video) Split And Merge Splay trees\nIn practice: Splay trees are typically used in the implementation of caches, memory allocators, routers, garbage collectors, data compression, ropes (replacement of string used for long text strings), in Windows NT (in the virtual memory, networking and file system code) etc CS 61B: Splay Trees (video) MIT Lecture: Splay Trees: Gets very mathy, but watch the last 10 minutes for sure. Video Red/black trees\nThese are a translation of a 2-3 tree (see below). In practice: Red–black trees offer worst-case guarantees for insertion time, deletion time, and search time. Not only does this make them valuable in time-sensitive applications such as real-time applications, but it makes them valuable building blocks in other data structures which provide worst-case guarantees; for example, many data structures used in computational geometry can be based on red–black trees, and the Completely Fair Scheduler used in current Linux kernels uses red–black trees. In the version 8 of Java, the Collection HashMap has been modified such that instead of using a LinkedList to store identical elements with poor hashcodes, a Red-Black tree is used Aduni - Algorithms - Lecture 4 (link jumps to starting point) (video) Aduni - Algorithms - Lecture 5 (video) Red-Black Tree An Introduction To Binary Search And Red Black Tree 2-3 search trees\nIn practice: 2-3 trees have faster inserts at the expense of slower searches (since height is more compared to AVL trees). You would use 2-3 tree very rarely because its implementation involves different types of nodes. Instead, people use Red Black trees. 23-Tree Intuition and Definition (video) Binary View of 23-Tree 2-3 Trees (student recitation) (video) 2-3-4 Trees (aka 2-4 trees)\nIn practice: For every 2-4 tree, there are corresponding red–black trees with data elements in the same order. The insertion and deletion operations on 2-4 trees are also equivalent to color-flipping and rotations in red–black trees. This makes 2-4 trees an important tool for understanding the logic behind red–black trees, and this is why many introductory algorithm texts introduce 2-4 trees just before red–black trees, even though 2-4 trees are not often used in practice. CS 61B Lecture 26: Balanced Search Trees (video) Bottom Up 234-Trees (video) Top Down 234-Trees (video) N-ary (K-ary, M-ary) trees\nnote: the N or K is the branching factor (max branches) binary trees are a 2-ary tree, with branching factor = 2 2-3 trees are 3-ary K-Ary Tree B-Trees\nFun fact: it\u0026rsquo;s a mystery, but the B could stand for Boeing, Balanced, or Bayer (co-inventor). In Practice: B-Trees are widely used in databases. Most modern filesystems use B-trees (or Variants). In addition to its use in databases, the B-tree is also used in filesystems to allow quick random access to an arbitrary block in a particular file. The basic problem is turning the file block i address into a disk block (or perhaps to a cylinder-head-sector) address B-Tree B-Tree Datastructure Introduction to B-Trees (video) B-Tree Definition and Insertion (video) B-Tree Deletion (video) MIT 6.851 - Memory Hierarchy Models (video) - covers cache-oblivious B-Trees, very interesting data structures - the first 37 minutes are very technical, may be skipped (B is block size, cache line size) k-D Trees Great for finding number of points in a rectangle or higher dimension object A good fit for k-nearest neighbors Kd Trees (video) kNN K-d tree algorithm (video) Skip lists \u0026ldquo;These are somewhat of a cult data structure\u0026rdquo; - Skiena Randomization: Skip Lists (video) For animations and a little more detail Network Flows Ford-Fulkerson in 5 minutes — Step by step example (video) Ford-Fulkerson Algorithm (video) Network Flows (video) Disjoint Sets \u0026amp; Union Find UCB 61B - Disjoint Sets; Sorting \u0026amp; selection (video) Sedgewick Algorithms - Union-Find (6 videos) Math for Fast Processing Integer Arithmetic, Karatsuba Multiplication (video) The Chinese Remainder Theorem (used in cryptography) (video) Treap Combination of a binary search tree and a heap Treap Data Structures: Treaps explained (video) Applications in set operations Linear Programming (videos) Linear Programming Finding minimum cost Finding maximum value Solve Linear Equations with Python - Simplex Algorithm Geometry, Convex hull (videos) Graph Alg. IV: Intro to geometric algorithms - Lecture 9 Geometric Algorithms: Graham \u0026amp; Jarvis - Lecture 10 Divide \u0026amp; Conquer: Convex Hull, Median Finding Discrete math Computer Science 70, 001 - Spring 2015 - Discrete Mathematics and Probability Theory Discrete Mathematics by Shai Simonson (19 videos) Discrete Mathematics By IIT Ropar NPTEL Machine Learning Why ML? How Google Is Remaking Itself As A Machine Learning First Company Large-Scale Deep Learning for Intelligent Computer Systems (video) Deep Learning and Understandability versus Software Engineering and Verification by Peter Norvig Google\u0026rsquo;s Cloud Machine learning tools (video) Google Developers\u0026rsquo; Machine Learning Recipes (Scikit Learn \u0026amp; Tensorflow) (video) Tensorflow (video) Tensorflow Tutorials Practical Guide to implementing Neural Networks in Python (using Theano) Courses: Great starter course: Machine Learning - videos only - see videos 12-18 for a review of linear algebra (14 and 15 are duplicates) Neural Networks for Machine Learning Google\u0026rsquo;s Deep Learning Nanodegree Google/Kaggle Machine Learning Engineer Nanodegree Self-Driving Car Engineer Nanodegree Metis Online Course ($99 for 2 months) Resources: Books: Python Machine Learning Data Science from Scratch: First Principles with Python Introduction to Machine Learning with Python Machine Learning for Software Engineers Data School: http://www.dataschool.io/ Additional Detail on Some Subjects I added these to reinforce some ideas already presented above, but didn't want to include them above because it's just too much. It's easy to overdo it on a subject. You want to get hired in this century, right? SOLID\nBob Martin SOLID Principles of Object Oriented and Agile Design (video) S - Single Responsibility Principle | Single responsibility to each Object more flavor O - Open/Closed Principle | On production level Objects are ready for extension but not for modification more flavor L - Liskov Substitution Principle | Base Class and Derived class follow ‘IS A’ Principle more flavor I - Interface segregation principle | clients should not be forced to implement interfaces they don\u0026rsquo;t use Interface Segregation Principle in 5 minutes (video) more flavor D -Dependency Inversion principle | Reduce the dependency In composition of objects. Why Is The Dependency Inversion Principle And Why Is It Important more flavor Union-Find\nOverview Naive Implementation Trees Union By Rank Path Compression Analysis Options More Dynamic Programming (videos)\n6.006: Dynamic Programming I: Fibonacci, Shortest Paths 6.006: Dynamic Programming II: Text Justification, Blackjack 6.006: DP III: Parenthesization, Edit Distance, Knapsack 6.006: DP IV: Guitar Fingering, Tetris, Super Mario Bros. 6.046: Dynamic Programming \u0026amp; Advanced DP 6.046: Dynamic Programming: All-Pairs Shortest Paths 6.046: Dynamic Programming (student recitation) Advanced Graph Processing (videos)\nSynchronous Distributed Algorithms: Symmetry-Breaking. Shortest-Paths Spanning Trees Asynchronous Distributed Algorithms: Shortest-Paths Spanning Trees MIT Probability (mathy, and go slowly, which is good for mathy things) (videos):\nMIT 6.042J - Probability Introduction MIT 6.042J - Conditional Probability MIT 6.042J - Independence MIT 6.042J - Random Variables MIT 6.042J - Expectation I MIT 6.042J - Expectation II MIT 6.042J - Large Deviations MIT 6.042J - Random Walks Simonson: Approximation Algorithms (video)\nString Matching\nRabin-Karp (videos): Rabin Karps Algorithm Precomputing Optimization: Implementation and Analysis Table Doubling, Karp-Rabin Rolling Hashes, Amortized Analysis Knuth-Morris-Pratt (KMP): TThe Knuth-Morris-Pratt (KMP) String Matching Algorithm Boyer–Moore string search algorithm Boyer-Moore String Search Algorithm Advanced String Searching Boyer-Moore-Horspool Algorithms (video) Coursera: Algorithms on Strings starts off great, but by the time it gets past KMP it gets more complicated than it needs to be nice explanation of tries can be skipped Sorting\nStanford lectures on sorting: Lecture 15 | Programming Abstractions (video) Lecture 16 | Programming Abstractions (video) Shai Simonson, Aduni.org: Algorithms - Sorting - Lecture 2 (video) Algorithms - Sorting II - Lecture 3 (video) Steven Skiena lectures on sorting: lecture begins at 26:46 (video) lecture begins at 27:40 (video) lecture begins at 35:00 (video) lecture begins at 23:50 (video) Video Series Sit back and enjoy.\nList of individual Dynamic Programming problems (each is short)\nx86 Architecture, Assembly, Applications (11 videos)\nMIT 18.06 Linear Algebra, Spring 2005 (35 videos)\nExcellent - MIT Calculus Revisited: Single Variable Calculus\nCSE373 - Analysis of Algorithms (25 videos)\nSkiena lectures from Algorithm Design Manual UC Berkeley 61B (Spring 2014): Data Structures (25 videos)\nUC Berkeley 61B (Fall 2006): Data Structures (39 videos)\nUC Berkeley 61C: Machine Structures (26 videos)\nOOSE: Software Dev Using UML and Java (21 videos)\nUC Berkeley CS 152: Computer Architecture and Engineering (20 videos)\nMIT 6.004: Computation Structures (49 videos)\nCarnegie Mellon - Computer Architecture Lectures (39 videos)\nMIT 6.006: Intro to Algorithms (47 videos)\nMIT 6.033: Computer System Engineering (22 videos)\nMIT 6.034 Artificial Intelligence, Fall 2010 (30 videos)\nMIT 6.042J: Mathematics for Computer Science, Fall 2010 (25 videos)\nMIT 6.046: Design and Analysis of Algorithms (34 videos)\nMIT 6.050J: Information and Entropy, Spring 2008 (19 videos)\nMIT 6.824: Distributed Systems, Spring 2020 (20 videos)\nMIT 6.851: Advanced Data Structures (22 videos)\nMIT 6.854: Advanced Algorithms, Spring 2016 (24 videos)\nHarvard COMPSCI 224: Advanced Algorithms (25 videos)\nMIT 6.858 Computer Systems Security, Fall 2014\nStanford: Programming Paradigms (27 videos)\nIntroduction to Cryptography by Christof Paar\nCourse Website along with Slides and Problem Sets Mining Massive Datasets - Stanford University (94 videos)\nGraph Theory by Sarada Herke (67 videos)\nComputer Science Courses Directory of Online CS Courses Directory of CS Courses (many with online lectures) Algorithms implementation Multiple Algorithms implementation by Princeton University Papers Love classic papers? 1978: Communicating Sequential Processes implemented in Go 2003: The Google File System replaced by Colossus in 2012 2004: MapReduce: Simplified Data Processing on Large Clusters mostly replaced by Cloud Dataflow? 2006: Bigtable: A Distributed Storage System for Structured Data 2006: The Chubby Lock Service for Loosely-Coupled Distributed Systems 2007: Dynamo: Amazon’s Highly Available Key-value Store The Dynamo paper kicked off the NoSQL revolution 2007: What Every Programmer Should Know About Memory (very long, and the author encourages skipping of some sections) 2012: AddressSanitizer: A Fast Address Sanity Checker: paper video 2013: Spanner: Google’s Globally-Distributed Database: paper video 2014: Machine Learning: The High-Interest Credit Card of Technical Debt 2015: Continuous Pipelines at Google 2015: High-Availability at Massive Scale: Building Google’s Data Infrastructure for Ads 2015: TensorFlow: Large-Scale Machine Learning on Heterogeneous Distributed Systems 2015: How Developers Search for Code: A Case Study More papers: 1,000 papers LICENSE CC-BY-SA-4.0\n","permalink":"http://intervalrain.github.io/posts/washam/","summary":"Coding Interview University John Washam:\nI originally created this as a short to-do list of study topics for becoming a software engineer, but it grew to the large list you see today. After going through this study plan, I got hired as a Software Development Engineer at Amazon! You probably won\u0026rsquo;t have to study as much as I did. Anyway, everything you need is here.\nI studied about 8-12 hours a day, for several months.","title":"[Washam] Way to SWE"},{"content":"\u003c!DOCTYPE HTML\u003e 詞曲：胡鎮宇\n你生活的　都踏踏實實地過了\n把曾經走過的路全都擺在記憶了\n那憂鬱悲傷快樂歡笑都記得\n記在腦海了\n你熟悉的　該輕輕鬆鬆地放了\n把人生未來的路全都拿在手裡了\n那曾經有過的與曾經失去的\n都成回憶了\n而我將洋洋灑灑邁開步伐地走了\n將四年的青春塗上另一種顏色\n而我還是無法自拔矯情卻又無法割捨\n回想自己的夢　去成就另一種快樂\n","permalink":"http://intervalrain.github.io/posts/music/about_future/","summary":"\u003c!DOCTYPE HTML\u003e 詞曲：胡鎮宇\n你生活的　都踏踏實實地過了\n把曾經走過的路全都擺在記憶了\n那憂鬱悲傷快樂歡笑都記得\n記在腦海了\n你熟悉的　該輕輕鬆鬆地放了\n把人生未來的路全都拿在手裡了\n那曾經有過的與曾經失去的\n都成回憶了\n而我將洋洋灑灑邁開步伐地走了\n將四年的青春塗上另一種顏色\n而我還是無法自拔矯情卻又無法割捨\n回想自己的夢　去成就另一種快樂","title":"[創作] 關於未來"},{"content":"rand() 函數 在 C/C++ 中可以使用 rand() 這個函數，產生最簡單的亂數： 需引用 \u0026lt;stdlib.h\u0026gt; 函式庫 在呼叫 rand() 前需要先使用srand()設定初始的亂數種子，增加「亂度」。(實際上產生的亂數是有規則的，以示例為例，是以時間做為種子，故是有可能被預測的) 其產生的亂數是一個介於 0 到 RAND_MAX(INT_MAX)的整數。 C 與 C++ 幾乎一樣，只差在表頭檔的使用。 C-style #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main(){ srand(time(NULL)); // random seed int x = rand(); printf(\u0026#34;x = %d\\n\u0026#34;, x); return 0; } Cpp-style #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); int x = rand(); cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;x is between 0 and \u0026#34; \u0026lt;\u0026lt; RAND_MAX \u0026lt;\u0026lt; endl; return 0; } 亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。 上例中使用的亂數種子是時間，因為時間每分每秒都在變化，所以每次產生的亂數都會不同，如果是用於數值模擬的話， 固定亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。若是做數值模擬的話，通常會讓模擬結果具有可重復性(repeatability)，方便除錯與驗證，這種狀況就可以將亂數種子固定不變，以確保每次的結果都相同。 [0, 1) 浮點數亂數 [0, 1) 代表 0 \u0026lt;= x \u0026lt; 1 若要產生 0 到 1 之間的浮點數亂數，可以這樣寫： #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); double x = (double)rand()/(RAND_MAX + 1.0); cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } [a, b)特定範圍浮點數亂數 [a, b) 表 a \u0026lt;= x \u0026lt; b #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); double x = (double)rand()/(RAND_MAX + 1.0); cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } [a, b)特定範圍整數亂數 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); int a = 1; // min int b = 100; // max int x = rand() % (b - a + 1) + a; cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } 上面這種使用餘數運算（%）的方式只是比較方便的寫法，事實上使用餘數運算所產生的整數亂數在理論上不是標準的均勻分布。\n我們以一個簡單的例子來解釋，假設 RAND_MAX 的值為 10，而我們要產生介於 3 到 5 之間的整數亂數（亦即 min = 3、max = 5），以下是所有的可能性對照表：\n\\(\\def\\arraystretch{1.4}\\begin{array}{c|l|c} 轉換後的整數亂數\u0026amp;\\text{rand()}函數產生的亂數\u0026amp;出現機率\\\\\\hline 3\u0026amp;0,3,6,9\u0026amp;4/11\\\\\\hline 4\u0026amp;1,4,7,10\u0026amp;4/11\\\\\\hline 5\u0026amp;2,5,8\u0026amp;3/11 \\end{array}\\) rand() 函數所產生的每一個整數其出現的機率是均等的，但是經過於數運算的轉換之後，因為 RAND_MAX 通常不會被整除，所以轉換之後的整數亂數出現機率就存在有細微的偏差，以這個例子來說，3、4、5 三個數字出現的機率比是 4:4:3。\n另外有些人會先產生固定範圍的浮點數亂數，再將浮點數轉型為整數，例如產生 [3, 6) 的浮點數亂數，然後轉型為 [3, 5] 的整數亂數，其實這種方式跟餘數運算一樣會有每個整數出現機率不均等的問題，簡單來說就是現在有 11 個球要放進 3 個籃子裡，不管怎麼放，每個籃子的球都不可能一樣多。\n均勻分布亂數(uniform distribution) #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int randint(int n){ if ((n - 1) == RAND_MAX) return rand(); long end = RAND_MAX / n; assert (end \u0026gt; 0L); end *= n; int r; while ((r = rand()) \u0026gt;= end); return r % n; } int main(){ int x = randint(5); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } 使用 randint 函數產生特定範圍整數亂數： int x = randint(max - min + 1) + min; 這種作法就好像要把 11 個球要放進 3 個籃子裡，而最後多出來的 2 顆球就直接丟掉，確保每個籃子都一樣只有 3 顆，這樣大家的機率就可以相等了。\n這種使用截斷分布（truncated distribution）來校正機率的方式雖然在理論上是正確的，但是 rand 函數是使用 LCG（Linear Congruential Generator）來產生亂數的，他的優點只是快速、方便而已，但它本身所產生的亂數品質沒有非常好，再怎麼校正效果都有限，若需要高品質的亂數，請改用 C++11 標準的 函式庫。\n","permalink":"http://intervalrain.github.io/posts/c++/random/","summary":"rand() 函數 在 C/C++ 中可以使用 rand() 這個函數，產生最簡單的亂數： 需引用 \u0026lt;stdlib.h\u0026gt; 函式庫 在呼叫 rand() 前需要先使用srand()設定初始的亂數種子，增加「亂度」。(實際上產生的亂數是有規則的，以示例為例，是以時間做為種子，故是有可能被預測的) 其產生的亂數是一個介於 0 到 RAND_MAX(INT_MAX)的整數。 C 與 C++ 幾乎一樣，只差在表頭檔的使用。 C-style #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main(){ srand(time(NULL)); // random seed int x = rand(); printf(\u0026#34;x = %d\\n\u0026#34;, x); return 0; } Cpp-style #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); int x = rand(); cout \u0026lt;\u0026lt; \u0026#34;x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;x is between 0 and \u0026#34; \u0026lt;\u0026lt; RAND_MAX \u0026lt;\u0026lt; endl; return 0; } 亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。 上例中使用的亂數種子是時間，因為時間每分每秒都在變化，所以每次產生的亂數都會不同，如果是用於數值模擬的話， 固定亂數種子 由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。若是做數值模擬的話，通常會讓模擬結果具有可重復性(repeatability)，方便除錯與驗證，這種狀況就可以將亂數種子固定不變，以確保每次的結果都相同。 [0, 1) 浮點數亂數 [0, 1) 代表 0 \u0026lt;= x \u0026lt; 1 若要產生 0 到 1 之間的浮點數亂數，可以這樣寫： #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main(){ srand(time(NULL)); double x = (double)rand()/(RAND_MAX + 1.","title":"[C++] 如何產生 random 值"}]