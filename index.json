[{"content":"cout Functions 設定顯示小數點位數  setprecision(int n) and fixed  #include \u0026lt;iostream\u0026gt;#include \u0026lt;iomanip\u0026gt; using namespace std;  int main(){   double a = 5.43/2.653;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.04674  cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; fixed;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.047   return 0; } 顯示 Boolean 值  std::boolalpha  #include \u0026lt;iostream\u0026gt; using namespace std;  int main(){   bool a = true;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 1  cout \u0026lt;\u0026lt; std::boolalpha;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // true   return 0; } ","permalink":"http://intervalrain.github.io/posts/c++/cout/","summary":"cout Functions 設定顯示小數點位數  setprecision(int n) and fixed  #include \u0026lt;iostream\u0026gt;#include \u0026lt;iomanip\u0026gt; using namespace std;  int main(){   double a = 5.43/2.653;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.04674  cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; fixed;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 2.047   return 0; } 顯示 Boolean 值  std::boolalpha  #include \u0026lt;iostream\u0026gt; using namespace std;  int main(){   bool a = true;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 1  cout \u0026lt;\u0026lt; std::boolalpha;  cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // true   return 0; } ","title":"[C++] Cout functions"},{"content":"STL  \u0008標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。\nSTL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。\n STL 的四大組成 演算法(Algorithms) Non-Manupulating Algorithms  sort(first_iterator, last_iterator): 對 vector 作排序 reverse(first_iterator, last_iterator): 反轉 vector 的排序 *max_element(first_iterator, last_iterator): 找出 vector 的最大值 *min_element(first_iterator, last_iterator): 找出 vector 的最小值 accumulate(first_iterator, last_iterator, initial value of sum): 計算 vector 的總和  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;numeric\u0026gt; using namespace std;  void print(vector\u0026lt;int\u0026gt;\u0026amp; vec){  for (vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it != vec.end(); it++){  cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  }  cout \u0026lt;\u0026lt; endl; }  int main(){  int arr[] = {10, 20, 5, 23, 42, 15};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n);   // print initial vector  print(vec); // [10, 20, 5, 23, 42, 15]   // sort  sort(vec.begin(), vec.end()); // [5, 10, 15, 20, 23, 42]  print(vec);   // reverse  reverse(vec.begin(), vec.end()); // [42, 23, 20, 15, 10, 5]  print(vec);   // max \u0026amp; min  cout \u0026lt;\u0026lt; *max_element(vec.begin(), vec.end()) \u0026lt;\u0026lt; endl; // 42  cout \u0026lt;\u0026lt; *min_element(vec.begin(), vec.end()) \u0026lt;\u0026lt; endl; // 5   // accumulate  cout \u0026lt;\u0026lt; accumulate(vec.begin(), vec.end(), 0) \u0026lt;\u0026lt; endl; // 115   return 0; } count(first_iterator, last_iterator, x): 計算 vector 中 x 的數量 find(fist_iterator, last_iterator, x): 回傳 vector 中第一個符合的 iterator，若無則傳回 v.end()。  #include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main() { \tint arr[] = {10, 20, 5, 23 ,42, 20, 15}; \tint n = sizeof(arr)/sizeof(arr[0]); \tvector\u0026lt;int\u0026gt; vec(arr, arr + n); \tcout \u0026lt;\u0026lt; count(vec.begin(), vec.end(), 20); // 2  \tfind(vec.begin(), vec.end(),5) != vec.end() ? // Element found \tcout \u0026lt;\u0026lt; \u0026#34;\\nElement found\u0026#34;: \tcout \u0026lt;\u0026lt; \u0026#34;\\nElement not found\u0026#34;;  \treturn 0; } binary_search(first_iterator, last_iterator, x): 測試 x 是否存在已排序的 vector 中 lower_bound(first_iterator, last_iterator, x): 傳回指向不小於 x 的元素的 iterator upper_bound(first_iterator, last_iterator, x): 傳回指向大於 x 的元素的 iterator  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main(){  int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n);  sort(vec.begin(), vec.end());   cout \u0026lt;\u0026lt; binary_search(vec.begin(), vec.end(), 20) \u0026lt;\u0026lt; endl; // 1  cout \u0026lt;\u0026lt; (lower_bound(vec.begin(), vec.end(), 20) - vec.begin()) \u0026lt;\u0026lt; endl; // 3  cout \u0026lt;\u0026lt; (upper_bound(vec.begin(), vec.end(), 20) - vec.begin()) \u0026lt;\u0026lt; endl; // 5   return 0; } Manipulating Algorithms  arr.erase(position_to_be_deleted): 移除指定位置的元素 arr.erase(unique(arr.begin(), arr.end()), arr.end()): 移除已排序的 vector 中重複的元素  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main(){  int arr[] = {5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n); // [5, 10, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20]   vec.erase(vec.begin() + 1); // [5, 15, 20, 20, 23, 42, 45, 20, 20, 20, 20, 20]  sort(vec.begin(), vec.end()); // [5, 15, 20, 20, 20, 20, 20, 20, 20, 23, 42, 45]  vec.erase(unique(vec.begin(), vec.end()), vec.end()); // [5, 15, 20, 23, 42, 45]   return 0; } next_permutation(first_iterator, last_iterator): 對 vector 作動成下一個字典排序 prev_permutation(first_iterator, last_iterator): 對 vector 作動成上一個字典排序  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main(){  int arr[] = {1,2,3,4,5,6,7};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n); // [1,2,3,4,5,6,7]   next_permutation(vec.begin(), vec.end()); // [1,2,3,4,5,7,6]  next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,5,7]  next_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5]  next_permutation(vec.begin(), vec.end()); // [1,2,3,4,7,5,6]  prev_permutation(vec.begin(), vec.end()); // [1,2,3,4,6,7,5]   return 0; } distance(first_iterator, last_iterator):  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026#34;print.cc\u0026#34; using namespace std;  int main(){  int arr[] = {5\u0008,10,15,20,20,23,42,45};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n);   cout \u0026lt;\u0026lt; distance(vec.begin(), max_element(vec.begin(), vec.end())) \u0026lt;\u0026lt; endl; // 7   return 0; } Array algorithms  any_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; all(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false; none_of(first_iterator, last_iterator, [](passing_value { return statement; })) ? if_true : if_false;  #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std;  int main(){  vector\u0026lt;int\u0026gt; vec1 {1,3,7,9,11,17,23};  all_of(vec1.begin(), vec1.end(), [](int x) { return (x \u0026amp; 1) == 1;}) ? cout \u0026lt;\u0026lt; \u0026#34;All odds\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;Not all odds\\n\u0026#34;;   vector\u0026lt;int\u0026gt; vec2 {1,3,6,8,9,11,13};  any_of(vec2.begin(), vec2.end(), [](int x) { return (x \u0026amp; 1) == 0;}) ? cout \u0026lt;\u0026lt; \u0026#34;There are at least one even\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;There are no any even\\n\u0026#34;;   none_of(vec1.begin(), vec1.end(), [](int x) { return (x \u0026amp; 1) == 0;}) ? cout \u0026lt;\u0026lt; \u0026#34;There are no any even\\n\u0026#34; : cout \u0026lt;\u0026lt; \u0026#34;There are at least one even\\n\u0026#34;;   return 0; } copy_n(source_array, array_size, target_array)  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std;  int main(){  int arr[] = {1,2,3,4,5,6};  int arr2[6];   copy_n(arr, 6, arr2);   for (int i : arr2){  cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  }   return 0; } iota(array_name, array_size, starting_number)  Partition operations Numeric algorithms 容器(Containers) Sequence Containers vector list deque arrays forward_list(C++11) Container Adaptors queue priority_queue stack Associative Containers set multiset map mutlimap Unordered Associative Containers unordered_set(C++11) unordered_multiset(C++11) unordered_map(C++11) unordered_multimap(C++11) 函式(Functions) Functors 迭代器(Iterators) Iterators Utility Library pair ","permalink":"http://intervalrain.github.io/posts/c++/stl/","summary":"STL  \u0008標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。\nSTL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。\n STL 的四大組成 演算法(Algorithms) Non-Manupulating Algorithms  sort(first_iterator, last_iterator): 對 vector 作排序 reverse(first_iterator, last_iterator): 反轉 vector 的排序 *max_element(first_iterator, last_iterator): 找出 vector 的最大值 *min_element(first_iterator, last_iterator): 找出 vector 的最小值 accumulate(first_iterator, last_iterator, initial value of sum): 計算 vector 的總和  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;numeric\u0026gt; using namespace std;  void print(vector\u0026lt;int\u0026gt;\u0026amp; vec){  for (vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it != vec.end(); it++){  cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  }  cout \u0026lt;\u0026lt; endl; }  int main(){  int arr[] = {10, 20, 5, 23, 42, 15};  int n = sizeof(arr)/sizeof(arr[0]);  vector\u0026lt;int\u0026gt; vec(arr, arr + n);   // print initial vector  print(vec); // [10, 20, 5, 23, 42, 15]   // sort  sort(vec.","title":"[C++] The C++ Standard Template Library(STL)"},{"content":"vector 的介紹  vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include \u0026lt;vector\u0026gt;  vector 的使用 建構式 constructor vector\u0026lt;int\u0026gt; v1; // 不進行初始化 vector\u0026lt;int\u0026gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector\u0026lt;int\u0026gt; v3(v2); // 利用vector初始化 vector\u0026lt;int\u0026gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector\u0026lt;int\u0026gt; v5(3, 0); // 含有3個0的vector  談一下特殊的二維vector，其實就是二維矩陣，寫法為  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vv(3, vector\u0026lt;int\u0026gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse  遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。  vector\u0026lt;int\u0026gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3};  // 1. iterator vector\u0026lt;int\u0026gt;::iterator it = v.begin(); while (it != v.end()){  cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  it++; } cout \u0026lt;\u0026lt; endl;  // 2. for loop for (int e : v){  cout \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; }  // 3. [] for (size_t i = 0; i \u0026lt; v.size(); ++i){  cout \u0026lt;\u0026lt; v[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } 資料的資刪查改 \\( \\def\\arraystrecth{1.4}\\begin{array}{|l|l|}\\hline \\text{methods}\u0026amp;\\text{description}\\\\\\hline\\hline \\text{push\\_back}\u0026amp;\\text{Add element at the end}\\\\\\hline \\text{pop\\_back}\u0026amp;\\text{Delete last element}\\\\\\hline \\text{insert}\u0026amp;\\text{Insert elements}\\\\\\hline \\text{erase}\u0026amp;\\text{Erase elements}\\\\\\hline \\end{array} \\)\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std;  int main(){  vector\u0026lt;int\u0026gt; vec;  vec.push_back(0); [0]  vec.push_back(1); [0,1]  vec.push_back(3); [0,1,3]  vec.push_back(4); [0,1,3,4]  vec.pop_back(); [0,1,3]  vector\u0026lt;int\u0026gt;::iterator it = vec.begin();  vec.insert(it + 2, 2); // 在下標為1的位置，插入2 [0,1,2,3]  vec.erase(it); [1,2,3]   return 0; } resize 和 reserve int main(){  cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 0  cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 0  v.resize(30);  cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30  cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30  v.reservse(50);  cout \u0026lt;\u0026lt; \u0026#34;size: \u0026#34; \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 30  cout \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; v.capacity()() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 50 } vector 的實作 member variables template \u0026lt;class T\u0026gt; class myVector{ private:  size_t _size; // 儲存現有 elements 的數目  size_t _capacity; // 此時陣列所有的最大容量 public:  T* arr; // 儲存 elements 的陣列指標 }; 建構式 constructor public:  // 無引數的初始化  myVector(){  this-\u0026gt;_size = 0;  this-\u0026gt;_capacity = DEFAULT_CAPACITY;  this-\u0026gt;arr = new int[this-\u0026gt;_capacity];  }   // 指定容量的初始化  myVector(int capacity){  this-\u0026gt;_size = 0;  this-\u0026gt;_capacity = capacity;  this-\u0026gt;arr = new int[this-\u0026gt;capacity];  }   // 以另一個 myVector 初始化  myVector(const myVector\u0026lt;T\u0026gt;\u0026amp; v):  _size(v.size),  _capacity(v._capacity)  {  this-\u0026gt;reserve(v.capacity);  for (size_t i = 0; i \u0026lt; v._size; ++i){  this-\u0026gt;push_back(v[i]);  }  }   // 填滿 n 個 val 的初始化  myVector(size_t n, T val):  _size(n),  _capacity(n)  {  this-\u0026gt;arr = new int[this-\u0026gt;_capacity];  for (size_t i = 0; i \u0026lt; n; ++i){  this-\u0026gt;arr[i] = val;  }  } 解構式 destructor public:  ~myVector(){  // 將原有的陣列丟棄  delete[] this-\u0026gt;arr;  } 運算子多載 operator overload public:  // 令 myVector 可讀可寫  T\u0026amp; operator[](size_t i){  assert (i \u0026lt; this-\u0026gt;_size);  return this-\u0026gt;arr[i];  } 函式 Methods public:  // 回傳 vector 元素的數目  size_t size(){  return this-\u0026gt;_size;  }   // 回傳當前 vector 的容量  size_t capacity(){  return this-\u0026gt;_capacity;  }   // 回傳指向陣列的下標 0 位置  T* begin(){  return this-\u0026gt;arr;  }   // 回傳指向陣列的最末位 + 1  T* end(){  return this-\u0026gt;arr + this-\u0026gt;_size;  }   const T* begin() const{  return this-\u0026gt;arr;  }   const T* end() const{  return this-\u0026gt;arr + this-\u0026gt;_size;  }   // 回傳此 myVector 是否含有元素  bool isEmpty(){  return this-\u0026gt;_size == 0;  } reserve 和 resize public:  // force to resize with a n capacity  void reserve(size_t n){  if (n \u0026gt; this-\u0026gt;_capacity){  T* tmp = new T[n];  if (arr != nullptr){  for (size_t i = 0; i \u0026lt; this-\u0026gt;_size; ++i){  tmp[i] = this-\u0026gt;arr[i];  }  delete[] this-\u0026gt;arr;  }  this-\u0026gt;arr = tmp;  _capacity = n;  }  }   // expand the capacity while adding elements  void resize(){  this-\u0026gt;_capacity *= 2;  int* tmp = new int[this-\u0026gt;_capacity];  for (size_t i = 0; i \u0026lt; this-\u0026gt;_size; ++i){  tmp[i] = this-\u0026gt;arr[i];  }  delete[] this-\u0026gt;arr;  this-\u0026gt;arr = tmp;  } 資料的增刪查改 public:   // adding elements in the last of vector  void push_back(T val){  if (this-\u0026gt;_capacity \u0026lt; this-\u0026gt;_size + 1)  resize();  this-\u0026gt;arr[this-\u0026gt;_size] = val;  this-\u0026gt;_size++;  }   // remove elements in the last of vector  T pop_back(){  assert(!this-\u0026gt;isEmpty());  T tmp = *(this-\u0026gt;end()-1);  this-\u0026gt;_size--;  return tmp;  }   // insert element by the index.  void insert(size_t i, T val){  assert (i \u0026lt;= this-\u0026gt;_size);  if (this-\u0026gt;_size + 1 \u0026gt; this-\u0026gt;capacity()) resize();  int* ptr = this-\u0026gt;begin() + i;  for (int* it = this-\u0026gt;end(); it != ptr; --it)  *it = *(it - 1);  *ptr = val;  this-\u0026gt;_size++;  }   //erase element by the index  T erase(size_t i){  assert(i \u0026lt; this-\u0026gt;_size);  int* it = this-\u0026gt;begin() + i;  T tmp = *it;  for (; it != this-\u0026gt;end(); ++it){  *it = *(it + 1);  }  this-\u0026gt;_size--;  return tmp;  } Reference: 有解無憂 UJ5U.com\n","permalink":"http://intervalrain.github.io/posts/c++/vector/","summary":"vector 的介紹  vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include \u0026lt;vector\u0026gt;  vector 的使用 建構式 constructor vector\u0026lt;int\u0026gt; v1; // 不進行初始化 vector\u0026lt;int\u0026gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector\u0026lt;int\u0026gt; v3(v2); // 利用vector初始化 vector\u0026lt;int\u0026gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector\u0026lt;int\u0026gt; v5(3, 0); // 含有3個0的vector  談一下特殊的二維vector，其實就是二維矩陣，寫法為  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vv(3, vector\u0026lt;int\u0026gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse  遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。  vector\u0026lt;int\u0026gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3};  // 1.","title":"[C++] STL: Vector 的使用與實作"},{"content":"TCAD 常用的三種程式語言 工具語言  用於操作 Sentaurus 工具的指令，例如：  snmesh sdevice    預處理語言  Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro)  例如：  #define __x__ 1 // 將所有 __x__ 字串取代成字串 1   TCL  公用語言，通常用來處理字串與數據。  範例  SPP 語言：@...@、#開頭的敘述都是 SPP 語言  #if \u0026#34;@tunneling@ == \u0026#34;Hurkx\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1_5\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E2\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif  TCL 語言：set 與 puts  其中 @\u0026hellip;@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 .cmd 檔。    set A [expr -@BF_Thick@-@AB_Thick@-@GR_Thick@-@CH_Thick@-@ML_Thick@] puts \u0026#34;DOE: Xmin [format %.2f $A]\u0026#34; ","permalink":"http://intervalrain.github.io/posts/device/tcad/","summary":"TCAD 常用的三種程式語言 工具語言  用於操作 Sentaurus 工具的指令，例如：  snmesh sdevice    預處理語言  Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro)  例如：  #define __x__ 1 // 將所有 __x__ 字串取代成字串 1   TCL  公用語言，通常用來處理字串與數據。  範例  SPP 語言：@...@、#開頭的敘述都是 SPP 語言  #if \u0026#34;@tunneling@ == \u0026#34;Hurkx\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E1_5\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif \u0026#34;@tunneling@ == \u0026#34;E2\u0026#34; #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif  TCL 語言：set 與 puts  其中 @\u0026hellip;@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 .","title":"[TCAD] 工具語言"},{"content":"計算機的抽象化與科技 電腦的定義  一種可以進行計算的裝置，特指可編程(programmable) 且可執行高速的數學或邏輯的運算，或可收集、儲存、處理資料的電子器械。  一般用途 or 特別用途 可編程 or 不可編程 科學用 or 商務 機械械 or 電子式 or 電機 \u0026hellip;  Instruction 與 data 分開儲存的結構稱為 哈佛架構Harvard Architecture\u0008      電腦的歷史  ENIAC (Electronic Numberical Integrator and Calculator)  1943 - 1946 at the University of Pennsylvania 約 25 公尺長、2.5 公尺高 由真空管製成: 耗能、易燒壞KJKKI 1900個加法/每秒   商業化、電晶體的發現 in 1947 使用電晶體的電腦 (IBM 14001, Big Blue) in 1959 IC(Integrated Circuit) in 1958 at 德儀 微處理器(Intel 4004) in 1971 Apple II in 1977 個人電腦(IBM PC) in 1981 IBM 開放式系統(open system)使得周邊設備大量的發展  Xerox PARC Alto: 具備滑鼠、以太網路、點陣圖、按鍵、菜單、WYSIWYG編輯器 區域網路 雷射列印 client / server 分散式計算   應用程式  VisiCalc for Applie II in 1979   超大型積體電路 VLSI(Very-Large-Scale Integration) RISC(Reduced Instruction Set Computer) 的出現，對應於 CISC(Complex Instruction Set Computer)  RISC: MIPS CISC: Intel x86 processor   Post PC Era: Embedded Computer  冰箱、手機、手錶…    電腦的發展  應用  行動電腦 手機 人類基因體計畫 世界網路 搜尋引擎   摩爾定律 Moore\u0026rsquo;s Law  Line Width/Feature Size: 電晶體的 Source 與 Drain 的距離，約是 gate length。     電腦的分類  通用電腦  特性：  軟體相容性 產品生命週期短 更好的效能(more transistors)與人機介面   個人電腦 Personal Computers  一般用途、軟體多樣性 取決於成本與效能的權衡   伺服器電腦 Server Computers  基於網路的 高容量、效能、可靠度 範圍可小至伺服，大至建築   超級電腦 Supercomputers  高端的科學與工程計算 最高的效能，但小的市佔     特殊用途電腦  特性：  通常沒有浮點數、記憶體管理 會與各種功能的外部裝置(peripherals)協作 e.g. DSP  多元的 ISA、效能、外部裝置 較不需考量相容性(通常是 pre-determined program)，ISA更簡單、低功耗   更多元的結構、生命週期更長 高產低銷 (Large volume sale and low price) 趨勢：低成本、更多功  SoC(system-on-chip)、micro P core on ASIC     嵌入式電腦 Embedded Computers  隱身在系統中 嚴格的功耗、效能、成本考量        ","permalink":"http://intervalrain.github.io/posts/ca/lec1/","summary":"計算機的抽象化與科技 電腦的定義  一種可以進行計算的裝置，特指可編程(programmable) 且可執行高速的數學或邏輯的運算，或可收集、儲存、處理資料的電子器械。  一般用途 or 特別用途 可編程 or 不可編程 科學用 or 商務 機械械 or 電子式 or 電機 \u0026hellip;  Instruction 與 data 分開儲存的結構稱為 哈佛架構Harvard Architecture\u0008      電腦的歷史  ENIAC (Electronic Numberical Integrator and Calculator)  1943 - 1946 at the University of Pennsylvania 約 25 公尺長、2.5 公尺高 由真空管製成: 耗能、易燒壞KJKKI 1900個加法/每秒   商業化、電晶體的發現 in 1947 使用電晶體的電腦 (IBM 14001, Big Blue) in 1959 IC(Integrated Circuit) in 1958 at 德儀 微處理器(Intel 4004) in 1971 Apple II in 1977 個人電腦(IBM PC) in 1981 IBM 開放式系統(open system)使得周邊設備大量的發展  Xerox PARC Alto: 具備滑鼠、以太網路、點陣圖、按鍵、菜單、WYSIWYG編輯器 區域網路 雷射列印 client / server 分散式計算   應用程式  VisiCalc for Applie II in 1979   超大型積體電路 VLSI(Very-Large-Scale Integration) RISC(Reduced Instruction Set Computer) 的出現，對應於 CISC(Complex Instruction Set Computer)  RISC: MIPS CISC: Intel x86 processor   Post PC Era: Embedded Computer  冰箱、手機、手錶…    電腦的發展  應用  行動電腦 手機 人類基因體計畫 世界網路 搜尋引擎   摩爾定律 Moore\u0026rsquo;s Law  Line Width/Feature Size: 電晶體的 Source 與 Drain 的距離，約是 gate length。     電腦的分類  通用電腦  特性：  軟體相容性 產品生命週期短 更好的效能(more transistors)與人機介面   個人電腦 Personal Computers  一般用途、軟體多樣性 取決於成本與效能的權衡   伺服器電腦 Server Computers  基於網路的 高容量、效能、可靠度 範圍可小至伺服，大至建築   超級電腦 Supercomputers  高端的科學與工程計算 最高的效能，但小的市佔     特殊用途電腦  特性：  通常沒有浮點數、記憶體管理 會與各種功能的外部裝置(peripherals)協作 e.","title":"[CA] Lec 1 - Computer Abstraction and Technology"},{"content":"計算機結構簡介 二進制  從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。  現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。   電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機  計算機結構/組織  計算機結構 Computer Architecture  處理器(processor)  Control Datapath   記憶體(memory) 裝置(Devices)  Input: 鍵盤、滑鼠、磁碟 Output: 磁碟、顯示器、影印機      計算機組織 Computer Organization(架構)  功能元件的性能: registers, ALU, shifters Structure Dataflow Control logic Register Transfer Level(RTL) description     計算機結構  Computer Architecture = Instruction Set Architecture(ISA) + Machine Organization Software 與 Hardware 間的 interface。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。  選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置   指令集Instruction Set Architecture(ISA)  可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) Instruction Set Instruction Formats 讀寫資料的模式與指令 例外狀況 e.g. Intel(CISC)、Arm(RISC)  CISC: Complex Instruction Set Computer RISC: Reduced Instruction Set Computer        [目錄]  Chapter 1. Computer Abstractions and Technology Chapter 2. Instruction Set Architecture Chapter 3. Computer Arithmetic Chapter 4. Designing a Single-Cycle Processor Chapter 5. Pipelining Chapter 6. Memory Hierarchy  ","permalink":"http://intervalrain.github.io/posts/ca/lec0/","summary":"計算機結構簡介 二進制  從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。  現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。   電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機  計算機結構/組織  計算機結構 Computer Architecture  處理器(processor)  Control Datapath   記憶體(memory) 裝置(Devices)  Input: 鍵盤、滑鼠、磁碟 Output: 磁碟、顯示器、影印機      計算機組織 Computer Organization(架構)  功能元件的性能: registers, ALU, shifters Structure Dataflow Control logic Register Transfer Level(RTL) description     計算機結構  Computer Architecture = Instruction Set Architecture(ISA) + Machine Organization Software 與 Hardware 間的 interface。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。  選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置   指令集Instruction Set Architecture(ISA)  可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) Instruction Set Instruction Formats 讀寫資料的模式與指令 例外狀況 e.","title":"[CA] Lec 0 - Introduction to Computer Architecture"},{"content":"題目 題目描述  設計一個類似 stack 的資料結構，實行 push() 跟 pop() 的功能，其中 pop() 會丟出 stack 中出現最多次的元素。 FreqStack class 必須實現：  FreqStack() 建構子必須初始化一個空的 FreqStack。 void push(int val) 將 val 推至 stack 的頂端。 int pop() 將 stack 中最頻繁出現的元素移除，並返回。  如果 stack 中最頻繁出現的元素出現平手的狀況，則返回平手的元素中最接近 stack 頂端的元素。      題目範例 輸入\n[\u0026ldquo;FreqStack\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n輸出\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n說明\nFreqStack freqStack = new FreqStack(); freqStack.push(5); // The stack is [5] freqStack.push(7); // The stack is [5,7] freqStack.push(5); // The stack is [5,7,5] freqStack.push(7); // The stack is [5,7,5,7] freqStack.push(4); // The stack is [5,7,5,7,4] freqStack.push(5); // The stack is [5,7,5,7,4,5] freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. freqStack.pop(); // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. freqStack.pop(); // return 5, as 5 is the most frequent. The stack becomes [5,7,4]. freqStack.pop(); // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]. 解題 想法  在解題時，我打算在 push 時動手腳，將 push 的元素直接 push 到對的位置後，執行 pop 的動作時，就只要將最頂端的元素取出即可。  FreqStack freqStack = new FreqStack(); freqStack.push(5); // [5] freqStack.push(7); // [5,7] freqStack.push(5); // [5,7,5] freqStack.push(7); // [5,7,5,7] freqStack.push(4); // [5,7,5,7,4] // 此時 4 因為並非最頻繁的元素，所以要將 4 往下推，即變成 [5,7,4,5,7] freqStack.push(5); // [5,7,4,5,7,5] freqStack.pop(); // return 5, [5,7,4,5,7] freqStack.pop(); // return 7, [5,7,4,5] freqStack.pop(); // return 5, [5,7,4] freqStack.pop(); // return 4, [5,7]  為了實現以上的想法，我試想將出現次數相同的元素放在同一個 stack，取出時則從頻率最高的 stack 開始取，即為：  freqStack[0] = [5,7,4] // 檢查元素是否出現在 freqStack[0] 否則則往freqStack[1] 移動 freqStack[1] = [5,7] freqStack[2] = [5] // pop 的時候，從freqStack[2] 開始取，空了則將 freqStack[2] 移除 實作1: List of Stacks public class freqStack{  // Field  List\u0026lt;Stack\u0026lt;Integer\u0026gt;\u0026gt; stacks;   // Constructor  public freqStack(){  stacks = new ArrayList\u0026lt;\u0026gt;();  }   // Methods  public void push(int val){  push(val, 0);  }   private void push(int val, int freq){  // 當 stacks[freq] 是空的時候，則新建一個 stack。  Stack\u0026lt;Integer\u0026gt; stack;  if (freq \u0026gt;= stacks.size()){  stack = new Stack\u0026lt;\u0026gt;();  stacks.add(stack);  } else {  stack = stacks.get(freq);  }  // 當該 stacks[freq] 已經有該元素，則往下一個 stacks 找  if (stack.contains(val)){  push(val, freq + 1);  } else {  stack.push(val);  }  }   public int pop(){  // 直接找到最高的 stack，然後把頂端的元素 pop 出。  Stack\u0026lt;Integer\u0026gt; stack = stacks.get(stacks.size() - 1);  int top = stack.pop();  if (stack.isEmpty()){  stacks.remove(stacks.size() - 1);  }  return top;  } }  然而，此時 push 的 \u0008complexity 與欲 push 的元素的出現次數 n 有關，元素出現 n 次，則需要往下找 n 個 stack，也就是 \\(O(n)\\)。  實作2: Use HashMap to record freqency  為了優化，我們可以加入一個 HashMap 來記錄出現的次數，再下次要 push 此元素時，只需要到 HashMap 中查詢出現的次數即可。  public class freqStack{  // Field  List\u0026lt;Stack\u0026lt;Integer\u0026gt;\u0026gt; stacks;  Map\u0026lt;Integer, Integer\u0026gt; map; // 用來記錄出現次數   // Constructor  public freqStack(){  stacks = new ArrayList\u0026lt;\u0026gt;();  map = new HashMap();  }   // Methods  public void push(int val){  Stack\u0026lt;Integer\u0026gt; stack;  // 還沒有此出現次數的元素出現，則新增此 stack  if (stacks.size() \u0026lt; map.getOrDefault(val, 0) + 1){  stack = new Stack\u0026lt;\u0026gt;();  } else {  // 取得此元素出現的次數，若沒出現過則取得 stacks[0]  stack = stacks.get(map.getOrDefault(val, 0));  }  stack.push(val);  map.put(val, map.getOrDefault(val, 0) + 1); // 更新出現次數  }   public int pop(){  // 直接找到最高的 stack，然後把頂端的元素 pop 出。  Stack\u0026lt;Integer\u0026gt; stack = stacks.get(stacks.size() - 1);  int top = stack.pop();  map.put(val, map.get(val) - 1); // 更新出現次數  if (stack.isEmpty()){  stacks.remove(stacks.size() - 1);  }  return top;  } } 程式碼  題解：請點此 測試檔：請點此  Reference: Leetcode: 895. Maximum Frequency Stack\n","permalink":"http://intervalrain.github.io/posts/leetcode/freqstack/","summary":"題目 題目描述  設計一個類似 stack 的資料結構，實行 push() 跟 pop() 的功能，其中 pop() 會丟出 stack 中出現最多次的元素。 FreqStack class 必須實現：  FreqStack() 建構子必須初始化一個空的 FreqStack。 void push(int val) 將 val 推至 stack 的頂端。 int pop() 將 stack 中最頻繁出現的元素移除，並返回。  如果 stack 中最頻繁出現的元素出現平手的狀況，則返回平手的元素中最接近 stack 頂端的元素。      題目範例 輸入\n[\u0026ldquo;FreqStack\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\n輸出","title":"[Leetcode] Maximum Frequency Stack"},{"content":"1. 請說明 Final, Finally, Finalize 三者不同?  Final:  一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。   Finally:  例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。   Finalize:  是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。    2. 請說明 String 字串中 == 與 .equals() 哪裡不同?   ==:\n 比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。    equals():\n 是 String 覆寫後的 equals 方法，比較值。    補充：\n Java 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。  若使用 String s1 = \u0026quot;Hello World\u0026quot;; 來宣告，則會透過字串池。 若使用 String s2 = new String(\u0026quot;Hello World\u0026quot;) 來宣告，則字串會存在 Heap 中，與上者的址不同。      3. 使用 \u0026ldquo;abc\u0026rdquo;.equals(s) 比較好還是 s.equals(\u0026ldquo;abc\u0026rdquo;)?  等效。 前者不會出現 NullPointerException。  4. Arrays 與 ArrayList 的差異?  Arrays 可包含原始(primitive)及物件(object)，ArrayList只允許物件。 Arrays 大小固定，ArrayList 可動態調整。 ArrayList 提供許多方法，如 removeAll、iterator等。  5. stack 與 heap 的區別?  stack: 可被預測生命週期的變數或函數資訊都放在 stack，例如：區域變數(local variable)、物件或陣列的返回位址(function/method return address)等資訊。 heap: 動態配置的記憶體空間，放置被 new 出來的物件以及內含的成員變數。  6. Arrays 與 String 的大小  Arrays 有 length 這個屬性。 String 有 legnth() 這個方法。  7. throw 與 throws 的區別  throws: throws 關鍵字通常被應用在聲明方法時，放在方法的大括號前，用來拋出異常，多個異常可以使用逗號隔開。後續使用者要調用方法時必須要拋出異常或者使用 try-catch 語句處理異常。 throw: throw 關鍵字通常用在設計方法時，預先宣告可能會產生的例外，後續方法使用者需要使用 try-catch 處理例外，或者使用 throws 關鍵字再拋出例外。 補充：  throw 用於方法內，throws 用於方法的聲明。 throw 用於方法內拋出異常，throws 用於方法聲明上拋出異常。 throw 後面只能有一個異常，throws 可以聲明多個異常。    8. int 和 Integer 何者會占用更多記憶體?  Integer，Integer 是一個物件，會在 heap 中儲存，並儲存址的值到 stack 中，而 int 只會保存值在 stack 中。  9. 是否能將 int 強制轉型為 byte?  可以，可以使用 b = (byte) a 來進行強制轉換，但是超過範圍的部分會被丟棄。  10. 是否能保證 gc 的執行?  否，垃報回收機制程式設計師無法保證，但可以透過 System.gc() 呼叫。  11. abstract class 與 interface 的區別?  abstract class 可以宣告抽象方法，提供子類別實作。 interface 的方法必定是抽象方法。 一個類別可以繼承多個介面，但只能繼承一個抽象類別。  12. List 與 Set 區別?  List:  有順序性(索引值)。 可重複。 ArrayList 實作了 List 介面。 ArrayList: 插入、刪除速度 \\(O(n)\\)，走訪速度\\(O(1)\\)。 \u0008LinkedList: 插入、刪除速度 \\O(1)\\)，走訪速度\\(O(n)\\)。   Set  無順序性(配合 iterator) 不可重複，走訪速度\\(O(1)\\)。 HashSet 實作了 Set 介面。 HashSet: 無順序性，查找速度快。 LinkedHashSet: 有順序性 TreeSet: 有排序性(依字母)   Map 1.有元素鍵值(Key-Value)，搜尋快 2.元素可重複，鍵值如果重複新加入值會覆蓋舊有值 3.HashMap: 查找速度慢，插入刪除速度快 4.TreeMap: 有排序性  ","permalink":"http://intervalrain.github.io/posts/java/interviewq/","summary":"1. 請說明 Final, Finally, Finalize 三者不同?  Final:  一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。   Finally:  例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。   Finalize:  是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。    2. 請說明 String 字串中 == 與 .equals() 哪裡不同?   ==:\n 比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。    equals():\n 是 String 覆寫後的 equals 方法，比較值。    補充：\n Java 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。  若使用 String s1 = \u0026quot;Hello World\u0026quot;; 來宣告，則會透過字串池。 若使用 String s2 = new String(\u0026quot;Hello World\u0026quot;) 來宣告，則字串會存在 Heap 中，與上者的址不同。      3.","title":"[Java] 面試常見問題"},{"content":"C  當我們要去評價程式碼的品質時，我們會考慮以下元素：  正確性(correctness): 程式碼是否有正確的解決我們的問題 設計(design): 程式碼的好壞決定於它的效率與可讀性 風格(style): 程式碼在視覺上是否有良好的format   我們的第一個 C 語言程式：  #include \u0026lt;stdio.h\u0026gt; int main(void) {  printf(\u0026#34;hello, world\\n\u0026#34;); } 整合開發環境、編譯器、介面 IDEs, compilers, interfaces  在執行程式前，我們必須將程式碼轉變成電腦可讀的 binary codes，也就是 0 與 1。 IDE(integrated development environments) 可以協助我們開發、編譯程式碼。如Visual Studio Code 我們撰寫的程式碼為開源碼(source code)，我們必須將他轉變成機器碼(machine code)，才能被電腦執行。 編譯器(compiler)是將一種語言轉變成另一種語言的程式，例如將開源碼編譯成機器碼。 在 IDE 中，我們可以在一個叫作 terminal 的視窗中輸入指令。 terminal 提供了 command-line interface(CLI) 當我們輸入 make hello，會產生一個叫作 hello 的檔案，我們可以透過輸入 ./hello 執行它。  . 代表當下的目錄，上面的指令代表我們要執行當下目錄中叫作 hello 的檔案。 hello 即是內含機器碼的檔案。   欲刪除檔案可以用 rm 指令。 輸入 ls 列出當下目錄所包含的檔案。 若源碼檔經過修過，則必須重新編譯，才能對執行檔進行修改。  函式、引數、傳回值、變數 Functions, Arguments, Return Values, Variables printf(\u0026#34;Hello, world\u0026#34;);  此處，介紹一個叫作 printf 的函數  f 代表 formatted 的字串。字串是多個字元(characters)組成的字詞，在 C 中，我們需要用雙引號(\u0026quot;\u0026quot;)來包住它。 括號 () 使我們可以輸入引數，也就是 printf 函數的 input。 最後，我們需要分號 ;，來宣告述句的結束。   其中，函式的一種產物叫作 side effect，也就是我們可以觀察到的變化，如螢幕印出字樣，或是發出聲響。 相比與 **side effects，我們也可以將函式的回傳值用於程式中，回傳值通被儲存於變數中。  string answer = get_string(\u0026#34;What\u0026#39;s your name? \u0026#34;);  此處，示範 CS50 IDE 中的一個函數。  這裡的 get_string為函式，而What's your name?  為引數。 然後，我們可以將回傳值存入到變數中，以上例，我們可利用賦值運算子(=)將右值(r_value)傳給左值(l_value)的answer。 最後，我們宣告變數的變數型別(type)。  如果我們嘗試將上述的變數改為其他變數型別，編譯器會顯示錯誤。      printf(\u0026#34;Hello, world\\n\u0026#34;);  我們此處為了換行，而使用了 escape sequence \\n。  ","permalink":"http://intervalrain.github.io/posts/cs50/lec1/","summary":"C  當我們要去評價程式碼的品質時，我們會考慮以下元素：  正確性(correctness): 程式碼是否有正確的解決我們的問題 設計(design): 程式碼的好壞決定於它的效率與可讀性 風格(style): 程式碼在視覺上是否有良好的format   我們的第一個 C 語言程式：  #include \u0026lt;stdio.h\u0026gt; int main(void) {  printf(\u0026#34;hello, world\\n\u0026#34;); } 整合開發環境、編譯器、介面 IDEs, compilers, interfaces  在執行程式前，我們必須將程式碼轉變成電腦可讀的 binary codes，也就是 0 與 1。 IDE(integrated development environments) 可以協助我們開發、編譯程式碼。如Visual Studio Code 我們撰寫的程式碼為開源碼(source code)，我們必須將他轉變成機器碼(machine code)，才能被電腦執行。 編譯器(compiler)是將一種語言轉變成另一種語言的程式，例如將開源碼編譯成機器碼。 在 IDE 中，我們可以在一個叫作 terminal 的視窗中輸入指令。 terminal 提供了 command-line interface(CLI) 當我們輸入 make hello，會產生一個叫作 hello 的檔案，我們可以透過輸入 ./hello 執行它。  . 代表當下的目錄，上面的指令代表我們要執行當下目錄中叫作 hello 的檔案。 hello 即是內含機器碼的檔案。   欲刪除檔案可以用 rm 指令。 輸入 ls 列出當下目錄所包含的檔案。 若源碼檔經過修過，則必須重新編譯，才能對執行檔進行修改。  函式、引數、傳回值、變數 Functions, Arguments, Return Values, Variables printf(\u0026#34;Hello, world\u0026#34;);  此處，介紹一個叫作 printf 的函數  f 代表 formatted 的字串。字串是多個字元(characters)組成的字詞，在 C 中，我們需要用雙引號(\u0026quot;\u0026quot;)來包住它。 括號 () 使我們可以輸入引數，也就是 printf 函數的 input。 最後，我們需要分號 ;，來宣告述句的結束。   其中，函式的一種產物叫作 side effect，也就是我們可以觀察到的變化，如螢幕印出字樣，或是發出聲響。 相比與 **side effects，我們也可以將函式的回傳值用於程式中，回傳值通被儲存於變數中。  string answer = get_string(\u0026#34;What\u0026#39;s your name?","title":"[CS50] Lec 1 - C"},{"content":"1. transient 的作用及使用方法  當一個物件繼承(implements)了 Serializable 介面，這個物件就可以被序列化，Java 的序列化模式為開發者提供了許多便利，開發者可以不必關心具體序列化的過程，只要繼承了 Serializable 介面，該類別(class)的所有屬性(property)和方法(method)都會自動序列化。 然而在實際開發過程中，有些屬性需要序列化，有些屬性則不需要。  用戶的私密訊息如密碼、銀行帳號等，通常不希望在網路操作時被傳輸。   此時，便可在這些對應的變數前加上 transient。 如此一來，這些私密訊息的生命週期只會存在於調用者的記憶體(memory)中，不會寫到磁碟(disk)裡。   注意讀取時，讀取數據的順序一定要和存放數據的順序保持一致。\n  範例：  import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; import java.io.Serializable;  public class TransientExample {  public static void main(String[] args){  User user = new User();  user.setUsername(\u0026#34;Rain\u0026#34;);  user.setPassword(\u0026#34;12345678\u0026#34;);   System.out.println(\u0026#34;Read before Serializable: \u0026#34;);  System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername());  System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword());   try {  ObjectOutput os = new ObjectOutputStream(new FileOutputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;));  os.writeObject(user);  os.flush();  os.close();  } catch (FileNotFoundException e){  e.printStackTrace();  } catch (IOException e){  e.printStackTrace();  }  try {  ObjectInputStream is = new ObjectInputStream(new FileInputStream(\u0026#34;/Users/rainhu/workspace/algo/temp/user.txt\u0026#34;));  user = (User) is.readObject();  is.close();   System.out.println(\u0026#34;Read after Serializable: \u0026#34;);  System.out.println(\u0026#34;Username: \u0026#34; + user.getUsername());  System.out.println(\u0026#34;Password: \u0026#34; + user.getPassword());  } catch (FileNotFoundException e){  e.printStackTrace();  } catch (IOException e){  e.printStackTrace();  } catch (ClassNotFoundException e){  e.printStackTrace();  }  } }  class User implements Serializable{  private static final long serialVersionID = 8294180014912103005L;   private String username;  private transient String password;   public String getUsername(){  return username;  }   public void setUsername(String username){  this.username = username;  }   public String getPassword(){  return password;  }   public void setPassword(String password){  this.password = password;  } }  輸出的結果是：   Read before Serializable:\nUsername: Rain\nPassword: 12345678\nRead after Serializable:\nUsername: Rain\nPassword: null\n  也就是說反序列化並沒有成功從文件獲取到訊息。  2. transient 的小結  一旦變數被 transient 修飾，變數將不再是物件持久化的一部分，該變敗內容將在序列化後無法再次訪問。 transient 關鍵字只能飾飾變數(variable)，不能修飾方法(method)和類別(class)。注意，區域變數是無法被 transient 修飾的。 被 transient 修飾的變數不能再被序列化，一個靜態變數不管是否被 transient 修飾，都不能被序列化。   其中，在上例中的 username 帶有 static 關鍵字，實際上是沒有被序列化的，也就是說我們在讀取之前改變 username 的值，讀取完並不會改變 username 的值，而是 JVM 中對應靜態變數的值。  3. 當遇上了 Externalizable  當被 transient 修飾的變數在存於一個繼承了 Externalizable 的介面，則代表沒有任何東西被自動序列化。 需要在 writeExternal方法中手工指定所要序列化的變數，這與是否被 transient 修飾無關。  ","permalink":"http://intervalrain.github.io/posts/java/transient/","summary":"1. transient 的作用及使用方法  當一個物件繼承(implements)了 Serializable 介面，這個物件就可以被序列化，Java 的序列化模式為開發者提供了許多便利，開發者可以不必關心具體序列化的過程，只要繼承了 Serializable 介面，該類別(class)的所有屬性(property)和方法(method)都會自動序列化。 然而在實際開發過程中，有些屬性需要序列化，有些屬性則不需要。  用戶的私密訊息如密碼、銀行帳號等，通常不希望在網路操作時被傳輸。   此時，便可在這些對應的變數前加上 transient。 如此一來，這些私密訊息的生命週期只會存在於調用者的記憶體(memory)中，不會寫到磁碟(disk)裡。   注意讀取時，讀取數據的順序一定要和存放數據的順序保持一致。\n  範例：  import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutput; import java.io.ObjectOutputStream; import java.io.Serializable;  public class TransientExample {  public static void main(String[] args){  User user = new User();  user.setUsername(\u0026#34;Rain\u0026#34;);  user.setPassword(\u0026#34;12345678\u0026#34;);   System.out.println(\u0026#34;Read before Serializable: \u0026#34;);  System.out.println(\u0026#34;Username: \u0026#34; + user.","title":"[Java] transient 關鍵字"},{"content":"Mismatch 的重要性  Mismatch 就是當元件的結構設計相同，且尺寸相等，發生性質差異的一種行為。 當尺寸漸縮，變異(viriability)的程度會愈來愈大。 變異(viriability)變大會影響到類比邏輯應用的表現。  Variability/Fluctuation 變異度/誤差定義  元件的單體量測值到整體的 Stardard Target 或 Median 的差距。 可分為系統誤差與隨機誤差。  Systematic variability 系統誤差 (Global)  外質特性(extrinsic) 可以透過製程改良或控制來改善  W2W: 裝置穩定度 equipment stability Wafer level: 裝置均勻度 equipment uniformity、黃光穩定度 Litho. stability Die level: 黃光均勻度 Litho. uniformity、溫度均勻度 temp. non-uniformity  pattern density like poly gate density might impact temperature uniformity   Layout-Dependent: 光學偏移效應 Optical proximity effect、機械應力 Mechanical stress    Random variability 隨機誤差 (Local/Mismatch)  本質特性(intrinsic) 較難被改善 沒有空間相關性 尺寸漸縮，比例可能被放大  微擾動: 參雜 dopant, LER, \u0026hellip;  random dopant fluctuation(RDF): dopant diffuse randomly gate dieletric roughness line edge roughness(LER) grain irregularity      統計手法 常態分佈  大部分的元件特性都呈常態分布(normal distribution) 中央極限定理 Advanced Central Limit Therem: 相互獨立的隨機變數, 其均值以常態分佈為極限 Sum of normally distributed random variables: 常態分佈的線性組合依然是常態分布 可簡單透過 median 與 sigma 來描述一組數據, 並用來預測數據 常態分布的函數式為 \\(f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}}\\)  分析手法  透過刪減 outlier 使 rawdata 盡量接近常態分布 (刪除 3倍 sigma 以外的 outlier，重複 6 次) 通常 Full mapping 量測(66pts) 會有 0~2 點的 outliers 數學公式: A = B + C 且 B 與 C 為不相依的變數時 \\((\\sigma_A)^2=(\\sigma_B)^2+(\\sigma_C)^2\\) $$(\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2$$ Total:  \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in wafer   Global:  \\((\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2\\) \\(\\text{Median(Vt1,Vt2,\u0026hellip;Vtn)}\\) \\(\\sigma(\\text{Med1,Med2,\u0026hellip;Medn})\\)   Local:  \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in die local = \\(\\sqrt{\\frac{\\sum\\sigma_i}{n}})\\) mismatch = \\(\\sigma(\\Delta\\text{Vt1},\\Delta\\text{Vt2},\u0026hellip;\\Delta\\text{Vtn})\\)    Mismatch量測  量測 Full mapping data 將同個 die 裡面的 device pair(the same W \u0026amp; L) 計算差值  \\(\\Delta\\text{Vt}=Vt1-Vt2\\) \\(\\Delta\\text{Ion}=\\frac{2\\times(\\text{Ion}_1-\\text{Ion}_2)}{\\text{Ion}_1+\\text{Ion}_2}\\)   Normalization  同一組 device pair 內，去除 outlier，使數據接近常態分佈 因為 mismatch 受 sacle 影響，故須對 scale 做正常化 1/sqrt(WL)，Standard variation of mismatch is proportional to inverse of square root of area.   Draw \\(\\Delta\\text{Vt}-\\frac{1}{\\sqrt{W/L}}\\)圖  斜率即為 Mismatch    ","permalink":"http://intervalrain.github.io/posts/device/mismatch/","summary":"Mismatch 的重要性  Mismatch 就是當元件的結構設計相同，且尺寸相等，發生性質差異的一種行為。 當尺寸漸縮，變異(viriability)的程度會愈來愈大。 變異(viriability)變大會影響到類比邏輯應用的表現。  Variability/Fluctuation 變異度/誤差定義  元件的單體量測值到整體的 Stardard Target 或 Median 的差距。 可分為系統誤差與隨機誤差。  Systematic variability 系統誤差 (Global)  外質特性(extrinsic) 可以透過製程改良或控制來改善  W2W: 裝置穩定度 equipment stability Wafer level: 裝置均勻度 equipment uniformity、黃光穩定度 Litho. stability Die level: 黃光均勻度 Litho. uniformity、溫度均勻度 temp. non-uniformity  pattern density like poly gate density might impact temperature uniformity   Layout-Dependent: 光學偏移效應 Optical proximity effect、機械應力 Mechanical stress    Random variability 隨機誤差 (Local/Mismatch)  本質特性(intrinsic) 較難被改善 沒有空間相關性 尺寸漸縮，比例可能被放大  微擾動: 參雜 dopant, LER, \u0026hellip;  random dopant fluctuation(RDF): dopant diffuse randomly gate dieletric roughness line edge roughness(LER) grain irregularity      統計手法 常態分佈  大部分的元件特性都呈常態分布(normal distribution) 中央極限定理 Advanced Central Limit Therem: 相互獨立的隨機變數, 其均值以常態分佈為極限 Sum of normally distributed random variables: 常態分佈的線性組合依然是常態分布 可簡單透過 median 與 sigma 來描述一組數據, 並用來預測數據 常態分布的函數式為 \\(f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-u)^2}{2\\sigma^2}}\\)  分析手法  透過刪減 outlier 使 rawdata 盡量接近常態分布 (刪除 3倍 sigma 以外的 outlier，重複 6 次) 通常 Full mapping 量測(66pts) 會有 0~2 點的 outliers 數學公式: A = B + C 且 B 與 C 為不相依的變數時 \\((\\sigma_A)^2=(\\sigma_B)^2+(\\sigma_C)^2\\) $$(\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2$$ Total:  \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in wafer   Global:  \\((\\sigma_{total})^2=(\\sigma_{global})^2+(\\sigma_{local})^2\\) \\(\\text{Median(Vt1,Vt2,\u0026hellip;Vtn)}\\) \\(\\sigma(\\text{Med1,Med2,\u0026hellip;Medn})\\)   Local:  \\(\\sigma(\\text{Vt1,Vt2,\u0026hellip;Vtn})\\) in die local = \\(\\sqrt{\\frac{\\sum\\sigma_i}{n}})\\) mismatch = \\(\\sigma(\\Delta\\text{Vt1},\\Delta\\text{Vt2},\u0026hellip;\\Delta\\text{Vtn})\\)    Mismatch量測  量測 Full mapping data 將同個 die 裡面的 device pair(the same W \u0026amp; L) 計算差值  \\(\\Delta\\text{Vt}=Vt1-Vt2\\) \\(\\Delta\\text{Ion}=\\frac{2\\times(\\text{Ion}_1-\\text{Ion}_2)}{\\text{Ion}_1+\\text{Ion}_2}\\)   Normalization  同一組 device pair 內，去除 outlier，使數據接近常態分佈 因為 mismatch 受 sacle 影響，故須對 scale 做正常化 1/sqrt(WL)，Standard variation of mismatch is proportional to inverse of square root of area.","title":"[Device] Mismatch Introduction"},{"content":"如何初始化 vector 事先準備  #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std;  1. 利用 push_back() 函式 vector\u0026lt;int\u0026gt; A; A.push_back(1); A.push_back(2); A.push_back(3); // A = [1,2,3] 2. 利用重載建構子(overloaded constructor) int size = 5; int fill = 2; vector\u0026lt;int\u0026gt; B(size, fill); // B = [2,2,2,2,2] 3. 將 array 傳給 vector 的建構子(-std=c++11) vector\u0026lt;int\u0026gt; C{1, 2, 3, 4, 5}; // C = [1,2,3,4,5] 4. 利用既有的 array int array[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; D(array, array+4); // D = [1,2,3,4] 5. 利用既有的 vector vector\u0026lt;int\u0026gt; E(C.begin()+1, C.end()-3); // E = [2] 6. 利用 fill 函式 vector\u0026lt;int\u0026gt; F(6); fill(F.begin(), F.end(), 3); // F = [3,3,3,3,3,3] Reference\n","permalink":"http://intervalrain.github.io/posts/c++/newvector/","summary":"如何初始化 vector 事先準備  #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std;  1. 利用 push_back() 函式 vector\u0026lt;int\u0026gt; A; A.push_back(1); A.push_back(2); A.push_back(3); // A = [1,2,3] 2. 利用重載建構子(overloaded constructor) int size = 5; int fill = 2; vector\u0026lt;int\u0026gt; B(size, fill); // B = [2,2,2,2,2] 3. 將 array 傳給 vector 的建構子(-std=c++11) vector\u0026lt;int\u0026gt; C{1, 2, 3, 4, 5}; // C = [1,2,3,4,5] 4. 利用既有的 array int array[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; D(array, array+4); // D = [1,2,3,4] 5.","title":"[C++] How to Initialize vector in C++"},{"content":"Integer.bitCount 的函式解析  要計算整數以二進制的方式表示時，所有 bit 位為 1 的總和。  雛形  從低位開始，檢查是否為 1。  public static int bitCount(int i){  int count = 0;  while (i \u0026gt; 0) {  if ((i \u0026amp; 1) == 1) // 如果最低位為 1，count就加 1  count++;  i \u0026gt;\u0026gt;= 1; // 向右推進 1 位，等同於 num /= 2;  }  return count; }  時間複雜度為 \\(O(n)\\)，\\(n\\) 為整數的位數(bit 數)。  優化  利用(i - 1) \u0026amp; i 可以消除最低位數的 1 的性質來計算。  public static bitCount(int i){  int count = 0;  while (i \u0026gt; 0){  i = i \u0026amp; (i - 1); // 0b0101_1100 - 1 = 0b0101_1011, 且 0b0101_1100 \u0026amp; 0b0101_1011 = 0b0101_1000;  count++;  }  return count; }  時間複雜度為 \\(O(n))\\)，\\(n\\) 為位數為 1 的個數。  利用 int 的特性再優化  \u0008因為 int 的最大正整數為 2^31，故我們可以兩兩錯位相加來求和  private static int bitCount(int i){  i = (i \u0026amp; 0x55555555) + ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); // 0b0101_0101_0101_0101_0101_0101_0101_0101  i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); // 0b0011_0011_0011_0011_0011_0011_0011_0011  i = (i \u0026amp; 0x0f0f0f0f) + ((i \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); // 0b0000_1111_0000_1111_0000_1111_0000_1111  i = (i \u0026amp; 0x00ff00ff) + ((i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); // 0b0000_0000_1111_1111_0000_0000_1111_1111  i = (i \u0026amp; 0x0000ffff) + ((i \u0026gt;\u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff); // 0b0000_0000_0000_0000_1111_1111_1111_1111  return i; }  時間複雜度為 \\(O(1))\\)。  Source Code(final) public static int bitCount(int i) {  // HD, Figure 5-2  i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555);  i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333);  i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f;  i = i + (i \u0026gt;\u0026gt;\u0026gt; 8);  i = i + (i \u0026gt;\u0026gt;\u0026gt; 16);  return i \u0026amp; 0x3f; }  一、三、四、五步不進行消位，在最後再利用 i \u0026amp; 0x3f 消去不必要的位數  ","permalink":"http://intervalrain.github.io/posts/java/bitcount/","summary":"Integer.bitCount 的函式解析  要計算整數以二進制的方式表示時，所有 bit 位為 1 的總和。  雛形  從低位開始，檢查是否為 1。  public static int bitCount(int i){  int count = 0;  while (i \u0026gt; 0) {  if ((i \u0026amp; 1) == 1) // 如果最低位為 1，count就加 1  count++;  i \u0026gt;\u0026gt;= 1; // 向右推進 1 位，等同於 num /= 2;  }  return count; }  時間複雜度為 \\(O(n)\\)，\\(n\\) 為整數的位數(bit 數)。  優化  利用(i - 1) \u0026amp; i 可以消除最低位數的 1 的性質來計算。  public static bitCount(int i){  int count = 0;  while (i \u0026gt; 0){  i = i \u0026amp; (i - 1); // 0b0101_1100 - 1 = 0b0101_1011, 且 0b0101_1100 \u0026amp; 0b0101_1011 = 0b0101_1000;  count++;  }  return count; }  時間複雜度為 \\(O(n))\\)，\\(n\\) 為位數為 1 的個數。  利用 int 的特性再優化  \u0008因為 int 的最大正整數為 2^31，故我們可以兩兩錯位相加來求和  private static int bitCount(int i){  i = (i \u0026amp; 0x55555555) + ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); // 0b0101_0101_0101_0101_0101_0101_0101_0101  i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); // 0b0011_0011_0011_0011_0011_0011_0011_0011  i = (i \u0026amp; 0x0f0f0f0f) + ((i \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 0x0f0f0f0f); // 0b0000_1111_0000_1111_0000_1111_0000_1111  i = (i \u0026amp; 0x00ff00ff) + ((i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0x00ff00ff); // 0b0000_0000_1111_1111_0000_0000_1111_1111  i = (i \u0026amp; 0x0000ffff) + ((i \u0026gt;\u0026gt;\u0026gt;16) \u0026amp; 0x0000ffff); // 0b0000_0000_0000_0000_1111_1111_1111_1111  return i; }  時間複雜度為 \\(O(1))\\)。  Source Code(final) public static int bitCount(int i) {  // HD, Figure 5-2  i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555);  i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333);  i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f;  i = i + (i \u0026gt;\u0026gt;\u0026gt; 8);  i = i + (i \u0026gt;\u0026gt;\u0026gt; 16);  return i \u0026amp; 0x3f; }  一、三、四、五步不進行消位，在最後再利用 i \u0026amp; 0x3f 消去不必要的位數  ","title":"[Java] Integer.bitCount 解析"},{"content":"一、OS 簡介 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：\n 資源分配者 監控使用者程式的執行，以防止不正常的運作造成對系統的危害。  一個標準 PC 的作業系統應該提供以下功能：  行程管理 (processing management) 記憶體管理 (memory management) 檔案系統 (file system) 網路通訊 (networking) 安全機制 (security) 使用者介面 (user integerface) 驅動程式 (device drivers)  OS 系統依大小來區分：  大型電腦：IBM OS/360 個人電腦：Windows、Linux、BSD、Mac OS X 嵌入式：VxWorks、eCos、Sysbian OS、Palm OS  依品牌來區分：  類 Unix 家族：包含 System V、BSD 與 Linux。 微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。 蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統 Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。  二、常見的系統類型  Multiprogramming System   系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel)) Multiprogramming Degree：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 Thrashing 現象)  當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。  [方法1] 降低 Multiprogramming Degree [方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 [方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。      分時系統 Time Sharing System   Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。 常見配置：  行程排程採用 RR 排程(Round-robin scheduling) 記憶體空間所有使用者分享 使用虛擬記憶體技術 I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。    分散式系統 Distributed System    須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：\n Client-Server System Peer-to-peer    舉例：志願計算，使用志願者電腦的閒置計算力，透過網際網路進行資料傳輸(如 Folding@home 蛋白質摺疊研究計畫)\n  分散式系統的好處：\n 資源共享 (Resource sharing) 加快計算速度 (Speed up) 可靠性 (Reliability)：指不容易因為一台電腦 shut down 而全部崩潰 通訊需求 (Coummunication Need)  補充：勿將 Multiprocessor 與分散式系統混為一談\n Symmetric Multiprocessing (SMP)：對稱式多元處理，每一個處理器具有相同的功能，可靠度高，強調負載平衡。 Asymmetric Multiprocessing (ASMP)：非對稱式多元處理，Master/Slave 架構。    即時系統 Real Time System   定義嚴謹的固定時間限制，電腦在處理工作時必須在這個定義的時間內完成，否則工作就算失效。  硬性即時系統(Hard Real Time Sydstem)：對於完成工作的時間有極嚴格的限制。若 Prcess 未能於規定的時間內完成，則 Process 即屬失效。(意義同即時系統之定義)  工廠自動化系統、軍事系統、核能安控等。 Application Program 設計上非常重要。 Data 及 Program 皆存在 ROM 或 RAM 中。 不使用虛擬記憶體，因為 Page Fault 的處理時間過長。 減少 os 的干預以降低 Dispatch Latency。   軟性即時系統(Soft Real Time System)：保證高優先權的 Process 必須先於所有低優先權的 Process 完成。  Multimedia System、Virtual Reality等。(影音多媒體的緩衝時間) CPU 的 Scheduling 應能支援 Priority Scheduling 且不能提供類似 Aging 技術。 可和分時系統、virtual memory 共存。      叢集系統 Clustered System   叢集系統共享儲存裝置，集合許多 CPU 並且經由 LAN 連線緊密地連結以完成工作。 叢集系統主要是利用多台獨立的電腦系統或是工作站來共同完成大型數值的平行計算。  Batch  較好的耐用度、安全性 常用於大量數據分析 常用於醫院、金融業 計算機一次只執行一件事 使用者與計算機的執行沒有互動性 CPU 時常處在閒置的狀態(因為 I/O speed 遠小於 CPU speed) OS 處理完一件事後，才將控制權交給下一個工作  Multi-programming   讓 I/O 與計算的工作可以同時進行，減少 CPU 閒置的時間。\n  Spooling(Simultaneous Peripheral Operation On-Line)。\n  但仍是一次執行一件事。   OS 的工作包含：\n 記憶體管控。  系統必須分配記憶體給不同的程式   CPU 排程。  系統必須決定哪些程式要執行   I/O 系統。  系統提供 I/O 的排程與裝置的分配      Time-sharing System   使用者與系統間具有互動性\n CPU 頻繁的切換不同的工作，所以會有很多時間點可以接收 I/O。 使用者可以及時看到結果。 使用者感受像是同時進行的，但其實是很快速的切換在不同的工作之間。    OS 的工作包含：\n Virtual memory，從硬碟中借儲存空間出來，當作 memory 來使用。 檔案系統和硬碟管理。 同步化(Synchronization) 和 死鎖(deadlock)。    \\( \\def\\arraystretch{1.5}\\begin{array}{|c|c|c|c|}\\hline \u0026amp;\\text{Batch}\u0026amp;\\text{Multi-programming}\u0026amp;\\text{Time-sharing}\\\\\\hline \\text{系統模型}\u0026amp;\\text{單一使用者、單一作業}\u0026amp;\\text{單一使用者、多作業排程}\u0026amp;\\text{多使用者、作業平行處理}\\\\\\hline \\text{目的}\u0026amp;\\text{簡單}\u0026amp;\\text{增加資源利用效率(機本)}\u0026amp;\\text{提升反應速度(人本)}\\\\\\hline \\text{特徵}\u0026amp;\\text{N.A.}\u0026amp;\\text{CPU 排程、記憶體管理、I/O系統}\u0026amp;\\text{檔案系統、虛擬記憶體、同步化、死鎖}\\\\\\hline \\end{array} \\)\n電腦系統結構 桌面系統(Desktop Systems)：單處理器(single processor)  PC(personal computer) GUI I/O devices: 鍵盤、滑書、螢幕、印表機… 多元的 OS  Window, MacOS, Unix, Linux   缺乏檔案與作業系統的保護  木馬、病毒    平行系統(Parallel Systems)：多處理器(multiprocessor/tightly couplde system)  多核、或多 CPU。 通常共享記憶體 優點：  Throughput: 提升計算能力 Economical: 很多裝置可以共用、節省成本 Reliability: 當其中一個 CPU 壞掉時，不會使得電腦完全無法操作。   分類：  對稱式多處理器系統 Symmetric multiprocessor system(SMP)  作業系統控制的每個處理器都扮演相同角色 大多 CPU 屬於這種 需要額外處理 synchronization   非對稱式多處理器系統Asymmetric multiprocessor system  每個處理器被指派處理不同的特殊工作 一個主要的 master CPU 與多個 slave CPUs 常見於極大的系統      多核處理器 Multi-Core Processor  在單一的 CPU 有多核 On-chip communication 比 between-chip communication 還快 One chip with multiple core 比 multiple single-core chips 還節能  Many-Core Processor  Nvidia General-Purpose GPU 圖形處理器  Single Instruction Multiple Data 處理矩陣更快   Intel Xeon Phi TILE64  記憶體存取結構(Memory Access Architecture) 統一記憶體存取架構 Uniform memory access(UMA) 非統一記憶體存取架構 Non-uniform memory access(NUMA) 分散式系統(Distributed Systems)： ","permalink":"http://intervalrain.github.io/posts/os/lec1/","summary":"一、OS 簡介 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。OS主要有以下兩個功能：\n 資源分配者 監控使用者程式的執行，以防止不正常的運作造成對系統的危害。  一個標準 PC 的作業系統應該提供以下功能：  行程管理 (processing management) 記憶體管理 (memory management) 檔案系統 (file system) 網路通訊 (networking) 安全機制 (security) 使用者介面 (user integerface) 驅動程式 (device drivers)  OS 系統依大小來區分：  大型電腦：IBM OS/360 個人電腦：Windows、Linux、BSD、Mac OS X 嵌入式：VxWorks、eCos、Sysbian OS、Palm OS  依品牌來區分：  類 Unix 家族：包含 System V、BSD 與 Linux。 微軟 Windows：Windows NT 核心，包含 Windows 2000、Windows XP。 蘋果 mac OS：執行於蘋果 Macintosh 系列電腦上的作業系統 Chrome OS：基於 Google 的瀏覽器 Google Chrome 的 Linux 核心。  二、常見的系統類型  Multiprogramming System   系統中存在多組行程同時 (concurrent) 執行，避免 CPU 閒置，提升 CPU 利用度。(注意不是平行執行(parallel)) Multiprogramming Degree：系統內所存在的等待執行 process 數目，Multiprogramming degree 愈高，則 CPU 使用度可能愈高。(非必定的原因是可能產生 Thrashing 現象)  當 CPU 效能降低時，系統會引入更多的 process 讓 CPU 盡可能工作。但當存有太多 process 時，大部分的工作會花費在 page fault 造成的 Page Replacement，致使 CPU 效率下降，最後造成 CPU 效能愈來愈低。  [方法1] 降低 Multiprogramming Degree [方法2] 利用 Page Fault Frequency (Ratio) 控制來防止 Thrashing。 [方法3] 利用 Working Set Model 預估各 Process 在不同執行時期所需的頁框數，並依此提供足夠的頁框數。      分時系統 Time Sharing System   Multiprogramming System 的一種，OS 透過資源分享，使得每個使用者都認為有一套專屬的系統存在，反應時間(Response Time)通常是一秒內。 常見配置：  行程排程採用 RR 排程(Round-robin scheduling) 記憶體空間所有使用者分享 使用虛擬記憶體技術 I/O Device 透過 Spooling(Simultaneous Peripheral Operation On-Line) 技術(把磁碟當成一個巨大緩衝區使用)共享。    分散式系統 Distributed System    須符合兩個條件，硬體上每台電腦都是自主的，軟體上用戶將整個系統看作是一台電腦。一般分為兩類：","title":"[OS] Lec 1 - Introduction"},{"content":"HashMap.comparableClassFor(Object x) 的函式解讀  原文敘述\nReturns x\u0026rsquo;s Class if it is of the form \u0026ldquo;class C implements Comparable\u0026rdquo;, else null.\n  我的翻譯 當x的類別為Comparable的實作時，返回x的類別；否則返回 null。\n  藉由這個函式實例的解讀，可以了解一下類別、泛型的相關概念。  Source Code static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) {  if (x instanceof Comparable) {  Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p;  if ((c = x.getClass()) == String.class) // bypass checks  return c;  if ((ts = c.getGenericInterfaces()) != null) {  for (Type t : ts) {  if ((t instanceof ParameterizedType) \u0026amp;\u0026amp;  ((p = (ParameterizedType) t).getRawType() ==  Comparable.class) \u0026amp;\u0026amp;  (as = p.getActualTypeArguments()) != null \u0026amp;\u0026amp;  as.length == 1 \u0026amp;\u0026amp; as[0] == c) // type arg is c  return c;  }  }  }  return null; } instanceof  insanceof 可理解成某類別的實作，無論是執行期時的類別，或是父類別，或是它實現的介面，或父類別實現的介面…，總之只要在繼承鏈上有這個類別就可以了。  getClass()  與instanceof相對應的是getClass()函式，無論該物件如果轉型，getClass()都會返回它執行時期的類別，可以簡單理解成實際類別\u0008，換言之也就是我們 new 出來物件時使用的類別。 有一種例外情形是匿名物件，當匿名物件調用getClass()時，返回的是依賴它的物件在執行期的類別，並以1,2,3\u0026hellip;的index區分。  getGenericInterfaces()  getGenericInterfaces()方法返回的是該物件在執行期時直接實作的介面。必然是該類別自己實作的介面，繼承的則不可。  getGenericSuperclass()和getSuperclass() 這兩個函式雖然沒有出現在 comparableClassFor(Object x)中，但也順帶一提。\n getSuperclass()返回的是直接父類的類別，不包括泛型參數。 \u0008getGenericSuperclass()返回的是包括泛型參數在內的直接父類別。 注意如果父類別聲明了泛型，但子類別繼承時沒有為父類別實作該泛型，這時候也是沒有泛型參數的  ParameterizedType  ParameterizedType 是 Type 介面的子介面，表示參數化的類別，亦即實作了泛型參數的類型。 注意如果直接用 bean 物件 instanceof ParameterizedType，结果都是 false。 Class 物件只能是 instanceof ParameterizedType，否則編譯會報錯。 只有用 Type 物件 instanceof ParameterizedType 才能得到想要的比較结果。可以這麼理解：一個 Bean 類別不會是 ParameterizedType，只有代表這個Bean類的類型（Type）才可能是ParameterizedType。 實現泛型參數，可以是給泛型傳入了一個真實的類別，或者傳入另一個新聲明的泛型參數，只聲明泛型而不實作，則 instanceof ParameterizedType 為 false。  getRawType()  getRawType()方法返回聲明了這個類別的類或介面，也就是去掉了泛型参数部分的類別物件。  getActualTypeArguments()  與getRawType()相對應，getActualTypeArguments()以數組的形式返回泛型參數列表。 當傳入的是真實類別時，印出來的是全類名 當傳入的是另一個聲明的泛型參數時滿印出來的是代表該泛型參數的符號。  getOwnerType()  ParameterizedType介面還有一個getOwnerType()函式，如果該類別是一个內部類別/介面，返回它的外部類別/介面。如果該類型不是內部類型不是内部類別/介面，返回null。  comparableClassFor(Object x) 總結 static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) {  if (x instanceof Comparable) { // 判斷是否實作了 Comparable 介面  Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p;  if ((c = x.getClass()) == String.class) // 如果是String類別，直接返回String.class  return c;  if ((ts = c.getGenericInterfaces()) != null) { // 檢查是否有直接實現的介面  for (Type t : ts) { // 遍歷介面  if ((t instanceof ParameterizedType) \u0026amp;\u0026amp; // 當介面實現了泛型  ((p = (ParameterizedType) t).getRawType() == // 取得介面不帶參數時的類別對象  Comparable.class) \u0026amp;\u0026amp; // 且為 Comparable  (as = p.getActualTypeArguments()) != null \u0026amp;\u0026amp; // 取得該介面的泛型參數  as.length == 1 \u0026amp;\u0026amp; as[0] == c) // type arg is c // 只帶有一種泛型且是實作類別為其本身  return c; // 返回該類別  }  }  }  return null; // 皆否則回傳 null } ","permalink":"http://intervalrain.github.io/posts/java/hashmap/","summary":"HashMap.comparableClassFor(Object x) 的函式解讀  原文敘述\nReturns x\u0026rsquo;s Class if it is of the form \u0026ldquo;class C implements Comparable\u0026rdquo;, else null.\n  我的翻譯 當x的類別為Comparable的實作時，返回x的類別；否則返回 null。\n  藉由這個函式實例的解讀，可以了解一下類別、泛型的相關概念。  Source Code static Class\u0026lt;?\u0026gt; comparableClassFor(Object x) {  if (x instanceof Comparable) {  Class\u0026lt;?\u0026gt; c; Type[] ts, as; ParameterizedType p;  if ((c = x.getClass()) == String.class) // bypass checks  return c;  if ((ts = c.getGenericInterfaces()) != null) {  for (Type t : ts) {  if ((t instanceof ParameterizedType) \u0026amp;\u0026amp;  ((p = (ParameterizedType) t).","title":"[Java] Java 的中 HashMap.comparableClassFor(Object x) 的函式解讀"},{"content":"什麼是 Computer Science(CS)?  CS 意在解決問題，更精準地說，是將問題 (input) 轉換成答案 (output) 的過程。 在計算機的世界，為了表達 inputs 和 outputs，我們必須將資訊標準化來儲存與操作它們，因為計算機只讀得懂 0 與 1 (開路/通路)。  如何表達數字?  在人類的世界，人們使用十進制(Decimal)。 在計算機的世界，用的是二進制(Binary)，也就是 0 與 1。  \\(1+1=10\\) \\((1,2,3,4,5,6,7,\u0026hellip;)_{10}=(001,010,011,100,101,110,111,\u0026hellip;)_2\\)   每個二進制的位元(digit)稱為 bit。 在現代計算機結構中，是由數以億計的電晶體(transistors)所組成的。  電晶體是一種具有開關(switch)性質的邏輯元件。   大部分的計算機一次用 8 個 bits，或稱 1 bytes，來表達數字。  \\(8 \\text{bits}=1 \\text{bytes}\\)    如何表達文字?  要表達文字，只需將不同的字元定義到對應的數字即可。 ASCII，American Standard Code for Information Interchange，即是一種基於拉丁字母的編碼系統，可應用顯示現代英語。  A-\u0026gt;65, B-\u0026gt;66, \u0026hellip;etc a-\u0026gt;97, b-\u0026gt;98, \u0026hellip;etc H-\u0026gt;72, I-\u0026gt;73, !-\u0026gt;33, so HI!=72, 73, 33   在不同語言，有不同的字符，就必須定義新的編碼系統，來容納更多的字符。  如 Unicode。 如 emojo 顏文字也是一種字符。    如何表達顏色?  同理，可以把不同的數字定義給不同的顏色，其中最常見的就是 RGB 系統。  由紅綠藍色塊所組成。 紅、綠、藍又個別以 8 bits 儲存的 256 種不同層度的顏色強度表示。 一共由 24 bits 來表達，超過1百萬種顏色。    那圖案、影片、音樂呢?  圖案是由數以萬計的色塊(dots)所組成，在螢幕顯示器上我們稱作畫素(pixels)。 影片則是由連續的圖案經由連續播放所建構而成的。 音樂同樣可以用 bits 來表達，其中 MIDI 是一種用數字來表達音符的形式。   All are composed by 0 and 1 in the computer world.\n 演算法 (Algorithms)  我們現在可以表達 inputs 和 outputs 了，接下來要開始解決問題。 演算法就是將 inputs 經過一連串系統性、且有邏輯的指令(instructions)轉化成 outpus 的過程。 試想我們要從電話簿中查朋友的電話，電話簿是按照名字排序的。   我們可以從第一頁往後找到最後一頁，只有名字與電話是存在的，我們就會在電話簿中找到，所以這個方法是無誤的。 我們也可以兩頁兩頁找，但我們有可能因此錯失我們要查的號碼。 我們也可以一次翻到當前電話簿的一半，利用電話簿的排序規則，決定往左半邊找或右半邊找，並且持續這個步驟直到找到。    將上述的演算法效率視覺化如下：  從上圖可見，當我們處理的樣本數很大時(電話簿頁數很多)，那麼我們用方法1解決問題的時間(找到號碼的時間)就會大的很多。而利用方法3解決問題的時間則會呈對數成長。 因此，好的演算法設計，會大大的影響計算機的操作效率。  Pseudocode  我們可以用英文(或人類語言)來表達我們的演算法，這種寫作方式叫作 Pseudocode。  Pick up phone book Open to middle of phone book Look at page If person is on page Call person Else if person is earlier in book Open to middle of left half to book Go back to line 3 Else if person is later in book Open to middle of right half to book Go back to line 3 Else Quit  其中像Pick up、Open to、Look at、Quit這些動作，在計算機中我們稱作函式(functions)。 其中分枝的部分If、Else，稱作條件(conditions)。 而我們需要決定的判斷式如person is on page、person is earlier than book、person is later in book稱為布林邏輯值(Boolean expressions)，也就是Yes or No，是或否。 最後，不斷地重覆Go back to line 3的動作，稱作迴圈(loops)。 接下來我們會繼續遇到各種玩意：  function  引數 arguments, 傳回值 return values   conditionals Boolean expressions loops variables   和 David 的第一個程式：將 \u0026ldquo;hello, world\u0026rdquo; 印到螢幕上。  #include \u0026lt;stdio.h\u0026gt; int main(void) {  printf(\u0026#34;hello, world\\n\u0026#34;); } Scratch  試試看到 Scratch(https://scratch.mit.edu/) 這套圖像化軟體語言操作看看吧！  Reference: https://cs50.harvard.edu/college/2021/fall/notes/0/\n","permalink":"http://intervalrain.github.io/posts/cs50/lec0/","summary":"什麼是 Computer Science(CS)?  CS 意在解決問題，更精準地說，是將問題 (input) 轉換成答案 (output) 的過程。 在計算機的世界，為了表達 inputs 和 outputs，我們必須將資訊標準化來儲存與操作它們，因為計算機只讀得懂 0 與 1 (開路/通路)。  如何表達數字?  在人類的世界，人們使用十進制(Decimal)。 在計算機的世界，用的是二進制(Binary)，也就是 0 與 1。  \\(1+1=10\\) \\((1,2,3,4,5,6,7,\u0026hellip;)_{10}=(001,010,011,100,101,110,111,\u0026hellip;)_2\\)   每個二進制的位元(digit)稱為 bit。 在現代計算機結構中，是由數以億計的電晶體(transistors)所組成的。  電晶體是一種具有開關(switch)性質的邏輯元件。   大部分的計算機一次用 8 個 bits，或稱 1 bytes，來表達數字。  \\(8 \\text{bits}=1 \\text{bytes}\\)    如何表達文字?  要表達文字，只需將不同的字元定義到對應的數字即可。 ASCII，American Standard Code for Information Interchange，即是一種基於拉丁字母的編碼系統，可應用顯示現代英語。  A-\u0026gt;65, B-\u0026gt;66, \u0026hellip;etc a-\u0026gt;97, b-\u0026gt;98, \u0026hellip;etc H-\u0026gt;72, I-\u0026gt;73, !-\u0026gt;33, so HI!","title":"[CS50] Lec 0 - Introduction to Computer Science"},{"content":"0. 前言  以往寫筆記通常是使用 Notion，簡單的 Markdown 語法搭配支援 LaTex，使得在撰寫學習筆記時，可以達到快速且美觀的呈現。 雖說 GitHub Pages 支援了 Markdown 的語法，但卻不支援 LaTex，這使得想將筆記從 Notion 移轉到 GitHub Pages，成為一個小缺點。 而此處介紹的是在網頁上顯示較為輕便的 KaTex。  1. 解決方法  利用 KaTex，在靜態頁面掛載 JavaScript 程式碼。 其在官網的描述是：   Beautilful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works.\n Step 1. 創建一個可常駐的靜態頁面  在 \\layouts\\partials\\ 下創建一個叫作 math.html 的頁面。  注意是 global 的 layouts 文件夾中不是 hugo themes 中的文件夾   開啟頁面之後，在 \u0026lt;head\u0026gt; 與 \u0026lt;/head\u0026gt; 之間加入下一步驟內的 JavaScript 程式碼。  Step 2. 將 JavaScript 程式碼貼入 math.html \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;  onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  上面的程式碼是將 KaTex 的渲染程式碼寫到 math.html 中。  Step 3. 將 Hugo theme 中的 header.html 複製出來  同樣將 header.html 複製到 global 下的 \\layout\\partials，並貼入  {{- /* Head custom content area start */ -}} {{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} {{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} {{- /* Head custom content area end */ -}}  上面的程式碼的功能將 math.html 嵌進 header.html 中，並以 config.yml 中的 .param.math 指令來控制。  Step 4. 開始撰寫 KaTex  一開始先將標頭的定義區將 math: true，即可開啟該頁面的 KaTex 渲染功能。 在 \\\\( 符號與 \\\\) 符號間進行 inline equation 插入。 或在 $ $ 符號與 $ $ 間進行 block equation 的插入。 LaTex 的語法可以參考https://www.cs.pu.edu.tw/~wckuo/doc/latex123/node11.html  參考來源：\n https://bend1031.github.io/ https://teddygood.github.io/posts/blog/katex/  ","permalink":"http://intervalrain.github.io/posts/ghpage/latexrendering/","summary":"0. 前言  以往寫筆記通常是使用 Notion，簡單的 Markdown 語法搭配支援 LaTex，使得在撰寫學習筆記時，可以達到快速且美觀的呈現。 雖說 GitHub Pages 支援了 Markdown 的語法，但卻不支援 LaTex，這使得想將筆記從 Notion 移轉到 GitHub Pages，成為一個小缺點。 而此處介紹的是在網頁上顯示較為輕便的 KaTex。  1. 解決方法  利用 KaTex，在靜態頁面掛載 JavaScript 程式碼。 其在官網的描述是：   Beautilful math in all browsers A JavaScript display engine for mathematics that works in all browsers. No more setup for readers. It just works.\n Step 1. 創建一個可常駐的靜態頁面  在 \\layouts\\partials\\ 下創建一個叫作 math.html 的頁面。  注意是 global 的 layouts 文件夾中不是 hugo themes 中的文件夾   開啟頁面之後，在 \u0026lt;head\u0026gt; 與 \u0026lt;/head\u0026gt; 之間加入下一步驟內的 JavaScript 程式碼。  Step 2.","title":"[ghpage] 在 GitHub Pages 中渲染 KaTex 公式"},{"content":"前言 2022/3/3 更新\n 此篇為筆者以工作經驗為背景寫下的筆記，如有錯誤煩請指教。點此聯絡我。  Ring Oscillator 環形振盪器(RO) 簡介  在 IC 電路設計中，除了 metal routing 會造成訊號的延遲，邏輯閘從高電位轉換到低電位、或從低電位轉換到高電位(switch)，也會造成相對應的 Gate Delay，然而 Gate Delay 非常小，很難以測量，故 RO 是一個便於測量 Gate Delay 的電路設計。 在 IC 電路設計中，除了考慮速度，還會考慮功耗，而邏輯閘開關所造成的動態功耗(dynamic power consumption)佔比非常大，故 Ring Oscillator 也可以用來計算閘開關的功耗。  1. Time Delay  為了方便測量 Time Delay，RO 是一種用奇數 n 個 inverter(NOT Gate) 串接成的電路。透過在輸入端振盪產生方波，經過奇數個 inverter 之後，在輸出端產生反向的方波訊號，其時間差為經過 n 個 inverter 的 time delay。利用 time delay 會透過串接 inverter 累加(或稱propagation)的性質，故可以算出單個閘極的 gate delay(\\(T_p\\), propagation time) \\(t_{HtoL}\\sim t_{LtoH}=t_p=\\Delta T/2n\\) [註] 圖為一個由3個反向器組成的環形振盪器，其輸出頻率為 \\(\\frac{1}{6}t_p\\)(Gate Delay)。 由偶數個 inverter 組成的環形電路無法構成環形振盪器，因為其輸入與輸出相同。然而這種配置可以被用作記憶體的基本單元，它是建構靜態隨機存取記憶體 SRAM (static random access memory)的基本組成。 環形振盪器通常全部由 inverter 所組成，較能抵抗環境影響。事實上也可以用 non-inverter 與 inverter 混合組成，前提是 inverter 的總數要是奇數。其振蕩器的週期等於兩倍的閘延遲(Gate delay)， 為了增加振盪頻率，通常有兩種方法  減少環形電路中的 inverter 數量。 提升電壓，但同時會有較大的電流與功耗。     2. Power consumption  分為 Dynamic Power Consumption 與 Static Power Consumption。 \\(P_{total}=a\\times f\\times(\\frac{1}{2}CV_{DD}^2+V_{DD}I_{SC})+V_{DD}I_{off}+V_{DD}I_{Diode}+V_{DD}I_{Gate}\\)  a 為 activity，每個 clock cycle 的平均開關切換數目。  故在電路設計上減少開關的次數也能有效降低功耗。   f 為頻率，代表一秒內可以完成幾次開關(switch)。     Dynamic Power(Switching Power)  為現今 CMOS 振盪器的主要功耗來源。 Dynamic Power 為 RO 在固定方波頻率為 \\(f\\) 時的平均功率(一組方波歷時為 \\(1/f\\))。 每一次開或關(switch)所耗的能為 \\(\\frac{1}{2}CV^2\\)  推導：  \\(C=\\frac{Q}{V}\\) \\(I=\\frac{dQ}{dt}=C\\frac{dV}{dt}\\) \\(W=IV=\\int_{0}^{t}CV\\frac{dV}{dt}=\\frac{1}{2}CV^2\\)     故功耗為\\(P_{dynamic}=I_{active}V=CV^2\\) 如何降低功耗?  降低 Activity  Clock Gating:  避免不必要的 flip-flop 避免 transition downstream logic 加入 enable 來控制邏輯複雜度    Data Gating:  利用 gating off inputs 來避免不必要的 toggling   Bus Encodings Freeze \u0026ldquo;Don\u0026rsquo;t cares\u0026rdquo; Remove Glitches   降低\\(C_{Load}\\) 降低\\(f\\) 降低\\(V_{DD}\\) 平行結構  可降低相同 Throughput 時的功耗   Trade off performance    Short-Circuit current  當 NMOS 與 PMOS 同時在切換開關時發生(NMOS尚未完全關閉，但PMOS已經部分啟動或是兩者相反)。  Kept to \u0026lt; 10% of capacitor charging current by making edges fast    Static Power  因為 subthreshold leakage，MOS並未完全關閉所造成的漏電流致使的功耗。 在小尺寸(\u0026lt;180nm)元件中，因為 short channel effect 的加劇，此功耗的比例會加劇，甚至達 10~40%。   Diode Leakage  Drain 端與 Source 端的 Diode junction 產生的 junction leakage。 通常很小可忽略。  Gate Leakage  因為電子穿隧穿過閘極氧化層(gate oxide)造成的漏電，通常在極薄的閘極氧化層發生，可忽略。  Reference reference1_Eletrical Engineering and Computer Science by MIT\n","permalink":"http://intervalrain.github.io/posts/device/ringoscillator/","summary":"前言 2022/3/3 更新\n 此篇為筆者以工作經驗為背景寫下的筆記，如有錯誤煩請指教。點此聯絡我。  Ring Oscillator 環形振盪器(RO) 簡介  在 IC 電路設計中，除了 metal routing 會造成訊號的延遲，邏輯閘從高電位轉換到低電位、或從低電位轉換到高電位(switch)，也會造成相對應的 Gate Delay，然而 Gate Delay 非常小，很難以測量，故 RO 是一個便於測量 Gate Delay 的電路設計。 在 IC 電路設計中，除了考慮速度，還會考慮功耗，而邏輯閘開關所造成的動態功耗(dynamic power consumption)佔比非常大，故 Ring Oscillator 也可以用來計算閘開關的功耗。  1. Time Delay  為了方便測量 Time Delay，RO 是一種用奇數 n 個 inverter(NOT Gate) 串接成的電路。透過在輸入端振盪產生方波，經過奇數個 inverter 之後，在輸出端產生反向的方波訊號，其時間差為經過 n 個 inverter 的 time delay。利用 time delay 會透過串接 inverter 累加(或稱propagation)的性質，故可以算出單個閘極的 gate delay(\\(T_p\\), propagation time) \\(t_{HtoL}\\sim t_{LtoH}=t_p=\\Delta T/2n\\) [註] 圖為一個由3個反向器組成的環形振盪器，其輸出頻率為 \\(\\frac{1}{6}t_p\\)(Gate Delay)。 由偶數個 inverter 組成的環形電路無法構成環形振盪器，因為其輸入與輸出相同。然而這種配置可以被用作記憶體的基本單元，它是建構靜態隨機存取記憶體 SRAM (static random access memory)的基本組成。 環形振盪器通常全部由 inverter 所組成，較能抵抗環境影響。事實上也可以用 non-inverter 與 inverter 混合組成，前提是 inverter 的總數要是奇數。其振蕩器的週期等於兩倍的閘延遲(Gate delay)， 為了增加振盪頻率，通常有兩種方法  減少環形電路中的 inverter 數量。 提升電壓，但同時會有較大的電流與功耗。     2.","title":"[Device] Ring Oscillator 環形振盪器"},{"content":"List of Generics equality Case In leetcode no. 39 Combination Sum gives\n Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nIt is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be use mutiple times. 7 is a candidate, and 7 = 7. These are the only two combinations.\n List Equality Consider the following case:\nList\u0026lt;Integer\u0026gt; a = Arrays.asList(1,2,3,4); List\u0026lt;Integer\u0026gt; b = Arrays.asList(4,3,2,1); List\u0026lt;Integer\u0026gt; c = Arrays.asList(4,4,3,2,1); If we apply containsAll methods to test List equality in any order, it might work. But it might not test size of List, so it might go wrong when there is repeated items.\nSystem.out.println(b.containsAll(a)) // true System.out.println(c.containsAll(a)) // true How about applying equals methods after sorting the List?\n// apply sort to all to-be-check items. Collections.sort(a); Collections.sort(b); Collections.sort(c);  System.out.println(a.equals(b)); // true System.out.println(a.equals(c)); // false Luckily, List can easily to test elements equality rathan than strict equality of the same object.\nSo, We can see if we want to test List Equality in any order, we can just simply sort List, and apply a.equals(b).\nList of List Equality But in case leetcode no. 39 Combination Sum, list of list of Integer in any order is considered acceptable answer. How do we test list of list of Integer equality?\nclass Solution{  public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target){..}   @Test  public void test(){  Solution sol = new Solution();  expected = List.of(List.of(2,2,3), List.of(7)) // [[2,2,3],[7]]  actual = sol.combinationSum(new int[]{2,3,6,7}  Collections.sort(expected); // fail  Collections.sort(actual); // fail  assertEquals(expected, acutal)  } } The code will fail, and the description shows below.\n The method sort(List) in the type Collections is not applicable for the arguments (List\u0026lt;List\u0026gt;)Java(67108979)\n Thus, we have to turns List of Integers in the List into some other type like String, by using toString(). So, we can do like this:\npublic boolean equalsAnyOrder(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; expected, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; actual){  // First we have to check size of list equaltiy  if (expected == null \u0026amp;\u0026amp; actual == null) return false;  if ((expected == null \u0026amp;\u0026amp; actual != null) || (expected != null \u0026amp;\u0026amp; actual == null) || expected.size() != actual.size()) return false;   // Create List of string to turn List of Integer into strings.  List\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;();  List\u0026lt;String\u0026gt; d = new ArrayList\u0026lt;\u0026gt;();  for (int i = 0; i \u0026lt; expected.size(); i++){  c.add(expected.get(i).toString());  d.add(actual.get(i).toString());  }   // Sort List of strings  Collections.sort(c);  Collections.sort(d);   // Apply simple list equaltiy (We have known List.equals() just test equality of elements in order.)  return c.equals(d); } More materials  Leetcode no.39 Solution Test List of List Equality Implementation Test cases for no.39 by Junit  ","permalink":"http://intervalrain.github.io/posts/java/listequal/","summary":"List of Generics equality Case In leetcode no. 39 Combination Sum gives\n Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.","title":"[Java] List of list of something equality"},{"content":"Rain Hu / intervalrain / \u0008陣雨  Music, coding, and life.\n陣雨 / 音樂使人快樂，也使人憂傷，如同陣雨。\nRain Hu / 寫程式充實生命，在生命的道路上，盲目的前行。\nintervalrain / 人生不過是一場電影或是一首歌，踟躕不如笑一個，然後繼續。\n About me  八年級，青年期的最後一個梯次。\n曾經有過音樂夢，當過吉他老師，組過樂團，當過鼓手，也曾在西餐廳駐唱表演。\n沒有隱疾，只有顯疾。人生周折而困頓，為了現實還是選擇當工程師賣肝。\n喜歡寫程式處理繁瑣重覆的事，然後拿空出來的時間作白日夢。\n喜歡唱歌、彈吉他、聽歌、看書，寫憤世嫉俗的歌，解Leetcode，吃。\n喜歡的食物有壽司、拉麵、鹹蛋苦瓜、菜脯蛋、魚香茄子、香菇雞湯。\n最喜歡的甜點有肉桂捲、可麗露、檸檬塔、藍莓塔、草莓蛋糕。\n最喜歡的水果是削好的蘋果跟切好的火龍果跟奇異果，芒果冰上面的芒果，還有所有莓果類，不能吃楊桃。\nCoffeholic，淺焙，上班日喜歡日曬，假日喜歡水洗，加班的話就蜜處理吧。\n討厭毛、討厭草、討厭昆蟲、討厭KMT、除了自己以外的機掰人。\n如果明天就要死亡的話，我會跟家人一起。\n More about me  Music  Streetvoice Youtube   Coding  Leetcode Algorithm    Contact  Email Facebook Instagram Twitter LinkedIn  ","permalink":"http://intervalrain.github.io/posts/aboutme/","summary":"Rain Hu / intervalrain / \u0008陣雨  Music, coding, and life.\n陣雨 / 音樂使人快樂，也使人憂傷，如同陣雨。\nRain Hu / 寫程式充實生命，在生命的道路上，盲目的前行。\nintervalrain / 人生不過是一場電影或是一首歌，踟躕不如笑一個，然後繼續。\n About me  八年級，青年期的最後一個梯次。\n曾經有過音樂夢，當過吉他老師，組過樂團，當過鼓手，也曾在西餐廳駐唱表演。\n沒有隱疾，只有顯疾。人生周折而困頓，為了現實還是選擇當工程師賣肝。\n喜歡寫程式處理繁瑣重覆的事，然後拿空出來的時間作白日夢。\n喜歡唱歌、彈吉他、聽歌、看書，寫憤世嫉俗的歌，解Leetcode，吃。\n喜歡的食物有壽司、拉麵、鹹蛋苦瓜、菜脯蛋、魚香茄子、香菇雞湯。\n最喜歡的甜點有肉桂捲、可麗露、檸檬塔、藍莓塔、草莓蛋糕。\n最喜歡的水果是削好的蘋果跟切好的火龍果跟奇異果，芒果冰上面的芒果，還有所有莓果類，不能吃楊桃。\nCoffeholic，淺焙，上班日喜歡日曬，假日喜歡水洗，加班的話就蜜處理吧。\n討厭毛、討厭草、討厭昆蟲、討厭KMT、除了自己以外的機掰人。\n如果明天就要死亡的話，我會跟家人一起。\n More about me  Music  Streetvoice Youtube   Coding  Leetcode Algorithm    Contact  Email Facebook Instagram Twitter LinkedIn  ","title":"About me"},{"content":"How to say hello to the world?\nJava class Hello{  public static void main(String[] args){  System.out.println(\u0026#34;Hello World!\u0026#34;);  } } C #include \u0026lt;stdio.h\u0026gt; int main(){  printf(\u0026#34;Hello World!\u0026#34;);  return 0; } C++ #include \u0026lt;iostream\u0026gt; int main(){  std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl;  return 0; } ###C#\nnamespace HelloWorld{  class Hello{  static void Main(String[] args){  System.Console.WriteLine(\u0026#34;Hello World!\u0026#34;);  }  } } Python print(\u0026#34;Hello World!\u0026#34;) Ruby puts \u0026#39;Hello World!\u0026#39; TCL Language puts \u0026#34;Hello World!\u0026#34; JavaScript console.log(\u0026#34;Hello World!\u0026#34;); TypeScript console.log \u0026#39;Hello World!\u0026#39; Perl print \u0026#34;Hello World!\u0026#34;; R cat(\u0026#39;Hello World!\u0026#39;); Swift println(\u0026#39;Hello World!\u0026#39;); Kotlin fun main(args: Array\u0026lt;String\u0026gt;){  println(\u0026#34;Hello World!\u0026#34;) } Go println(\u0026#39;Hello World!\u0026#39;); PHP echo \u0026#34;Hello World!\u0026#34;; VBA msgbox \u0026#34;Hello World\u0026#34; Assembly Language global _main extern _printf section .text _main: push message call _printf add esp, 4 message: db \u0026#39;Hello World!\u0026#39;, 11, 0 Me Hello the fucking world ","permalink":"http://intervalrain.github.io/posts/helloworld/","summary":"How to say hello to the world?\nJava class Hello{  public static void main(String[] args){  System.out.println(\u0026#34;Hello World!\u0026#34;);  } } C #include \u0026lt;stdio.h\u0026gt; int main(){  printf(\u0026#34;Hello World!\u0026#34;);  return 0; } C++ #include \u0026lt;iostream\u0026gt; int main(){  std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl;  return 0; } ###C#\nnamespace HelloWorld{  class Hello{  static void Main(String[] args){  System.Console.WriteLine(\u0026#34;Hello World!\u0026#34;);  }  } } Python print(\u0026#34;Hello World!","title":"Hello World"},{"content":"布林表達式的轉換  將文字敘述轉換成布林表達式：   \\( \\def\\arraystrecth{1.5}\\begin{array}{l} \\underbrace{\\text{The alarm will ring}}_ {Z} \\text{ iff } \\underbrace{\\text{the power of alarm is on}} _{A} \\text{ and } \\underbrace{\\text{the door is not closed}} _{B\u0026rsquo;} \\\\ \\text{ or } \\underbrace{\\text{it is after 6 p.m.}} _{C} \\text{ and } \\underbrace{\\text{the window is not closed}} _{D\u0026rsquo;} \\end{array} \\)\n  \\(Z=AB\u0026rsquo;+CD\u0026rsquo;\\)  由真值表開始建構邏輯電路  Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|c|c} A\u0026amp;B\u0026amp;C\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array} } \\) 利用 1\u0026rsquo;s 的函數\n\\(f=A\u0026rsquo; BC+AB\u0026rsquo; C\u0026rsquo;+AB\u0026rsquo; C+ABC\u0026rsquo;+ABC\\)\n\\(=A\u0026rsquo; BC+AB\u0026rsquo;+AB\\)\n\\(=A\u0026rsquo; BC+A\\)\n\\(=A+BC\\) 利用 0\u0026rsquo;s 的函數\n\\(f=(A+B+C)(A+B+C\u0026rsquo;)(A+B\u0026rsquo;+C)\\)\n\\(=(A+B)(A+B\u0026rsquo;+C)\\)\n\\(=A+B(B\u0026rsquo;+C)\\)\n\\(=A+BC\\)  Minterm 與 maxterm 展開   以 \\(F=A\u0026rsquo; BC+A\\) 為範例 \\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{c|ccc|c|c|cc} \\text{Row No.}\u0026amp;A\u0026amp;B\u0026amp;C\u0026amp;\\text{Minterns}\u0026amp;\\text{Maxterms}\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;\\text{A\u0026rsquo;B\u0026rsquo;C\u0026rsquo;}=\\text{m}_0\u0026amp;\\text{A+B+C}=\\text{M}_0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;\\text{A\u0026rsquo;B\u0026rsquo;C}=\\text{m}_1\u0026amp;\\text{A+B+C\u0026rsquo;}=\\text{M}_1\u0026amp;0\u0026amp;1\\\\ 2\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;\\text{A\u0026rsquo;BC\u0026rsquo;}=\\text{m}_2\u0026amp;\\text{A+B\u0026rsquo;+C}=\\text{M}_2\u0026amp;0\u0026amp;1\\\\ 3\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;\\text{A\u0026rsquo;BC}=\\text{m}_3\u0026amp;\\text{A+B\u0026rsquo;+C\u0026rsquo;}=\\text{M}_3\u0026amp;1\u0026amp;0\\\\ 4\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;\\text{AB\u0026rsquo;C\u0026rsquo;}=\\text{m}_4\u0026amp;\\text{A\u0026rsquo;+B+C}=\\text{M}_4\u0026amp;1\u0026amp;0\\\\ 5\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;\\text{AB\u0026rsquo;C}=\\text{m}_5\u0026amp;\\text{A\u0026rsquo;+B+C\u0026rsquo;}=\\text{M}_5\u0026amp;1\u0026amp;0\\\\ 6\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;\\text{ABC\u0026rsquo;}=\\text{m}_6\u0026amp;\\text{A\u0026rsquo;+B\u0026rsquo;+C}=\\text{M}_6\u0026amp;1\u0026amp;0\\\\ 7\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;\\text{ABC}=\\text{m}_7\u0026amp;\\text{A\u0026rsquo;+B\u0026rsquo;+C\u0026rsquo;}=\\text{M}_7\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\)\n  \\(m_i\u0026rsquo;=M_i\\)\n  \\(\\text{f=A\u0026rsquo;BC+A=1}\\)\n\\(\\text{=A\u0026rsquo;BC+AB\u0026rsquo;C\u0026rsquo;+AB\u0026rsquo;C+ABC\u0026rsquo;+ABC}\\)\n\\(=m_3+m_4+m_5+m_6+m_7\\)\n\\(=\\sum m(3,4,5,6,7)\\)\n  \\(\\text{f=(A+B+C)(A+B+C\u0026rsquo;)(A+B\u0026rsquo;+C)=0}\\)\n\\(=M_0M_1M_2\\)\n\\(=\\prod M(0,1,2)\\)\n  Maxterm 與 minterm 的轉換\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{rcl} g\u0026amp;=\u0026amp;\\sum m(2,3,4,6,7)\\\\ \u0026amp;=\u0026amp;\\prod M(0,1,5)\\\\ g\u0026rsquo;\u0026amp;=\u0026amp;\\sum m(0,1,5)\\\\ g\u0026amp;=\u0026amp;[\\sum m(0,1,5)]\u0026rsquo;\\\\ \u0026amp;=\u0026amp;\\prod m\u0026rsquo;(0,1,5)\\\\ \u0026amp;=\u0026amp;\\prod M(0,1,5) \\end{array} } \\)\n  性質：\n \\(\\boxed{\\text{m}_i\\text{m}_j=0\\text{ if i}\\neq j}\\)    未完整定義的函式(Don\u0026rsquo;t Care)  Truth table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{lll|l} A\u0026amp;B\u0026amp;C\u0026amp;F\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;X\\leftarrow \\text{Don\u0026rsquo;t care}\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;X\\leftarrow \\text{Don\u0026rsquo;t care}\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\) 表達式：  \\(F=\\sum m(0,3,7)+\\sum d(1,6)=\\prod M(2,4,5)\\cdot \\prod(1,6)\\)    Binary adders and subtracters Half Adder 半加器  \\(X,Y_{\\text{in}}\\rightarrow{\\boxed{\\text{Half Adder}}\\rightarrow \\text{Sum}}\\) Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{cc|c} X\u0026amp;Y\u0026amp;Sum\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\\\\ \\end{array} } \\) 表達式： \\(\\text{Sum}=X\u0026rsquo; Y+XY\u0026rsquo;\\)  Full Adder 全加器  \\(X,Y,C_{\\text{in}}\\rightarrow{\\boxed{\\text{Full Adder}}\\rightarrow C_{out}, \\text{Sum}}\\) Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|cc} X\u0026amp;Y\u0026amp;C_{\\text{in}}\u0026amp;C_{\\text{out}}\u0026amp;\\text{Sum}\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\) 表達式：  \\(\\text{Sum}=X\\oplus Y\\oplus C_{\\text{in}}\\) \\(C_\\text{out}=YC_{\\text{in}}+XC_{\\text{in}}+XY\\)   邏輯電路   4-Bit Parallel Adder (Ripple Carry Adder 漣波加法器)  四個平行串接的全加器 (Full Adder)   Binary Subtracter using Full Adders  用全加器來實現減法器  Full Subtracter   \\(x_i,y_i,b_i\\rightarrow\\boxed{\\text{Full Subtracter}}\\rightarrow b_{i+1},d_i\\)\n  Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|cc} x_i\u0026amp;y_i\u0026amp;b_i\u0026amp;b_{i+1}\u0026amp;d_i\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} } \\)\n  示意\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{c|cc} \u0026amp;\\text{Column i Before Borrow}\u0026amp;\\text{Column i After Borrow}\\\\\\hline x_i\u0026amp;0\u0026amp;10\u0026amp;\\\\ -b_i\u0026amp;-1\u0026amp;-1\\\\ -y_i\u0026amp;-1\u0026amp;-1\\\\\\hline d_i\u0026amp;\u0026amp;0(b_{i+1}=1)\\\\ \\end{array} } \\)\n  Parallel Subtracter Speeding up integer additions Ripple Carry Adder  一般的漣波進位加法器  設計簡單、規律 有較大的 Time Delay  一個 Full Adder 為\\(C_\\text{out}=YC_{\\text{in}}+XC_{\\text{in}}+XY\\) 也就是先 AND 再 OR，兩個 gate delay 故 n-bit adder 的 time delay 是 2n      Carry Lockahead Adder(CLA)  \\(\\text{Sum}=A\\oplus B\\oplus C_{in}\\) \\(C_{out}=AB+(A+B)C_{in}\\) \\(C_{i+1}=A_iB_i+(A_i+B_i)C_i\\) \\(C_{i+1}=g_i+p_iC_i\\)  \\(g_i=A_iB_i\\) generate function \\(p_i=A_i+B_i\\) propagate function   \\(C_2=g_1+p_1C_1\\) \\(C_2=g_1+p_1p_0g_0+p_1p_0C_0\\) \\(C_n=g_{n-1}+p_{n-1}g_{n-2}+p_{n-1}p_{n-2}g_{n-3}+\u0026hellip;+p_{n-1}p_{n-2}\u0026hellip;p_1g_0+p_{n-1}p_{n-2}\u0026hellip;p_0C_0\\) 換句話說，\\(C_n\\)可以藉由 \\(C_0\\)運算出來，以 4-bit 為例，可以從漣波的 8 次降到 5 次的 Gate delay。   Carry Select Adder  將兩個加法作平行處理  預先假設 carry-in 的值，待前一級的 carry-in 算出後再用 selector 選擇正確的 carry-in，減去收到前級 carry-in 再開始運算的時間。     Binary multiplication  用邏輯閘模擬一般十進制進位法的乘法  示意\n\\( \\def\\arraystretch{1}\\begin{array}{rcccc} \\text{Multiplicand}\u0026amp;\u0026amp;\u0026amp;B_1\u0026amp;B_0\\\\ \\text{Multiplier}\u0026amp;\u0026amp;\u0026amp;A_1\u0026amp;A_0\\\\\\hline \\text{Partial products}\u0026amp;\u0026amp;\u0026amp;A_0B_1\u0026amp;A_0B_0\\\\ \\text{shift one bit left}\u0026amp;\u0026amp;A_1B_1\u0026amp;A_1B_0\\\\ \\text{Sum of partial products}\u0026amp;C1\u0026amp;C2\u0026amp;C3\u0026amp;C4\\\\ \\end{array} \\)     ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec3/","summary":"布林表達式的轉換  將文字敘述轉換成布林表達式：   \\( \\def\\arraystrecth{1.5}\\begin{array}{l} \\underbrace{\\text{The alarm will ring}}_ {Z} \\text{ iff } \\underbrace{\\text{the power of alarm is on}} _{A} \\text{ and } \\underbrace{\\text{the door is not closed}} _{B\u0026rsquo;} \\\\ \\text{ or } \\underbrace{\\text{it is after 6 p.m.}} _{C} \\text{ and } \\underbrace{\\text{the window is not closed}} _{D\u0026rsquo;} \\end{array} \\)\n  \\(Z=AB\u0026rsquo;+CD\u0026rsquo;\\)  由真值表開始建構邏輯電路  Truth Table:\n\\( \\boxed{ \\def\\arraystretch{1}\\begin{array}{ccc|c|c} A\u0026amp;B\u0026amp;C\u0026amp;f\u0026amp;f\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0 \\end{array} } \\) 利用 1\u0026rsquo;s 的函數","title":"[Logic Design] Lec 3 - Minterm 與 Maxterm 展開"},{"content":"基本邏輯運算 Logic Gates Not Gates  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|}\\hline \\text{X}\u0026amp;\\overline{\\text{X}}\\text{or}\\text{X\u0026rsquo;}\\\\\\hline 0\u0026amp;1\\\\\\hline 1\u0026amp;0\\\\\\hline \\end{array} \\)  And Gates  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\cdot\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\)  Or Gates  Symbol  Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X+Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\)  布林表達式與真值表(Boolean Expression and Truth Table)  Boolean expression  用 ' 代表 NOT 用 + 代表 OR 用 . 代表 AND 將輸入用上面的運算子表示成算式，如：\\((A+C)(B\u0026rsquo;+C)\\)   Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{ccc|cccccc} A\u0026amp;B\u0026amp;C\u0026amp;B\u0026rsquo;\u0026amp;AB\u0026rsquo;\u0026amp;AB\u0026rsquo;+C\u0026amp;A+C\u0026amp;B\u0026rsquo;+C\u0026amp;(A+C)(B\u0026rsquo;+C)\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;1\\\\ \\end{array} \\)  基本運算定理 NOT gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x\u0026rsquo;)\u0026rsquo;\u0026amp;=\u0026amp;x \\end{array} } \\)\nAND gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x+0\u0026amp;=\u0026amp;x\\\\ x+1\u0026amp;=\u0026amp;1\\\\ x+x\u0026amp;=\u0026amp;x\\\\ x+x\u0026rsquo;\u0026amp;=\u0026amp;1 \\end{array} } \\)\nOR gate 的基本運算定理 \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\cdot 0\u0026amp;=\u0026amp;0\\\\ x\\cdot 1\u0026amp;=\u0026amp;x\\\\ x\\cdot x\u0026amp;=\u0026amp;x\\\\ x\\cdot x\u0026rsquo;\u0026amp;=\u0026amp;0 \\end{array} } \\)\n進階運算定理 交換律 Commutative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} xy\u0026amp;=\u0026amp;yx\\\\ x+y\u0026amp;=\u0026amp;y+x \\end{array} } \\)\n結合律 Associative Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (xy)z\u0026amp;=\u0026amp;x(yz)\\\\ (x+y)+z\u0026amp;=\u0026amp;x+(y+z) \\end{array} } \\)\n分配律 Distributive Law \\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026amp;=\u0026amp;xy+xz\\\\ x+yz\u0026amp;=\u0026amp;(x+y)(x+z) \\end{array} } \\)\nMultiplying out and factoring Sum of Product(SOP) form  將算式化整成各個輸入端先 AND 後再 OR 例： \\(ABC+AB\u0026rsquo;C+AB\u0026rsquo;C\u0026rsquo;\\)  Product of Sum(POS) form  將算式化整成各個輸入端先 OR 後再 AND 例： \\((A+B+C)(A+B\u0026rsquo;+C)(A+B\u0026rsquo;+C\u0026rsquo;)\\)  Multiplying out：  將算式化簡成 SOP form 善用\\(\\boxed{(A+B)(A+C)=A+BC}\\) 範例：\n\\((A+BC)(A+D+E)\\)\n\\(=(A+x)(A+y)\\)\n\\(=A+xy\\)\n\\(=A+BC(D+E)\\)\n\\(=A+BCD+BCE\\)  Factoring：  將算式化簡成 POS form 善用\\(\\boxed{A+BC=(A+B)(A+C)}\\) 範例：\n\\(AB\u0026rsquo;+C\u0026rsquo;D\\)\n\\(=(AB\u0026rsquo;+C\u0026rsquo;)(AB\u0026rsquo;+D)\\)\n\\(=(A+C\u0026rsquo;)(B\u0026rsquo;+C\u0026rsquo;)(A+D)(B\u0026rsquo;+D))\\)  2-level realization  利用 Multiplying out 與 Factoring 可以將電路簡化成 2-level circuit 因為減少了 Delay propagation 可以減少 Total Time Delay  DeMorgan\u0026rsquo;s Laws and Duality DeMorgan\u0026rsquo;s Laws  方法：  \\(AND\\leftrightarrow OR\\) \\(A\\leftrightarrow A\u0026rsquo;\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} (x+y+z+\u0026hellip;)\u0026rsquo;\u0026amp;=\u0026amp;x\u0026rsquo; y\u0026rsquo; z\u0026rsquo;\u0026hellip;\\\\ (xyz\u0026hellip;)\u0026rsquo;\u0026amp;=\u0026amp;x\u0026rsquo;+y\u0026rsquo;+z\u0026rsquo;\u0026hellip; \\end{array} } \\)   Truth Table 證明\n\\( \\def\\arraystretch{1.5}\\begin{array}{ccc|ccc|c|c|c} x\u0026amp;y\u0026amp;z\u0026amp;x\u0026rsquo;\u0026amp;y\u0026rsquo;\u0026amp;z\u0026rsquo;\u0026amp;x+y+z\u0026amp;(x+y+z)\u0026rsquo;\u0026amp;x\u0026rsquo; y\u0026rsquo; z\u0026rsquo;\\\\\\hline 0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\\\\ 0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\\\\ 1\u0026amp;1\u0026amp;1\u0026amp;0\u0026amp;0\u0026amp;0\u0026amp;1\u0026amp;0\u0026amp;0\\\\ \\end{array} \\) 範例\n\\([(A\u0026rsquo; B+C\u0026rsquo;)(D\u0026rsquo;+EF\u0026rsquo;)+GH+W]\u0026rsquo;\\)\n\\(=[(A+B\u0026rsquo;)C+D(E\u0026rsquo;+F)] (G\u0026rsquo;+H\u0026rsquo;)W\u0026rsquo;\\)  Duality   方法\n \\(AND\\leftrightarrow OR\\) \\(0\\leftrightarrow 1\\)\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{cccccccccc} [f(\u0026amp;x_1,\u0026amp;x_2,\u0026amp;\u0026hellip;,\u0026amp;x_n,\u0026amp;0,\u0026amp;1,\u0026amp;+,\u0026amp;\\cdot\u0026amp;)]^D\\\\ =f(\u0026amp;x_1,\u0026amp;x_2,\u0026amp;\u0026hellip;,\u0026amp;x_n,\u0026amp;1,\u0026amp;0,\u0026amp;\\cdot,\u0026amp;+\u0026amp;) \\end{array} } \\)    性質\n \\(\\boxed{F=G\\rightarrow F^D=G^D}\\)    範例\n\\((x+y\u0026rsquo;)y=xy\\rightarrow x\\cdot y\u0026rsquo;+y=x+y\\)\n  回顧分配律 Distributive Law，即為 Duality 的表現。\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x(y+z)\u0026amp;=\u0026amp;xy+xz\\\\ x+yz\u0026amp;=\u0026amp;(x+y)(x+z) \\end{array} } \\)\n  Exclusive-OR and equivalence operations Exlusive-OR(XOR,\\(\\oplus\\))  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\oplus\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;0\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\oplus 0\u0026amp;=\u0026amp;x\\\\ x\\oplus 1\u0026amp;=\u0026amp;x\u0026rsquo;\\\\ x\\oplus x\u0026amp;=\u0026amp;0\\\\ x\\oplus x\u0026rsquo;\u0026amp;=\u0026amp;1\\\\ x\\oplus y\u0026amp;=\u0026amp;y\\oplus x\\\\ (x\\oplus y)\\oplus z\u0026amp;=\u0026amp;x\\oplus (y\\oplus z)\\\\ x(y\\oplus z)\u0026amp;=\u0026amp;xy\\oplus xz\\\\ x\\oplus y\u0026amp;=\u0026amp;xy+x\u0026rsquo; y' \\end{array} } \\)  Equivalence(\\(\\equiv\\))  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\equiv{Y}\\\\\\hline 0\u0026amp;0\u0026amp;1\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\) 性質：\n\\( \\boxed{ \\def\\arraystretch{1.5}\\begin{array}{ccc} x\\equiv 0\u0026amp;=\u0026amp;x\u0026rsquo;\\\\ x\\equiv 1\u0026amp;=\u0026amp;x\\\\ x\\equiv x\u0026amp;=\u0026amp;1\\\\ x\\equiv x\u0026rsquo;\u0026amp;=\u0026amp;0\\\\ x\\equiv y\u0026amp;=\u0026amp;y\\equiv x\\\\ (x\\equiv y)\\equiv z\u0026amp;=\u0026amp;x\\equiv (y\\equiv z)\\\\ x(y\\equiv z)\u0026amp;=\u0026amp;xy\\equiv xz\\\\ x\\equiv y\u0026amp;=\u0026amp;xy\u0026rsquo;+x\u0026rsquo; y \\end{array} } \\)  連鎖律 The consensus thorem  公式：  \\(\\boxed{xy+x\u0026rsquo; z+yz=xy+x\u0026rsquo; z}\\) \\(\\boxed{(x+y)(x\u0026rsquo;+z)(y+z)=(x+y)(x\u0026rsquo;+z)}\\)   證明：\n\\(xy+x\u0026rsquo; z+yz\\)\n\\(=xy+x\u0026rsquo; z + (x+x\u0026rsquo;)yz\\)\n\\(=xy+xyz+x\u0026rsquo; z+x\u0026rsquo; yz\\)\n\\(=xy(1+z)+x\u0026rsquo; z(1+y)\\)\n\\(=xy+x\u0026rsquo; z\\)  簡化布林表達式的流程  利用 \\(\\boxed{xy+xy\u0026rsquo;=x(y+y\u0026rsquo;)=x}\\)(AND性質) 利用 \\(\\boxed{x+xy+\u0026hellip;=x(1+y+\u0026hellip;)=x}\\)(OR性質) 利用 \\(\\boxed{xy+x\u0026rsquo; z+yz=xy+x\u0026rsquo;z }\\)(連鎖律) 利用 \\(\\boxed{x+x\u0026rsquo;y=x(y+y\u0026rsquo;)+x\u0026rsquo;y=xy+xy\u0026rsquo;+x\u0026rsquo; y=x+y}\\) 必要時加入 redundant terms   Lec3會使用圖表法，較不容易出錯。  如何證明布林表達式的正確性?  建構 Truth Table 簡化 LHS 和 RHS  ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec2/","summary":"基本邏輯運算 Logic Gates Not Gates  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|}\\hline \\text{X}\u0026amp;\\overline{\\text{X}}\\text{or}\\text{X\u0026rsquo;}\\\\\\hline 0\u0026amp;1\\\\\\hline 1\u0026amp;0\\\\\\hline \\end{array} \\)  And Gates  Symbol  Truth Table\n\\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X}\\cdot\\text{Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;0\\\\\\hline 1\u0026amp;0\u0026amp;0\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\)  Or Gates  Symbol  Truth Table \\( \\def\\arraystrecth{1.5}\\begin{array}{|c|c|c|}\\hline \\text{X}\u0026amp;\\text{Y}\u0026amp;\\text{Z=X+Y}\\\\\\hline 0\u0026amp;0\u0026amp;0\\\\\\hline 0\u0026amp;1\u0026amp;1\\\\\\hline 1\u0026amp;0\u0026amp;1\\\\\\hline 1\u0026amp;1\u0026amp;1\\\\\\hline \\end{array} \\)  布林表達式與真值表(Boolean Expression and Truth Table)  Boolean expression  用 ' 代表 NOT 用 + 代表 OR 用 .","title":"[Logic Design] Lec 2 - 布林代數"},{"content":"數位系統與開關電路  在現實世界中，資訊是以類比(Analog)的方式傳遞的，換言之，資訊是連續的 在電腦世界中，資訊是以數位(Digital)的方式傳遞的，也就是開與關或是0或1。 A/D \u0026lt;-\u0026gt; DSP(digital signal processor) \u0026lt;-\u0026gt; D/A   Switching Circuit  可分為三個層級：  System: 模組Modules、算術運算單元 ALU(Arithmetic logic unit)、記憶體 Memory Logic：邏輯閘(gates) Circuit：電晶體(transistors)   經由 switching network 的設計，可將輸入轉成合乎 spec 的輸出。其中 switching network 的種類包含：  Combinational network  輸出是輸入的函數，且表達當下的值。   Sequential network  輸出是輸入的函數，可以表達當下的值或是過去的值。 具有記憶體的行為   Switches  由電晶體來實現 transistor level, gate level, module level\u0026hellip;      數字系統與轉換  在現實世界中，最普遍使用的數字系統為十進制(Decimal) 然而在電腦世界中，因為只有代表開與關的 0 與 1，故使用的數字系統是以二進制(Binary)為基礎。  \\(N=(a_2a_1a_0)_R=a_2\\times R^2+a_1\\times R^1+a_0\\times R^0\\)    負數    N 正數表示 -N 正數加負號 1的補數 2的補數     +0 0000 -0 1000 1111 N/A   +1 0001 -1 1001 1110 1111   +2 0010 -2 1010 1101 1110   +3 0011 -3 1011 1100 1101   +4 0100 -4 1100 1011 1100   +5 0101 -5 1101 1010 1011   +6 0110 -6 1110 1001 1010   +7 0111 -7 1111 1000 1001   +8 N/A -8 N/A N/A 1000    二進制算數  當兩數相加或兩數相減時，超過可用bits數時會發生overflow，  例如-3+-4=-4是OK的 但-5+-6=-11會產生溢位    二進制的表達方式 Binary codes    Decimal Digit 8421 Code(BCD) 6311 Code Excess-3 Code 2-out-of-5 Code Gray Code     0 0000 0000 0011 00011 0000   1 0001 0001 0100 00101 0001   2 0010 0011 0101 00110 0011   3 0011 0100 0110 01001 0010   4 0100 0101 0111 01010 0110   5 0101 0111 1000 01100 1110   6 0110 1000 1001 10001 1010   7 0111 1001 1010 10010 1011   8 1000 1011 1011 10100 1001   9 1001 1100 1100 11000 1000    Weighted Codes  8421 Code 與 6311 都是 Weighted Code，代表每4個bit，各自代表的數字，  例：1011 for 8421 = 8 + 0 + 2 + 1 = 11 例：1011 for 6311 = 6 + 0 + 1 + 1 = 8    Excess-3 Codes  Excess-3 是以 8421 Code 為基礎下，額外加 3。 使得 i 與 10-i 互為 1 的補數，  0 與 9 為補數。(0011 與 1100) 1 與 8 為補數。(0100 與 1011) 2 與 7 為補數。(0101 與 1010) 3 與 6 為補數。(0110 與 1001) 4 與 5 為補數。(0111 與 1000)    Gray Codes  兩相鄰的數只會相差一個 bit 又名 Reflected Binary Codes(RBC)、Unit distance code、Minimum error code 可以減少 switching operation 如何轉換 Gray Code? 參考Leetcode no.89  ASCII table ","permalink":"http://intervalrain.github.io/posts/logicdesign/lec1/","summary":"數位系統與開關電路  在現實世界中，資訊是以類比(Analog)的方式傳遞的，換言之，資訊是連續的 在電腦世界中，資訊是以數位(Digital)的方式傳遞的，也就是開與關或是0或1。 A/D \u0026lt;-\u0026gt; DSP(digital signal processor) \u0026lt;-\u0026gt; D/A   Switching Circuit  可分為三個層級：  System: 模組Modules、算術運算單元 ALU(Arithmetic logic unit)、記憶體 Memory Logic：邏輯閘(gates) Circuit：電晶體(transistors)   經由 switching network 的設計，可將輸入轉成合乎 spec 的輸出。其中 switching network 的種類包含：  Combinational network  輸出是輸入的函數，且表達當下的值。   Sequential network  輸出是輸入的函數，可以表達當下的值或是過去的值。 具有記憶體的行為   Switches  由電晶體來實現 transistor level, gate level, module level\u0026hellip;      數字系統與轉換  在現實世界中，最普遍使用的數字系統為十進制(Decimal) 然而在電腦世界中，因為只有代表開與關的 0 與 1，故使用的數字系統是以二進制(Binary)為基礎。  \\(N=(a_2a_1a_0)_R=a_2\\times R^2+a_1\\times R^1+a_0\\times R^0\\)    負數    N 正數表示 -N 正數加負號 1的補數 2的補數     +0 0000 -0 1000 1111 N/A   +1 0001 -1 1001 1110 1111   +2 0010 -2 1010 1101 1110   +3 0011 -3 1011 1100 1101   +4 0100 -4 1100 1011 1100   +5 0101 -5 1101 1010 1011   +6 0110 -6 1110 1001 1010   +7 0111 -7 1111 1000 1001   +8 N/A -8 N/A N/A 1000    二進制算數  當兩數相加或兩數相減時，超過可用bits數時會發生overflow，  例如-3+-4=-4是OK的 但-5+-6=-11會產生溢位    二進制的表達方式 Binary codes    Decimal Digit 8421 Code(BCD) 6311 Code Excess-3 Code 2-out-of-5 Code Gray Code     0 0000 0000 0011 00011 0000   1 0001 0001 0100 00101 0001   2 0010 0011 0101 00110 0011   3 0011 0100 0110 01001 0010   4 0100 0101 0111 01010 0110   5 0101 0111 1000 01100 1110   6 0110 1000 1001 10001 1010   7 0111 1001 1010 10010 1011   8 1000 1011 1011 10100 1001   9 1001 1100 1100 11000 1000    Weighted Codes  8421 Code 與 6311 都是 Weighted Code，代表每4個bit，各自代表的數字，  例：1011 for 8421 = 8 + 0 + 2 + 1 = 11 例：1011 for 6311 = 6 + 0 + 1 + 1 = 8    Excess-3 Codes  Excess-3 是以 8421 Code 為基礎下，額外加 3。 使得 i 與 10-i 互為 1 的補數，  0 與 9 為補數。(0011 與 1100) 1 與 8 為補數。(0100 與 1011) 2 與 7 為補數。(0101 與 1010) 3 與 6 為補數。(0110 與 1001) 4 與 5 為補數。(0111 與 1000)    Gray Codes  兩相鄰的數只會相差一個 bit 又名 Reflected Binary Codes(RBC)、Unit distance code、Minimum error code 可以減少 switching operation 如何轉換 Gray Code?","title":"[Logic Design] Lec 1 - 數字系統與轉換"}]