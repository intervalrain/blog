<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43;s | Rain Hu&#39;s Workspace</title>
<meta name="keywords" content="" />
<meta name="description" content="C&#43;&#43;s - Rain Hu&#39;s Workspace">
<meta name="author" content="Rain Hu, intervarrain, 陣雨">
<link rel="canonical" href="https://intervalrain.github.io/c&#43;&#43;/" />
<meta name="google-site-verification" content="XYZabc" />
<meta name="msvalidate.01" content="XYZabc" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.a17c641b9e6ec5ee7bc49a565650096f69ae478de79da3309cb62f6993aaa8d0.css" integrity="sha256-oXxkG55uxe57xJpWVlAJb2muR43nnaMwnLYvaZOqqNA=" rel="preload stylesheet" as="style">
<link rel="preload" href="/images/rain.png" as="image">
<link rel="icon" href="https://intervalrain.github.io/images/rain.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://intervalrain.github.io/images/rain.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://intervalrain.github.io/images/rain.png">
<link rel="apple-touch-icon" href="https://intervalrain.github.io/images/rain.png">
<link rel="mask-icon" href="https://intervalrain.github.io/images/rain.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://intervalrain.github.io/c&#43;&#43;/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script src="https://utteranc.es/client.js"
    repo="intervalrain.github.io"
    issue-term="pathname"
    label="Comment"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script><meta property="og:title" content="C&#43;&#43;s" />
<meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://intervalrain.github.io/c&#43;&#43;/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;s"/>
<meta name="twitter:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"/>
<meta name="twitter:site" content="@intervalrain"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "C++s",
      "item": "https://intervalrain.github.io/c++/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://intervalrain.github.io/" accesskey="h" title="Rain Hu&#39;s Workspace (Alt + H)">
                <img src="https://intervalrain.github.io/images/rain.png" alt="logo" aria-label="logo"
                    height="35">Rain Hu&#39;s Workspace</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://intervalrain.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/aboutme" title="About me">
                    <span>About me</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/csharp/csharp" title="C#">
                    <span>C#</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/csindex" title="CS">
                    <span>CS</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/leetcode" title="LeetCode">
                    <span>LeetCode</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://intervalrain.github.io/">Home</a></div>
  <h1>C&#43;&#43;s</h1>
</header>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] Segment Tree
    </h2>
  </header>
  <section class="entry-content">
    <p>線段樹 Segment Tree 簡介  線段樹是演算法中常用來維護區間訊息的資料結構。 空間複雜度為 \(O(n)\)，\(n\) 代表區間數。 查詢的時間複雜度為 \(O(\log n&#43;k)\)，\(k\) 代表符合條件的區間數量。 線段樹將每個長度為為 1 的區間劃分為左右兩個區間遞迴求解，把整個線段劃分為一個樹型結構，通過合併左右兩個區間訊息來求得該區間的訊息。 在實現時，我們考慮遞迴建樹，設當前的根節點為 root，如果根節點管轄的區間長度已經是 1，則可以直接根據數組上相應位置的值初始化該節點。否則需將該區間從中點處分割為兩個子區間，分別進入左右子節點遞迴建樹，最後合併兩個子節點的訊息，  建樹 build void build(int s, int t, int p, const vector&lt;int&gt;&amp; arr){  if (s == t){  tree[p] = SegmentItem(arr[s], 1);  return;  }  int m = s &#43; ((t - s) &gt;&gt; 1);  build(s, m, p*2, arr);  build(m&#43;1, t, p*2&#43;1, arr);  // push_up  tree[p] = tree[p*2] &#43; tree[(p*2)&#43;1]; } 查詢 query SegmentItem find(int l, int r, int s, int t, int p){  if (l &lt;= s &amp;&amp; t &lt;= r){  return tree[p];  }  int m = s &#43; ((t - s) &gt;&gt; 1);  SegmentItem sum;  if (r &lt;= m) return find(l, r, s, m, p*2);  if (l &gt; m) return find(l, r, m&#43;1, t, p*2&#43;1);  return find(l, r, s, m, p*2) &#43; find(l, r, m&#43;1, t, p*2&#43;1); } zkw 線段樹  來自清華大學張昆瑋(zkw)-《統計的力量》 以非遞迴的方式構建，效率更高，程式更短。 普通的線段樹是從上到下做處理，容易定位根節點，卻不容易定位子節點。 zkw 線段樹是當二叉樹是滿二叉樹時，因為子節點的編號具有以下規律：  葉子節點(left) 全部退化為線段 \([x,x]\) 。 \(n\) 個數據點則取大於等 \(n\)且為 \(2\) 的冪次的兩倍作為數組大小。 \((m=2^a\ge n)\) for (int m = 1; m &lt;= n; m &gt;&gt;= 1)  維護點為 \(n\) 個。索引為\([m,m&#43;n)\)。 子葉數目為 \(m\) 個。索引為\([m,2m)\) 節點數為 \(2m-1\) 個。(數組大小需設 \(2m\) 因為 zkw tree是 1-index的) 樹高 \(H=\log_2(m)&#43;1\) 層。  第 \(h\) 層有 \(2^{h-1}\) 個節點， 該層線段長度為 \(2^{H-h}\)。   若某節點為 \(p\)，父節點為 \(p/2\)，子節點為 \(2p\) 和 \(2p&#43;1\) int parent = p &gt;&gt; 1; int left = p &lt;&lt; 1; int right = p &lt;&lt; 1 | 1;  若兩節點為 \(p\) 與 \(q\)，且兩節點互為兄弟節點，則 \(p\oplus q=1\) if (left ^ right)  // left 與 right 為兄弟節點 else  // left 與 right 不為兄弟節點  除根節點外，左節點皆為偶數，右節點皆為奇數 if (i == 1)  // i 為根節點 else if (i &amp; 1)  // i 為奇數，為右節點 else if (!...</p>
  </section>
  <footer class="entry-footer"><span title='2022-10-18 23:14:38 +0800 CST'>October 18, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] Segment Tree" href="https://intervalrain.github.io/c&#43;&#43;/segtree/"></a>
</article>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] stringstream 類範例 - split 與 concat
    </h2>
  </header>
  <section class="entry-content">
    <p>stringstream  需引用 &lt;sstream&gt; , &lt;iostream&gt;, &lt;string&gt;函式庫 配合 str() 將 stringstream 類轉換成 string 類別。  split() vector&lt;string&gt; split(string&amp; str, char del){  stringstream ss(str);  string item;  vector&lt;string&gt; res;  while (getline(ss, item, del)){  if (!item.empty()){  res.push_back(item);  }  }  return res; } concat() string concat(vector&lt;string&gt;&amp; svec, char del){  stringstream ss;  for (const auto&amp; s : svec){  ss &lt;&lt; s &lt;&lt; del;  }  return ss....</p>
  </section>
  <footer class="entry-footer"><span title='2022-10-14 00:21:23 +0800 CST'>October 14, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] stringstream 類範例 - split 與 concat" href="https://intervalrain.github.io/c&#43;&#43;/stringstream/"></a>
</article>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - deque
    </h2>
  </header>
  <section class="entry-content">
    <p>Deque  不同於 stack 與 queues， deques 兩個端點都支援擴展。 基於 doubly linked list，deques 有幾項額外的特徵：  支援隨機存取 插入元素時間 \(O(1)\)    函式 1. push_front() 2. push_back() 3. front() 4. back() 5. begin() 6. end() 7. insert() 8. erase() 9. pop_front() 10. pop_back() 11. empty() 12. clear() 13. random_access() 內部運作原理  上述所有函數和操作都在雙鏈表中以O（1）時間執行，但這些清單不能隨機訪問任何元素。C&#43;&#43;中的deque也是如此。這個 O（1） 在 deque 中可以使用圓形陣列來實現。使用循環陣列，可以在O（1）時間內實現從陣列的正面和背面插入和刪除等操作以及元素的隨機訪問。但這帶來了一個問題。當 deque 增長到超出容量時，使用者將需要將數位大小加倍，並將所有數據複製到陣列中。此外，如果數據是某個使用者定義的對象，那麼加倍和複製數據的成本就會變得非常昂貴。 這是一個基本的解決方案。Deque使用一些棘手的實現，當它說O（1）來push_back（）和push_front（）時，它實際上是調用的複製構造函數數量的常數時間。因此，如果數據物件是具有多個成員的某個類物件，則最小化複製構造函數調用的數量將節省時間。此外，複製構造函數調用的次數是恆定的。現在讓我們看看如何實現這一點。   這可以通過使用指向一些固定大小的塊的指標數位來實現，這些塊包含deque數據。下面是一個說明性示例。 這些 Deque 數據被劃分為固定大小的塊。在這裡，我們考慮了將數據劃分為大小為5的固定塊。 塊的填充從指標的兩個 deque 陣列的中間開始，並使用push_front和push_back操作向前和向後擴展。中間塊通常是滿的，當它被填滿時，數據被移動到上部或下部塊。 在上部塊中，元素以相反的順序推送，因為在這種情況下，填充數據的第一個位置將是4，然後是3，2，1，0。但是在中間和下部塊中，數據按正向順序填充，如0，1，2，3，4等。 當上面的塊被填滿時，指標將創建一個新塊並開始指向一個新的數位塊。這為更多數據創造了空間。在這種情況下，也可以填充指標塊。這會導致一個問題。 這是加倍來救援的時候。在加倍時，指標陣列的大小加倍。這不會複製整個數據，而只會複製指標。這是許多人在討論恆定時間時提出的一般論點。時間在調用的複製構造函數數方面保持不變。 如果數據集非常大，則指標塊幾乎不會執行加倍，因為單個指標可以指向大量數據塊。因此，指標陣列被填充並加倍的可能性非常小。  </p>
  </section>
  <footer class="entry-footer"><span title='2022-06-12 01:36:18 +0800 CST'>June 12, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - deque" href="https://intervalrain.github.io/c&#43;&#43;/stl_deque/"></a>
</article>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] Custom Comparator
    </h2>
  </header>
  <section class="entry-content">
    <p>C&#43;&#43; Custom Comparator sort(iter, iter, comp) Lambda function int main(){  auto comp = [](int a, int b){ return a &lt; b; }  vector&lt;int&gt; = {3,6,7,2,1,9,5,4,8};  sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Usual boolean function bool comp(const int&amp; a, const int&amp; b){  return a &lt; b; } int main(){  vector&lt;int&gt; = {3,6,7,2,1,9,5,4,8};  sort(vec.begin(), vec.end(), comp); // 1,2,3,4,5,6,7,8,9 } Old solution using struct/class with () operator struct cmp {  bool operator() (int a, int b) const {  return a &lt; b;  } }; int main(){  vector&lt;int&gt; = {3,6,7,2,1,9,5,4,8};  sort(vec....</p>
  </section>
  <footer class="entry-footer"><span title='2022-06-11 10:07:49 +0800 CST'>June 11, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] Custom Comparator" href="https://intervalrain.github.io/c&#43;&#43;/custom_comparator/"></a>
</article>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - pair
    </h2>
  </header>
  <section class="entry-content">
    <p>pair 函式庫  #include &lt;utility&gt;  宣告  pair&lt;data_type1, data_type2&gt; Pair_name;  初始化 pair&lt;int, int&gt; p1; // 宣告但不初始化 pair&lt;int, char&gt; p2(1, &#39;a&#39;); // 不同資料型態的初始化 pair&lt;int, int&gt; p3(1, 10); // 同資料型態的初始化 pair&lt;int, int&gt; p4(p3); // 利用其它 pair 來初始化 pair&lt;int, int&gt; p5 = {1, 2} // 用 assign 的方式初始化  p2 = make_pair(1, &#39;a&#39;); // 利用 make_pair 函式 成員  .first .second  函式 1. make_pair(v1, v2); 2. pair1.swap(pair2); 3. tie(a,b) 示例 #include &lt;iostream&gt;#include &lt;utility&gt;using namespace std;  int main(){  // initialize  pair&lt;int,int&gt; p1;  pair&lt;int,int&gt; p2(2,4);  pair&lt;int,char&gt; p3(3,&#39;c&#39;);  pair&lt;int,int&gt; p4(p2);  pair&lt;int,int&gt; p5 = {5,10};   // member  cout &lt;&lt; p2....</p>
  </section>
  <footer class="entry-footer"><span title='2022-06-02 01:23:15 +0800 CST'>June 2, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - pair" href="https://intervalrain.github.io/c&#43;&#43;/stl_pair/"></a>
</article>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - map
    </h2>
  </header>
  <section class="entry-content">
    <p>map 宣告 map &lt;int, int&gt; mp; // key和value都是整數 方法 mp[key] = value;  加入新的key-value pair  mp.count(key);  檢查 key 是否存在 map 中  mp.erase(key);  刪除 key  mp.clear();  清空 map 中的所有元素：  value = mp[key]  利用 key 取值  mp.empty()  判斷是否為空的map  map 的遍歷  遍歷整個map時，利用iterator操作： 取key：it-&gt;first 或 *(it).first 取value：it-&gt;second 或 *(it).second  for (auto it = mp.begin(); it != mp.end(); &#43;&#43;it){  cout &lt;&lt; it-&gt;first &lt;&lt; &#34; =&gt; &#34; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;; }  for (auto it = mp....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-23 22:24:21 +0800 CST'>April 23, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - map" href="https://intervalrain.github.io/c&#43;&#43;/stl_map/"></a>
</article>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] 易錯題目收集
    </h2>
  </header>
  <section class="entry-content">
    <p>C&#43;&#43; 易錯題目收集 1. bit-format expression #include &lt;bits/stdc&#43;&#43;.h&gt;using namespace std; int main(){  unsigned int x = -1;  int y = ~0;  if (x==y)  cout &lt;&lt; &#34;same&#34;;  else  cout &lt;&lt; &#34;not same&#34;;  return 0; }  結果  same  解析  unsigned int x = -1 相當於11111111 y = ~0 也相當於11111111     2. 如何使 C(n,3) 正確且 n 的有效值最大?  結果  return n*(n-1)/2*(n-2)/3;  解析  n*(n-1)必為基偶相乘 n*(n-1)*(n-2)必為3的倍數 故此題的作法可避免因整數除法而造成的小數位消去     3....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-17 17:34:39 +0800 CST'>April 17, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] 易錯題目收集" href="https://intervalrain.github.io/c&#43;&#43;/question/"></a>
</article>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - list, forward_list
    </h2>
  </header>
  <section class="entry-content">
    <p>list  Lists 是序列式容器，但其記憶體的分配並非連續的。 跟 vector 相比，其遍歷的速度會較慢\(O(n)\，但一旦位置確定後，其插入(insert)或移除(delete)元素的速度很快\(O(1)\)。 一般來說，List 指的是雙向鏈結陣列(doubly linked list)。 而單向鏈結陣列則為 forward_list  函式庫  #include &lt;list&gt;  宣告  list&lt;data_type&gt; list_name;  初始化 list&lt;int&gt; lst; // 宣告 函式 1. front() 2. back() 3. push_front() 4. push_back() 5. pop_front() 6. pop_back() 7. list::begin() 8. list::end() 9. list::rbegin() 10. list::rend() 11. list::cbegin() 12. list::cend() 13. list::crbegin() 14. list::crend() 15. empty() 16. insert() 17. erase() 18. assign() 19. remove() 20. list::remove_if() 21....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-17 11:45:58 +0800 CST'>April 17, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - list, forward_list" href="https://intervalrain.github.io/c&#43;&#43;/stl_list/"></a>
</article>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - vector
    </h2>
  </header>
  <section class="entry-content">
    <p>vector  Vectors 是一動態陣列，可以自動的調整其容器的容量。 Vector 的元素被儲存在連續的記憶體空間，所以可以使用迭代器(iterators)來進行存取。 在 vectors 中，元素是被插入在尾端的，插入尾端的時間取決於是否須進行容量的調整。 在 vectors 中，刪除尾端元素的時間複雜度則是固定的\(O(1)\)，因為不會發生容量調整。 在 vectors 的前端或中間插入元素或是清除元素，時間的複雜度都是\(O(n)\)。  迭代器(Iterators) 1. vec.begin()  回傳指向 vector 中第一個元素的迭代器 (vec[0])  2. vec.end()  回傳指向 vector 中最後一個元素之後一個的迭代器 (vec[n&#43;1])  3. vec.rbegin()  回傳指向 vector 中最後一個元素的反向迭代器 (vec[n])  4. vec.rend()  回傳指向 vector 中第一個元素之前一個的反向迭代器 (vec[-1])  5. vec.cbegin()  回傳指向 vector 中第一個元素的常數迭代器 (vec[0])  6. vec.cend()  回傳指向 vector 中最後一個元素之後一個的常數迭代器 (vec[n&#43;1])  7. vec.crbegin()  回傳指向 vector 中最後一個元素的反向常數迭代器 (vec[n])  8....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-16 22:08:37 +0800 CST'>April 16, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - vector" href="https://intervalrain.github.io/c&#43;&#43;/stl_vector/"></a>
</article>

<article class="post-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Container
    </h2>
  </header>
  <section class="entry-content">
    <p>容器(Containers)  C&#43;&#43; container 基本上分為四大類：  Sequence containers Container adaptors Associative containers Unordered associative containers 還有兩個特殊 containers: valarray, bitset    \(\begin{array}{|l|l|l|l|l|l|}\hline \text{Name}&amp;\text{Iterators}&amp;\text{Capacity}&amp;\text{Access}&amp;\text{Modifiers}&amp;\text{Others} \\\hline \text{array}&amp;\text{begin}&amp;\text{size}&amp;\text{[]}&amp;\text{swap} \\&amp;\text{end}&amp;\text{empty}&amp;\text{at} \\&amp;&amp;&amp;\text{front} \\&amp;&amp;&amp;\text{back} \\\hline \text{vector}&amp;\text{begin}&amp;\text{size}&amp;\text{[]}&amp;\text{push\_back}&amp;\text{} \\&amp;\text{end}&amp;\text{empty}&amp;\text{at}&amp;\text{pop\_back} \\&amp;&amp;\text{capacity}&amp;\text{front}&amp;\text{insert} \\&amp;&amp;&amp;\text{back}&amp;\text{erase} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \text{deque}&amp;\text{begin}&amp;\text{size}&amp;\text{[]}&amp;\text{push\_back}&amp;\text{} \\&amp;\text{end}&amp;\text{empty}&amp;\text{at}&amp;\text{pop\_back} \\&amp;&amp;&amp;\text{front}&amp;\text{insert} \\&amp;&amp;&amp;\text{back}&amp;\text{erase} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \text{list}&amp;\text{begin}&amp;\text{size}&amp;\text{front}&amp;\text{push\_back}&amp;\text{sort} \\&amp;\text{end}&amp;\text{empty}&amp;\text{back}&amp;\text{pop\_back}&amp;\text{reverse} \\&amp;&amp;&amp;&amp;\text{insert} \\&amp;&amp;&amp;&amp;\text{erase} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \text{forward\_list}&amp;\text{begin}&amp;\text{empty}&amp;\text{front}&amp;\text{push\_front}&amp;\text{sort} \\&amp;\text{end}&amp;&amp;&amp;\text{pop\_back}&amp;\text{reverse} \\&amp;&amp;&amp;&amp;\text{insert\_after} \\&amp;&amp;&amp;&amp;\text{erase\_after} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \end{array} \)
基礎容器 pair 序列式容器(Sequence Containers)  特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。  vector list, forward_list deque arrays 容器適配器(Container Adaptors)  用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。  queue priority_queue stack 關聯性容器(Associative Containers)  又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。  set multiset map multimap 無序關聯容器(Unordered Associative Containers(C&#43;&#43;11))  通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。  unordered_set unordered_multiset unordered_map unordered_mutlimap  你可能會想繼續閱讀…  演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library    </p>
  </section>
  <footer class="entry-footer"><span title='2022-04-15 01:09:18 +0800 CST'>April 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Container" href="https://intervalrain.github.io/c&#43;&#43;/stl_container/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://intervalrain.github.io/c&#43;&#43;/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://intervalrain.github.io/">Rain Hu&#39;s Workspace</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
