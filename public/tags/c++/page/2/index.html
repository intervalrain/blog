<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43; | Rain Hu&#39;s Workspace</title>
<meta name="keywords" content="" />
<meta name="description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊">
<meta name="author" content="Rain Hu, intervarrain, 陣雨">
<link rel="canonical" href="https://intervalrain.github.io/tags/c&#43;&#43;/" />
<meta name="google-site-verification" content="XYZabc" />
<meta name="msvalidate.01" content="XYZabc" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.a17c641b9e6ec5ee7bc49a565650096f69ae478de79da3309cb62f6993aaa8d0.css" integrity="sha256-oXxkG55uxe57xJpWVlAJb2muR43nnaMwnLYvaZOqqNA=" rel="preload stylesheet" as="style">
<link rel="preload" href="/images/rain.png" as="image">
<link rel="icon" href="https://intervalrain.github.io/images/rain.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://intervalrain.github.io/images/rain.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://intervalrain.github.io/images/rain.png">
<link rel="apple-touch-icon" href="https://intervalrain.github.io/images/rain.png">
<link rel="mask-icon" href="https://intervalrain.github.io/images/rain.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://intervalrain.github.io/tags/c&#43;&#43;/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script src="https://utteranc.es/client.js"
    repo="intervalrain.github.io"
    issue-term="pathname"
    label="Comment"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script><meta property="og:title" content="C&#43;&#43;" />
<meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://intervalrain.github.io/tags/c&#43;&#43;/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;"/>
<meta name="twitter:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"/>
<meta name="twitter:site" content="@intervalrain"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://intervalrain.github.io/" accesskey="h" title="Rain Hu&#39;s Workspace (Alt + H)">
                <img src="https://intervalrain.github.io/images/rain.png" alt="logo" aria-label="logo"
                    height="35">Rain Hu&#39;s Workspace</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://intervalrain.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/aboutme" title="About me">
                    <span>About me</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/csharp/csharp" title="C#">
                    <span>C#</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/csindex" title="CS">
                    <span>CS</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/leetcode" title="LeetCode">
                    <span>LeetCode</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://intervalrain.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://intervalrain.github.io/tags/">Tags</a></div>
  <h1>C&#43;&#43;</h1>
</header>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Container
    </h2>
  </header>
  <section class="entry-content">
    <p>容器(Containers)  C&#43;&#43; container 基本上分為四大類：  Sequence containers Container adaptors Associative containers Unordered associative containers 還有兩個特殊 containers: valarray, bitset    \(\begin{array}{|l|l|l|l|l|l|}\hline \text{Name}&amp;\text{Iterators}&amp;\text{Capacity}&amp;\text{Access}&amp;\text{Modifiers}&amp;\text{Others} \\\hline \text{array}&amp;\text{begin}&amp;\text{size}&amp;\text{[]}&amp;\text{swap} \\&amp;\text{end}&amp;\text{empty}&amp;\text{at} \\&amp;&amp;&amp;\text{front} \\&amp;&amp;&amp;\text{back} \\\hline \text{vector}&amp;\text{begin}&amp;\text{size}&amp;\text{[]}&amp;\text{push\_back}&amp;\text{} \\&amp;\text{end}&amp;\text{empty}&amp;\text{at}&amp;\text{pop\_back} \\&amp;&amp;\text{capacity}&amp;\text{front}&amp;\text{insert} \\&amp;&amp;&amp;\text{back}&amp;\text{erase} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \text{deque}&amp;\text{begin}&amp;\text{size}&amp;\text{[]}&amp;\text{push\_back}&amp;\text{} \\&amp;\text{end}&amp;\text{empty}&amp;\text{at}&amp;\text{pop\_back} \\&amp;&amp;&amp;\text{front}&amp;\text{insert} \\&amp;&amp;&amp;\text{back}&amp;\text{erase} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \text{list}&amp;\text{begin}&amp;\text{size}&amp;\text{front}&amp;\text{push\_back}&amp;\text{sort} \\&amp;\text{end}&amp;\text{empty}&amp;\text{back}&amp;\text{pop\_back}&amp;\text{reverse} \\&amp;&amp;&amp;&amp;\text{insert} \\&amp;&amp;&amp;&amp;\text{erase} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \text{forward\_list}&amp;\text{begin}&amp;\text{empty}&amp;\text{front}&amp;\text{push\_front}&amp;\text{sort} \\&amp;\text{end}&amp;&amp;&amp;\text{pop\_back}&amp;\text{reverse} \\&amp;&amp;&amp;&amp;\text{insert\_after} \\&amp;&amp;&amp;&amp;\text{erase\_after} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \end{array} \)
基礎容器 pair 序列式容器(Sequence Containers)  特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。  vector list, forward_list deque arrays 容器適配器(Container Adaptors)  用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。  queue priority_queue stack 關聯性容器(Associative Containers)  又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。  set multiset map multimap 無序關聯容器(Unordered Associative Containers(C&#43;&#43;11))  通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。  unordered_set unordered_multiset unordered_map unordered_mutlimap  你可能會想繼續閱讀…  演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library    </p>
  </section>
  <footer class="entry-footer"><span title='2022-04-15 01:09:18 +0800 CST'>April 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Container" href="https://intervalrain.github.io/c&#43;&#43;/stl_container/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] 如何產生 random 值
    </h2>
  </header>
  <section class="entry-content">
    <p>rand() 函數  在 C/C&#43;&#43; 中可以使用 rand() 這個函數，產生最簡單的亂數： 需引用 &lt;stdlib.h&gt; 函式庫 在呼叫 rand() 前需要先使用srand()設定初始的亂數種子，增加「亂度」。(實際上產生的亂數是有規則的，以示例為例，是以時間做為種子，故是有可能被預測的) 其產生的亂數是一個介於 0 到 RAND_MAX(INT_MAX)的整數。 C 與 C&#43;&#43; 幾乎一樣，只差在表頭檔的使用。  C-style #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt; int main(){  srand(time(NULL)); // random seed  int x = rand();   printf(&#34;x = %d\n&#34;, x);  return 0; } Cpp-style #include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt; using namespace std;  int main(){  srand(time(NULL));  int x = rand();   cout &lt;&lt; &#34;x = &#34; &lt;&lt; x &lt;&lt; endl;  cout &lt;&lt; &#34;x is between 0 and &#34; &lt;&lt; RAND_MAX &lt;&lt; endl;   return 0; } 亂數種子  由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。 上例中使用的亂數種子是時間，因為時間每分每秒都在變化，所以每次產生的亂數都會不同，如果是用於數值模擬的話，  固定亂數種子  由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。若是做數值模擬的話，通常會讓模擬結果具有可重復性(repeatability)，方便除錯與驗證，這種狀況就可以將亂數種子固定不變，以確保每次的結果都相同。  [0, 1) 浮點數亂數  [0, 1) 代表 0 &lt;= x &lt; 1 若要產生 0 到 1 之間的浮點數亂數，可以這樣寫：  #include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt; using namespace std;  int main(){  srand(time(NULL));  double x = (double)rand()/(RAND_MAX &#43; 1....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-14 00:26:23 +0800 CST'>April 14, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] 如何產生 random 值" href="https://intervalrain.github.io/c&#43;&#43;/random/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] Cout functions
    </h2>
  </header>
  <section class="entry-content">
    <p>cout Functions 設定顯示小數點位數  setprecision(int n) and fixed  #include &lt;iostream&gt;#include &lt;iomanip&gt; using namespace std;  int main(){   double a = 5.43/2.653;  cout &lt;&lt; a &lt;&lt; endl; // 2.04674  cout &lt;&lt; setprecision(3) &lt;&lt; fixed;  cout &lt;&lt; a &lt;&lt; endl; // 2.047   return 0; } 顯示 Boolean 值  std::boolalpha  #include &lt;iostream&gt; using namespace std;  int main(){   bool a = true;  cout &lt;&lt; a &lt;&lt; endl; // 1  cout &lt;&lt; std::boolalpha;  cout &lt;&lt; a &lt;&lt; endl; // true   return 0; } </p>
  </section>
  <footer class="entry-footer"><span title='2022-04-08 10:20:38 +0800 CST'>April 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] Cout functions" href="https://intervalrain.github.io/c&#43;&#43;/cout/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Algorithm
    </h2>
  </header>
  <section class="entry-content">
    <p>演算法(Algorithms) Non-Manupulating Algorithms 1. sort()  sort(first_iterator, last_iterator) 對 vector 作排序  2. reverse()  reverse(first_iterator, last_iterator) 反轉 vector 的排序  3. *max_element()  *max_element(first_iterator, last_iterator) 找出 vector 的最大值  4. *min_element()  *min_element(first_iterator, last_iterator)` 找出 vector 的最小值  5. accumulate  accumulate(first_iterator, last_iterator, initial value of sum) 計算 vector 的總和  #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;numeric&gt; using namespace std;  void print(vector&lt;int&gt;&amp; vec){  for (vector&lt;int&gt;::iterator it = vec.begin(); it !...</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-06 16:04:36 +0800 CST'>April 6, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Algorithm" href="https://intervalrain.github.io/c&#43;&#43;/stl_algo/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL)
    </h2>
  </header>
  <section class="entry-content">
    <p>STL  標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。
STL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。
 STL 的四大組成  演算法(Algorithms) 容器(Containers) 函式(Functions) 迭代器(Iterators)  補充  Utility Library  </p>
  </section>
  <footer class="entry-footer"><span title='2022-04-05 01:09:42 +0800 CST'>April 5, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL)" href="https://intervalrain.github.io/c&#43;&#43;/stl/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] STL: Vector 的使用與實作
    </h2>
  </header>
  <section class="entry-content">
    <p>vector 的介紹  vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include &lt;vector&gt;  vector 的使用 建構式 constructor vector&lt;int&gt; v1; // 不進行初始化 vector&lt;int&gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector&lt;int&gt; v3(v2); // 利用vector初始化 vector&lt;int&gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector&lt;int&gt; v5(3, 0); // 含有3個0的vector  談一下特殊的二維vector，其實就是二維矩陣，寫法為  vector&lt;vector&lt;int&gt;&gt; vv(3, vector&lt;int&gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse  遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。  vector&lt;int&gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3};  // 1....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-03 18:14:14 +0800 CST'>April 3, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] STL: Vector 的使用與實作" href="https://intervalrain.github.io/c&#43;&#43;/vector/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] How to Initialize vector in C&#43;&#43;
    </h2>
  </header>
  <section class="entry-content">
    <p>如何初始化 vector 事先準備  #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std;  1. 利用 push_back() 函式 vector&lt;int&gt; A; A.push_back(1); A.push_back(2); A.push_back(3); // A = [1,2,3] 2. 利用重載建構子(overloaded constructor) int size = 5; int fill = 2; vector&lt;int&gt; B(size, fill); // B = [2,2,2,2,2] 3. 將 array 傳給 vector 的建構子(-std=c&#43;&#43;11) vector&lt;int&gt; C{1, 2, 3, 4, 5}; // C = [1,2,3,4,5] 4. 利用既有的 array int array[] = {1,2,3,4,5}; vector&lt;int&gt; D(array, array&#43;4); // D = [1,2,3,4] 5....</p>
  </section>
  <footer class="entry-footer"><span title='2022-03-03 01:33:02 +0800 CST'>March 3, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] How to Initialize vector in C&#43;&#43;" href="https://intervalrain.github.io/c&#43;&#43;/newvector/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://intervalrain.github.io/tags/c&#43;&#43;/">« Prev Page</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://intervalrain.github.io/">Rain Hu&#39;s Workspace</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
