<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Programming | Rain Hu&#39;s Workspace</title>
<meta name="keywords" content="" />
<meta name="description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊">
<meta name="author" content="Rain Hu, intervarrain, 陣雨">
<link rel="canonical" href="https://intervalrain.github.io/tags/programming/" />
<meta name="google-site-verification" content="XYZabc" />
<meta name="msvalidate.01" content="XYZabc" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.a17c641b9e6ec5ee7bc49a565650096f69ae478de79da3309cb62f6993aaa8d0.css" integrity="sha256-oXxkG55uxe57xJpWVlAJb2muR43nnaMwnLYvaZOqqNA=" rel="preload stylesheet" as="style">
<link rel="preload" href="/images/rain.png" as="image">
<link rel="icon" href="https://intervalrain.github.io/images/rain.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://intervalrain.github.io/images/rain.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://intervalrain.github.io/images/rain.png">
<link rel="apple-touch-icon" href="https://intervalrain.github.io/images/rain.png">
<link rel="mask-icon" href="https://intervalrain.github.io/images/rain.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://intervalrain.github.io/tags/programming/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script src="https://utteranc.es/client.js"
    repo="intervalrain.github.io"
    issue-term="pathname"
    label="Comment"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script><meta property="og:title" content="Programming" />
<meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://intervalrain.github.io/tags/programming/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Programming"/>
<meta name="twitter:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"/>
<meta name="twitter:site" content="@intervalrain"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://intervalrain.github.io/" accesskey="h" title="Rain Hu&#39;s Workspace (Alt + H)">
                <img src="https://intervalrain.github.io/images/rain.png" alt="logo" aria-label="logo"
                    height="35">Rain Hu&#39;s Workspace</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://intervalrain.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/aboutme" title="About me">
                    <span>About me</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/csharp/csharp" title="C#">
                    <span>C#</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/csindex" title="CS">
                    <span>CS</span>
                </a>
            </li>
            <li>
                <a href="https://intervalrain.github.io/leetcode" title="LeetCode">
                    <span>LeetCode</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://intervalrain.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://intervalrain.github.io/tags/">Tags</a></div>
  <h1>Programming</h1>
</header>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - vector
    </h2>
  </header>
  <section class="entry-content">
    <p>vector  Vectors 是一動態陣列，可以自動的調整其容器的容量。 Vector 的元素被儲存在連續的記憶體空間，所以可以使用迭代器(iterators)來進行存取。 在 vectors 中，元素是被插入在尾端的，插入尾端的時間取決於是否須進行容量的調整。 在 vectors 中，刪除尾端元素的時間複雜度則是固定的\(O(1)\)，因為不會發生容量調整。 在 vectors 的前端或中間插入元素或是清除元素，時間的複雜度都是\(O(n)\)。  迭代器(Iterators) 1. vec.begin()  回傳指向 vector 中第一個元素的迭代器 (vec[0])  2. vec.end()  回傳指向 vector 中最後一個元素之後一個的迭代器 (vec[n&#43;1])  3. vec.rbegin()  回傳指向 vector 中最後一個元素的反向迭代器 (vec[n])  4. vec.rend()  回傳指向 vector 中第一個元素之前一個的反向迭代器 (vec[-1])  5. vec.cbegin()  回傳指向 vector 中第一個元素的常數迭代器 (vec[0])  6. vec.cend()  回傳指向 vector 中最後一個元素之後一個的常數迭代器 (vec[n&#43;1])  7. vec.crbegin()  回傳指向 vector 中最後一個元素的反向常數迭代器 (vec[n])  8....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-16 22:08:37 +0800 CST'>April 16, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - vector" href="https://intervalrain.github.io/c&#43;&#43;/stl_vector/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Container
    </h2>
  </header>
  <section class="entry-content">
    <p>容器(Containers)  C&#43;&#43; container 基本上分為四大類：  Sequence containers Container adaptors Associative containers Unordered associative containers 還有兩個特殊 containers: valarray, bitset    \(\begin{array}{|l|l|l|l|l|l|}\hline \text{Name}&amp;\text{Iterators}&amp;\text{Capacity}&amp;\text{Access}&amp;\text{Modifiers}&amp;\text{Others} \\\hline \text{array}&amp;\text{begin}&amp;\text{size}&amp;\text{[]}&amp;\text{swap} \\&amp;\text{end}&amp;\text{empty}&amp;\text{at} \\&amp;&amp;&amp;\text{front} \\&amp;&amp;&amp;\text{back} \\\hline \text{vector}&amp;\text{begin}&amp;\text{size}&amp;\text{[]}&amp;\text{push\_back}&amp;\text{} \\&amp;\text{end}&amp;\text{empty}&amp;\text{at}&amp;\text{pop\_back} \\&amp;&amp;\text{capacity}&amp;\text{front}&amp;\text{insert} \\&amp;&amp;&amp;\text{back}&amp;\text{erase} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \text{deque}&amp;\text{begin}&amp;\text{size}&amp;\text{[]}&amp;\text{push\_back}&amp;\text{} \\&amp;\text{end}&amp;\text{empty}&amp;\text{at}&amp;\text{pop\_back} \\&amp;&amp;&amp;\text{front}&amp;\text{insert} \\&amp;&amp;&amp;\text{back}&amp;\text{erase} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \text{list}&amp;\text{begin}&amp;\text{size}&amp;\text{front}&amp;\text{push\_back}&amp;\text{sort} \\&amp;\text{end}&amp;\text{empty}&amp;\text{back}&amp;\text{pop\_back}&amp;\text{reverse} \\&amp;&amp;&amp;&amp;\text{insert} \\&amp;&amp;&amp;&amp;\text{erase} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \text{forward\_list}&amp;\text{begin}&amp;\text{empty}&amp;\text{front}&amp;\text{push\_front}&amp;\text{sort} \\&amp;\text{end}&amp;&amp;&amp;\text{pop\_back}&amp;\text{reverse} \\&amp;&amp;&amp;&amp;\text{insert\_after} \\&amp;&amp;&amp;&amp;\text{erase\_after} \\&amp;&amp;&amp;&amp;\text{swap} \\&amp;&amp;&amp;&amp;\text{clear} \\\hline \end{array} \)
基礎容器 pair 序列式容器(Sequence Containers)  特點是不會對儲存的元素進行排序，元素排列的順序取決於儲存的順序。  vector list, forward_list deque arrays 容器適配器(Container Adaptors)  用於封裝序列容器的類模板，在一般的序列容器的基礎上提供一些不同的功能，通過實現適配器的介面來提供不同的功能。  queue priority_queue stack 關聯性容器(Associative Containers)  又名 Map、Dictionary，是一種抽象的資料結構，包含著類似於(key, value)的有序對(entry)。 一個關聯陣列中的有序對(entry)可以重複(如multimap)，也可以不重複(map)。 利用雜湊表(Hash Table)或搜尋樹(search tree)實現，有些情況下，有可以使用直接定址的陣列、二元搜尋樹或其他專門的結構。  set multiset map multimap 無序關聯容器(Unordered Associative Containers(C&#43;&#43;11))  通過雜湊表(Hash Table)實現的資料結構。 無序是指元素的名字(或者鍵值)的儲存是無序的；這與用平衡二元樹實現的有序的關聯性容器是相對概念。  unordered_set unordered_multiset unordered_map unordered_mutlimap  你可能會想繼續閱讀…  演算法(Algorithms) 函式(Functions) 迭代器(Iterators) Utility Library    </p>
  </section>
  <footer class="entry-footer"><span title='2022-04-15 01:09:18 +0800 CST'>April 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Container" href="https://intervalrain.github.io/c&#43;&#43;/stl_container/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[IDAS&#43;] Optimize Summary Table Function
    </h2>
  </header>
  <section class="entry-content">
    <p>前言  在做 WAT 量測後的資料處理時，IDAS 老舊的 VBA macro 執行時間實在過於久，且佔用大量的記憶體，於是就下了一個命題，想減少產生報表的時間。  想法  通常量測多片 wafer 的狀況下，不同 wafer 的排列順序是一致的，如果可以加入 Java 中 HashMap 的資料結構來處理 VBA 中 Lookup()，便可大幅減少 summary table 時，對 rawdata 做搜尋的時間。 令時間複雜度從\(O(n)\)進步到\(O(1)\)。  做法 產生 Dictionary 物件  由於 VBA 預設並沒有 Dictionary 的物，所以需要用 CreateObject(&#34;Scritping.Dictionary&#34;) 的程式碼，引入 Dictionary。 其 Dictionary 物件的 method 可參考 Microsoft 的文件：點此 在此先預先定義一個 function setDict() 可以對初始化 Dictionary。 接著宣告兩個 Dictionary 物件來存取 spec 和 data 工作頁的列數(row)。  Dim SpecDict As Object &#39; Claim a dict to store spec rows in worksheet SPEC....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-14 00:39:50 +0800 CST'>April 14, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [IDAS&#43;] Optimize Summary Table Function" href="https://intervalrain.github.io/vba/idas&#43;_record/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] 如何產生 random 值
    </h2>
  </header>
  <section class="entry-content">
    <p>rand() 函數  在 C/C&#43;&#43; 中可以使用 rand() 這個函數，產生最簡單的亂數： 需引用 &lt;stdlib.h&gt; 函式庫 在呼叫 rand() 前需要先使用srand()設定初始的亂數種子，增加「亂度」。(實際上產生的亂數是有規則的，以示例為例，是以時間做為種子，故是有可能被預測的) 其產生的亂數是一個介於 0 到 RAND_MAX(INT_MAX)的整數。 C 與 C&#43;&#43; 幾乎一樣，只差在表頭檔的使用。  C-style #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt; int main(){  srand(time(NULL)); // random seed  int x = rand();   printf(&#34;x = %d\n&#34;, x);  return 0; } Cpp-style #include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt; using namespace std;  int main(){  srand(time(NULL));  int x = rand();   cout &lt;&lt; &#34;x = &#34; &lt;&lt; x &lt;&lt; endl;  cout &lt;&lt; &#34;x is between 0 and &#34; &lt;&lt; RAND_MAX &lt;&lt; endl;   return 0; } 亂數種子  由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。 上例中使用的亂數種子是時間，因為時間每分每秒都在變化，所以每次產生的亂數都會不同，如果是用於數值模擬的話，  固定亂數種子  由於電腦實際上並沒有辦法自己產生「真正的亂數」，只能透過複雜的數學演算法模擬出類似亂數的數值資料，而在模擬亂數時，需要設定一個亂數種子，電腦會根據這個亂數種子來計算出一連串的亂數，相同的亂數種子就會產生相同的亂數序列，所以如果要讓產生的亂數每次都不同，就要設定不同的亂數種子。若是做數值模擬的話，通常會讓模擬結果具有可重復性(repeatability)，方便除錯與驗證，這種狀況就可以將亂數種子固定不變，以確保每次的結果都相同。  [0, 1) 浮點數亂數  [0, 1) 代表 0 &lt;= x &lt; 1 若要產生 0 到 1 之間的浮點數亂數，可以這樣寫：  #include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt; using namespace std;  int main(){  srand(time(NULL));  double x = (double)rand()/(RAND_MAX &#43; 1....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-14 00:26:23 +0800 CST'>April 14, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] 如何產生 random 值" href="https://intervalrain.github.io/c&#43;&#43;/random/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] Cout functions
    </h2>
  </header>
  <section class="entry-content">
    <p>cout Functions 設定顯示小數點位數  setprecision(int n) and fixed  #include &lt;iostream&gt;#include &lt;iomanip&gt; using namespace std;  int main(){   double a = 5.43/2.653;  cout &lt;&lt; a &lt;&lt; endl; // 2.04674  cout &lt;&lt; setprecision(3) &lt;&lt; fixed;  cout &lt;&lt; a &lt;&lt; endl; // 2.047   return 0; } 顯示 Boolean 值  std::boolalpha  #include &lt;iostream&gt; using namespace std;  int main(){   bool a = true;  cout &lt;&lt; a &lt;&lt; endl; // 1  cout &lt;&lt; std::boolalpha;  cout &lt;&lt; a &lt;&lt; endl; // true   return 0; } </p>
  </section>
  <footer class="entry-footer"><span title='2022-04-08 10:20:38 +0800 CST'>April 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] Cout functions" href="https://intervalrain.github.io/c&#43;&#43;/cout/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Algorithm
    </h2>
  </header>
  <section class="entry-content">
    <p>演算法(Algorithms) Non-Manupulating Algorithms 1. sort()  sort(first_iterator, last_iterator) 對 vector 作排序  2. reverse()  reverse(first_iterator, last_iterator) 反轉 vector 的排序  3. *max_element()  *max_element(first_iterator, last_iterator) 找出 vector 的最大值  4. *min_element()  *min_element(first_iterator, last_iterator)` 找出 vector 的最小值  5. accumulate  accumulate(first_iterator, last_iterator, initial value of sum) 計算 vector 的總和  #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;numeric&gt; using namespace std;  void print(vector&lt;int&gt;&amp; vec){  for (vector&lt;int&gt;::iterator it = vec.begin(); it !...</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-06 16:04:36 +0800 CST'>April 6, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - Algorithm" href="https://intervalrain.github.io/c&#43;&#43;/stl_algo/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL)
    </h2>
  </header>
  <section class="entry-content">
    <p>STL  標準模板庫(Standard Template Library, STL)是提供常用資料結構模板的程式庫，其包含了類別(classes)、演算法(algorithms)與迭代器(iterators)。
STL 是通用的程式庫，所以所有的元素都是泛型的，可以點此瞭解更多模板(template)的內容。
 STL 的四大組成  演算法(Algorithms) 容器(Containers) 函式(Functions) 迭代器(Iterators)  補充  Utility Library  </p>
  </section>
  <footer class="entry-footer"><span title='2022-04-05 01:09:42 +0800 CST'>April 5, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL)" href="https://intervalrain.github.io/c&#43;&#43;/stl/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[C&#43;&#43;] STL: Vector 的使用與實作
    </h2>
  </header>
  <section class="entry-content">
    <p>vector 的介紹  vector 是可變大小陣列的序列容器，採用連續的儲存空間來儲存元素，意味著可以採用下標來對 vector 的元素進行存取，和陣列 array 一樣高效，但是又不像陣列的大小是固定的，vector 的大小可以被動態處理，隨著元素量而增加。 #include &lt;vector&gt;  vector 的使用 建構式 constructor vector&lt;int&gt; v1; // 不進行初始化 vector&lt;int&gt; v2 = {1,2,3}; // 像陣列一樣初始化 vector&lt;int&gt; v3(v2); // 利用vector初始化 vector&lt;int&gt; v4(v2.begin(), v2.end()-1); // 利用iterator初始化 vector&lt;int&gt; v5(3, 0); // 含有3個0的vector  談一下特殊的二維vector，其實就是二維矩陣，寫法為  vector&lt;vector&lt;int&gt;&gt; vv(3, vector&lt;int&gt;(5, 0)); // vv[0] = [0, 0, 0, 0, 0] // vv[1] = [0, 0, 0, 0, 0] // vv[2] = [0, 0, 0, 0, 0] 遍歷 traverse  遍歷的方法有三種，分別是iterator，for loop，[]，其中**[]下標運算子只有string和vector**可以使用，因為他們的地址是連續的。 三種方法均是可讀、可寫。  vector&lt;int&gt; v = {0, 9, 3, 1, 6, 3, 9, 4, 3, 3};  // 1....</p>
  </section>
  <footer class="entry-footer"><span title='2022-04-03 18:14:14 +0800 CST'>April 3, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] STL: Vector 的使用與實作" href="https://intervalrain.github.io/c&#43;&#43;/vector/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[TCAD] 工具語言
    </h2>
  </header>
  <section class="entry-content">
    <p>TCAD 常用的三種程式語言 工具語言  用於操作 Sentaurus 工具的指令，例如：  snmesh sdevice    預處理語言  Sentaurus Workbench Preprocessing Language(SPP)：在 SWB 執行指令檔之前，會先翻譯 SPP 語言。(類似於 C 的 macro)  例如：  #define __x__ 1 // 將所有 __x__ 字串取代成字串 1   TCL  公用語言，通常用來處理字串與數據。  範例  SPP 語言：@...@、#開頭的敘述都是 SPP 語言  #if &#34;@tunneling@ == &#34;Hurkx&#34; #define _B2BTunnelModel_ Band2Band(Model=Hurkx) #define _B2BTunnelMath_ NoSRHperPotential #elif &#34;@tunneling@ == &#34;E1&#34; #define _B2BTunnelModel_ Band2Band(Model=E1) #define _B2BTunnelMath_ NoSRHperPotential #elif &#34;@tunneling@ == &#34;E1_5&#34; #define _B2BTunnelModel_ Band2Band(Model=E1_5) #define _B2BTunnelMath_ NoSRHperPotential #elif &#34;@tunneling@ == &#34;E2&#34; #define _B2BTunnelModel_ Band2Band(Model=E2) #define _B2BTunnelMath_ NoSRHperPotential #else #define _B2BTunnelModel_ #define _B2BTunnelMath_ #endif  TCL 語言：set 與 puts  其中 @…@ 因為是 SPP 語言，故會先被前面定義好的 header 取代，之後才會執向 ....</p>
  </section>
  <footer class="entry-footer"><span title='2022-03-26 21:46:26 +0800 CST'>March 26, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [TCAD] 工具語言" href="https://intervalrain.github.io/device/tcad/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="https://intervalrain.github.io/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2>[Java] 面試常見問題
    </h2>
  </header>
  <section class="entry-content">
    <p>1. 請說明 Final, Finally, Finalize 三者不同?  Final:  一種修飾關鍵字。 加在變數前，使變數成為常數。 加在方法前，使方法無法被覆寫(override)。 加在類別前，使類別不能被繼承(extend)。   Finally:  例外處理關鍵字，Try-Catch-Finally 功能為保證一定執行，用意是做資源釋放。   Finalize:  是Object類別的方法，故所有物件都一定有此方法。 當物件要銷毀前會執行的方法，此外可以透過 System.gc() 呼叫資源回收。    2. 請說明 String 字串中 == 與 .equals() 哪裡不同?   ==:
 比較儲存的值，基本型別(primitives)是儲存在 Stack 中，因此值會相同，字串是儲存在 String Pool 中，故 Stack 中存的是址。 使用 == 比較字串時，其實是比較他們的址。    equals():
 是 String 覆寫後的 equals 方法，比較值。    補充：
 Java 的字串有 String Pool 機制，當宣告一個新的字串時，Java 會先去 String Pool 中尋找是否有相同的字串，有則共用，無則新增。  若使用 String s1 = &#34;Hello World&#34;; 來宣告，則會透過字串池。 若使用 String s2 = new String(&#34;Hello World&#34;) 來宣告，則字串會存在 Heap 中，與上者的址不同。      3....</p>
  </section>
  <footer class="entry-footer"><span title='2022-03-16 02:45:45 +0800 CST'>March 16, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [Java] 面試常見問題" href="https://intervalrain.github.io/java/interviewq/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://intervalrain.github.io/tags/programming/page/2/">« Prev Page</a>
    <a class="next" href="https://intervalrain.github.io/tags/programming/page/4/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://intervalrain.github.io/">Rain Hu&#39;s Workspace</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
