<!DOCTYPE html>
<html lang="zh-tw" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Programming | Rain Hu&#39;s Workspace</title>
<meta name="keywords" content="">
<meta name="description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊">
<meta name="author" content="Rain Hu, intervarrain, 陣雨">
<link rel="canonical" href="http://localhost:1313/tags/programming/">
<meta name="google-site-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.662816b9df27c772d2b97c5f5f6bf4f2c5531051a330015f0ad4135736d0e56a.css" integrity="sha256-ZigWud8nx3LSuXxfX2v08sVTEFGjMAFfCtQTVzbQ5Wo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/images/rain.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/images/rain.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/images/rain.png">
<link rel="apple-touch-icon" href="http://localhost:1313/images/rain.png">
<link rel="mask-icon" href="http://localhost:1313/images/rain.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/programming/index.xml">
<link rel="alternate" hreflang="zh-tw" href="http://localhost:1313/tags/programming/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<script src="https://utteranc.es/client.js"
    repo="intervalrain.github.io"
    issue-term="pathname"
    label="Comment"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script><meta property="og:url" content="http://localhost:1313/tags/programming/">
  <meta property="og:site_name" content="Rain Hu&#39;s Workspace">
  <meta property="og:title" content="Programming">
  <meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊">
  <meta property="og:locale" content="zh-tw">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Programming">
<meta name="twitter:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊">
      <meta name="twitter:site" content="@intervalrain">

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Rain Hu&#39;s Workspace (Alt + H)">
                <img src="http://localhost:1313/images/rain.png" alt="" aria-label="logo"
                    height="35">Rain Hu&#39;s Workspace</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/aboutme" title="About me">
                    <span>About me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/csharp/csharp" title="C#">
                    <span>C#</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/csindex" title="CS">
                    <span>CS</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/leetcode" title="LeetCode">
                    <span>LeetCode</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">首頁</a>&nbsp;»&nbsp;<a href="http://localhost:1313/tags/">Tags</a></div>
  <h1>
    Programming
  </h1>
</header>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[VHDL] HDLbits 3 - Circuits
    </h2>
  </header>
  <div class="entry-content">
    <p>1. Getting Started
2. Verilog Language
3. Circuits
4. Verification: Reading Simulations
5. Verification: Writing Testbenches
6. CS450
3 Circuits 3.1 Combinational Logic 3.1.1 Basic Gates Wire module top_module ( input in, output out); assign out = in; endmodule GND module top_module ( output out); assign out = 1&#39;b0; endmodule NOR module top_module ( input in1, input in2, output out); assign out = ~(in1|in2); endmodule Another Gate ...</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-28 00:10:20 +0800 CST'>May 28, 2022</span>&nbsp;·&nbsp;18 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [VHDL] HDLbits 3 - Circuits" href="http://localhost:1313/verilog/hdlbits3/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[VHDL] HDLbits 4 - Verification: Reading Simulations
    </h2>
  </header>
  <div class="entry-content">
    <p>4 Verification - Reading Simulations 4.1 Finding bugs in code 4.2 Build a circuit from a simulation waveform 1. Getting Started
2. Verilog Language
3. Circuits
4. Verification: Reading Simulations
5. Verification: Writing Testbenches
6. CS450
</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-28 00:10:20 +0800 CST'>May 28, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [VHDL] HDLbits 4 - Verification: Reading Simulations" href="http://localhost:1313/verilog/hdlbits4/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[VHDL] HDLbits 5 - Verification: Writing Testbenches
    </h2>
  </header>
  <div class="entry-content">
    <p>5 Verification - Writing Testbenches 1. Getting Started
2. Verilog Language
3. Circuits
4. Verification: Reading Simulations
5. Verification: Writing Testbenches
6. CS450
</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-28 00:10:20 +0800 CST'>May 28, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [VHDL] HDLbits 5 - Verification: Writing Testbenches" href="http://localhost:1313/verilog/hdlbits5/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[VHDL] HDLbits 6 - CS450
    </h2>
  </header>
  <div class="entry-content">
    <p>6 CS450 1. Getting Started
2. Verilog Language
3. Circuits
4. Verification: Reading Simulations
5. Verification: Writing Testbenches
6. CS450
</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-28 00:10:20 +0800 CST'>May 28, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [VHDL] HDLbits 6 - CS450" href="http://localhost:1313/verilog/hdlbits6/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[VHDL] Verilog Hardware Description Language
    </h2>
  </header>
  <div class="entry-content">
    <p>1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a &#43; b &#43; c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \( \boxed{\text{Full Adder}} \begin{cases} \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{OR}} \end{cases}\\ \text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件} \) 1.3 Verilog 語法詞彙 由一連串的標記(token)所組成 識別字(identifiers) 關鍵字(keywords) 字串(strings) 註解(comments) 空白(whitespace) 數值(numbers) 1.3.1 識別字(identifiers) 描述電路行為所使用的自訂物件 不違反命名規則，工程師自行定義的物件名稱 命名規則 字母、數字、底線_或是錢字號$所組合而成。 開頭只能使用字母或底線。 識別字是有大小寫之分的。 舉例 Shift_reg_b (Valid) _bus123 (Valid) $error_condition (Invalid) NT$899 (Valid) 3_bit_data (Invalid) 1.3.2 關鍵字(keywords) 描述電路語法所保留的一組特殊名稱的標記 定義語言的結構來描述電路 輸入(input)、輸出(output) 資料型態、電路行為 所有關鍵字都必須使用小寫表示 不可當作識別字使用 常見關鍵字 \(\begin{array}{|l|l|l|l|l|l|}\hline \text{always}&amp;\text{and}&amp;\text{assign}&amp;\text{begin}&amp;\text{buf}&amp;\text{bufif0}\\\hline \text{bufif1}&amp;\text{case}&amp;\text{casex}&amp;\text{casez}&amp;\text{cmos}&amp;\text{default}\\\hline \text{defparam}&amp;\text{else}&amp;\text{end}&amp;\text{endcase}&amp;\text{endfunction}&amp;\text{endmodule}\\\hline \text{endtask}&amp;\text{event}&amp;\text{for}&amp;\text{forever}&amp;\text{fork}&amp;\text{function}\\\hline \text{highz0}&amp;\text{highz1}&amp;\text{if}&amp;\text{initial}&amp;\text{inout}&amp;\text{input}\\\hline \text{integer}&amp;\text{join}&amp;\text{module}&amp;\text{nand}&amp;\text{negedge}&amp;\text{nmos}\\\hline \text{nor}&amp;\text{not}&amp;\text{notif0}&amp;\text{notif1}&amp;\text{or}&amp;\text{output}\\\hline \text{parameter}&amp;\text{pmos}&amp;\text{posedge}&amp;\text{pull0}&amp;\text{pull1}&amp;\text{pulldown}\\\hline \text{pullup}&amp;\text{rcmos}&amp;\text{real}&amp;\text{realtime}&amp;\text{reg}&amp;\text{repeat}\\\hline \text{rnmos}&amp;\text{rpmos}&amp;\text{rtran}&amp;\text{rtranif0}&amp;\text{rtranif1}&amp;\text{strong0}\\\hline \text{string1}&amp;\text{supply0}&amp;\text{supply1}&amp;\text{task}&amp;\text{time}&amp;\text{tran}\\\hline \text{tranif0}&amp;\text{tranif1}&amp;\text{tri}&amp;\text{tri0}&amp;\text{tri1}&amp;\text{triand}\\\hline \text{trior}&amp;\text{trireg}&amp;\text{wait}&amp;\text{wand}&amp;\text{weak0}&amp;\text{weak1}\\\hline \text{while}&amp;\text{wire}&amp;\text{wor}&amp;\text{xnor}&amp;\text{xor}\\\hline \end{array}\) 1.3.3 字串(strings) 一連串字元(character)組成的單一個體 可含有字母、數字、及一些特殊字元 字串的所有字元必須在同一行上，並在雙引號之間 1.3.4 註解(comments) 程式碼中加入說明文字 可讀性(readability) 文件化(documentation) 版權宣告(license declaration) 以//開頭的單行註解(one-line comment) 以/*為開頭，並以*/為結尾的多行註解(multiple-line comment) 多行註解不支援巢狀結構 1.3.5 空白(whitespace) 區隔不同物件 空格(blank spaces，\b) 欄位(tabs，\t) 換行(newlines，\n) 除字串內空白，註解與空白在編譯與合成時會被忽略 1.3.6 數值(numbers) Verilog 有兩種數值表示法 固定長度(sized): 定義位元寬度 &lt;size&gt;&#39;&lt;bsase format&gt;&lt;number&gt; &lt;size&gt;：十進位來表示此數的位元數(bits) &lt;base format&gt;：定義進制 &#39;H|&#39;h：十六進制 &#39;D|&#39;d：十進制 &#39;O|&#39;p：八進制 &#39;B|&#39;b：二進制 &lt;number&gt;：用&lt;base format&gt;來表示數值 若為負號，將-放在&lt;size&gt;前面 舉例： 18&#39;h47CB：18 bits 的十六進位數 47CB 13&#39;h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB 12&#39;d1023：12 bits 的十進位數 1023 9&#39;o723：9 bits 的八進位數 723 5&#39;b11101：5bits 的二進位數 11101 5&#39;b1xx01：含有 unknown values 的表示法 不定長度(unsized): 未定義位元寬度 ‘&lt;base format&gt;&lt;number 不使用&lt;size&gt;規定位元長度 使用 HDL 編譯器內定的長度(32bit的寬度) 沒有寫明&lt;base format&gt;，則內定為十進制 舉例： &#39;h47CB：32 bits 的十六進位數 47CB 1023：32 bits 的十進位數 1023 &#39;o723：32 bits 的八進位數 723 &#39;b11101：32 bits 的二進位數 11101 Verilog 有四種數值位準(value level) \(\begin{array}{|c|l|}\hline \text{數值位準}&amp;\text{實際電路狀態}\\\hline \text{0}&amp;\text{邏輯0，假(false)，接地}\\\hline \text{1}&amp;\text{邏輯1，真(true)，接壓電源}\\\hline \text{x}&amp;\text{不確定值(unknown value)}\\\hline \text{z}&amp;\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\hline \end{array} \) 1.4 Verilog 資料物件與型態 資料物件(data objects) 描述行為過程中所使用的訊號載具 一個物件經過處理再傳到另一個物件 資料型態(data type) 定義資料物件的類型 接線、暫存器、參數等 1.4.1 接線(Nets) 接線(nets)是連接實體元件的連接線 要被驅動才能改變其內部的值 最主要的關鍵字是 wire 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 z(高阻抗、浮接) 宣告方式 wire w; // 宣告一條接線，命名為w，內定預設值為z wire x = 1&#39;b0; // 宣告一條接線，命名為x，並指定x為邏輯0 wire a, b, c // 宣告三條接線，命名為a, b, c 1.4.2 暫存器(Registers) 抽象的資料儲存物件(有別於實體暫存器 D flip-flop) 保留一個數值直到下一次指定新值為止 觀念類似 C 語言中的變數 主要的關鍵字是 reg 一個位元的純量(scalar) 多位元長度的向量(vector) 內定值為 x(未知) \(\begin{array}{|l|l|}\hline \text{reg}&amp;\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\hline \text{integer}&amp;\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\ &amp;\text{算術運算產生2補數結果(2’s complement results))}\\\hline \text{real}&amp;\text{雙倍精確度之有號浮點數}\\ &amp;\text{(signed floating-point variable with double precision)}\\\hline \text{time}&amp;\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\hline \end{array}\) 設計電路請以reg為主，其他類型合成器可能不支援。 宣告方式 reg a; // 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x reg x, y; // 宣告 2 個宣存器，命名為 x, y integer count; // 宣告 1 個整數為 count，值可以為正負 real fraction; // 宣告 1 個浮點數為 fraction，值含小數點 1.4.3 純量與向量(scalar and vector) 純量(scalar) 一個位元的物件 向量(vector) 多個位元的物件 接線(ex. wire) 與 reg 內定一位元 [大數字:小數字]、[小數字:大數字]→[MSB:LSB] 宣告方式 wire a; // 宣告 1 個 1-bits 接線 wire [4:0] x; // 宣告 1 個 5-bits 接線 reg b; // 宣告 1 個 1-bits 暫存器 reg [0:7] y; // 宣告 1 個 8-bits 暫存器 reg [31:0] z; // 宣告 1 個 32-bits 暫存器 1.4.4 陣列(Array) 多個暫存器、接線的聚合體 索引值(index)定義聚合體中的個別物件 支援多維度的陣列 記憶體(memory)、暫存器檔案(register file) 陣列中暫存器、接線的個數 [大數字:小數字]、[小數字:大數字] 宣告方式 // mem_block 是一個包含 128 個暫存器的陣列， // 每個暫存器皆為 32 位元寬 reg [31:0] mem_block [127:0]; // mem_2D 是一個 2 維 4x64 的暫存器陣列， // 每個暫存器皆為 8 位元寬 reg [7:0] mem_2D [3:0][63:0]; 1.4.5 參數(parameter) 定義編譯合成電路時的常數 每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路 重複使用 關鍵字 parameter 宣告方式 parameter width = 4; wire [width-1:0] a, b; // 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動 reg [width-1:0] y; // 暫存器 y 的位元寬度，會隨著參數值的改變而變動 1.5 模組(Module)、埠(Port) 1.5.1 模組(Module) 一個電路區塊、可以由其他模組組成 連接模組時 考慮模組的輸入與輸出介面 不需要考慮模組內部的詳細電路 電路設計時 只修改模組內部電路 不會改變電路外部及周遭的模組 模組內部的電路描述可包含 訊號資料型態宣告 引用其他模組(邏輯閘) assign 資料處理模型之描述 always 行為模型之描述 函數(function) 與 任務(task) 除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為 模組宣告 以關鍵字 module 為開頭，在其後加一個識別用的模組名稱(module name) 再來是輸入與輸出埠列(module terminal list)和埠列宣告，接著是模組內部關於電路的描述 以關鍵字 endmodule 做為模組結尾 支援階層`式的設計概念 module module_name(terminal_list) port_declaration(...) param_declaration(optional) data_type_declaration(wire, reg) other_module(logic_gate) assign data_flow_model always behavior_model function, task endmodule 1.5.2 埠(port) 終端點、模組與外界溝通的介面接點(門) 一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通 若模組與外界不需要溝通，則埠列也就不存在(封閉系統) 測試環境(test bench) 埠的宣告 埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。 埠的宣告型態內定為接線(net)的 wire，若需要將訊號儲存起來則埠號型態須宣告成暫存器 reg。 輸入埠和雙向埠只能是接線(net)，不可宣告成暫存器。 輸出埠可以宣告成接線(net)或暫存器。 module full_adder(a, b, carry, sum); // 埠列 input [3:0] a, b; // 輸入埠(4位元向量) input carry // 輸入埠(1位元純量) output [4:0] sum; // 輸出埠(5位元向量) reg [4:0] sum; // 因輸出sum需儲存資料，故宣告成暫存器 ... endmodule 1.6 邏輯閘層次模型 利用關鍵字即可引用基本的邏輯閘元件 基本的邏輯閘關鍵字 and nand or nor not xor xnor 1.6.1 多個輸入邏輯閘(Multiple-Input Gates) and、nand、or、nor、xor、xnor 具有多個純量(scalar)的輸入，但是只有一個純量的輸出 多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面 輸出必須透過接線(wire)連接，輸入無規定 多個輸入邏輯閘的別名可以加或是不加 使用方法 gate_type instance(out, in_1, in_2, in_3, ..., in_n); gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n), inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n), inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n), ... inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn); \(\begin{array}{ccc} \underbrace{\text{a, b, c, d}}_{\text{輸入}} \rightarrow \boxed{\text{Multiple-Input Gate}} \rightarrow \underbrace{\text{e}} _{\text{輸出}} \end{array} \) \(\text{and\quad a1(} \underbrace{\text{e}}_{\text{輸出}} \text{, } \underbrace{\text{a, b, c, d}} _{\text{輸入}} \text{);} \) 1.6.2 多個輸出邏輯閘(Multiple-Output Gates) not、buf
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-05-01 17:37:22 +0800 CST'>May 1, 2022</span>&nbsp;·&nbsp;4 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [VHDL] Verilog Hardware Description Language" href="http://localhost:1313/verilog/intro/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[Java] 淺談 Java MVC
    </h2>
  </header>
  <div class="entry-content">
    <p>前言 MVC MVC 是一種軟體架構模式。 模型 (Model) 視圖 (View) 控制器 (Controller) 目的是實現一種動態且有彈性的程式設計，使後續對程式設計的維護與擴充都變得更容易，另一方面也能使程式的某一部分被重複使用而提升設計效率。 SSH SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Struts Spring Hibernate SSM SSH 是 MVC 的一種，是常用的系統框架，由下面三種集合而成： Spring-MVC Spring MyBatis SSH v.s. SSM Spring-MVC v.s. Struts Struts 和 Spring-MVC 都負責取轉發，但兩者針對 request 的請求上區別很大， Struts 是針對一個 Action class 來進行 request，即一個 Action 對應一個 request，屬於類攔截，請求的數據類共享。 Spring-MVC 則是針對 method 級別的 request，即一個 method 對應一個 request，屬於方法攔截，請求的數據方法不共享。 Spring-MVC 的配置文件相對較少，容易上手，方便開發。 Spring-MVC 的入口是 Servlet 級別的而 Struts 的級別是 Filter 級別的。 Hibernate v.s. MyBatis Hibernate 是一種 O/R 關係型，即完成資料庫和持久化類別之間的映射；而 MyBatis 是針對的 SQL-Mapping。猶如 Hibernate 是對資料庫封裝完成後，調用相對應的語句(HQL)來控制資料庫；而 MyBatis 是用原生的資料庫語法。 基於以上原因，Hibernate 的優化較 MyBatis 難，MyBatis 不需要額外學習新的語法，入門較快。 對於更高級的 Queuy，MyBatis 需要編寫 SQL 語句與 ResultMap。而 Hibernate 有因應的映射機制，無需關心 SQL 的生成與結果映射，可以專注於開發流程。 Hibernate 的資料庫移植性很好，MyBatis 的資料庫移植性不好，不同的資料庫需要寫不同的 SQL。 Spring Spring、Spring MVC、Spring Boot Spring 是一種框架，包含一系列的 IoC 容器的設計和依賴注入(DI) 及 整合AOP功能。 Spring MVC 是一種以 Spring 為核心的框架。 Spring Boot 是一種以 Spring 為核心的框架，同時又能簡化配置(configuration)。 Spring 的核心基礎 DI DI = 依賴注入 Dependency Injection 一種 coding style，為了未來在維護上能更加的靈活，概念類似： // 1 System.out.println(&#34;This is Spring&#34;); // 2 String str = &#34;This is Spring&#34;; System.out.println(str); IoC IoC = 控制反轉 Inversion of Control 將產生物件這件事交給IoC去做。簡單來說，IoC是一個xml檔，也可以是一個class(Bean class)。 IoC做的事情就是設定其他class(Bean class)的名稱，以及 Constructor 會用到的參數或物件。 public class User{ Family family = new Family(&#34;Jason&#34;, &#34;Jocelyn&#34;, &#34;Mark&#34;, &#34;Eva&#34;); public void showAll(){ family.showFamily(); } } public class Family{ String dad; String mom; String son; String dau; public Family(String dad, String mom, String son, String dau){ this.dad = dad; this.mom = mom; this.son = son; this.dau = dau; } public void showFamily(){ System.out.println(dad &#43; &#34; &#34; &#43; mom &#43; &#34; &#34; &#43; son &#43; &#34; &#34; &#43; dau); } } &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans&gt; &lt;bean id=&#34;family&#34; class=&#34;Family&#34;&gt; &lt;property name=&#34;dad&#34; value=&#34;Jason&#34; /&gt; &lt;property name=&#34;mom&#34; value=&#34;Jocelyn&#34; /&gt; &lt;property name=&#34;son&#34; value=&#34;Mike&#34; /&gt; &lt;property name=&#34;dau&#34; value=&#34;Eva&#34; /&gt; &lt;/bean&gt; &lt;bean id=&#34;user&#34; class=&#34;User&#34;&gt; &lt;property name=&#34;allFamily&#34; value=&#34;family&#34; /&gt; &lt;/bean&gt; &lt;/beans&gt; 實例 DI &#43; IoC Dinner public class Diner{ Food food; public void getDinner(){ food.getFood(); } } xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans&gt; &lt;bean id=&#34;pork&#34; class=&#34;Pork&#34;/&gt; &lt;bean id=&#34;chicken&#34; class=&#34;Chicken&#34;/&gt; &lt;bean id=&#34;food&#34; class=&#34;Food&#34;&gt; &lt;property name=&#34;food&#34; value=&#34;chicken&#34; /&gt; &lt;/bean&gt; &lt;/beans&gt; classes public interface Food{ public void getFood(); } public class Chicken implements Food{ @override public void getFood(){ System.out.println(&#34;Eat chicken&#34;); } } public class Pork implements Food{ @override public void getFood(){ System.out.println(&#34;Eat pork&#34;); } } Spring Boot 由 Pivotal 團隊在 2013 年開始研發、2014年4月發布第一個版本。 是基於 Spring4.0 所設計的一種新型框架，繼承的 Spring 框架原有的優秀特性，還通過簡化配置來進一步簡化了 Spring 應用的整個搭建和開發過程。 通過集成大量的框架使得依賴包的版本衝突與引用的不穩定性得到很好的解決。 官方說明: Spring Boot makes it easy to create stand-alone, production-grade Spring baesd Applications that you can “just run”. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-04-29 15:38:18 +0800 CST'>April 29, 2022</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [Java] 淺談 Java MVC" href="http://localhost:1313/java/java_mvc/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - map
    </h2>
  </header>
  <div class="entry-content">
    <p>map 宣告 map &lt;int, int&gt; mp; // key和value都是整數 方法 mp[key] = value; 加入新的key-value pair mp.count(key); 檢查 key 是否存在 map 中 mp.erase(key); 刪除 key mp.clear(); 清空 map 中的所有元素： value = mp[key] 利用 key 取值 mp.empty() 判斷是否為空的map map 的遍歷 遍歷整個map時，利用iterator操作： 取key：it-&gt;first 或 *(it).first 取value：it-&gt;second 或 *(it).second for (auto it = mp.begin(); it != mp.end(); &#43;&#43;it){ cout &lt;&lt; it-&gt;first &lt;&lt; &#34; =&gt; &#34; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;; } for (auto it = mp.begin(); it != mp.end(); &#43;&#43;it){ cout &lt;&lt; (*it).first &lt;&lt; &#34; =&gt; &#34; &lt;&lt; (*it).second &lt;&lt; &#39;\n&#39;; } </p>
  </div>
  <footer class="entry-footer"><span title='2022-04-23 22:24:21 +0800 CST'>April 23, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - map" href="http://localhost:1313/c&#43;&#43;/stl_map/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[Java] HashMap中的hashCode設計原理
    </h2>
  </header>
  <div class="entry-content">
    <p>程式碼 static final int hash(Object key){ int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } h » 16 的用途 h是key.hashCode()，h &gt;&gt;&gt; 16代表的是取其高位的16位 key.hashCode() ^ (h » 16) 這與 Java1.8 中 tab[(n-1) &amp; hash] 的原理有關 static int indexFor(int h, int length){ return h &amp; (length - 1); } 返回的值即為陣列的下標。 大多數情況下，capacity 都小於2^16，所以在此的 &amp; 運算，只會對 h 的低16位進行 &amp; 運算。 若將高位16位也加入計算，可以增加下標的發散度，避免衝突的次數。 而使用 XOR 的原因是，更較於 AND 或 OR 均勻，因為 AND 會使結果趨向於 0，OR 會使結果趨向於 1。 </p>
  </div>
  <footer class="entry-footer"><span title='2022-04-22 11:22:39 +0800 CST'>April 22, 2022</span>&nbsp;·&nbsp;1 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [Java] HashMap中的hashCode設計原理" href="http://localhost:1313/java/hashmap/hashcode/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[C&#43;&#43;] 易錯題目收集
    </h2>
  </header>
  <div class="entry-content">
    <p>C&#43;&#43; 易錯題目收集 1. bit-format expression #include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; int main(){ unsigned int x = -1; int y = ~0; if (x==y) cout &lt;&lt; &#34;same&#34;; else cout &lt;&lt; &#34;not same&#34;; return 0; } 結果 same 解析 unsigned int x = -1 相當於11111111 y = ~0 也相當於11111111 2. 如何使 C(n,3) 正確且 n 的有效值最大? 結果 return n*(n-1)/2*(n-2)/3; 解析 n*(n-1)必為基偶相乘 n*(n-1)*(n-2)必為3的倍數 故此題的作法可避免因整數除法而造成的小數位消去 3. register在C&#43;&#43;中的用法 #include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; int main(){ register int i = 10; int *ptr = &amp;i; cout &lt;&lt; *ptr; return 0; } 選項 Prints 10 on all compilers Prints 0 on all compilers May generate Compilation Error May generate Runtime Error 結果 May generate Compilation Error 解析 register關鍵字用來分配變數儲存於CPU的register，以達到快速存取。所以對其提取有可能造成編譯錯誤，因為指標指向的位址不在在RAM上。 在大部分的C&#43;&#43;編譯器，不推薦使用register關鍵字，因為沒有任何意義，儘管他會被默認成auto關鍵字，使得C&#43;&#43;編譯器可能可能適用。 4. 有趣的 for loop 問題 int fun(){ static int num = 16; return num--; } int main(){ for(fun(); fun(); fun()) cout &lt;&lt; fun(); return 0; } 結果 14 11 8 5 2 解析 main()中的 for-loop 可以寫成等效的 while-loop 如下 int main(){ int num = 16; num--; // num = 15 while (num-- != 0){ // 先判斷後遞減 15 !=0, num = 14 cout &lt;&lt; (num--) &lt;&lt; &#34; &#34;; // 先印出後遞減印出 14, num = 13 num--; // 遞減後回到while, num = 12 } return 0; } static int num = 16 設定初值為 16，並遞減，故 num = 15 判斷 num 是否為真，後遞減。15 != 0，遞減使 num = 14，進入迴圈 印出 num = 14 後，遞減，num = 13 迴圈結束前作遞減，num = 12，重新回到 step2 5. const 與 volatile Pick the correct statemewnt for const and volatile keywords. 選項 const is the opposite of volatile and vice versa const and volatile can’t be used for struct and union const and volatile can’t be used for enum const and volatile can’t be used for typedef const and volatile are independent i.e. it’s possible that a variable is defined as both const and volatile 結果 const and volatile are independent i.e. it&#39;s possible that a variable is defined as both const and volatile 解析 const 是確保變數不會變修改，使其值變成唯讀。 volatile 通常用在具有最佳化或多執行緒相關的變數或物件，volatile用來阻止編譯器因誤認某段程式碼無法被程式碼本身所改變，而造成的過度優化。volatile會使得每次存取這個變數或物件時，都會直接從變數位址中取得資料，避免可能使用暫存器中的值，在變數可能被其他程式更新的狀況下，產生錯誤的值。 6. operator priority int main(){ cout &lt;&lt; (1 &lt;&lt; 2 &#43; 3 &lt;&lt; 4); return 0 } 結果 512 解析 &#43;優先於&lt;&lt; 故此段敘述等效於 cout &lt;&lt; (1 &lt;&lt; (2 &#43; 3) &lt;&lt; 4); cout &lt;&lt; (1 &lt;&lt; 5 &lt;&lt; 4); cout &lt;&lt; (32 &lt;&lt; 4); cout &lt;&lt; 512; 7. floating constant Suppose a C&#43;&#43; program has floating constant 1.414, what&#39;s the best way to convert this as &#34;float&#34; data type? 選項 (float)1.414 float(1.414) 1.414f or 1.414F 1.414 itself of “float” data type i.e. nothing else required 結果 `1.414f` or `1.414F` 解析 floating constant 被預設為 double 資料型態，故利用f或F的suffix，即可將之轉為 float 資料型態。 8. array pointer int main(){ int arr[5]; // Assume base address of arr is 2000 and size of integer is 32 bit printf(%u %u, arr&#43;1, &amp;arr&#43;1); return 0; } 結果 2004 2020 解析 array 的名稱會傳回第一個元素的地址(除了使用 sizeof)。 對 array 加 1 會加上 sizeof(type)。 &amp;array 代表整個 array 的地址，加 1 回加上 sizeof(while array)。 9. initialize array int main(){ int a[][] = {{1,2},{3,4}}; int i, j; for (int i = 0; i &lt; 2; i&#43;&#43;){ for (int j = 0; j &lt; 2; j&#43;&#43;){ printf(&#34;%d &#34;, a[i][j]); } } return 0; } 結果 Compilation Error 解析 Array 在記憶體中是以row-major的型式儲存的。 儘管 array 是多維陣列，他都是被儲存成單一線性的區塊 下列 assign 的方式是合法的，(第一個可被省略) int a[] = {...}; int a[][10] = {{...}, ...}; int a[][5][10] = {{{...},...},...}; </p>
  </div>
  <footer class="entry-footer"><span title='2022-04-17 17:34:39 +0800 CST'>April 17, 2022</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] 易錯題目收集" href="http://localhost:1313/c&#43;&#43;/question/"></a>
</article>

<article class="post-entry tag-entry"> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/images/cover.jpg" alt="Oh! You closed up the window, so you cannot see raining">
</figure>
  <header class="entry-header">
    <h2 class="entry-hint-parent">[C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - list, forward_list
    </h2>
  </header>
  <div class="entry-content">
    <p>list Lists 是序列式容器，但其記憶體的分配並非連續的。 跟 vector 相比，其遍歷的速度會較慢\(O(n)\，但一旦位置確定後，其插入(insert)或移除(delete)元素的速度很快\(O(1)\)。 一般來說，List 指的是雙向鏈結陣列(doubly linked list)。 而單向鏈結陣列則為 forward_list 函式庫 #include &lt;list&gt; 宣告 list&lt;data_type&gt; list_name; 初始化 list&lt;int&gt; lst; // 宣告 函式 1. front() 2. back() 3. push_front() 4. push_back() 5. pop_front() 6. pop_back() 7. list::begin() 8. list::end() 9. list::rbegin() 10. list::rend() 11. list::cbegin() 12. list::cend() 13. list::crbegin() 14. list::crend() 15. empty() 16. insert() 17. erase() 18. assign() 19. remove() 20. list::remove_if() 21. reverse() 22. size() 23. list::resize() 24. sort() 25. list::max_size() 26. list::unique() 27. list::emplace_front() 28. list::emplace_back() 29. list::clear() 30. list::operator= 31. list::swap() 32. list::splice() 33. list::merge()4 34. list::emplace() 示例 #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;list&gt; using namespace std; void print(list&lt;int&gt; lst){ list&lt;int&gt;::iterator it; for (it = lst.begin(); it != lst.end(); &#43;&#43;it){ cout &lt;&lt; *it &lt;&lt; &#34; &#34;; } cout &lt;&lt; &#34;\n&#34;; } int main(){ list&lt;int&gt; lst1, lst2; for (int i = 0; i &lt; 10; &#43;&#43;i){ lst1.push_back(i); lst2.push_front(i); } cout &lt;&lt; &#34;List1 is : &#34;; print(lst1); cout &lt;&lt; &#34;List2 is : &#34;; print(lst2); cout &lt;&lt; &#34;List1.front() : &#34; &lt;&lt; lst1.front() &lt;&lt; &#34;\n&#34;; cout &lt;&lt; &#34;List2.back() : &#34; &lt;&lt; lst2.back() &lt;&lt; &#34;\n&#34;; cout &lt;&lt; &#34;After List1.pop_front() : &#34;; lst1.pop_front(); print(lst1); cout &lt;&lt; &#34;After List2.pop_back() : &#34;; lst2.pop_back(); print(lst2); cout &lt;&lt; &#34;After List1.reverse() : &#34;; lst1.reverse(); print(lst1); cout &lt;&lt; &#34;After List2.sort() : &#34;; lst2.sort(); print(lst2); return 0; } 函式(functions) 1. list.front() Returns the value of the first element in the list. 2. list.back() Returns the value of the last element in the list. 3. list.push_front(E val) Adds a new element val at the beginning of the list. 4. list.push_back(E val) Adds a new element val at the end of the list. 5. list.pop_front() Removes the first element of the list, and reduces size of the list by 1. Won’t return value. 6. list.pop_back() Removes the last element of the list, and reduces size of the list by 1. Won’t return value. 7. list.begin() Returns a iterator pointing to the first element of the list. 6. list.end() Returns a iterator pointing to the theoretical last element which follows the last element. 7. list.rbegin() Returns a reverse iterator which points to the last element of the list. 8. list.rend() Returns a reverse iterator which points to the position before the beginning of the list. 9. list.cbegin() Returns a constant random access iterator which points to the beginning of the list. 10. list.cend() Returns a constant random access iterator which points to the end of the list. 11. list.crbegin() Returns a constant reverse random access iterator which points to the beginning of the list. 12. list.crend() Returns a constant reverse random access iterator which points to the end of the list. 13. list.empty() Returns whether the list is empty or not. 14. list.insert(pos, n, val) pos: iterator, to point out the position to insert n: the numbers of val to insert (optional, default = 1) val: the insert elements Inserts new elements in the list before the element at a specified position. 15. list.erase(pos) pos: iterator, to point out the position to erase Removes a single element from the list. 16. list.erase(first, last) first: iterator, to point out the begining of the range. last: iterator, to point out the end of the range. Removes a range of elements from the list. 17. list.assign() 18. list.remove() 19. list.remove_if() 20. list.reverse() 21. list.size() 22. list.resize() 23. list.sort() 24. list.max_size() 25. list.unique() 26. list.emplace_front() 27. list.emplace_back() 28. list.clear() 29. list.swap() 30. list.splice() 31. list.merge() 32. list.emplace() 你可能會想繼續閱讀… 回到容器(Containers) vector deque arrays forward_list </p>
  </div>
  <footer class="entry-footer"><span title='2022-04-17 11:45:58 +0800 CST'>April 17, 2022</span>&nbsp;·&nbsp;3 分鐘&nbsp;·&nbsp;Rain Hu</footer>
  <a class="entry-link" aria-label="post link to [C&#43;&#43;] The C&#43;&#43; Standard Template Library(STL) - list, forward_list" href="http://localhost:1313/c&#43;&#43;/stl_list/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://localhost:1313/tags/programming/">
      «&nbsp;上一頁&nbsp;
    </a>
    <a class="next" href="http://localhost:1313/tags/programming/page/3/">下一頁&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Rain Hu&#39;s Workspace</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
