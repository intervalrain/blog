<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Algo on Rain's Blog</title><link>http://intervalrain.github.io/tags/algo/</link><description>Recent content in Algo on Rain's Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 27 Jan 2023 10:50:26 +0800</lastBuildDate><atom:link href="http://intervalrain.github.io/tags/algo/index.xml" rel="self" type="application/rss+xml"/><item><title>[Algo] 2-4. 回溯法 Backtracking</title><link>http://intervalrain.github.io/posts/cs/algo/backtracking/</link><pubDate>Fri, 27 Jan 2023 10:50:26 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/backtracking/</guid><description>一、回溯法 二、回溯法的應用 三、例題 回到目錄：[Algo] 演算法筆記 想要複習：[Algo] 2-3. 分治法 接著閱讀：[Algo] 2-5. 動態規劃</description></item><item><title>[Algo] 2-3. 分治法 Divide and Conquer</title><link>http://intervalrain.github.io/posts/cs/algo/divide_and_conquer/</link><pubDate>Fri, 27 Jan 2023 10:48:42 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/divide_and_conquer/</guid><description>一、分治法 分治法，簡而言之就是分而治之，把複雜的問題分成兩個或更多個相似或相似的子問題，直到子問題可以直接求解，最後再將子問題的解做合併。 三步驟：Divide、Conquer、Merge 以 pseudo code 來表示大概像： void func(collection set) { // 子問題求解 if (base_case) { // 根據要求將子問題解合併成母問題解 do_something return; } // 將母問題分解成子問題 for (collection subset : set) { func(subset); } } graph LR; 母問題-->子問題1; 母問題-->子問題2; subgraph Divide 子問題1-->最小子問題1; 子問題1-->最小子問題2; 子問題2-->最小子問題3; 子問題2-->最小子問題4; end subgraph Conquer 最小子問題1-->最小子問題解1; 最小子問題2-->最小子問題解2; 最小子問題3-->最小子問題解3; 最小子問題4-->最小子問題解4; end subgraph Merge 最小子問題解1-->合併; 最小子問題解2-->合併; 最小子問題解3-->合併; 最小子問題解4-->合併; end 合併-->母問題解 舉例說明，河內塔遊戲： 河內塔是由三根桿子以大小不同碟片所組成的遊戲，僧人一次可以從一根桿子移動一個碟片到另一根桿子，但是小的碟片若放憂大的碟片下面會使得小的碟片裂開(也就是碟片只能由上而下從小排到大)，試問將一座塔從一根桿子完整的移動到另一根桿子需要移動多少次。 思考上面的情形，以三個碟片為例，若我們要從 A 到 C 移動一座塔，我們可以將之分解成「如何把上面兩個碟片移動到 B」，因為剩下的一個大碟片，可以很簡單的從 A 移動到 C。也就是說 f3(A-&amp;gt;C) = f2(A-&amp;gt;B) + f1(A-&amp;gt;C) + f2(B-&amp;gt;C)。 再更進一步，f2(A-&amp;gt;B) 和 f2(B-&amp;gt;C) 其實就是移動兩個碟片到另一座塔，所以可以分解成 f2(A-&amp;gt;C) = f1(A-&amp;gt;B) + f1(A-&amp;gt;C) + f1(B-&amp;gt;C)，至此，我們已經把 f3 都分解成可以代表一次移動的最小子問題的解 f1 了： graph TD; A[f3,A->C] B[f2,A->B] C[f1,A->C] D[f2,B->C] E[f1,A->C] F[f1,A->B] G[f1,C->B] H[f1,B->A] I[f1,B->C] J[f1,A->C] A-->B A--->C A-->D B-->E B-->F B-->G D-->H D-->I D-->J 故我們可以以數學方式證明：</description></item><item><title>[Algo] 2-2. 貪心演算法 Greedy</title><link>http://intervalrain.github.io/posts/cs/algo/greedy/</link><pubDate>Tue, 24 Jan 2023 18:31:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/greedy/</guid><description>一、貪心演算法 是一種在每一步都採前當下看起來最好的選擇的一種策略。 由於是當下看起來最好的選擇，故也有可能選到錯的路線，導致最終的答案不是最佳解。 先舉個生活中常見的例子： 今天小明的撲滿裡存滿了大大小小的1塊、5塊跟10塊，今天小明打算要要幫撲滿瘦身，令它的重量降低，那麼小明可以到銀行換鈔，將幣值小、重量重的硬幣集結起來換成幣值大、重量輕的紙鈔。 用貪心演算法的思維，我們一定是從幣值大的 1000 開始換起，再來 500、100、50、10，以此類推，有多少換多少。 // vector&amp;lt;int&amp;gt;&amp;amp; nums = {1000, 500, 100, 50, 10, 5, 1}; vector&amp;lt;int&amp;gt; coinChange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int money) { vector&amp;lt;int&amp;gt; res(nums.size(), 0); for (int i = 0; i &amp;lt; nums.size(); i++) { res[i] += (money / nums[i]); money %= nums[i]; } return res; } 但若我們新增了一個幣值是 23，那麼上面這個思路就有可能會導致錯誤。 貪心演算法的特點 直覺且快速 通常不是最佳的 需要會被要求證明 always stays ahead：跑者每個時間點都在第一名，最後結果會是第一名 用歸納法證明。 exchange argument 用反證法，找到原解的 inversions，並作交換，證明交換後並不影響最佳解。 二、貪心演算法的應用 0. 核心思維 貪心演算法是從某一個初始狀態出發，每次通過選取區域性最優解向目標前進，並最終期望取得整體最優解的一種演算法。由這個定義可知，貪心選擇標準就是選擇當前最好的決策，貪心演算法根據這個標準進行決策，將原問題變成一個相似但規模更小的子問題，而後每一步選出來的一定是原問題整體最優解的一部分。
如果一個問題貪心後只剩下一個子問題且有最優子結構，那麼該問題就可以使用貪心演算法。當一個問題的整體最優解包含其子問題的最優解時，我們稱次問題具有最優子結構性質。 解題一般步驟 設計資料結構並找規律 進心貪心猜想 正確性證明(歸納法證明或是列舉反例進行反證) 實現程式碼 1.</description></item><item><title>[Algo] 2-1. 暴力演算法 Brute Force</title><link>http://intervalrain.github.io/posts/cs/algo/brute_force/</link><pubDate>Tue, 24 Jan 2023 15:57:40 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/brute_force/</guid><description>一、暴力演算法 暴力演算法就是枚舉法，試想今天有一個行李箱的密碼鎖為四個一組，但你又忘記密碼，那要怎麼辦？你會試著從 0000 轉到 9999 共 10000 種組合都試過，必定會找出密碼，把所有可能都枚舉過一遍，遍是暴力演算法。
暴力演算法可以應用於很多問題，包含數論、樹、圖論等等，而暴力演算法的重點在於枚舉所有可能，以樹來說就是樹的遍歷。
舉例來說：
Leetcode 1. Two Sum
給定一個數列，找數列中任兩個數的和為 target，回傳兩個數的索引值。 在還沒有認識任何資料結構之前，我們能想到最簡單的方法就是遍歷整個數列，用兩個指標 i 與 j，各指向一個數，將所有可能檢查過一遍，直到找到目標。 vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { for (int i = 0; i &amp;lt; nums.size() - 1; i++) for (int j = i + 1; j &amp;lt; nums.size(); j++) if (nums[i] + nums[j] == target) return {i, j}; return {-1, -1}; } 以上例來說，用暴力破解法求解時，求兩數和的時候，我們需進行兩個維度的 for-loop 迴圈來求解。若進一步到三數和、四數和、五數和時，我們會發現，維度會隨著多少個數字和增加。也就是三數和為 3 個迴圈，四數和為 4 個迴圈，以此類推。 以 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis來分析，也就相當於 k 數和的時間複雜度為 \(O(n^k)\)，這個增長是相當恐怖的。 暴力演算法的特點</description></item><item><title>[Algo] 1-9. Algorithm</title><link>http://intervalrain.github.io/posts/cs/algo/algorithm/</link><pubDate>Tue, 03 Jan 2023 21:49:42 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/algorithm/</guid><description>algorithm &amp;lt;algorithm&amp;gt; 定義了專為元素集合設計的函式。
元素集合包含可以被迭代器或指標存取的一系列元素，例如陣列或 STL container。但且注意，演算法只會透過迭代器去操作容器中的值，並不會更改其結構或是大小。
一、函式 1. 無修改值的操作 all_of bool all_of(Iterator first, Iterator last, UnaryPredicate pred)
檢查是否全部的元素都符合判斷式。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int main(){ vector&amp;lt;int&amp;gt; arr1 = {1,2,3,4,5}; vector&amp;lt;int&amp;gt; arr2 = {1,3,5,7,9}; vector&amp;lt;int&amp;gt; arr3 = {2,4,6,8,10}; auto isodd = [](int x)-&amp;gt;bool{ return x%2; }; cout &amp;lt;&amp;lt; all_of(arr1.begin(), arr1.end(), isodd) &amp;lt;&amp;lt; endl; // 0 cout &amp;lt;&amp;lt; all_of(arr2.begin(), arr2.end(), isodd) &amp;lt;&amp;lt; endl; // 1 cout &amp;lt;&amp;lt; all_of(arr3.begin(), arr3.</description></item><item><title>[Algo] 2-5. 動態規劃 Dynamic Programming</title><link>http://intervalrain.github.io/posts/cs/algo/dp/</link><pubDate>Tue, 15 Nov 2022 16:10:53 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/dp/</guid><description>一、動態規劃的思考藝術 動態規劃其實就是一種暴力枚舉的優化，在暴力枚舉的過程中有著大量的重複，藉由「備忘錄(memoization)」的方式做到剪枝(pruning)來達到優化的一種演算法。 舉例來說： Leetcode 62. Unique Paths
機器人由左上走到右下角星星有幾種走法，其中機器人只能選擇往右走或往下走。 試想機器人從 (1,1) 走到 (m,n) 的不同路徑中，可見有大量的重複，比如過程中有一點 (i,j)，其 (1,1) 走到 (i,j) 有 k 條不同路徑，麼那對於任何一條固定 (i,j) 到 (m,n) 的路徑，都需走 k 遍來模擬。 但其實我們不必關心具體的走法，我們只關心狀態，也就是走法的數目。 同理，我們若知道 (i,j) 到 (m,n) 共有 t 條不同的路徑，那麼 (1,1) -&amp;gt; (i,j) -&amp;gt; (m,n) 的不同路徑總數就是 k*s。 我們知道最左邊那欄與最上面那列都只有可能有一種路徑可以走，又每一格的路徑來自於上方與左方的和： sum of (i,j) = sum of (i-1,j) + sum of (i,j-1) \(\begin{array}{|c|c|c|c|c|c|c|}\hline \text{1}&amp;amp;\text{1}&amp;amp;\text{1}&amp;amp;\text{1}&amp;amp;\text{1}&amp;amp;\text{1}&amp;amp;\text{1}\\\hline \text{1}&amp;amp;\text{2}&amp;amp;\text{3}&amp;amp;\text{4}&amp;amp;\text{5}&amp;amp;\text{6}&amp;amp;\text{7}\\\hline \text{1}&amp;amp;\text{3}&amp;amp;\text{6}&amp;amp;\text{10}&amp;amp;\text{15}&amp;amp;\text{21}&amp;amp;\text{28}\\\hline \end{array}\) 寫成程式碼就是 int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m+1, vector&amp;lt;int&amp;gt;(n+1,0)); for (int i = 1; i &amp;lt;= m; i++) // 將第一列填成 1 dp[i][1] = 1; for (int j = 1; j &amp;lt;= n; j++) // 將第一欄填成 1 dp[1][j] = 1; for (int i = 2; i &amp;lt;= m; i++) { // 將剩下的格子填完 for (int j = 2; j &amp;lt;= n; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m][n]; } 注意填格子的順序是有一定的限制的，必須要確保相關聯的子問題已經處理過。 動態規劃 由上例我們可以發現，原本的問題可以拆解成更小的問題(從 (1,1)-&amp;gt;(m,n) 變成從 (1,1)-&amp;gt;(i,j) 和從 (i,j)-&amp;gt;(m,n))。 我們令 f(i,j) 表示從 (1,1)-&amp;gt;(i,j) 的不同路徑數，則我們可以得到轉移方程式 f(i,j)=f(i-1,j)+f(i,j-1)。 我們發現，想求出 f(i,j) 只需要知道幾個更小的 f(i',j')。我們將 f(i',j') 稱為子問題。 我們捨棄冗餘的訊息(具體的走法)，只記錄對解決問題有幫助的結果。 動態規劃的兩大特點(適用前提) 無後效性 一旦 f(i,j) 確定，就不用關心我們如何計算出 f(i,j) 想要確定 f(i,j)，只需要知道 f(i-1,j) 和 f(i,j-1) 的值，而至於它們是如何算出來的，對當前或之後的任何子問題都沒有影響。 過去不依賴未來，未來不影響過去。 最優子結構 f(i,j) 的定義就已經蘊含了最優。 大問題的最優解可以由若干個小問題的最優解推出。(max, min, sum&amp;hellip;) DP 能適用於：能將大問題拆成若干小問題，滿足無後效性、最優子結構性質。 以下介紹幾種刷題會遇到的動態規劃套路： 二、動態規劃框架 1.</description></item><item><title>[Algo] 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis</title><link>http://intervalrain.github.io/posts/cs/algo/bigo/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/bigo/</guid><description>一、Big O 表示法 Big O 的數學定義： \(\boxed{O(g(n)) = \lbrace{f(n):存在正常量\space c\space 和\space n_0，使得對所有\space n\ge n_0，有\space 0 \le f(n) \le cg(n)\rbrace}}\) 我們常用的 big O 表示法中的 \(O\) 其實代表了一個函數的集合，比方說 \(O(n^2)\) 代表著一個由 \(g(n) = n^2\) 派生出來的一個函數集合；我們說一個演算法的時間複雜度為 \(O(n^2)\)，意思就是描述該演算法的複雜度函數屬於這個函數集合之中。 分析複雜度時，常用的兩個特性： 只保留增長速率最快的項，其它省略 \(\boxed{O(2n+100) = O(n)}\) \(\boxed{O(2^{n+1}) = O(2^n)}\) \(\boxed{O(m+3n+99) = O(m+n)}\) \(\boxed{O(n^3+999\times n^2+999\times n) = O(n^3)}\) Big O 記號表示複雜度的「上限」 換句話說，只要給出的是一個上限，用 Big O 表示法都是正確的。 但在習慣上，我們特別取最緊臨的上限。但若複雜度會跟算法的輸入數據有關，沒辦法提前給出一個特別精確的時間複雜度時，擴大時間複雜度的上限就變得有意義了。 例如湊零錢問題中，金額 amount 的值為 n，coins 列表中的個數為 k，則這棵遞迴樹就是 K 叉樹。而節點的數量與樹的結構有關，而我們無法提前知道樹的結構，所以我們按照最壞情形來處理，高度為 n 的一棵滿 k 叉樹，其節點數為 \(\frac{k^n-1}{k-1}\)，用 big O 表示就是 \(O(k^n)\)。 回到目錄：[Algo] 演算法筆記 接著閱讀：[Algo] 0-2.</description></item><item><title>[Algo] 0-4. 二叉樹(Binary Tree)</title><link>http://intervalrain.github.io/posts/cs/algo/binary_tree/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/binary_tree/</guid><description>一、二叉樹的思維模式 二叉樹的解題模式大致分為兩類： 是否可以通過遍歷一遍得解 是否可以定義一個遞迴函數，通過分治法推導出原問題的答案？ [LeetCode. 104] Maximum Depth of Binary Tree(Easy) 以此題為例，可以遍歷完整個樹，並比較當下的樹的深度，得以求解。 int depth = 0; int maxDepth(TreeNode* root){ traverse(root, 1); return depth; } void traverse(TreeNode* root, int currDepth){ if (!root) return; traverse(root-&amp;gt;left, currDepth+1); depth = max(depth, currDepth); traverse(root-&amp;gt;right, currDepth+1); } 若想辦法定義一個遞迴函數，通過分治法推導出原問題，換言之，就是先處理更小的樹，再藉由小的樹處理大的樹： int maxDepth(TreeNode* root) { if (root == NULL) return 0; return 1 + max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)); } 事實上，兩個思維模式便對應著兩種演算法：回溯法(back tracking)與動態規劃(dynamic programming) 二、前序、中序、後序 無論使用哪種思維模式(遍歷或找出遞迴函數)，都要思考單獨抽出一個節點，它需要在何時(前、中、後序)做哪些事情，其它的節點交由遞迴函數去執行相同的操作。 以下我們以 quick sort 與 merge sort 為例，同樣是分治法，看看在數組上有什麼同樣的思維模式。 quick sort 從 sort() 函式便可見類似於前序的結構。 void sort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right){ if (left &amp;gt;= right) return; // 終止條件 int mid = partition(nums, left, right); // 做什麼事(pre-order) sort(nums, left, mid-1); // 左子樹 sort(nums, mid+1, right); // 右子樹 } int partition(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right){ int pivot = right; while (left &amp;lt; right){ while (nums[left] &amp;lt; nums[pivot]) left++; while (nums[right] &amp;gt; nums[pivot]) right--; if (left &amp;lt; right) swap(nums[left], nums[right]); } if (left == right &amp;amp;&amp;amp; nums[left] &amp;gt; nums[pivot] || nums[right] &amp;lt; nums[pivot]){ swap(nums[left], pivot); return left; } return pivot; } merge sort 從 sort() 函式便可見類似於後序的結構。 void sort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right){ if (right &amp;lt;= left) return; // 終止條件 int mid = left + (right-left)/2; sort(nums, left, mid); // 左子樹 sort(nums, mid+1, right); // 右子樹 merge(nums, left, mid, right); // 做什麼事(post-order) } void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int mid, int right){ vector&amp;lt;int&amp;gt; vec; int i = left, j = mid+1; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right){ int x = nums[i] &amp;lt; nums[j] ?</description></item><item><title>[Algo] 0-3. 鏈表(Linked List)</title><link>http://intervalrain.github.io/posts/cs/algo/linked_list/</link><pubDate>Thu, 06 Oct 2022 22:30:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/linked_list/</guid><description>一、鏈表的基本結構 鏈表是由節點和指針構成的數據結構，每個節點存有一個值，和一個指向下一個節點的指針。不同於數組，鏈表並不能隨機訪問，必須透過指針找到該節點才能獲取其值；同理在未遍歷到鏈表結尾時，我們也無法知道鏈表長度，除非依賴其它數據結構儲存長度。 LeetCode 中默認的鏈表： struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; 二、鏈表的基本操作 在開始演算法實踐前，先來練習一下鏈表的 CRUD 吧！ 1. 查(Read) 由於鏈表並非在儲存格中連續分布，所以無法用索引進行隨機訪問，所以我們必須逐個訪問，直到到達我們想要的元素。 藉由指針每次指向當前節點的 next，移動 n 次到達 index 為 n 的節點。 int at(ListNode* head, int n){ // index 為 n ListNode* curr = head; while (n--){ // 移動 n 次 curr = curr-&amp;gt;next; } return curr-&amp;gt;val; } 2. 改(Update) 改的步驟，只是將查完的元素予以賦值。 void update(ListNode* head, int n, int val){ ListNode* curr = head; while (n--){ curr = curr-&amp;gt;next; } curr-&amp;gt;val = val; // 查完後賦值 } 3.</description></item><item><title>[Algo] 0-2. 算法思維</title><link>http://intervalrain.github.io/posts/cs/algo/concept/</link><pubDate>Thu, 06 Oct 2022 22:15:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/concept/</guid><description>一、資料結構概要 資料結構的存儲方式大體上只分為兩種： Array、Linked List。
雖說資料結構有 disjoint matrix, queue, stack, tree, graph 等等，但它們都可以視為 Array 與 Linked List 的上層結構，可以看成是以 Array 或 Linked List 為基底上的操作，只是 API 不同而已。 Array：由於是緊湊連續儲存的，可以隨機訪問，通過 index 快速找到對應元素，且相對節約空間。但也因必須一次性分配儲存空間，所以 array 如果需要擴充容量，就必須再重新分配一塊更大的空間，再把數孛複製過去，其時間複雜度為 \(O(N)\)；在 array 中間進行 delete 與 insert，必須搬移後面所有數據以保持連續，故時間複雜度也為\(O(N)\)。 Linked List：因為元素不連續，而是靠指針指向下一個元素的位置，所以不存在 array 的擴充容量的問題，如果知道某一元素的前一個節點與後一個節點，操作指針即可刪除該元素或者插入新元素，時間複雜度為\(O(1)\)。但正因為儲存空間不連續，無法根擇 index 算出對應元素的地址，所以不能隨機訪問；而且由於每個元素必須額外儲存前後元素位置的指針，相對較耗空間。 在 C、C++ 語言中，指針(pointer)的存在使得其能更直接對儲存空間的位址做操作，所以在處理 C 語言時，要額外了解指針的運作方式。 二、資料結構的基本操作 資料結構的基本操作不外乎： 遍歷(traverse)、增減查改(CRUD, create, read, update, delete) Array：數組的遍歷框架 -&amp;gt; 典型的線性迭代結構： void traverse(vector&amp;lt;int&amp;gt; arr){ for (int i = 0; i &amp;lt; arr.size(); i++){ // iteration } } ListNode：鏈表的遍歷框架 -&amp;gt; 兼具迭代與遞迴 class ListNode { public: int val; ListNode* next; }; void traverse(ListNode* head){ for (ListNode curr = head; curr !</description></item></channel></rss>