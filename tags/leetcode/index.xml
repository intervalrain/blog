<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Leetcode on Rain's Blog</title><link>http://intervalrain.github.io/tags/leetcode/</link><description>Recent content in Leetcode on Rain's Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 03 Jan 2023 20:09:30 +0800</lastBuildDate><atom:link href="http://intervalrain.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>[LeetCode] 944. Delete Columns to Make Sorted</title><link>http://intervalrain.github.io/posts/leetcode/944/</link><pubDate>Tue, 03 Jan 2023 20:09:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/944/</guid><description>944. Delete Columns to Make Sorted
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、String 一、題目 You are given an array of n string strs, all of the same length.
The string s can be arranged such that there is one on each line, making a grid. For example, strs = [&amp;quot;abc&amp;quot;, &amp;quot;bce&amp;quot;, &amp;quot;cae&amp;quot; can be arranged as :
abc bce cae You want to delete the columns that are not sorted lexicographically. In the aove example (0-indexed), columns 0('a','b','c') and 2('c','e','e') are sorted while column 1('b','c','a') is not, so you would delete column 1.</description></item><item><title>[LeetCode] 2522. Partition String Into Substrings With Values at Most K</title><link>http://intervalrain.github.io/posts/leetcode/2522/</link><pubDate>Mon, 02 Jan 2023 23:15:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2522/</guid><description>2522. Partition String Into Substrings With Values at Most K
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 You are given a string s consisting of digits from 1 to 9 and an integer k.
A partition of a string s is called good if:
Each digit of s is part of exactly one substring. The value of each substring is less than or equal to k. Return the minimum number of substrings in a good partition of s.</description></item><item><title>[LeetCode] 2523. Closest Prime Numbers in Range</title><link>http://intervalrain.github.io/posts/leetcode/2523/</link><pubDate>Mon, 02 Jan 2023 16:33:40 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2523/</guid><description>2523. Closest Prime Numbers in Range
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 Given two positive integers left and right, find the two integers num1 and num2 such that:
left &amp;lt;= nums1 &amp;lt; nums2 &amp;lt;= right. nums1 and nums2 are both prime numbers. nums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.
Return the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.</description></item><item><title>[LeetCode] 520. Detect Capital</title><link>http://intervalrain.github.io/posts/leetcode/520/</link><pubDate>Mon, 02 Jan 2023 11:05:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/520/</guid><description>520. Detect Capital
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String 一、題目 We define the usage of capitals in a word to be right when one of the following cases holds:
All letters in this word are capitals, like &amp;quot;USA&amp;quot;. All letters in this word are not capitals, like &amp;quot;leetcode&amp;quot;. Only the first letter in this word is capital, like &amp;quot;Google&amp;quot;.
Given a string word, return true if the usage of capitals in it is right.</description></item><item><title>[LeetCode] 2521. Distinct Prime Factors of Product of Array</title><link>http://intervalrain.github.io/posts/leetcode/2521/</link><pubDate>Sun, 01 Jan 2023 23:52:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2521/</guid><description>2521. Distinct Prime Factors of Product of Array
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.
Note that:
A number greater than 1 is called prime if it is divisible by only 1 and itself. An integer val1 is a factor of another integer val2 if val2 / val1 is an integer.</description></item><item><title>[LeetCode] 2520. Count the Digits That Divide a Number</title><link>http://intervalrain.github.io/posts/leetcode/2520/</link><pubDate>Sun, 01 Jan 2023 23:41:54 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2520/</guid><description>2520. Count the Digits That Divide a Number
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 Given an integer num, return the number of digits in num that divide num. An integer val divides nums if nums % val == 0.
Example 1:
Input: num = 7 Output: 1 Explanation: 7 divides itself, hence the answer is 1. Example 2:
Input: num = 121 Output: 2 Explanation: 121 is divisible by 1, but not 2.</description></item><item><title>[LeetCode] 290. Word Pattern</title><link>http://intervalrain.github.io/posts/leetcode/290/</link><pubDate>Sun, 01 Jan 2023 23:14:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/290/</guid><description>290. Word Pattern
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Hash Table、String 一、題目 Given a pattern and a string s, find if s follows the same pattern.
Here follow means a full match, such that there is a bijection between a letter in pattern and non-empty word in s.
Example 1:
Input: pattern = &amp;ldquo;abba&amp;rdquo;, s = &amp;ldquo;dog cat cat dog&amp;rdquo; Output: true Example 2:
Input: pattern = &amp;ldquo;abba&amp;rdquo;, s = &amp;ldquo;dog cat cat fish&amp;rdquo; Output: false Example 3:</description></item><item><title>[LeetCode] 1834. Single-Threaded CPU</title><link>http://intervalrain.github.io/posts/leetcode/1834/</link><pubDate>Thu, 29 Dec 2022 22:49:27 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1834/</guid><description>1834. Single-Threaded CPU
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Sorting、Heap (Priority Queue&amp;gt; 一、題目 You are given n​​​​ tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the i​​​​​​th​​​​ task will be available to process at enqueueTimei and will take processingTimei to finish processing.
You have a single-threaded CPU that can process at most one task at a time and will act in the following way:</description></item><item><title>[LeetCode] 1962. Remove Stones to Minimize the Total</title><link>http://intervalrain.github.io/posts/leetcode/1962/</link><pubDate>Thu, 29 Dec 2022 00:03:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1962/</guid><description>1962. Remove Stones to Minimize the Total
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Heap (Priority Queue) 一、題目 You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:
Choose any piles[i] and remove floor(piles[i] / 2) stones from it. Notice that you can apply the operation on the same pile more than once.</description></item><item><title>[LeetCode] 2279. Maximum Bags With Full Capacity of Rocks</title><link>http://intervalrain.github.io/posts/leetcode/2279/</link><pubDate>Tue, 27 Dec 2022 20:48:32 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2279/</guid><description>2279. Maximum Bags With Full Capacity of Rocks
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Greedy、Sorting 一、題目 You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.</description></item><item><title>[LeetCode] 2389. Longest Subsequence With Limited Sum</title><link>http://intervalrain.github.io/posts/leetcode/2389/</link><pubDate>Sun, 25 Dec 2022 20:07:51 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2389/</guid><description>2389. Longest Subsequence With Limited Sum
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Binary Search、Greedy、Sorting、Prefix Sum 一、題目 You are given an integer array nums of length n, and an integer array queries of length m.
Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</description></item><item><title>[LeetCode] 790. Domino and Tromino Tiling</title><link>http://intervalrain.github.io/posts/leetcode/790/</link><pubDate>Sat, 24 Dec 2022 23:53:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/790/</guid><description>790. Domino and Tromino Tiling
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Dynamic Programming 一、題目 You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.
Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 10^9 + 7.
In a tiling, every square must be covered by a tile.</description></item><item><title>[LeetCode] 841. Keys and Rooms</title><link>http://intervalrain.github.io/posts/leetcode/841/</link><pubDate>Tue, 20 Dec 2022 23:00:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/841/</guid><description>841. Keys and Rooms
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Depth-First Search、Breadth-First Search、Graph 一、題目 There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.
When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</description></item><item><title>[LeetCode] 25. Reverse Nodes in k-Group</title><link>http://intervalrain.github.io/posts/leetcode/25/</link><pubDate>Fri, 16 Dec 2022 23:32:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/25/</guid><description>25. Reverse Nodes in k-Group
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Linked List、Recursion 一、題目 Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</description></item><item><title>[LeetCode] 24. Swap Nodes in Pairs</title><link>http://intervalrain.github.io/posts/leetcode/24/</link><pubDate>Wed, 14 Dec 2022 23:35:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/24/</guid><description>24. Swap Nodes in Pairs
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Recursion 一、題目 Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&amp;rsquo;s nodes (i.e., only nodes themselves may be changed.)
Example 1:
Input: head = [1,2,3,4] Output: [2,1,4,3] Example 2:
Input: head = [] Output: [] Example 3:
Input: head = [1] Output: [1] Constraints:</description></item><item><title>[LeetCode] 931. Minimum Falling Path Sum</title><link>http://intervalrain.github.io/posts/leetcode/931/</link><pubDate>Tue, 13 Dec 2022 21:53:27 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/931/</guid><description>931. Minimum Falling Path Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Matrix 一、題目 Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.
A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).</description></item><item><title>[LeetCode] 70. Climbing Stairs</title><link>http://intervalrain.github.io/posts/leetcode/70/</link><pubDate>Mon, 12 Dec 2022 22:43:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/70/</guid><description>70. Climbing Stairs
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math、Dynamic Programming、Memoization 一、題目 You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps Example 2:</description></item><item><title>[LeetCode] 2501. Longest Square Streak in an Array</title><link>http://intervalrain.github.io/posts/leetcode/2501/</link><pubDate>Sun, 11 Dec 2022 22:42:14 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2501/</guid><description>2501. Longest Square Streak in an Array
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、Binary Search、Dynamic Programming、Sorting \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 You are given an integer array nums. A subsequence of nums is called a square streak if:
The length of the subsequence is at least 2, and after sorting the subsequence, each element (except the first element) is the square of the previous number.
Return the length of the longest square streak in nums, or return -1 if there is no square streak.</description></item><item><title>[LeetCode] 2500. Delete Greatest Value in Each Row</title><link>http://intervalrain.github.io/posts/leetcode/2500/</link><pubDate>Sun, 11 Dec 2022 22:42:12 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2500/</guid><description>2500. Delete Greatest Value in Each Row
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Hash Table、Binary Search、Dynamic Programming、Sorting \(\color{blue}\textsf{Weekly Contest 323}\) 一、題目 You are given an m x n matrix grid consisting of positive integers.
Perform the following operation until grid becomes empty:
Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them. Add the maximum of deleted elements to the answer.
Note that the number of columns decreases by one after each operation.</description></item><item><title>[LeetCode] 124. Binary Tree Maximum Path Sum</title><link>http://intervalrain.github.io/posts/leetcode/124/</link><pubDate>Sun, 11 Dec 2022 21:53:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/124/</guid><description>124. Binary Tree Maximum Path Sum
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Dynamic Programming、Tree、Depth-First Search、Binary Tree 一、題目 A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node&amp;rsquo;s values in the path.</description></item><item><title>[LeetCode] 1339. Maximum Product of Splitted Binary Tree</title><link>http://intervalrain.github.io/posts/leetcode/1339/</link><pubDate>Sat, 10 Dec 2022 20:12:36 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1339/</guid><description>1339. Maximum Product of Splitted Binary Tree
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, split the bianry tree into two subtrees by removing one edge such that the product of the sums of the subtreesis maximized.
Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 10^9 + 7.
Note that you need to maximize the answer before taking the mod and not after taking it.</description></item><item><title>[LeetCode] 1026. Maximum Difference Between Node and Ancestor</title><link>http://intervalrain.github.io/posts/leetcode/1026/</link><pubDate>Sat, 10 Dec 2022 00:49:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1026/</guid><description>1026. Maximum Difference Between Node and Ancestor
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.
A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.</description></item><item><title>[LeetCode] 872. Leaf-Similar Trees</title><link>http://intervalrain.github.io/posts/leetcode/872/</link><pubDate>Thu, 08 Dec 2022 21:41:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/872/</guid><description>872. Leaf-Similar Trees
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Tree、Depth-First Search、Binary Tree 一、題目 Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).
Two binary trees are considered leaf-similar if their leaf value sequence is the same.
Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.</description></item><item><title>[LeetCode] 938. Range Sum of BST</title><link>http://intervalrain.github.io/posts/leetcode/938/</link><pubDate>Wed, 07 Dec 2022 23:41:31 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/938/</guid><description>938. Range Sum of BST
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Tree、Depth-First Search、Binary Search Tree、Binary Tree 一、題目 Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].
Example 1:
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15].</description></item><item><title>[LeetCode] 328. Odd Even Linked List</title><link>http://intervalrain.github.io/posts/leetcode/328/</link><pubDate>Tue, 06 Dec 2022 23:56:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/328/</guid><description>328. Odd Even Linked List
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List 一、題目 Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
The first node is considered odd, and the second node is even, and so on.
Note that the relative order inside both the even and odd groups should remain as it was in the input.</description></item><item><title>[LeetCode] 2472. Maximum Number of Non-overlapping Palindrome Substrings</title><link>http://intervalrain.github.io/posts/leetcode/2472/</link><pubDate>Tue, 29 Nov 2022 23:55:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2472/</guid><description>2472. Maximum Number of Non-overlapping Palindrome Substrings
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: String、Dynamic Programming \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 You are given a string s and a positive integer k. Select a set of non-overlapping substrings from the string s that satisfy the following conditions:
The length of each substring is at least k. Each substring is a palindrome. Return the maximum number of substrings in an optimal selection. A substring is a contiguous sequence of characters within a string.</description></item><item><title>[LeetCode] 2471. Minimum Number of Operations to Sort a Binary Tree by Level</title><link>http://intervalrain.github.io/posts/leetcode/2471/</link><pubDate>Tue, 29 Nov 2022 23:55:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2471/</guid><description>2471. Minimum Number of Operations to Sort a Binary Tree by Level
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Tree、Breadth-First Search、Binary Tree \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.</description></item><item><title>[LeetCode] 2470. Number of Subarrays With LCM Equal to K</title><link>http://intervalrain.github.io/posts/leetcode/2470/</link><pubDate>Tue, 29 Nov 2022 23:55:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2470/</guid><description>2470. Number of Subarrays With LCM Equal to K
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Math、Number Theory \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 Given an integer array nums and an integer k, return the number of subarrays of nums where the least common multiple of the subarray&amp;rsquo;s elements is k. A subarray is a contiguous non-empty sequence of elements within an array. The least common multiple of an array is the smallest positive integer that is divisible by all the array elements.</description></item><item><title>[LeetCode] 2469. Convert the Temperature</title><link>http://intervalrain.github.io/posts/leetcode/2469/</link><pubDate>Tue, 29 Nov 2022 23:55:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2469/</guid><description>2469. Convert the Temperature
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math \(\color{blue}\textsf{weekly Contest 319}\) 一、題目 You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius. You should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit]. Return the array ans. Answers within 10^-5 of the actual answer will be accepted. Note that:
Kelvin = Celsius + 273.</description></item><item><title>[LeetCode] 446. Arithmetic Slices II - Subsequence</title><link>http://intervalrain.github.io/posts/leetcode/446/</link><pubDate>Mon, 28 Nov 2022 23:39:03 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/446/</guid><description>446. Arithmetic Slices II - Subsequence
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Dynamic Programming 一、題目 Given an integer array nums, return the number of all the arithmetic subsequences of nums. A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.</description></item><item><title>[LeetCode] 2488. Count Subarrays With Median K</title><link>http://intervalrain.github.io/posts/leetcode/2488/</link><pubDate>Sun, 27 Nov 2022 21:04:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2488/</guid><description>2488. Count Subarrays With Median K
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Hash Table、Prefix Sum \(\color{blue}\textsf{Weekly Contest 321}\) 一、題目 You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.
Return the number of non-empty subarrays in nums that have a median equal to k. Note:
The median of an array is the middle element after sorting the array in ascending order.</description></item><item><title>[LeetCode] 2487. Remove Nodes From Linked List</title><link>http://intervalrain.github.io/posts/leetcode/2487/</link><pubDate>Sun, 27 Nov 2022 21:04:51 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2487/</guid><description>2487. Remove Nodes From Linked List
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Stack、Recursion、Monotonic Stack \(\color{blue}\textsf{Weekly Contest 321}\) 一、題目 You are given the head of a linked list.
Remove every node which has a node with strictly greater value anywhere to the right side of it.
Return the head of the modified linked list.
Example 1:
Input: head = [5,2,13,3,8] Output: [13,8] Explanation: The nodes that should be removed are 5, 2 and 3.</description></item><item><title>[LeetCode] 2486. Accept Characters to String to Make Subsequence</title><link>http://intervalrain.github.io/posts/leetcode/2486/</link><pubDate>Sun, 27 Nov 2022 21:04:50 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2486/</guid><description>2486. Accept Characters to String to Make Subsequence
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Two Pointer、String、Greedy \(\color{blue}\textsf{Weekly Contest 321}\) 一、題目 You are given two strings s and t consisting of only lowercase English letters. Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.</description></item><item><title>[LeetCode] 2485. Find the Pivot Integer</title><link>http://intervalrain.github.io/posts/leetcode/2485/</link><pubDate>Sun, 27 Nov 2022 21:04:47 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2485/</guid><description>2485. Find the Pivot Integer
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math、Prefix Sum \(\color{blue}\textsf{Weekly Contest 321}\) 一、題目 Given a positive integer n, find the pivot integer x such that:
The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively. Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.</description></item><item><title>[LeetCode] 1235. Maximum Profit in Job Scheduling</title><link>http://intervalrain.github.io/posts/leetcode/1235/</link><pubDate>Sat, 26 Nov 2022 14:09:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1235/</guid><description>1235. Maximum Profit in Job Scheduling
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Binary Search、Dynamic Programming、Sorting 一、題目 We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&amp;rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X.</description></item><item><title>[LeetCode] 1143. Longest Common Subsequence</title><link>http://intervalrain.github.io/posts/leetcode/1143/</link><pubDate>Thu, 24 Nov 2022 23:15:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1143/</guid><description>1143. Longest Common Subsequence
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String、Dynamic Programming 一、題目 Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
For example, &amp;quot;ace&amp;quot; is a subsequence of &amp;quot;abcde&amp;quot;.</description></item><item><title>[LeetCode] 300. Longest Increasing Subsequence</title><link>http://intervalrain.github.io/posts/leetcode/300/</link><pubDate>Thu, 24 Nov 2022 20:59:40 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/300/</guid><description>300. Longest Increasing Subsequence
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Binary Search、Dynamic Programming 一、題目 Given an integer array nums, return the length of the longest strictly increasing subsequence
Example 1:
Input: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Example 2:
Input: nums = [0,1,0,3,2,3] Output: 4 Example 3:
Input: nums = [7,7,7,7,7,7,7] Output: 1 Constraints:
1 &amp;lt;= nums.length &amp;lt;= 2500 -104 &amp;lt;= nums[i] &amp;lt;= 104 Follow up: Can you come up with an algorithm that runs in O(n log n) time complexity</description></item><item><title>[LeetCode] 2468. Split Message Based on Limit</title><link>http://intervalrain.github.io/posts/leetcode/2468/</link><pubDate>Thu, 24 Nov 2022 01:09:57 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2468/</guid><description>2468. Split Message Based on Limit
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: String、Binary Search \(\color{blue}\textsf{Biweekly Contest 91}\) 一、題目 You are given a string, message, and a positive integer, limit.
You must split message into one or more parts based on limit. Each resulting part should have the suffix &amp;quot;&amp;lt;a/b&amp;gt;&amp;quot;, where &amp;quot;b&amp;quot; is to be replaced with the total number of parts and &amp;quot;a&amp;quot; is to be replaced with the index of the part, starting from 1 and going up to b.</description></item><item><title>[LeetCode] 2467. Most Profitable Path in a Tree</title><link>http://intervalrain.github.io/posts/leetcode/2467/</link><pubDate>Thu, 24 Nov 2022 01:09:51 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2467/</guid><description>2467. Most Profitable Path in a Tree
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Tree、Depth-First Search、Breadth-First Search、Graph \(\color{blue}\textsf{Biweekly Contest 91}\) 一、題目 There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. At every node i, there is a gate.</description></item><item><title>[LeetCode] 1926. Nearest Exit from Entrance in Maze</title><link>http://intervalrain.github.io/posts/leetcode/1926/</link><pubDate>Tue, 22 Nov 2022 23:41:58 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1926/</guid><description>1926. Nearest Exit from Entrance in Maze
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.
In one step, you can move one cell up, down, left, or right.</description></item><item><title>[LeetCode] 279. Perfect Squares</title><link>http://intervalrain.github.io/posts/leetcode/279/</link><pubDate>Tue, 22 Nov 2022 19:40:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/279/</guid><description>279. Perfect Squares
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Math、Dynamic Programming、Breadth-First Search 一、題目 Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.
Example 1:</description></item><item><title>[LeetCode] 337. House Robber III</title><link>http://intervalrain.github.io/posts/leetcode/337/</link><pubDate>Sat, 19 Nov 2022 21:43:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/337/</guid><description>337. House Robber III
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Dynamic Programming、Tree、Depth-First Search、Binary Tree 一、題目 The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description></item><item><title>[LeetCode] 587. Erect the Fence</title><link>http://intervalrain.github.io/posts/leetcode/587/</link><pubDate>Sat, 19 Nov 2022 16:56:09 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/587/</guid><description>587. Erect the Rence
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Math、Geometry 一、題目 You are given an array trees where trees[i] = [xi, yi] represents the location of a tree in the garden. You are asked to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Return the coordinates of trees that are exactly located on the fence perimeter.</description></item><item><title>[LeetCode] 322. Coin Change</title><link>http://intervalrain.github.io/posts/leetcode/322/</link><pubDate>Thu, 17 Nov 2022 21:31:45 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/322/</guid><description>322. Coin Change
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Breadth-First Search 一、題目 You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.</description></item><item><title>[LeetCode] 2466. Count Ways To Build Good Strings</title><link>http://intervalrain.github.io/posts/leetcode/2466/</link><pubDate>Thu, 17 Nov 2022 21:23:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2466/</guid><description>2466. Count Ways To Build Good Strings
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Dynamic Programming \(\color{blue}\textsf{Biweekly Contest 91}\) 一、題目 Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:
Append the character '0' zero times. Append the character '1' one times. This can be performed any number of times. A good string is a string constructed by the above process having a length between low and high (inclusive).</description></item><item><title>[LeetCode] 2465. Number of Distinct Averages</title><link>http://intervalrain.github.io/posts/leetcode/2465/</link><pubDate>Thu, 17 Nov 2022 21:00:05 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2465/</guid><description>2465. Number of Distinct Averages
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Hash Table、Two Pointers、Sorting \(\color{blue}\textsf{Biweekly Contest 91}\) 一、題目 You are given a 0-indexed integer array nums of even length. As long as nums is not empty, you must repetitively:
Find the minimum number in nums and remove it. Find the maximum number in nums and remove it. Calculate the average of the two removed numbers. The average of two numbers a and b is (a + b) / 2.</description></item><item><title>[LeetCode] 223. Rectangle Area</title><link>http://intervalrain.github.io/posts/leetcode/223/</link><pubDate>Thu, 17 Nov 2022 20:39:17 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/223/</guid><description>223. Rectangle Area
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Math、Geometry 一、題目 Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles. The first rectangle is defined by its bottom-left corner (ax1, ay1) and its top-right corner (ax2, ay2). The second rectangle is defined by its bottom-left corner (bx1, by1) and tis top-right corner (bx2, by2).
Example 1:
Input: ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2 Output: 45 Example 2:</description></item><item><title>[LeetCode] 374. Guess Number Higher or Lower</title><link>http://intervalrain.github.io/posts/leetcode/374/</link><pubDate>Wed, 16 Nov 2022 22:57:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/374/</guid><description>374. Guess Number Higher or Lower
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Binary Search、Interactive 一、題目 We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results:</description></item><item><title>[LeetCode] 213. House Robber II</title><link>http://intervalrain.github.io/posts/leetcode/213/</link><pubDate>Tue, 15 Nov 2022 23:45:49 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/213/</guid><description>213. House Robber II
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming 一、題目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.</description></item><item><title>[LeetCode] 198. House Robber</title><link>http://intervalrain.github.io/posts/leetcode/198/</link><pubDate>Tue, 15 Nov 2022 23:33:01 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/198/</guid><description>198. House Robber
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming 一、題目 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</description></item><item><title>[LeetCode] 947. Most Stones Removed with Same Row or Column</title><link>http://intervalrain.github.io/posts/leetcode/947/</link><pubDate>Tue, 15 Nov 2022 00:12:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/947/</guid><description>947. Most Stones Removed with Same Row or Column
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Depth-First Search、Union Find、Graph 一、題目 On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone. A stone can be removed if it shares either the same row or the same column as another stone that has not been removed. Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.</description></item><item><title>[LeetCode] 151. Reverse Words in a String</title><link>http://intervalrain.github.io/posts/leetcode/151/</link><pubDate>Sun, 13 Nov 2022 17:35:59 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/151/</guid><description>151. Reverse Words in a String
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Two Pointers、String 一、題目 Given an input string s, reverse the order of the words.
A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.
Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words.</description></item><item><title>[LeetCode] 23. Merge k Sorted Lists</title><link>http://intervalrain.github.io/posts/leetcode/23/</link><pubDate>Fri, 11 Nov 2022 00:24:47 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/23/</guid><description>23. Merge k Sorted Lists
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Linked List、Divide and Conquer、Heap (Priority Queue)、Merge Sort 一、題目 You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.
Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are:
[
1-&amp;gt;4-&amp;gt;5,
1-&amp;gt;3-&amp;gt;4,
2-&amp;gt;6
]
merging them into one sorted list:
1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 Example 2:</description></item><item><title>[LeetCode] 22. Generate Parentheses</title><link>http://intervalrain.github.io/posts/leetcode/22/</link><pubDate>Thu, 10 Nov 2022 23:44:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/22/</guid><description>22. Generate Parentheses
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String、Dynamic Programming、Backtracking 一、題目 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
Example 1:
Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: n = 1 Output: [&amp;quot;()&amp;quot;] Constraints:
1 &amp;lt;= n &amp;lt;= 8 二、分析 DFS 演算法是在遍歷「節點」，而回溯法是在遍歷「樹枝」。站在一個節點上，需思考三個問題： 路徑(PATH)：已做出的選擇。 選項(OPTION)：當前可以做的選擇。 終止條件(TERMINATE)：到達決策樹的底層，無法再做其它選擇。 以下為回溯法的框架： vector&amp;lt;PATH&amp;gt; res; void backtrack(PATH, OPTION) { if (TERMINATE) { res.push_back(PATH); return; } for (CHOICE : OPTION) { DO OPTION; backtrack(PATH, OPTION); CANCEL OPTION; } } 本題的終止條件是當 path 的長度為 2n 的時候。 而選項是增加左括號 ( 與增加右括號 )。 加上兩個子節點的條件便完成， 左節點需滿足 left &amp;lt; n。 右節點需滿足 right &amp;lt; n &amp;amp;&amp;amp; right &amp;lt; left。 DP 動態規劃則需觀察轉移方程式。 dp[0] base case： `` dp[1] 很容易得到：() dp[2] 也不難：()()、(()) 接下來觀察 dp[3]，可以分解為下面三個： ( + dp[0] + ) + dp[2]：()()()、()(()) ( + dp[1] + ) + dp[1]：(())() ( + dp[2] + ) + dp[0]：(()())、((())) 換句話說，轉移方程式可以寫成：dp[i] = &amp;quot;(&amp;quot; + dp[j] + &amp;quot;)&amp;quot; + dp[i-j-1] 三、解題 1.</description></item><item><title>[LeetCode] 21. Merge Two Sorted Lists</title><link>http://intervalrain.github.io/posts/leetcode/21/</link><pubDate>Thu, 10 Nov 2022 20:25:07 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/21/</guid><description>21. Merge Two Sorted Lists
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Linked List、Recursion 一、題目 You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list.
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:</description></item><item><title>[LeetCode] 1047. Remove All Adjacent Duplicates In String</title><link>http://intervalrain.github.io/posts/leetcode/1047/</link><pubDate>Thu, 10 Nov 2022 20:01:29 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1047/</guid><description>1047. Remove All Adjacent Duplicates In String
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String、Stack 一、題目 You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.
We repeatly make duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.</description></item><item><title>[LeetCode] 901. Online Stock Span</title><link>http://intervalrain.github.io/posts/leetcode/901/</link><pubDate>Wed, 09 Nov 2022 23:35:42 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/901/</guid><description>901. Online Stock Span
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Stack、Design、Monotonic Stack、Data Stream 一、題目 Design an algorithm that collects daily price quotes for some stock and returns the span of that stock&amp;rsquo;s price for the current day.
The span of the stock&amp;rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today&amp;rsquo;s price.</description></item><item><title>[LeetCode] 1544. Make The String Great</title><link>http://intervalrain.github.io/posts/leetcode/1544/</link><pubDate>Tue, 08 Nov 2022 23:14:34 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1544/</guid><description>1544. Make The String Great
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String、Stack 一、題目 Given a string s of lower and upper case English letters.
A good string is a string which doesn&amp;rsquo;t have two adjacent characters s[i] and s[i + 1] where:
0 &amp;lt;= i &amp;lt;= s.length - 2 s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
To make the string good, you can choose two adjacent characters that make the string bad and remove them.</description></item><item><title>[LeetCode] 2463. Minimum Total Distance Traveled</title><link>http://intervalrain.github.io/posts/leetcode/2463/</link><pubDate>Tue, 08 Nov 2022 23:13:52 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2463/</guid><description>2463. Minimum Total Distance Traveled
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Dynamic Programming、Sorting \(\color{blue}\textsf{Weekly Contest 318}\) 一、題目 There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.</description></item><item><title>[LeetCode] 2462. Total Cost to Hire K</title><link>http://intervalrain.github.io/posts/leetcode/2462/</link><pubDate>Tue, 08 Nov 2022 00:53:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2462/</guid><description>2462. Total Cost to Hire K
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Heap (Priority Queue)、Simulation \(\color{blue}\textsf{Weekly Contest 318}\) 一、題目 You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker. You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:
You will run k sessions and hire exactly one worker in each session. In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers.</description></item><item><title>[LeetCode] 2461. Maximum Sum of Distinct Subarrays With Length K</title><link>http://intervalrain.github.io/posts/leetcode/2461/</link><pubDate>Tue, 08 Nov 2022 00:36:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2461/</guid><description>2461. Maximum Sum of Distinct Subarrays With Length K
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、Sliding Window \(\color{blue}\textsf{Weekly Contest 318}\) 一、題目 You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:
The length of the subarray is k, and All the elements of the subarray are distinct. Return the maximum subarray sum of all the subarrays that meet the conditions.</description></item><item><title>[LeetCode] 2460. Apply Operations to an Array</title><link>http://intervalrain.github.io/posts/leetcode/2460/</link><pubDate>Tue, 08 Nov 2022 00:09:13 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2460/</guid><description>2460. Apply Operations to an Array
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Simulation \(\color{blue}\textsf{Weekly Contest 318}\) 一、題目 You are given a 0-indexed array nums of size n consisting of non-negative integers. You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:
If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0.</description></item><item><title>[LeetCode] 1323. Maximum 69 Number</title><link>http://intervalrain.github.io/posts/leetcode/1323/</link><pubDate>Mon, 07 Nov 2022 23:55:31 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1323/</guid><description>1323. Maximum 69 Number
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math、Greedy 一、題目 You are given a positive integer num consisting only of digits 6 and 9.
Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).
Example 1:
Input: num = 9669 Output: 9969 Explanation:
Changing the first digit results in 6669.
Changing the second digit results in 9969.
Changing the third digit results in 9699.</description></item><item><title>[LeetCode] 79. Word Search</title><link>http://intervalrain.github.io/posts/leetcode/79/</link><pubDate>Sat, 05 Nov 2022 21:12:17 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/79/</guid><description>79. Word Search
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Backtracking、Matrix 一、題目 Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example 1:
Input: board = [[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;E&amp;rdquo;],[&amp;ldquo;S&amp;rdquo;,&amp;ldquo;F&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;S&amp;rdquo;],[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;D&amp;rdquo;,&amp;ldquo;E&amp;rdquo;,&amp;ldquo;E&amp;rdquo;]], word = &amp;ldquo;ABCCED&amp;rdquo; Output: true Example 2:</description></item><item><title>[LeetCode] 212. Word Search II</title><link>http://intervalrain.github.io/posts/leetcode/212/</link><pubDate>Sat, 05 Nov 2022 20:58:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/212/</guid><description>212. Word Search II
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、String、Backtracking、Trie、Matrix 一、題目 Given an m x n board of characters and a list of strings words, return all words on the board.
Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
Example 1:
Input: board = [[&amp;ldquo;o&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;],[&amp;ldquo;e&amp;rdquo;,&amp;ldquo;t&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;e&amp;rdquo;],[&amp;ldquo;i&amp;rdquo;,&amp;ldquo;h&amp;rdquo;,&amp;ldquo;k&amp;rdquo;,&amp;ldquo;r&amp;rdquo;],[&amp;ldquo;i&amp;rdquo;,&amp;ldquo;f&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;v&amp;rdquo;]], words = [&amp;ldquo;oath&amp;rdquo;,&amp;ldquo;pea&amp;rdquo;,&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;rain&amp;rdquo;] Output: [&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;oath&amp;rdquo;] Example 2:</description></item><item><title>[LeetCode] 2131. Longest Palindrome by Concatenating Two Letter Words</title><link>http://intervalrain.github.io/posts/leetcode/2131/</link><pubDate>Thu, 03 Nov 2022 23:10:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2131/</guid><description>2131. Longest Palindrome by Concatenating Two Letter Words
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、String、Greedy、Counting 一、題目 You are given an array of strings words. Each element of words consists of two lowercase English letters.
Create the longest possible palindrome by selecting some elements from words and concatenating them in any order. Each element can be selected at most once.
Return the length of the longest palindrome that you can create. If it is impossible to create any palindrome, return 0.</description></item><item><title>[LeetCode] 433. Minimum Genetic Mutation</title><link>http://intervalrain.github.io/posts/leetcode/433/</link><pubDate>Wed, 02 Nov 2022 23:36:32 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/433/</guid><description>433. Minimum Genetic Mutation
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table、String、Breadth-First Search 一、題目 A gene string can be represented by an 8-character long string, with choices from A, C, G, and T.
Suppose we need to investigate a mutation from a gene string start to a gene string end where one mutation is defined as one single character changed in the gene string.
For example, &amp;quot;AACCGGTT&amp;quot; --&amp;gt; &amp;quot;AACCGGTA&amp;quot; is one mutation.</description></item><item><title>[LeetCode] 20. Valid Parentheses</title><link>http://intervalrain.github.io/posts/leetcode/20/</link><pubDate>Tue, 01 Nov 2022 20:51:49 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/20/</guid><description>20. Valid Parentheses
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String、Stack 一、題目 Given a string s containing just the characters (, ), {, }, [ and ], determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1:</description></item><item><title>[LeetCode] 1706. Where Will the Ball Fall</title><link>http://intervalrain.github.io/posts/leetcode/1706/</link><pubDate>Tue, 01 Nov 2022 19:02:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1706/</guid><description>1706. Where Will the Ball Fall
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Dynamic Programming、Depth-First Search、Matrix、Simulation 一、題目 You have a 2-D grid of size m x n representing a box, and you have n balls. The box is open on the top and bottom sides.
Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.
A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as 1.</description></item><item><title>[LeetCode] 766. Toeplitz Matrix</title><link>http://intervalrain.github.io/posts/leetcode/766/</link><pubDate>Tue, 01 Nov 2022 00:40:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/766/</guid><description>766. Toeplitz Matrix
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Matrix 一、題目 Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.
Example 1:
Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] Output: true Explanation:
In the above grid, the diagonals are:
&amp;ldquo;[9]&amp;rdquo;, &amp;ldquo;[5, 5]&amp;rdquo;, &amp;ldquo;[1, 1, 1]&amp;rdquo;, &amp;ldquo;[2, 2, 2]&amp;rdquo;, &amp;ldquo;[3, 3]&amp;rdquo;, &amp;ldquo;[4]&amp;rdquo;.
In each diagonal all elements are the same, so the answer is True.</description></item><item><title>[LeetCode] 19. Remove Nth Node From End of List</title><link>http://intervalrain.github.io/posts/leetcode/19/</link><pubDate>Mon, 31 Oct 2022 00:05:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/19/</guid><description>19. Remove Nth Node From End of List
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Two Pointers 一、題目 Given the head of a linked list, remove the nth node from the end of the list and return its head.
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Example 3:
Input: head = [1,2], n = 1 Output: [1] Constraints:</description></item><item><title>[LeetCode] 1293. Shortest Path in a Grid with Obstacles Elimination</title><link>http://intervalrain.github.io/posts/leetcode/1293/</link><pubDate>Sun, 30 Oct 2022 21:29:37 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1293/</guid><description>1293. Shortest Path in a Grid with Obstacles Elimination
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Breadth-First Search、Matrix 一、題目 You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacles). You can move up, down, left, or right from and to an empty cell in one step.
Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right conrer m-1, n-1 given that you can eliminate at most k obstacles.</description></item><item><title>[LeetCode] 2136. Earliest Possible Day of Full Bloom</title><link>http://intervalrain.github.io/posts/leetcode/2136/</link><pubDate>Sun, 30 Oct 2022 00:25:25 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2136/</guid><description>2136. Earliest Possible Day of Full Bloom
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Greedy、Sorting 一、題目 You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed take time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:
plantTime[i] is the number of full days it takes you to plant the ith seed.</description></item><item><title>[LeetCode] 18. 4Sum</title><link>http://intervalrain.github.io/posts/leetcode/18/</link><pubDate>Fri, 28 Oct 2022 23:58:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/18/</guid><description>18. 4Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Sorting 一、題目 Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
0 &amp;lt;= a, b, c, d &amp;lt; n a, b, c and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order. Example 1:
Input: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2:</description></item><item><title>[LeetCode] 17. Letter Combinations of a Phone Number</title><link>http://intervalrain.github.io/posts/leetcode/17/</link><pubDate>Fri, 28 Oct 2022 22:59:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/17/</guid><description>17. Letter Combinations of a Phone Number
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table,String,Backtracking 一、題目 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order
A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example 1:
Input: digits = &amp;ldquo;23&amp;rdquo; Output: [&amp;ldquo;ad&amp;rdquo;,&amp;ldquo;ae&amp;rdquo;,&amp;ldquo;af&amp;rdquo;,&amp;ldquo;bd&amp;rdquo;,&amp;ldquo;be&amp;rdquo;,&amp;ldquo;bf&amp;rdquo;,&amp;ldquo;cd&amp;rdquo;,&amp;ldquo;ce&amp;rdquo;,&amp;ldquo;cf&amp;rdquo;] Example 2:</description></item><item><title>[LeetCode] 16. 3Sum Closet</title><link>http://intervalrain.github.io/posts/leetcode/16/</link><pubDate>Fri, 28 Oct 2022 21:51:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/16/</guid><description>no. Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointers、Sorting 一、題目 Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closet to target.
Return *the sum of the three integers`.
You may assume that each input would have exactly one solution.
Example 1:
Input: nums = [-1,2,1,-4], target = 1 Output: 2 Explanation: The sum that is closet to the target is 2.</description></item><item><title>[LeetCode] 15. 3Sum</title><link>http://intervalrain.github.io/posts/leetcode/15/</link><pubDate>Fri, 28 Oct 2022 13:30:19 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/15/</guid><description>15. 3Sum
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Sorting 一、題目 Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.</description></item><item><title>[Leetcode] 14. Longest Common Prefix</title><link>http://intervalrain.github.io/posts/leetcode/14/</link><pubDate>Fri, 28 Oct 2022 00:00:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/14/</guid><description>14. Longest Common Prefix
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: String 一、題目 Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;ldquo;flower&amp;rdquo;, &amp;ldquo;flow&amp;rdquo;, &amp;ldquo;flight&amp;rdquo;] Output: &amp;ldquo;fl&amp;rdquo; Example 2:
Input: strs = [&amp;ldquo;dog&amp;rdquo;, &amp;ldquo;racecar&amp;rdquo;, &amp;ldquo;car&amp;rdquo;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. Constraints:
1 &amp;lt;= strs.length &amp;lt;= 200 0 &amp;lt;= strs[i].</description></item><item><title>[Leetcode] 13. Roman to Integer</title><link>http://intervalrain.github.io/posts/leetcode/13/</link><pubDate>Thu, 27 Oct 2022 21:58:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/13/</guid><description>13. Roman to Integer
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.
\(\boxed{\begin{array}{ll} \textbf{Symbol}&amp;amp;\textbf{Value}\\ \texttt{I}&amp;amp;1\\ \texttt{V}&amp;amp;5\\ \texttt{X}&amp;amp;10\\ \texttt{L}&amp;amp;50\\ \texttt{C}&amp;amp;100\\ \texttt{D}&amp;amp;500\\ \texttt{M}&amp;amp;1000\\ \end{array}}\)
For example, 2 is written as II in Roman numeral, just two one&amp;rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description></item><item><title>[Leetcode] 835. Image Overlap</title><link>http://intervalrain.github.io/posts/leetcode/835/</link><pubDate>Thu, 27 Oct 2022 17:35:25 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/835/</guid><description>835. Image Overlap
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Matrix 一、題目 You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.
We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images.</description></item><item><title>[Leetcode] 12. Integer to Roman</title><link>http://intervalrain.github.io/posts/leetcode/12/</link><pubDate>Wed, 26 Oct 2022 20:36:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/12/</guid><description>12. Integer to Roman
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table、Math、String 一、題目 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.
\(\boxed{\begin{array}{ll} \textbf{Symbol}&amp;amp;\textbf{Value}\\ \texttt{I}&amp;amp;1\\ \texttt{V}&amp;amp;5\\ \texttt{X}&amp;amp;10\\ \texttt{L}&amp;amp;50\\ \texttt{C}&amp;amp;100\\ \texttt{D}&amp;amp;500\\ \texttt{M}&amp;amp;1000\\ \end{array}}\)
For example, 2 is written as II in Roman numeral, just two one&amp;rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description></item><item><title>[Leetcode] 11. Container With Most Water</title><link>http://intervalrain.github.io/posts/leetcode/11/</link><pubDate>Wed, 26 Oct 2022 19:36:06 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/11/</guid><description>11. Container With Most Water
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Two Pointer、Greedy 一、題目 You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
Find two lines that together with the x-axis form a container, such that the container contains the most water.
Return the maximum amount of water a container can store.</description></item><item><title>[Leetcode] 10. Regular Expression Matching</title><link>http://intervalrain.github.io/posts/leetcode/10/</link><pubDate>Wed, 26 Oct 2022 18:36:01 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/10/</guid><description>10. Regular Expression Matching
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: String、Dynamic Programming、Recursion 一、題目 Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:
'.' Matches any single character. '*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial). Example 1:
Input: s = &amp;ldquo;aa&amp;rdquo;, p = &amp;ldquo;a&amp;rdquo; Output: false Explanation: &amp;ldquo;a&amp;rdquo; does not match the entire string &amp;ldquo;aa&amp;rdquo;.</description></item><item><title>[Leetcode] 9. Palindrome Number</title><link>http://intervalrain.github.io/posts/leetcode/9/</link><pubDate>Wed, 26 Oct 2022 10:20:08 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/9/</guid><description>9. Palindrome Number
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Math 一、題目 Given an integer x, return true if x is palindrome number.
An integer is a palindrome when it reads the same backward as forward.
For example, 121 is a palindrome while 123 is not. Example 1:
Input: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left. Example 2:
Input: x = -121 Output: false Explanation: From left to right, it reads -121.</description></item><item><title>[Leetcode] 8. String to Integer (atoi)</title><link>http://intervalrain.github.io/posts/leetcode/8/</link><pubDate>Wed, 26 Oct 2022 00:21:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/8/</guid><description>8. String to Integer (atoi)
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String 一、題目 Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++&amp;rsquo;s atoi function).
The algorithm for myAtoi(string s) is as follows:
Read in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either.</description></item><item><title>[Leetcode] 7. Reverse Integer</title><link>http://intervalrain.github.io/posts/leetcode/7/</link><pubDate>Tue, 25 Oct 2022 23:47:53 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/7/</guid><description>7. Reverse Integer
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Math 一、題目 Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31-1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123 Output: 321 Example 2:
Input: x = -123 Output: -321 Example 3:</description></item><item><title>[Leetcode] 6. Zigzag Conversion</title><link>http://intervalrain.github.io/posts/leetcode/6/</link><pubDate>Tue, 25 Oct 2022 21:40:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/6/</guid><description>6. Zigzag Conversion
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String 一、題目 The string &amp;quot;PAYPALISHIRING&amp;quot; is written in a zigzag pattern on a given number of rows like this: (you may want to dispaly this pattern in a fixed font for better legibility)
\( \quad\texttt{P A H N}\\ \quad\texttt{APLSIIG}\\ \quad\texttt{Y I R}\\ \)
And then read line by line: &amp;quot;PAHNAPLSIIGYIR&amp;quot;
Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows</description></item><item><title>[LeetCode] 5. Longest Palindromic Substring</title><link>http://intervalrain.github.io/posts/leetcode/5/</link><pubDate>Tue, 25 Oct 2022 16:32:51 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/5/</guid><description>5. Longest Substring Without Repeating Characters
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: String、Dynamic Programming 一、題目 Given a string s, return the longest palindromic substring in s.
A string is called a palindrome string if the reverse of that string is the same of the original string.
Example 1:
Input: s = &amp;ldquo;babad&amp;rdquo; Output: &amp;ldquo;bab&amp;rdquo; Explanation: &amp;ldquo;aba&amp;rdquo; is also a valid answer. Example 2:
Input: s = &amp;ldquo;cbbd&amp;rdquo; Output: &amp;ldquo;bb&amp;rdquo; Constraints:
1 &amp;lt;= s.</description></item><item><title>[LeetCode] 4. Median of Two Sorted Arrays</title><link>http://intervalrain.github.io/posts/leetcode/4/</link><pubDate>Tue, 25 Oct 2022 14:52:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/4/</guid><description>4. Median of Two Sorted Arrays
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Array、Binary Search、Divide and Conquer 一、題目 Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the sorted arrays.
The overall run time complexity should be O(log (m+n)).
Example 1:
Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2:
Input: nums1 = [1,2], nums2 = [3,4] Output: 2.</description></item><item><title>[LeetCode] 3. Longest Substring Without Repeating Characters</title><link>http://intervalrain.github.io/posts/leetcode/3/</link><pubDate>Tue, 25 Oct 2022 14:20:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/3/</guid><description>3. Longest Substring Without Repeating Characters
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Hash Table、String、Sliding Window 一、題目 Given a string s, find the length of the longest substring without repeating characters.
Example 1:
Input: s = &amp;ldquo;abcabcbb&amp;rdquo; Output: 3 Explanation: The answer is &amp;ldquo;abc&amp;rdquo;, with the length of 3. Example 2:
Input: s = &amp;ldquo;bbbbb&amp;rdquo; Output: 1 Explanation: The answer is &amp;ldquo;b&amp;rdquo;, with the length of 1. Example 3:
Input: s = &amp;ldquo;pwwkew&amp;rdquo; Output: 3 Explanation: The answer is &amp;ldquo;wke&amp;rdquo;, with the length of 3.</description></item><item><title>[LeetCode] 2. Add Two Numbers</title><link>http://intervalrain.github.io/posts/leetcode/2/</link><pubDate>Tue, 25 Oct 2022 13:38:00 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/2/</guid><description>2. Add Two Numbers
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Linked List、Math、Recursion 一、題目 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807 Example 2:</description></item><item><title>[LeetCode] 1. Two Sum</title><link>http://intervalrain.github.io/posts/leetcode/1/</link><pubDate>Tue, 25 Oct 2022 12:41:32 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/1/</guid><description>1. Two Sum
Hardness: \(\color{green}\textsf{Easy}\) Ralated Topics: Array、Hash Table 一、題目 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], taget = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0,1].</description></item><item><title>[LeetCode] Catalog</title><link>http://intervalrain.github.io/posts/leetcode/</link><pubDate>Tue, 25 Oct 2022 11:30:32 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/</guid><description>Catalog 一、依題號 1-500(42) 1. Two Sum
2. Add Two Numbers
3. Longest Substring Without Repeating Characters
4. Median of Two Sorted Array
5. Longest Palindromic Substring
6. Zigzag Conversion
7. Reverse Integer
8. String to Integer (atoi)
9. Palindrome Number
10. Regular Expression Matching
11. Container With Most Water
12. Integer to Roman
13. Roman to Integer
14. Longest Common Prefix
15. 3Sum
16. 3Sum Closet
17. Letter Combinations of a Phone Number</description></item><item><title>[Leetcode] 347. Top K Frequent Elements</title><link>http://intervalrain.github.io/posts/leetcode/347/</link><pubDate>Sat, 23 Jul 2022 23:48:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/347/</guid><description>347. Top K Frequent Elements
Hardness: \(\color{orange}\textsf{Medium}\) Ralated Topics: Array、Hash Table、Divide and Conquer、Sorting、Heap (Priority Queue)、Bucket Sort、Counting、Quickselect 一、題目 Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
Example 1:
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:
Input: nums = [1], k = 1 Output: [1] Constraints:
1 &amp;lt;= nums.length &amp;lt;= 10^5 -10^4 &amp;lt;= nums[i] &amp;lt;= 10^4 k is in the range [1, the number of unique elements in the array].</description></item><item><title>[Leetcode] Maximum Frequency Stack 最大頻率堆疊</title><link>http://intervalrain.github.io/posts/leetcode/freqstack/</link><pubDate>Sat, 19 Mar 2022 16:53:23 +0800</pubDate><guid>http://intervalrain.github.io/posts/leetcode/freqstack/</guid><description>Maximum Frequency Stack algorithm</description></item></channel></rss>