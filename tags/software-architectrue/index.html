<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Architectrue | Rain Hu's Workspace</title><meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/tags/software-architectrue/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/tags/software-architectrue/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="Software Architectrue"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:type" content="website"><meta property="og:url" content="https://intervalrain.github.io/tags/software-architectrue/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Software Architectrue"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/posts/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/posts/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/tags/>Tags</a></div><h1>Software Architectrue</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>[ML] sample1 - 手寫數字辨識</h2></header><section class=entry-content><p>MNIST NIST(National Insitute of Standards and Technology) 是美國國家標準與技術研究院，MNIST 是由 NIST 所提供的一組經典的機器學習測資，可以想成是深度學習中的「Hello World!」，它由 60000張 訓練圖片與 10000 張測試圖片所組成，為手寫數字的灰階圖片，大小為 28 * 28 像素，分類 0 到 9 共 10 個數字。
可透過 keras 模組直接取得資料 >>> from tensorflow.keras.datasets import mnist 輸入 mnist.load_data() 可取得 mnist 資料集，回傳值為 2*2 的 tuple of ndarray。 >>> (train_images, train_labels), (test_images, test_labels) = mnist.load_data() tuple 裡面裝載的是 NumPy 的 ndarray 物件，我們可以利用 o.shape 來取得 ndarray 的屬性 len(o) 來取得陣列的個數 >>> train_images.shape (60000, 28, 28) # 3 軸陣列，其大小為 60000 * 28 * 28 >>> test_images....</p></section><footer class=entry-footer><span title='2023-10-28 14:11:35 +0800 +0800'>October 28, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;hgraca</footer><a class=entry-link aria-label="post link to [ML] sample1 - 手寫數字辨識" href=https://intervalrain.github.io/posts/ml/ex1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] 埠與適配器架構 Ports & Adapters Architecture aka 六邊形架構 Hexagonal Architecture</h2></header><section class=entry-content><p>埠與適配器架構（又稱為六角架構）是由 Alistair Cockburn 所構想，並在 2005 年於他的部落格中寫下。這是他用一句話定義其目標的方式：
Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases. - Alistair Cockburn 2005, Ports and Adapters
允許一個應用程式能夠同等地由用戶、程式、自動化測試或批次腳本驅動，並且能夠在與其最終運行時間設備和數據庫隔離的情況下進行開發和測試。 - 艾利斯特·科本 2005，端口與適配器
我看過一些討論「Ports & Adapters 架構」的文章，其中大量提到了分層(layers)。然而，在原始的 Alistair Cockburn 的文章中，我並未讀到任何關於分層的內容。
Ports & Adapters 架構的思想是將我們的應用程式視為系統的中心產物，所有的輸入和輸出都通過一個端口進入/離開應用程式，該端口將應用程式與外部工具、技術和交付機制隔離。應用程式應該對誰/什麼正在發送輸入或接收其輸出一無所知。這旨在提供一些保護，以防止技術和業務需求的演變，促使產品在開發完成後不久就因為技術/供應商的封鎖而變得過時。
在這篇文章中，我們將深入探討以下主題：
傳統方法的問題 傳統的方法在前後兩端都可能帶來問題。
在前端方面，我們最終會有業務邏輯滲透到 UI 中（例如，當我們在控制器或視圖中放置用例邏輯，使其在其他 UI 中無法重用）或甚至是 UI 滲透到業務邏輯中（例如，由於我們在模板中需要一些邏輯，因此我們在我們的實體中創建方法）。
在後端方面，我們可能會有外部庫和技術滲透到業務邏輯中，因為我們可能會透過類型提示、子類別化，甚至在我們的業務邏輯內實例化庫類別來直接引用它們。
從分層架構演變而來 到了 2005 年，多虧了 EBI 和 DDD，我們已經知道在系統中真正重要的是內部層。這些層是所有業務邏輯之所在，它們是我們與競爭對手的真正差異，是應用程式中價值的核心。...</p></section><footer class=entry-footer><span title='2023-10-27 23:46:32 +0800 +0800'>October 27, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;hgraca</footer><a class=entry-link aria-label="post link to [IT] 埠與適配器架構 Ports & Adapters Architecture aka 六邊形架構 Hexagonal Architecture" href=https://intervalrain.github.io/posts/hgraca/ports-adapters-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] 領域驅動設計 Domain-Driven Design</h2></header><section class=entry-content><p>「領域驅動設計」這個詞是在 Eric Evans 在他的著作《領域驅動設計：解決軟體核心的複雜性(Domain-Driven Design: Tackling complexity in the Heart of Software, 2003)》中所提出的，書中正式地提出了許多軟體開發的概念。
我無法用一篇文章就概括 DDD，與 DDD 相關的重要概念實在太多了。以下列出我認為一些重要的 DDD 概成，包含：
Ubiquitous Language Layers Bounded Contexts Anti-Corruption Layer Shared Kernel Generic Subdomain 通用語言 Ubiquitous Language 在軟體開發中，一個常見的問題是怎麼理解程式碼，它是什麼，它能做什麼，它如何做，它為什麼這樣做…如果程式碼使用的術語與領域專家使用的術語不同，理解程式碼便變得更加複雜。例如，如果領域專家談論的是 elder users，而程式碼中提到的是 supervisors，那麼名詞可能就會造成在討論應用程式時造成混淆。然而，大部分的模糊性可以透過適當地命名類別和方法來解決，讓類別的命名明確地表達出物件是什麼，讓方法的命名明確地表達出方法在領域上下文中做了什麼事。
使用通用語言的主要概念是將應用程式與商業邏輯對齊，這是通過在程式碼中採用業務與技術之間的共同語言所實現的。該語言的來源是公司的業務部門，它們擁有需要實施的概念，但術語則與公司的技術部門協商(這意味著業務部門並不總是選擇最佳命名)以創建一種業務與程式開發人員共通且不會發生歧義的共同語言。包含程式碼、類別、方法、屬性和模組的命名都最重與通用語言對齊。
層 Layers 我在之前的文章中已經談過分層的概念，但我認為此刻重提由DDD所識別的各層是很重要的
User Interface 使用者介面 負責繪製用戶與應用程式互動的螢幕，並將用戶的輸入轉換為應用程式命令。值得注意的是，「用戶」可以是人類，但也可以是連接到我們API的其他應用程式，這完全對應於EBI架構中的邊界對象。
Application Layer 應用層 協調領域對象以執行用戶所需的任務：用例。它不包含業務邏輯。這與EBI架構中的互動者相關，只是互動者是與UI或實體無關的任何對象，而在這種情況下，應用層只包含與用例相關的對象。這一層是應用服務所屬的地方，因為它們是用例協調發生的容器，使用存儲庫、領域服務、實體、價值對象或任何其他領域對象。
Domain Layer 領域層 這是包含所有業務邏輯的層，包括領域服務、實體、事件以及任何其他包含業務邏輯的對象類型。顯然，它與EBI的實體對象類型有關。這是系統的核心。領域服務將包含不完全適合於實體的領域邏輯，通常在完成某些領域動作時協調多個實體。
Infrastructure 基礎建設 支援上層的技術能力，即持久性或訊息傳遞。 有界上下文 在企業應用中，模型可能會大幅增長，同時進行程式碼開發的團隊規模也可能會擴大。這帶來了兩個問題：
開發人員必須處理的程式碼庫越大，認知負荷就越大，理解程式碼的難度也就越高，因此可能會引入更多的錯誤和判斷失誤， 越多的開發人員在同一個程式碼庫上工作，就愈難協調對應用程式的共同技術與領域視野。 換句話說，手頭的問題變得過於龐大。
對於大問題的常見解決方案是將其分解成較小的部分，這正是「有界上下文」發揮作用的地方。
Two subsystems commonly serve very different user communities - Eric Evans 2014, Domain-Driven Design Reference...</p></section><footer class=entry-footer><span title='2023-10-26 23:11:53 +0800 +0800'>October 26, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;hgraca</footer><a class=entry-link aria-label="post link to [IT] 領域驅動設計 Domain-Driven Design" href=https://intervalrain.github.io/posts/hgraca/domain-driven-design/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] 套件與命名空間 packaging & namespacing</h2></header><section class=entry-content><p>系統的架構是該系統的高層視圖、大局觀，以粗略的筆觸描繪的系統設計。架構決策是系統中的結構性決策，影響整個程式庫的決策，也是定義其他所有元素將在其上建立的決策。
架構決定系統的許多元素，包含：
組件 Components 組件之間的關係 Relationships between components 指導組件與組件間關係如何設計與如何演化 Principles guiding the design and evolution of components and relationships 換句話說，這些是隨著系統演進更難改變的設計決策，它們是支撐功能開發的基礎。
義大利麵架構 Spaghetti Architecture 有些專案，結構隨機，既不反映架構，也不反映領域。如果我問「我應該把這個 value object 放在哪裡？」結果得到「把它放在 src 資料夾的某個地方」這樣的回答；如果我問「執行這個邏輯的 service 在哪裡？」卻得到「用你的 IDE 進行搜索」這樣的回答。這意味著專案沒有經過組織，這樣鬆散的結構就稱為義大利麵架構(Spaghetti Architecture)。
這是一個大問題，因為這意味著沒有套件模組化，高階的程式碼關係和流程並沒有可以遵循的邏輯結構，導致模組之間高度耦合且低內聚，實際上可能代表根本沒有模組，應該屬於模組的程式碼散佈在整個程式碼庫中。
可維護的程式碼庫 擁有一個可維護的程式庫意味著我們可以變更最少的程式碼來實現最大的概念變更。換句話說，當我們需要對一個程式碼單元進行變更時，我們應該盡可能少地對其他程式碼單元進行變更。
這樣帶來的優點有：
程式碼的修改變得簡單，因為它們對較少的程式碼產生影響。 程式碼的修改會更快，因為需要修改的程式碼較少。 因為修改的程式碼變少，出現錯誤的可能性也更低。 封裝(encapsulation)、**低耦合(low coupling)和高內聚(high cohesion)**是使程式碼隔離的核心原則，使得我們能夠擁有可維護的程式碼基礎。
封裝 Encapsulation 這是隱藏類別的內部訊息與實作的過程。
也就是說，它對外隱藏了實作的方式，使得一個類別的內部結構可以自由變更，而不會影響使用這個特定類別的其他類別。
低耦合 Low coupling 耦合是指一個程式碼單元與另一個程式碼單元的關係。如果對一個模組的更改將導致對另一個模組的更改，則該模組被認為與另一個模組高度耦合。而如果一個模組獨立於任何其他模組，則該模組被認為是低耦合的。這可以通過擁有一個穩定的介面來實現，有效地隱藏了對其他模組的實現。
低耦合的好處 可維護性(maintainability) - 變更僅限於單一模組 可測試性(testability) - 可以將單元測試涉及的模塊限制到最小 可讀性(readability) - 需要分析的類別被保持在最小範圍內 高內聚 High Cohesion 內聚性是指一個模塊的功能之間的緊密相關程度的衡量。低內聚是指模組間具有許多不相關的職責；高內聚是指模組間有類似的概念。
高內聚的好處 可讀性(readability) - 相關的功能都包含在單一模塊中 可維護性(maintainability) - bug 通常會被限制在單一模組中 重用性(reusability) - 專注於類別的功能，不被無用的功能污染 結構上的影響 前述的原則通常與類別相關，然而，它們對於類別群組也同樣適用。類別群組在一般情況下被稱為套件(package)，但如果它們具有純粹的功能性目標(例如 ORM)，我們可以更具體地稱呼它們為模組(module)；如果它們具有領域目標(例如 AccountManagement)，我們可以稱呼它們為組件(components)。這與 Bass, Clements 和 Kazman 在他們的書《實踐軟體架構(Software Architecture in Practice)》中解釋的定義是一致的。...</p></section><footer class=entry-footer><span title='2023-10-23 23:14:14 +0800 +0800'>October 23, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;hgraca</footer><a class=entry-link aria-label="post link to [IT] 套件與命名空間 packaging & namespacing" href=https://intervalrain.github.io/posts/hgraca/packaging-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] EBI 架構</h2></header><section class=entry-content><p>EBI 架構全名是 Entity-Boundary-Interactor Architecture，第一次由 Robert C. Martin 在他乾淨架構(Clean Architecture)中的演講中提到。
然而，EBI 架構正式的發布是來自 Ivar Jacobson 在 1992 年所出版的 《物件導向的軟體工程：用例驅動方法(Object-Oriented Software Engineering: A use case driven approach)》。當時，Jacobson 實際上稱之為 Entity-Interface-Control，爾後才進行更名，為了避免將 Interface 與程式語言中的 Interface 或 User Interface 混淆；也避免將 Control 與 MVC 中的 Controller 混淆。
Entity 實體 Entity objects 持有所有系統使用的數據且持有所有與數據耦合的行為。每個 Entity object 代表一個與問題領域相關的概念，同時具備身份(identity)與永久性(persistence)。Jacobson 告訴我們，Entity object 應該要包含那些會因 entity 自身變化而變化的邏輯，也就是說，如果它持有的數據結構改變，則對該數據的操作也將需要變化，因此它們應該位於 entity中。
值得注意的是，Jacobson在1992年就已經發出了一個警告：
Beginners may sometime only use entity object as data carriers and place all dynamic behaviour in control objects […]....</p></section><footer class=entry-footer><span title='2023-10-22 23:54:36 +0800 +0800'>October 22, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;hgraca</footer><a class=entry-link aria-label="post link to [IT] EBI 架構" href=https://intervalrain.github.io/posts/hgraca/ebi-architecture/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://intervalrain.github.io/tags/software-architectrue/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>