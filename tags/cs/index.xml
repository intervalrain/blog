<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>CS on Rain's Blog</title><link>http://intervalrain.github.io/tags/cs/</link><description>Recent content in CS on Rain's Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 15 Nov 2022 16:10:53 +0800</lastBuildDate><atom:link href="http://intervalrain.github.io/tags/cs/index.xml" rel="self" type="application/rss+xml"/><item><title>[Algo] 2-5. 動態規劃 Dynamic Programming</title><link>http://intervalrain.github.io/posts/cs/algo/dp/</link><pubDate>Tue, 15 Nov 2022 16:10:53 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/dp/</guid><description>一、動態規劃的思考藝術 動態規劃其實就是一種暴力枚舉的優化，在暴力枚舉的過程中有著大量的重複，藉由「備忘錄(memoization)」的方式做到剪枝(pruning)來達到優化的一種演算法。 舉例來說： Leetcode 62. Unique Paths
機器人由左上走到右下角星星有幾種走法，其中機器人只能選擇往右走或往下走。 試想機器人從 (1,1) 走到 (m,n) 的不同路徑中，可見有大量的重複，比如過程中有一點 (i,j)，其 (1,1) 走到 (i,j) 有 k 條不同路徑，麼那對於任何一條固定 (i,j) 到 (m,n) 的路徑，都需走 k 遍來模擬。 但其實我們不必關心具體的走法，我們只關心狀態，也就是走法的數目。 同理，我們若知道 (i,j) 到 (m,n) 共有 t 條不同的路徑，那麼 (1,1) -&amp;gt; (i,j) -&amp;gt; (m,n) 的不同路徑總數就是 k*s。 我們知道最左邊那欄與最上面那列都只有可能有一種路徑可以走，又每一格的路徑來自於上方與左方的和： sum of (i,j) = sum of (i-1,j) + sum of (i,j-1) \(\begin{array}{|c|c|c|c|c|c|c|}\hline \text{1}&amp;amp;\text{1}&amp;amp;\text{1}&amp;amp;\text{1}&amp;amp;\text{1}&amp;amp;\text{1}&amp;amp;\text{1}\\\hline \text{1}&amp;amp;\text{2}&amp;amp;\text{3}&amp;amp;\text{4}&amp;amp;\text{5}&amp;amp;\text{6}&amp;amp;\text{7}\\\hline \text{1}&amp;amp;\text{3}&amp;amp;\text{6}&amp;amp;\text{10}&amp;amp;\text{15}&amp;amp;\text{21}&amp;amp;\text{28}\\\hline \end{array}\) 寫成程式碼就是 int uniquePaths(int m, int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m+1, vector&amp;lt;int&amp;gt;(n+1,0)); for (int i = 1; i &amp;lt;= m; i++) // 將第一列填成 1 dp[i][1] = 1; for (int j = 1; j &amp;lt;= n; j++) // 將第一欄填成 1 dp[1][j] = 1; for (int i = 2; i &amp;lt;= m; i++) { // 將剩下的格子填完 for (int j = 2; j &amp;lt;= n; j++) { dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m][n]; } 注意填格子的順序是有一定的限制的，必須要確保相關聯的子問題已經處理過。 動態規劃 由上例我們可以發現，原本的問題可以拆解成更小的問題(從 (1,1)-&amp;gt;(m,n) 變成從 (1,1)-&amp;gt;(i,j) 和從 (i,j)-&amp;gt;(m,n))。 我們令 f(i,j) 表示從 (1,1)-&amp;gt;(i,j) 的不同路徑數，則我們可以得到轉移方程式 f(i,j)=f(i-1,j)+f(i,j-1)。 我們發現，想求出 f(i,j) 只需要知道幾個更小的 f(i',j')。我們將 f(i',j') 稱為子問題。 我們捨棄冗餘的訊息(具體的走法)，只記錄對解決問題有幫助的結果。 動態規劃的兩大特點(適用前提) 無後效性 一旦 f(i,j) 確定，就不用關心我們如何計算出 f(i,j) 想要確定 f(i,j)，只需要知道 f(i-1,j) 和 f(i,j-1) 的值，而至於它們是如何算出來的，對當前或之後的任何子問題都沒有影響。 過去不依賴未來，未來不影響過去。 最優子結構 f(i,j) 的定義就已經蘊含了最優。 大問題的最優解可以由若干個小問題的最優解推出。(max, min, sum&amp;hellip;) DP 能適用於：能將大問題拆成若干小問題，滿足無後效性、最優子結構性質。 以下介紹幾種刷題會遇到的動態規劃套路： 二、動態規劃框架 1.</description></item><item><title>[Algo] 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis</title><link>http://intervalrain.github.io/posts/cs/algo/bigo/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/bigo/</guid><description>一、Big O 表示法 Big O 的數學定義： \(\boxed{O(g(n)) = \lbrace{f(n):存在正常量\space c\space 和\space n_0，使得對所有\space n\ge n_0，有\space 0 \le f(n) \le cg(n)\rbrace}}\) 我們常用的 big O 表示法中的 \(O\) 其實代表了一個函數的集合，比方說 \(O(n^2)\) 代表著一個由 \(g(n) = n^2\) 派生出來的一個函數集合；我們說一個演算法的時間複雜度為 \(O(n^2)\)，意思就是描述該演算法的複雜度函數屬於這個函數集合之中。 分析複雜度時，常用的兩個特性： 只保留增長速率最快的項，其它省略 \(\boxed{O(2n+100) = O(n)}\) \(\boxed{O(2^{n+1}) = O(2^n)}\) \(\boxed{O(m+3n+99) = O(m+n)}\) \(\boxed{O(n^3+999\times n^2+999\times n) = O(n^3)}\) Big O 記號表示複雜度的「上限」 換句話說，只要給出的是一個上限，用 Big O 表示法都是正確的。 但在習慣上，我們特別取最緊臨的上限。但若複雜度會跟算法的輸入數據有關，沒辦法提前給出一個特別精確的時間複雜度時，擴大時間複雜度的上限就變得有意義了。 例如湊零錢問題中，金額 amount 的值為 n，coins 列表中的個數為 k，則這棵遞迴樹就是 K 叉樹。而節點的數量與樹的結構有關，而我們無法提前知道樹的結構，所以我們按照最壞情形來處理，高度為 n 的一棵滿 k 叉樹，其節點數為 \(\frac{k^n-1}{k-1}\)，用 big O 表示就是 \(O(k^n)\)。 回到目錄：[Algo] 演算法筆記 接著閱讀：[Algo] 0-2.</description></item><item><title>[Algo] 0-4. 二叉樹(Binary Tree)</title><link>http://intervalrain.github.io/posts/cs/algo/binary_tree/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/binary_tree/</guid><description>一、二叉樹的思維模式 二叉樹的解題模式大致分為兩類： 是否可以通過遍歷一遍得解 是否可以定義一個遞迴函數，通過分治法推導出原問題的答案？ [LeetCode. 104] Maximum Depth of Binary Tree(Easy) 以此題為例，可以遍歷完整個樹，並比較當下的樹的深度，得以求解。 int depth = 0; int maxDepth(TreeNode* root){ traverse(root, 1); return depth; } void traverse(TreeNode* root, int currDepth){ if (!root) return; traverse(root-&amp;gt;left, currDepth+1); depth = max(depth, currDepth); traverse(root-&amp;gt;right, currDepth+1); } 若想辦法定義一個遞迴函數，通過分治法推導出原問題，換言之，就是先處理更小的樹，再藉由小的樹處理大的樹： int maxDepth(TreeNode* root) { if (root == NULL) return 0; return 1 + max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)); } 事實上，兩個思維模式便對應著兩種演算法：回溯法(back tracking)與動態規劃(dynamic programming) 二、前序、中序、後序 無論使用哪種思維模式(遍歷或找出遞迴函數)，都要思考單獨抽出一個節點，它需要在何時(前、中、後序)做哪些事情，其它的節點交由遞迴函數去執行相同的操作。 以下我們以 quick sort 與 merge sort 為例，同樣是分治法，看看在數組上有什麼同樣的思維模式。 quick sort 從 sort() 函式便可見類似於前序的結構。 void sort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right){ if (left &amp;gt;= right) return; // 終止條件 int mid = partition(nums, left, right); // 做什麼事(pre-order) sort(nums, left, mid-1); // 左子樹 sort(nums, mid+1, right); // 右子樹 } int partition(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right){ int pivot = right; while (left &amp;lt; right){ while (nums[left] &amp;lt; nums[pivot]) left++; while (nums[right] &amp;gt; nums[pivot]) right--; if (left &amp;lt; right) swap(nums[left], nums[right]); } if (left == right &amp;amp;&amp;amp; nums[left] &amp;gt; nums[pivot] || nums[right] &amp;lt; nums[pivot]){ swap(nums[left], pivot); return left; } return pivot; } merge sort 從 sort() 函式便可見類似於後序的結構。 void sort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right){ if (left &amp;lt;= right) return; // 終止條件 int mid = left + (right-left)/2; sort(nums, left, mid); // 左子樹 sort(nums, mid+1, right); // 右子樹 merge(nums, left, mid, right); // 做什麼事(post-order) } void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int mid, int right){ vector&amp;lt;int&amp;gt; vec; int i = left, j = right; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right){ int x = nums[i] &amp;lt; nums[j] ?</description></item><item><title>[Algo] 0-3. 鏈表(Linked List)</title><link>http://intervalrain.github.io/posts/cs/algo/linked_list/</link><pubDate>Thu, 06 Oct 2022 22:30:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/linked_list/</guid><description>一、鏈表的基本結構 鏈表是由節點和指針構成的數據結構，每個節點存有一個值，和一個指向下一個節點的指針。不同於數組，鏈表並不能隨機訪問，必須透過指針找到該節點才能獲取其值；同理在未遍歷到鏈表結尾時，我們也無法知道鏈表長度，除非依賴其它數據結構儲存長度。 LeetCode 中默認的鏈表： struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; 二、鏈表的基本操作 在開始演算法實踐前，先來練習一下鏈表的 CRUD 吧！ 1. 查(Read) 由於鏈表並非在儲存格中連續分布，所以無法用索引進行隨機訪問，所以我們必須逐個訪問，直到到達我們想要的元素。 藉由指針每次指向當前節點的 next，移動 n 次到達 index 為 n 的節點。 int at(ListNode* head, int n){ // index 為 n ListNode* curr = head; while (n--){ // 移動 n 次 curr = curr-&amp;gt;next; } return curr-&amp;gt;val; } 2. 改(Update) 改的步驟，只是將查完的元素予以賦值。 void update(ListNode* head, int n, int val){ ListNode* curr = head; while (n--){ curr = curr-&amp;gt;next; } curr-&amp;gt;val = val; // 查完後賦值 } 3.</description></item><item><title>[Algo] 0-2. 算法思維</title><link>http://intervalrain.github.io/posts/cs/algo/concept/</link><pubDate>Thu, 06 Oct 2022 22:15:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/concept/</guid><description>一、資料結構概要 資料結構的存儲方式大體上只分為兩種： Array、Linked List。
雖說資料結構有 disjoint matrix, queue, stack, tree, graph 等等，但它們都可以視為 Array 與 Linked List 的上層結構，可以看成是以 Array 或 Linked List 為基底上的操作，只是 API 不同而已。 Array：由於是緊湊連續儲存的，可以隨機訪問，通過 index 快速找到對應元素，且相對節約空間。但也因必須一次性分配儲存空間，所以 array 如果需要擴充容量，就必須再重新分配一塊更大的空間，再把數孛複製過去，其時間複雜度為 \(O(N)\)；在 array 中間進行 delete 與 insert，必須搬移後面所有數據以保持連續，故時間複雜度也為\(O(N)\)。 Linked List：因為元素不連續，而是靠指針指向下一個元素的位置，所以不存在 array 的擴充容量的問題，如果知道某一元素的前一個節點與後一個節點，操作指針即可刪除該元素或者插入新元素，時間複雜度為\(O(1)\)。但正因為儲存空間不連續，無法根擇 index 算出對應元素的地址，所以不能隨機訪問；而且由於每個元素必須額外儲存前後元素位置的指針，相對較耗空間。 在 C、C++ 語言中，指針(pointer)的存在使得其能更直接對儲存空間的位址做操作，所以在處理 C 語言時，要額外了解指針的運作方式。 二、資料結構的基本操作 資料結構的基本操作不外乎： 遍歷(traverse)、增減查改(CRUD, create, read, update, delete) Array：數組的遍歷框架 -&amp;gt; 典型的線性迭代結構： void traverse(vector&amp;lt;int&amp;gt; arr){ for (int i = 0; i &amp;lt; arr.size(); i++){ // iteration } } ListNode：鏈表的遍歷框架 -&amp;gt; 兼具迭代與遞迴 class ListNode { public: int val; ListNode* next; }; void traverse(ListNode* head){ for (ListNode curr = head; curr !</description></item><item><title>CS 學習筆記</title><link>http://intervalrain.github.io/posts/csindex/</link><pubDate>Thu, 06 Oct 2022 22:01:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/csindex/</guid><description> From the begining:
Washam&amp;rsquo;s Coding Interview University 演算法 Leetcode 演算法筆記 計算機結構 計算機結構 作業系統 計算機作業系統 工具 Git Docker Kubernetes MVC 程式碼實踐 重構(Refactoring) Google Coding Style(C++)</description></item><item><title>[DS] 演算法筆記</title><link>http://intervalrain.github.io/posts/cs/algo/</link><pubDate>Thu, 06 Oct 2022 22:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/</guid><description>前言：此系列文章為參考 labuladong 的 fucking algorithm與 Leetcode101(高暢) 作為基底，簡化核心內容，並將程式碼以自己的 C++ code 替代，作為自己的學習筆記。
第零章、核心框架 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis 0-2. 算法思維 0-3. 鏈表 Linked List 0-4. 二叉樹 Binary Tree 第一章、資料結構、STL 1-1. vector 1-2. list 1-3. stack 1-4. queue 1-5. set 1-6. map 1-7. deque 1-8. priority_queue 第二章、演算法設計 2-1. 暴力演算法 Brute Force 2-2. 貪心演算法 Greedy 2-3. 分治法 Divide and Conquer 2-4. 回溯法 Backtacking 2-5. 動態規劃 Dynamic Programming 第三章、特殊資料結構 3-1. Segment Tree 3-2.</description></item><item><title>[CA] 記憶體</title><link>http://intervalrain.github.io/posts/cs/ca/memory/</link><pubDate>Sun, 03 Jul 2022 01:54:06 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/memory/</guid><description>準備中</description></item><item><title>[CA] Pipeline</title><link>http://intervalrain.github.io/posts/cs/ca/pipeline/</link><pubDate>Sun, 03 Jul 2022 01:54:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/pipeline/</guid><description>準備中</description></item><item><title>[CA] 處理器</title><link>http://intervalrain.github.io/posts/cs/ca/processor/</link><pubDate>Sun, 03 Jul 2022 01:54:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/processor/</guid><description>準備中</description></item><item><title>[CA] 計算機算術</title><link>http://intervalrain.github.io/posts/cs/ca/arithmetic/</link><pubDate>Sun, 03 Jul 2022 01:53:50 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/arithmetic/</guid><description>準備中</description></item><item><title>[CA] 指令集架構</title><link>http://intervalrain.github.io/posts/cs/ca/isa/</link><pubDate>Sun, 03 Jul 2022 01:53:45 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/isa/</guid><description>準備中</description></item><item><title>[作業系統] 計算機組織與結構</title><link>http://intervalrain.github.io/posts/cs/ca/</link><pubDate>Sun, 03 Jul 2022 01:39:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/</guid><description>計算機組織與結構 計算機抽象化與科技 指令集架構 計算機算術 處理器 Pipeline 記憶體 參考資料 黃婷婷 清大開放式課程 計算機結構 Mr. opengate</description></item><item><title>CPU 個數、CPU 核心數、CPU 執行緒數</title><link>http://intervalrain.github.io/posts/cs/os/cpucorethread/</link><pubDate>Sat, 02 Jul 2022 21:43:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/cpucorethread/</guid><description>Introduction to CPU, core and thread</description></item><item><title>[作業系統] 計算機作業系統</title><link>http://intervalrain.github.io/posts/cs/os/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/</guid><description>計算機作業系統 概述 進程管理 死鎖 記憶體管理 設備管理 鏈接 參考資料 cyc2018 Mr. opengate</description></item><item><title>[計算機作業系統] 概述</title><link>http://intervalrain.github.io/posts/cs/os/intro/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/intro/</guid><description>作業系統 簡介 電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)
硬體(hardware)：為系統提供基本的計算資源。 中央處理器(central processing unit, CPU) 記憶體(memory) I/O 裝置 應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。 使用者(users) 作業系統(Operating system, OS)： 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。
OS 最主要的兩個功能是：
資源分配：根據需求調配資源分配率(resource utilization)與效能(performance) 監控使用者程式的執行，避免不正常的運作造成對系統的危害。 一個標準的 PC 作業系統應該提供以下的功能：
行程管理(Processing management) 記憶體管理(Memory management) 檔案系統(File system) 網路通訊(Networking) 安全機制(Security) 使用者介面(User interface) 驅動程式(Device drivers) PC 基本特徵 1. 並行計算(Concurrent computing) Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 分享(Sharing) 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬(Virtual) 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4.</description></item><item><title>[計算機作業系統] 死鎖</title><link>http://intervalrain.github.io/posts/cs/os/deadlock/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/deadlock/</guid><description>準備中</description></item><item><title>[計算機作業系統] 記憶體管理</title><link>http://intervalrain.github.io/posts/cs/os/memorymanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/memorymanagement/</guid><description>準備中</description></item><item><title>[計算機作業系統] 設備管理</title><link>http://intervalrain.github.io/posts/cs/os/equipmentmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/equipmentmanagement/</guid><description>準備中</description></item><item><title>[計算機作業系統] 進程管理</title><link>http://intervalrain.github.io/posts/cs/os/processmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/processmanagement/</guid><description>進程管理 進程與執行緒 1. 進程(process) 進程是資源分配的基本單位。 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。 2. 執行緒(thread) 執行緒又稱線程，是獨立調度的基本單位。 一個進程可以有多個執行緒，它們共享進程資源。 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。 3. 區別 擁有資源 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。 調度 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。 系統開銷 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。 通訊 執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。 進程狀態的切換 就緒就態(ready)：等待被調度 執行狀態(running) 阻塞狀態(waiting)：等待資源 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。 進程調度演算法 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。 1. 批次處理系統(batch system) 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。 1.1 先來先服務(first-come first-served, FCFS) 非搶占式的調度，按照請求的順序進行調度。 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長 1.2 短作業優先(shortest job first, SJF) 非搶占式的調度算法，按估計運行時間最短的順序進行調度。 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。 1.</description></item><item><title>[計算機作業系統] 鏈接</title><link>http://intervalrain.github.io/posts/cs/os/link/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/os/link/</guid><description>準備中</description></item><item><title>[CA] 計算機的抽象化與科技</title><link>http://intervalrain.github.io/posts/cs/ca/abstraction/</link><pubDate>Thu, 24 Mar 2022 01:12:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ca/abstraction/</guid><description>計算機的抽象化與科技 1.1 簡介 有賴於科技高速的成長，計算機工業出現了嶄新的型態，計算機導致了文明的第三次革命-資訊革命，與農業革命和工業革命並駕齊驅。如科幻電影般的生活應用，也如雨後出筍般的出現。 汽車 手機 人類基因組計劃(Human genome project) 全球網路(World Wide Web) 搜尋引擎 計算機的應用分類與其特性 個人電腦(Personal Computer, PCs) 伺服器(Servers) 通過網路連接其它的工作站或電腦，通常面向單一且複雜大型的科學或工程應用，也可能是多而小的工作。 成本和功能的差異性也最廣，可以是沒有螢幕沒有鍵盤的桌電，也可以是如超級計算機(supercomputers)這樣的極端。 嵌入式計算機(Embedded Computers) 最大的計算機類別，也涵蓋最廣泛的應用和性能。 通常具有獨特的應用要求，這些要求將最低效能發揮的淋漓盡致，使成本與功耗成為很重要的指標。 後PC時代 個人行動裝置(Poersonal Mobile Device, PMD) 如智慧型手機與平板的出現，取代的 PC 的地位。 雲端計算(Cloud Computing) 取代了傳統伺服器，這些雲端計算建構在「倉庫規模計算機」(Warehouse Scale Computer, WSC)。 企業如Google、Amazon，提供了 WSC 的租借服務，這類通過雲端佈署的「軟體即服務」(Software as a Service, SaaS)，正在改變軟體業。 學習目標 過去在硬體的限制下，程式設計師需要嚴格的考慮程式的效能：減少記憶體空間以使程式更快。 在計算機設計與記憶體科技的進步下，取而代之程式設計師要考量的事情變成：處理器的並行性和記憶體的分層，或諸如在 PMD 或雲端上運行的程式的能源效率問題。 以下是我們將要學習的目標： 用高級語言編寫的程式如何翻譯成硬體語言，以及硬體如何執行生成的程式？藉此可以理解硬體與軟體的關係，也與程式的性能有關聯。 軟體和硬體間的介面是什麼，軟體如何指示硬體執行所需的工作？這些概念對於理解如何編寫多種軟體至關重要。 什麼決定了一個程式的性能，程式設計師如何提高性能？這關係了源始碼編譯成電腦的語言時，硬體執行程式的效率。 硬體設計人員可以使用哪些技術來提高性能(Performance)？ 硬體設計人員可以使用哪些技術來提升能源效率(Energy Efficiency)？程式設計師又如何協助改善？ 什麼理由導致了循序處理(Sequential processing)轉變成了平行處理(Parallel processing)？ 自第一台商用計算機問世以來，計算機架構師提出了哪些想法來奠定現代計算的基礎？ 1.2 計結中八個重要的思想 摩爾定律(Moore&amp;rsquo;s Law)之於設計 摩爾定律源於 Intel 創辦人之一的 Gordon Moore 對 IC 容量增長的預測。 由於計算機設計需耗時數年，而晶片的成長使得計算機架構師在設計時，必須將眼光放到設計完成時的技術狀態，而非當下。 用抽象化(Abstraction)來簡化設計 程式設計師與計算機架構師都必須要不斷發明新的技術以面對日益更新的科技， 抽象化是一種分層設計的概念。對程式設計師而言，低階的細節被忽略，只需要遵從簡單的模型或規範去進行設計。而硬體工程師則是要去實現出這個定義好的模型的硬體、細節部分。 快速處理常見情況 將常使用的指令進行優化(common case fast)，比起其它不常使用的指令，更能提升效能。 何者為最常使用的指令，必須透過嚴密的實驗與測量才以得知。 平行處理(parallelism) Pipeline 預測 某些情況下，將硬體的效能預測的高一點，好過於等到效能滿足才開始設計。 記憶體的結構化(hierarchy) 透過將記憶體分層，將最快、最小、最昂貴的部分置於層狀結構的頂層；而最慢、最大、最便宜的記憶體置於層狀結構的底層。 用多餘創造可靠性(dependability) 計算機不只要速度快，還要具有可靠性。任何物理設備都可能發生故障，此時可以透過引入冗餘的元件來使系統變的更可靠，這些冗餘的元件可以在發生故障時接管工作並協助檢測故障。 1.</description></item><item><title>[CS50] Lec 1 - C</title><link>http://intervalrain.github.io/posts/cs50/lec1/</link><pubDate>Thu, 10 Mar 2022 02:39:12 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs50/lec1/</guid><description>Introduction to programming language C</description></item></channel></rss>