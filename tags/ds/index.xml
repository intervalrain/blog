<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>DS on Rain's Blog</title><link>http://intervalrain.github.io/tags/ds/</link><description>Recent content in DS on Rain's Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 06 Oct 2022 23:00:28 +0800</lastBuildDate><atom:link href="http://intervalrain.github.io/tags/ds/index.xml" rel="self" type="application/rss+xml"/><item><title>[DS] 3. 二叉樹(Binary Tree)</title><link>http://intervalrain.github.io/posts/cs/algo/binary_tree/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/binary_tree/</guid><description>一、二叉樹的思維模式 二叉樹的解題模式大致分為兩類： 是否可以通過遍歷一遍得解 是否可以定義一個遞迴函數，通過分治法推導出原問題的答案？ [LeetCode. 104] Maximum Depth of Binary Tree(Easy) 以此題為例，可以遍歷完整個樹，並比較當下的樹的深度，得以求解。 int depth = 0; int maxDepth(TreeNode* root){ traverse(root, 1); return depth; } void traverse(TreeNode* root, int currDepth){ if (!root) return; traverse(root-&amp;gt;left, currDepth+1); depth = max(depth, currDepth); traverse(root-&amp;gt;right, currDepth+1); } 若想辦法定義一個遞迴函數，通過分治法推導出原問題，換言之，就是先處理更小的樹，再藉由小的樹處理大的樹： int maxDepth(TreeNode* root) { if (root == NULL) return 0; return 1 + max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)); } 事實上，兩個思維模式便對應著兩種演算法：回溯法(back tracking)與動態規劃(dynamic programming) 二、前序、中序、後序 無論使用哪種思維模式(遍歷或找出遞迴函數)，都要思考單獨抽出一個節點，它需要在何時(前、中、後序)做哪些事情，其它的節點交由遞迴函數去執行相同的操作。 以下我們以 quick sort 與 merge sort 為例，同樣是分治法，看看在數組上有什麼同樣的思維模式。 quick sort 從 sort() 函式便可見類似於前序的結構。 void sort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right){ if (left &amp;gt;= right) return; // 終止條件 int mid = partition(nums, left, right); // 做什麼事(pre-order) sort(nums, left, mid-1); // 左子樹 sort(nums, mid+1, right); // 右子樹 } int partition(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right){ int pivot = right; while (left &amp;lt; right){ while (nums[left] &amp;lt; nums[pivot]) left++; while (nums[right] &amp;gt; nums[pivot]) right--; if (left &amp;lt; right) swap(nums[left], nums[right]); } if (left == right &amp;amp;&amp;amp; nums[left] &amp;gt; nums[pivot] || nums[right] &amp;lt; nums[pivot]){ swap(nums[left], pivot); return left; } return pivot; } merge sort 從 sort() 函式便可見類似於後序的結構。 void sort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right){ if (left &amp;lt;= right) return; // 終止條件 int mid = left + (right-left)/2; sort(nums, left, mid); // 左子樹 sort(nums, mid+1, right); // 右子樹 merge(nums, left, mid, right); // 做什麼事(post-order) } void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int mid, int right){ vector&amp;lt;int&amp;gt; vec; int i = left, j = right; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right){ int x = nums[i] &amp;lt; nums[j] ?</description></item><item><title>[DS] 2. 鏈表(Linked List)</title><link>http://intervalrain.github.io/posts/cs/algo/linked_list/</link><pubDate>Thu, 06 Oct 2022 22:30:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/linked_list/</guid><description>一、鏈表的基本結構 鏈表是由節點和指針構成的數據結構，每個節點存有一個值，和一個指向下一個節點的指針。不同於數組，鏈表並不能隨機訪問，必須透過指針找到該節點才能獲取其值；同理在未遍歷到鏈表結尾時，我們也無法知道鏈表長度，除非依賴其它數據結構儲存長度。 LeetCode 中默認的鏈表： struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) {} }; 二、鏈表的基本操作 在開始演算法實踐前，先來練習一下鏈表的 CRUD 吧！ 1. 查(Read) 由於鏈表並非在儲存格中連續分布，所以無法用索引進行隨機訪問，所以我們必須逐個訪問，直到到達我們想要的元素。 藉由指針每次指向當前節點的 next，移動 n 次到達 index 為 n 的節點。 int at(ListNode* head, int n){ // index 為 n ListNode* curr = head; while (n--){ // 移動 n 次 curr = curr-&amp;gt;next; } return curr-&amp;gt;val; } 2. 改(Update) 改的步驟，只是將查完的元素予以賦值。 void update(ListNode* head, int n, int val){ ListNode* curr = head; while (n--){ curr = curr-&amp;gt;next; } curr-&amp;gt;val = val; // 查完後賦值 } 3.</description></item><item><title>[DS] 1. 算法思維</title><link>http://intervalrain.github.io/posts/cs/algo/concept/</link><pubDate>Thu, 06 Oct 2022 22:15:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/concept/</guid><description>一、資料結構概要 資料結構的存儲方式大體上只分為兩種： Array、Linked List。
雖說資料結構有 disjoint matrix, queue, stack, tree, graph 等等，但它們都可以視為 Array 與 Linked List 的上層結構，可以看成是以 Array 或 Linked List 為基底上的操作，只是 API 不同而已。 Array：由於是緊湊連續儲存的，可以隨機訪問，通過 index 快速找到對應元素，且相對節約空間。但也因必須一次性分配儲存空間，所以 array 如果需要擴充容量，就必須再重新分配一塊更大的空間，再把數孛複製過去，其時間複雜度為 \(O(N)\)；在 array 中間進行 delete 與 insert，必須搬移後面所有數據以保持連續，故時間複雜度也為\(O(N)\)。 Linked List：因為元素不連續，而是靠指針指向下一個元素的位置，所以不存在 array 的擴充容量的問題，如果知道某一元素的前一個節點與後一個節點，操作指針即可刪除該元素或者插入新元素，時間複雜度為\(O(1)\)。但正因為儲存空間不連續，無法根擇 index 算出對應元素的地址，所以不能隨機訪問；而且由於每個元素必須額外儲存前後元素位置的指針，相對較耗空間。 在 C、C++ 語言中，指針(pointer)的存在使得其能更直接對儲存空間的位址做操作，所以在處理 C 語言時，要額外了解指針的運作方式。 二、資料結構的基本操作 資料結構的基本操作不外乎： 遍歷(traverse)、增減查改(CRUD, create, read, update, delete) Array：數組的遍歷框架 -&amp;gt; 典型的線性迭代結構： void traverse(vector&amp;lt;int&amp;gt; arr){ for (int i = 0; i &amp;lt; arr.size(); i++){ // iteration } } ListNode：鏈表的遍歷框架 -&amp;gt; 兼具迭代與遞迴 class ListNode { public: int val; ListNode* next; }; void traverse(ListNode* head){ for (ListNode curr = head; curr !</description></item><item><title>[DS] 演算法筆記</title><link>http://intervalrain.github.io/posts/cs/algo/</link><pubDate>Thu, 06 Oct 2022 22:00:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/algo/</guid><description> 前言：此系列文章為參考 labuladong 的 fucking algorithm與 Leetcode101(高暢) 作為基底，簡化核心內容，並將程式碼以自己的 C++ code 替代，作為自己的學習筆記。
第零章、核心框架 1. 算法思維 2. 鏈表 Linked List 3. 二叉樹 Binary Tree 第一章、資料結構 第二章、動態規劃 第三章、</description></item><item><title>[DS] 資料結構與演算法</title><link>http://intervalrain.github.io/posts/cs/ds/</link><pubDate>Fri, 08 Jul 2022 02:46:28 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs/ds/</guid><description>資料結構與演算法實作練習</description></item></channel></rss>