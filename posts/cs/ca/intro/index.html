<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[計算機組織與結構] 概述 | Rain's Blog</title><meta name=keywords content="CA,CS"><meta name=description content="前言 二進制 從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。 現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。 電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機 計算機結構 vs. 計算機組織 計算機結構 Computer Architecture 處理器(processor) 控制器(Control) 資料路徑(Datapath) 記憶體(memory) 裝置(Devices) 輸入(Input): 鍵盤、滑鼠、磁碟 輸出(Output): 磁碟、顯示器、影印機 計算機組織 Computer Organization(架構) 功能元件的性能: 暫存器(registers)、算術邏輯單元(ALU)、移位器(shifters) 結構(Structure) 資料流(Dataflow) 控制邏輯(Control logic) 暫存器傳輸階層(Register Transfer Level, RTL) 描述 計算機結構 計算機結構(Computer Architecture) = 指令集架構(Instruction Set Architecture, ISA) + 機器組織(Machine Organization) 軟體與硬體間的介面。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。 選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置 指令集架構 Instruction Set Architecture(ISA) 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) 指令集(Instruction Set) 指令形式(Instruction Formats) 讀寫資料的模式與指令 例外狀況 計算機的發展 電腦的分類與市場：歸因於行動裝置的崛起和技術的進步(CMOS、SoC、CAD tools等)。 桌上型電腦(Desktop computers) 伺服器電腦(Server computers) 嵌入式電腦(Embedded computers) 依指令集的長度、複雜度分為 複雜指令集電腦(Complex Instruction Set Computer, CISC) 精簡指令集電腦(Reduced Instruction Set Computer, RISC) 微處理器(Microprocessor) 的分類與市場：主要有兩大架構 ARM 架構： 過去稱為進階精簡指令集機器(Advanced RISC Machine)。 32 位元 RISC 處理器架構。 低成本、高效能、低耗電。 廣泛使用在嵌入式系統設計。 適用於行動通訊領域。 MIPS 架構： Microprocessor without Interlocked Pipeline Stages RISC 處理器架構，早年使用 32 位元，最新版本已變成 64 位元。 廣泛使用於電子產品、網路設備、個人娛樂裝置與商業裝置。 在 MIPS 架構中，指令被分為 R型、I型、J型，三種類型的指令的最高 6 位均為 6 位的 opcode 碼。 瓶頸 摩爾定律(Moore&rsquo;s Law) 積體電路晶片上所整合的電路數目，每隔 18 個月就增加一倍。 摩爾定律的時代將會結束，因為研究和實驗室的成本需求十分高昂，而有財力投資在建立和維護晶片工廠的企業很少。而且製程也愈來愈接近半導體的物理極限，將會難以再縮小下去。 能耗限制(The power wall) 微處理器的效能提升一直仰賴提高處理器的操作頻率，但在提升操作步率的同時，也會帶來龐大的功耗，故形成 Power Wall。 散熱問題愈趨嚴重、電壓無法再下降。 \(\text{P}_\text{dynamic} = \text{IV} = \frac{1}{2}\text{CV}^2\times\frac{1}{\text{T}} = \frac{1}{2}\text{CVF}\) 多處理器(Multi-processor)開始發展 反應時間(Response Time)不增加，但吞吐量(Throughput)增加。 程式設計師要開始考量平行運算程式設計。 阿姆達爾定律(Amdahl&rsquo;s Law) 它代表了處理器平行運算之後效率提升的能力，無論如何提升處理器的數目，加速比將會達到一個極限。(比方說導線的電導率決定電子傳遞速度的上限) \(\text{T} _\text{improved}=\frac{\text{T} _\text{affected} }{\text{improvement facetor}}+\text{T} _\text{unaffected}\) \(\text{T} _\text{improved} \rightarrow 0 + \text{T} _\text{unaffected}\) unaffected term 會決定速度的上限 效能(Performance) 效能的表示法 吞吐量(Throughput)：單位時間的工作量。適用於大型主機。 反應時間(Response time)：任務完成所需的時間。適用於個人電腦。 I/O time CPU time：任務的處理(processing)時間 系統 CPU 使用者 CPU Elapsed time = Total Response time，包含處理器、I/O、OS overhaed、閒置時間 CPU time \(\boxed{\text{CPU Time} = \text{n}_ \text{clock}\times\text{t}_ \text{clock}}\) \(\text{n}_\text{clock}\)：clock 的數目 \(\text{t}_\text{clock}\)：單位 clock 的時間 \(\boxed{\text{CPI}=\frac{\text{n}_\text{clock}}{\text{n} _\text{IC}}}\) \(\text{n}_\text{IC}\)：指令數目(Instruction Count, IC) \(\text{CPI}\)：Cycle per instruction \(\boxed{\text{CPU Time} = \text{n}_ \text{IC}\times\text{CPI}\times\text{t}_ \text{clock}}\) \(\boxed{\text{Clock Rate} = \frac{1}{\text{t}_\text{clock}} = \frac{\text{n} _\text{clock}}{\text{CPU time}}}\) 影響效能的因素 \(\boxed{\begin{array}{ccccccc} \text{CPU Time}&=&\frac{\text{Instruct."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="[計算機組織與結構] 概述"><meta property="og:description" content="前言 二進制 從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。 現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。 電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機 計算機結構 vs. 計算機組織 計算機結構 Computer Architecture 處理器(processor) 控制器(Control) 資料路徑(Datapath) 記憶體(memory) 裝置(Devices) 輸入(Input): 鍵盤、滑鼠、磁碟 輸出(Output): 磁碟、顯示器、影印機 計算機組織 Computer Organization(架構) 功能元件的性能: 暫存器(registers)、算術邏輯單元(ALU)、移位器(shifters) 結構(Structure) 資料流(Dataflow) 控制邏輯(Control logic) 暫存器傳輸階層(Register Transfer Level, RTL) 描述 計算機結構 計算機結構(Computer Architecture) = 指令集架構(Instruction Set Architecture, ISA) + 機器組織(Machine Organization) 軟體與硬體間的介面。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。 選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置 指令集架構 Instruction Set Architecture(ISA) 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) 指令集(Instruction Set) 指令形式(Instruction Formats) 讀寫資料的模式與指令 例外狀況 計算機的發展 電腦的分類與市場：歸因於行動裝置的崛起和技術的進步(CMOS、SoC、CAD tools等)。 桌上型電腦(Desktop computers) 伺服器電腦(Server computers) 嵌入式電腦(Embedded computers) 依指令集的長度、複雜度分為 複雜指令集電腦(Complex Instruction Set Computer, CISC) 精簡指令集電腦(Reduced Instruction Set Computer, RISC) 微處理器(Microprocessor) 的分類與市場：主要有兩大架構 ARM 架構： 過去稱為進階精簡指令集機器(Advanced RISC Machine)。 32 位元 RISC 處理器架構。 低成本、高效能、低耗電。 廣泛使用在嵌入式系統設計。 適用於行動通訊領域。 MIPS 架構： Microprocessor without Interlocked Pipeline Stages RISC 處理器架構，早年使用 32 位元，最新版本已變成 64 位元。 廣泛使用於電子產品、網路設備、個人娛樂裝置與商業裝置。 在 MIPS 架構中，指令被分為 R型、I型、J型，三種類型的指令的最高 6 位均為 6 位的 opcode 碼。 瓶頸 摩爾定律(Moore&rsquo;s Law) 積體電路晶片上所整合的電路數目，每隔 18 個月就增加一倍。 摩爾定律的時代將會結束，因為研究和實驗室的成本需求十分高昂，而有財力投資在建立和維護晶片工廠的企業很少。而且製程也愈來愈接近半導體的物理極限，將會難以再縮小下去。 能耗限制(The power wall) 微處理器的效能提升一直仰賴提高處理器的操作頻率，但在提升操作步率的同時，也會帶來龐大的功耗，故形成 Power Wall。 散熱問題愈趨嚴重、電壓無法再下降。 \(\text{P}_\text{dynamic} = \text{IV} = \frac{1}{2}\text{CV}^2\times\frac{1}{\text{T}} = \frac{1}{2}\text{CVF}\) 多處理器(Multi-processor)開始發展 反應時間(Response Time)不增加，但吞吐量(Throughput)增加。 程式設計師要開始考量平行運算程式設計。 阿姆達爾定律(Amdahl&rsquo;s Law) 它代表了處理器平行運算之後效率提升的能力，無論如何提升處理器的數目，加速比將會達到一個極限。(比方說導線的電導率決定電子傳遞速度的上限) \(\text{T} _\text{improved}=\frac{\text{T} _\text{affected} }{\text{improvement facetor}}+\text{T} _\text{unaffected}\) \(\text{T} _\text{improved} \rightarrow 0 + \text{T} _\text{unaffected}\) unaffected term 會決定速度的上限 效能(Performance) 效能的表示法 吞吐量(Throughput)：單位時間的工作量。適用於大型主機。 反應時間(Response time)：任務完成所需的時間。適用於個人電腦。 I/O time CPU time：任務的處理(processing)時間 系統 CPU 使用者 CPU Elapsed time = Total Response time，包含處理器、I/O、OS overhaed、閒置時間 CPU time \(\boxed{\text{CPU Time} = \text{n}_ \text{clock}\times\text{t}_ \text{clock}}\) \(\text{n}_\text{clock}\)：clock 的數目 \(\text{t}_\text{clock}\)：單位 clock 的時間 \(\boxed{\text{CPI}=\frac{\text{n}_\text{clock}}{\text{n} _\text{IC}}}\) \(\text{n}_\text{IC}\)：指令數目(Instruction Count, IC) \(\text{CPI}\)：Cycle per instruction \(\boxed{\text{CPU Time} = \text{n}_ \text{IC}\times\text{CPI}\times\text{t}_ \text{clock}}\) \(\boxed{\text{Clock Rate} = \frac{1}{\text{t}_\text{clock}} = \frac{\text{n} _\text{clock}}{\text{CPU time}}}\) 影響效能的因素 \(\boxed{\begin{array}{ccccccc} \text{CPU Time}&=&\frac{\text{Instruct."><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/cs/ca/intro/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-23T00:18:35+08:00"><meta property="article:modified_time" content="2022-03-23T00:18:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[計算機組織與結構] 概述"><meta name=twitter:description content="前言 二進制 從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。 現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。 電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機 計算機結構 vs. 計算機組織 計算機結構 Computer Architecture 處理器(processor) 控制器(Control) 資料路徑(Datapath) 記憶體(memory) 裝置(Devices) 輸入(Input): 鍵盤、滑鼠、磁碟 輸出(Output): 磁碟、顯示器、影印機 計算機組織 Computer Organization(架構) 功能元件的性能: 暫存器(registers)、算術邏輯單元(ALU)、移位器(shifters) 結構(Structure) 資料流(Dataflow) 控制邏輯(Control logic) 暫存器傳輸階層(Register Transfer Level, RTL) 描述 計算機結構 計算機結構(Computer Architecture) = 指令集架構(Instruction Set Architecture, ISA) + 機器組織(Machine Organization) 軟體與硬體間的介面。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。 選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置 指令集架構 Instruction Set Architecture(ISA) 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) 指令集(Instruction Set) 指令形式(Instruction Formats) 讀寫資料的模式與指令 例外狀況 計算機的發展 電腦的分類與市場：歸因於行動裝置的崛起和技術的進步(CMOS、SoC、CAD tools等)。 桌上型電腦(Desktop computers) 伺服器電腦(Server computers) 嵌入式電腦(Embedded computers) 依指令集的長度、複雜度分為 複雜指令集電腦(Complex Instruction Set Computer, CISC) 精簡指令集電腦(Reduced Instruction Set Computer, RISC) 微處理器(Microprocessor) 的分類與市場：主要有兩大架構 ARM 架構： 過去稱為進階精簡指令集機器(Advanced RISC Machine)。 32 位元 RISC 處理器架構。 低成本、高效能、低耗電。 廣泛使用在嵌入式系統設計。 適用於行動通訊領域。 MIPS 架構： Microprocessor without Interlocked Pipeline Stages RISC 處理器架構，早年使用 32 位元，最新版本已變成 64 位元。 廣泛使用於電子產品、網路設備、個人娛樂裝置與商業裝置。 在 MIPS 架構中，指令被分為 R型、I型、J型，三種類型的指令的最高 6 位均為 6 位的 opcode 碼。 瓶頸 摩爾定律(Moore&rsquo;s Law) 積體電路晶片上所整合的電路數目，每隔 18 個月就增加一倍。 摩爾定律的時代將會結束，因為研究和實驗室的成本需求十分高昂，而有財力投資在建立和維護晶片工廠的企業很少。而且製程也愈來愈接近半導體的物理極限，將會難以再縮小下去。 能耗限制(The power wall) 微處理器的效能提升一直仰賴提高處理器的操作頻率，但在提升操作步率的同時，也會帶來龐大的功耗，故形成 Power Wall。 散熱問題愈趨嚴重、電壓無法再下降。 \(\text{P}_\text{dynamic} = \text{IV} = \frac{1}{2}\text{CV}^2\times\frac{1}{\text{T}} = \frac{1}{2}\text{CVF}\) 多處理器(Multi-processor)開始發展 反應時間(Response Time)不增加，但吞吐量(Throughput)增加。 程式設計師要開始考量平行運算程式設計。 阿姆達爾定律(Amdahl&rsquo;s Law) 它代表了處理器平行運算之後效率提升的能力，無論如何提升處理器的數目，加速比將會達到一個極限。(比方說導線的電導率決定電子傳遞速度的上限) \(\text{T} _\text{improved}=\frac{\text{T} _\text{affected} }{\text{improvement facetor}}+\text{T} _\text{unaffected}\) \(\text{T} _\text{improved} \rightarrow 0 + \text{T} _\text{unaffected}\) unaffected term 會決定速度的上限 效能(Performance) 效能的表示法 吞吐量(Throughput)：單位時間的工作量。適用於大型主機。 反應時間(Response time)：任務完成所需的時間。適用於個人電腦。 I/O time CPU time：任務的處理(processing)時間 系統 CPU 使用者 CPU Elapsed time = Total Response time，包含處理器、I/O、OS overhaed、閒置時間 CPU time \(\boxed{\text{CPU Time} = \text{n}_ \text{clock}\times\text{t}_ \text{clock}}\) \(\text{n}_\text{clock}\)：clock 的數目 \(\text{t}_\text{clock}\)：單位 clock 的時間 \(\boxed{\text{CPI}=\frac{\text{n}_\text{clock}}{\text{n} _\text{IC}}}\) \(\text{n}_\text{IC}\)：指令數目(Instruction Count, IC) \(\text{CPI}\)：Cycle per instruction \(\boxed{\text{CPU Time} = \text{n}_ \text{IC}\times\text{CPI}\times\text{t}_ \text{clock}}\) \(\boxed{\text{Clock Rate} = \frac{1}{\text{t}_\text{clock}} = \frac{\text{n} _\text{clock}}{\text{CPU time}}}\) 影響效能的因素 \(\boxed{\begin{array}{ccccccc} \text{CPU Time}&=&\frac{\text{Instruct."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[計算機組織與結構] 概述","item":"http://intervalrain.github.io/posts/cs/ca/intro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[計算機組織與結構] 概述","name":"[計算機組織與結構] 概述","description":"前言 二進制 從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。 現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。 電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機 計算機結構 vs. 計算機組織 計算機結構 Computer Architecture 處理器(processor) 控制器(Control) 資料路徑(Datapath) 記憶體(memory) 裝置(Devices) 輸入(Input): 鍵盤、滑鼠、磁碟 輸出(Output): 磁碟、顯示器、影印機 計算機組織 Computer Organization(架構) 功能元件的性能: 暫存器(registers)、算術邏輯單元(ALU)、移位器(shifters) 結構(Structure) 資料流(Dataflow) 控制邏輯(Control logic) 暫存器傳輸階層(Register Transfer Level, RTL) 描述 計算機結構 計算機結構(Computer Architecture) = 指令集架構(Instruction Set Architecture, ISA) + 機器組織(Machine Organization) 軟體與硬體間的介面。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。 選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置 指令集架構 Instruction Set Architecture(ISA) 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) 指令集(Instruction Set) 指令形式(Instruction Formats) 讀寫資料的模式與指令 例外狀況 計算機的發展 電腦的分類與市場：歸因於行動裝置的崛起和技術的進步(CMOS、SoC、CAD tools等)。 桌上型電腦(Desktop computers) 伺服器電腦(Server computers) 嵌入式電腦(Embedded computers) 依指令集的長度、複雜度分為 複雜指令集電腦(Complex Instruction Set Computer, CISC) 精簡指令集電腦(Reduced Instruction Set Computer, RISC) 微處理器(Microprocessor) 的分類與市場：主要有兩大架構 ARM 架構： 過去稱為進階精簡指令集機器(Advanced RISC Machine)。 32 位元 RISC 處理器架構。 低成本、高效能、低耗電。 廣泛使用在嵌入式系統設計。 適用於行動通訊領域。 MIPS 架構： Microprocessor without Interlocked Pipeline Stages RISC 處理器架構，早年使用 32 位元，最新版本已變成 64 位元。 廣泛使用於電子產品、網路設備、個人娛樂裝置與商業裝置。 在 MIPS 架構中，指令被分為 R型、I型、J型，三種類型的指令的最高 6 位均為 6 位的 opcode 碼。 瓶頸 摩爾定律(Moore\u0026rsquo;s Law) 積體電路晶片上所整合的電路數目，每隔 18 個月就增加一倍。 摩爾定律的時代將會結束，因為研究和實驗室的成本需求十分高昂，而有財力投資在建立和維護晶片工廠的企業很少。而且製程也愈來愈接近半導體的物理極限，將會難以再縮小下去。 能耗限制(The power wall) 微處理器的效能提升一直仰賴提高處理器的操作頻率，但在提升操作步率的同時，也會帶來龐大的功耗，故形成 Power Wall。 散熱問題愈趨嚴重、電壓無法再下降。 \\(\\text{P}_\\text{dynamic} = \\text{IV} = \\frac{1}{2}\\text{CV}^2\\times\\frac{1}{\\text{T}} = \\frac{1}{2}\\text{CVF}\\) 多處理器(Multi-processor)開始發展 反應時間(Response Time)不增加，但吞吐量(Throughput)增加。 程式設計師要開始考量平行運算程式設計。 阿姆達爾定律(Amdahl\u0026rsquo;s Law) 它代表了處理器平行運算之後效率提升的能力，無論如何提升處理器的數目，加速比將會達到一個極限。(比方說導線的電導率決定電子傳遞速度的上限) \\(\\text{T} _\\text{improved}=\\frac{\\text{T} _\\text{affected} }{\\text{improvement facetor}}+\\text{T} _\\text{unaffected}\\) \\(\\text{T} _\\text{improved} \\rightarrow 0 + \\text{T} _\\text{unaffected}\\) unaffected term 會決定速度的上限 效能(Performance) 效能的表示法 吞吐量(Throughput)：單位時間的工作量。適用於大型主機。 反應時間(Response time)：任務完成所需的時間。適用於個人電腦。 I/O time CPU time：任務的處理(processing)時間 系統 CPU 使用者 CPU Elapsed time = Total Response time，包含處理器、I/O、OS overhaed、閒置時間 CPU time \\(\\boxed{\\text{CPU Time} = \\text{n}_ \\text{clock}\\times\\text{t}_ \\text{clock}}\\) \\(\\text{n}_\\text{clock}\\)：clock 的數目 \\(\\text{t}_\\text{clock}\\)：單位 clock 的時間 \\(\\boxed{\\text{CPI}=\\frac{\\text{n}_\\text{clock}}{\\text{n} _\\text{IC}}}\\) \\(\\text{n}_\\text{IC}\\)：指令數目(Instruction Count, IC) \\(\\text{CPI}\\)：Cycle per instruction \\(\\boxed{\\text{CPU Time} = \\text{n}_ \\text{IC}\\times\\text{CPI}\\times\\text{t}_ \\text{clock}}\\) \\(\\boxed{\\text{Clock Rate} = \\frac{1}{\\text{t}_\\text{clock}} = \\frac{\\text{n} _\\text{clock}}{\\text{CPU time}}}\\) 影響效能的因素 \\(\\boxed{\\begin{array}{ccccccc} \\text{CPU Time}\u0026amp;=\u0026amp;\\frac{\\text{Instruct.","keywords":["CA","CS"],"articleBody":"前言 二進制 從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。 現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。 電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機 計算機結構 vs. 計算機組織 計算機結構 Computer Architecture 處理器(processor) 控制器(Control) 資料路徑(Datapath) 記憶體(memory) 裝置(Devices) 輸入(Input): 鍵盤、滑鼠、磁碟 輸出(Output): 磁碟、顯示器、影印機 計算機組織 Computer Organization(架構) 功能元件的性能: 暫存器(registers)、算術邏輯單元(ALU)、移位器(shifters) 結構(Structure) 資料流(Dataflow) 控制邏輯(Control logic) 暫存器傳輸階層(Register Transfer Level, RTL) 描述 計算機結構 計算機結構(Computer Architecture) = 指令集架構(Instruction Set Architecture, ISA) + 機器組織(Machine Organization) 軟體與硬體間的介面。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。 選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置 指令集架構 Instruction Set Architecture(ISA) 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) 指令集(Instruction Set) 指令形式(Instruction Formats) 讀寫資料的模式與指令 例外狀況 計算機的發展 電腦的分類與市場：歸因於行動裝置的崛起和技術的進步(CMOS、SoC、CAD tools等)。 桌上型電腦(Desktop computers) 伺服器電腦(Server computers) 嵌入式電腦(Embedded computers) 依指令集的長度、複雜度分為 複雜指令集電腦(Complex Instruction Set Computer, CISC) 精簡指令集電腦(Reduced Instruction Set Computer, RISC) 微處理器(Microprocessor) 的分類與市場：主要有兩大架構 ARM 架構： 過去稱為進階精簡指令集機器(Advanced RISC Machine)。 32 位元 RISC 處理器架構。 低成本、高效能、低耗電。 廣泛使用在嵌入式系統設計。 適用於行動通訊領域。 MIPS 架構： Microprocessor without Interlocked Pipeline Stages RISC 處理器架構，早年使用 32 位元，最新版本已變成 64 位元。 廣泛使用於電子產品、網路設備、個人娛樂裝置與商業裝置。 在 MIPS 架構中，指令被分為 R型、I型、J型，三種類型的指令的最高 6 位均為 6 位的 opcode 碼。 瓶頸 摩爾定律(Moore’s Law) 積體電路晶片上所整合的電路數目，每隔 18 個月就增加一倍。 摩爾定律的時代將會結束，因為研究和實驗室的成本需求十分高昂，而有財力投資在建立和維護晶片工廠的企業很少。而且製程也愈來愈接近半導體的物理極限，將會難以再縮小下去。 能耗限制(The power wall) 微處理器的效能提升一直仰賴提高處理器的操作頻率，但在提升操作步率的同時，也會帶來龐大的功耗，故形成 Power Wall。 散熱問題愈趨嚴重、電壓無法再下降。 \\(\\text{P}_\\text{dynamic} = \\text{IV} = \\frac{1}{2}\\text{CV}^2\\times\\frac{1}{\\text{T}} = \\frac{1}{2}\\text{CVF}\\) 多處理器(Multi-processor)開始發展 反應時間(Response Time)不增加，但吞吐量(Throughput)增加。 程式設計師要開始考量平行運算程式設計。 阿姆達爾定律(Amdahl’s Law) 它代表了處理器平行運算之後效率提升的能力，無論如何提升處理器的數目，加速比將會達到一個極限。(比方說導線的電導率決定電子傳遞速度的上限) \\(\\text{T} _\\text{improved}=\\frac{\\text{T} _\\text{affected} }{\\text{improvement facetor}}+\\text{T} _\\text{unaffected}\\) \\(\\text{T} _\\text{improved} \\rightarrow 0 + \\text{T} _\\text{unaffected}\\) unaffected term 會決定速度的上限 效能(Performance) 效能的表示法 吞吐量(Throughput)：單位時間的工作量。適用於大型主機。 反應時間(Response time)：任務完成所需的時間。適用於個人電腦。 I/O time CPU time：任務的處理(processing)時間 系統 CPU 使用者 CPU Elapsed time = Total Response time，包含處理器、I/O、OS overhaed、閒置時間 CPU time \\(\\boxed{\\text{CPU Time} = \\text{n}_ \\text{clock}\\times\\text{t}_ \\text{clock}}\\) \\(\\text{n}_\\text{clock}\\)：clock 的數目 \\(\\text{t}_\\text{clock}\\)：單位 clock 的時間 \\(\\boxed{\\text{CPI}=\\frac{\\text{n}_\\text{clock}}{\\text{n} _\\text{IC}}}\\) \\(\\text{n}_\\text{IC}\\)：指令數目(Instruction Count, IC) \\(\\text{CPI}\\)：Cycle per instruction \\(\\boxed{\\text{CPU Time} = \\text{n}_ \\text{IC}\\times\\text{CPI}\\times\\text{t}_ \\text{clock}}\\) \\(\\boxed{\\text{Clock Rate} = \\frac{1}{\\text{t}_\\text{clock}} = \\frac{\\text{n} _\\text{clock}}{\\text{CPU time}}}\\) 影響效能的因素 \\(\\boxed{\\begin{array}{ccccccc} \\text{CPU Time}\u0026=\u0026\\frac{\\text{Instruct.}}{\\text{{Program}}}\u0026\\times\u0026\\frac{\\text{Clock cycles}}{\\text{Instruct.}}\u0026\\times\u0026\\frac{\\text{Seconds}}{\\text{Clock cycle}}\\\\ \u0026=\u0026\\text{n}_ \\text{IC}\u0026\\times\u0026\\text{CPI}\u0026\\times\u0026\\text{t}_ \\text{clock} \\end{array}}\\) \\(\\begin{array}{|l|c|c|c|}\\hline \u0026\\text{Instruction Count}\u0026\\text{CPI}\u0026\\text{Clock Rate}\\\\\\hline \\text{程式、演算法}\u0026\\checkmark\u0026\\checkmark\u0026\\\\\\hline \\text{程式語言、編譯器}\u0026\\checkmark\u0026\\checkmark\u0026\\\\\\hline \\text{指令集}\u0026\\checkmark\u0026\\checkmark\\\\\\hline \\text{計算機結構(ISA已定義好)}\u0026\u0026\\checkmark\u0026\\checkmark\\\\\\hline \\text{科技}\u0026\u0026\u0026\\checkmark\\\\\\hline \\end{array}\\) 效能的測量 不同程式需求，在不同的硬體設計架構上，會有不同的效能呈現。 如矩陣相乘的程式，對有處理矩陣相乘的 ISA，workload 必定會比較小。 如數字相乘的程式，有乘法器的 ISA，必定優於只有加法器的 ISA。 Benchmarks 為不同程式需求，產生不同的標準程式。 Standard Performance Evaluation Corporation(SPEC) SPEC CPU performance benchmark High-performance computing Client-server models Mail systems File systems Web servers SPEC Power benchmark 在不同 workload level 下測量功耗。 \\(\\sum\\text{ssj\\_ops} _\\text{i}/\\sum\\text{power} _\\text{i}\\) MIPS 成為效能的指標 MIPS(Millions of Instructions Per Second) 注意這裡不是 Microprocessor without Interlocked Pipeline Stages ","wordCount":"324","inLanguage":"en","datePublished":"2022-03-23T00:18:35+08:00","dateModified":"2022-03-23T00:18:35+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/cs/ca/intro/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[計算機組織與結構] 概述</h1><div class=post-meta><span title='2022-03-23 00:18:35 +0800 +0800'>March 23, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/CS/CA/intro.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a><ul><li><a href=#%e4%ba%8c%e9%80%b2%e5%88%b6 aria-label=二進制>二進制</a></li><li><a href=#%e8%a8%88%e7%ae%97%e6%a9%9f%e7%b5%90%e6%a7%8b-vs-%e8%a8%88%e7%ae%97%e6%a9%9f%e7%b5%84%e7%b9%94 aria-label="計算機結構 vs. 計算機組織">計算機結構 vs. 計算機組織</a></li></ul></li><li><a href=#%e8%a8%88%e7%ae%97%e6%a9%9f%e7%9a%84%e7%99%bc%e5%b1%95 aria-label=計算機的發展>計算機的發展</a></li><li><a href=#%e6%95%88%e8%83%bdperformance aria-label=效能(Performance)>效能(Performance)</a><ul><li><a href=#%e6%95%88%e8%83%bd%e7%9a%84%e8%a1%a8%e7%a4%ba%e6%b3%95 aria-label=效能的表示法>效能的表示法</a></li><li><a href=#cpu-time aria-label="CPU time">CPU time</a></li><li><a href=#%e5%bd%b1%e9%9f%bf%e6%95%88%e8%83%bd%e7%9a%84%e5%9b%a0%e7%b4%a0 aria-label=影響效能的因素>影響效能的因素</a></li><li><a href=#%e6%95%88%e8%83%bd%e7%9a%84%e6%b8%ac%e9%87%8f aria-label=效能的測量>效能的測量</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><h2 id=二進制>二進制<a hidden class=anchor aria-hidden=true href=#二進制>#</a></h2><ul><li>從真實世界的 <strong>類比訊號</strong> 到方便儲存與傳送的 <strong>數位訊號</strong> (Analog to Digital)。</li><li>訊號容易用 <strong>二進制</strong> 表達，在電子電路上，可以用 <strong>電子開關(Switch)</strong> 來描述(bit)。</li><li>利用 <strong>電晶體(Transistor)</strong> 其特性，可以作為一個電子開關。<ul><li>現今的積體電路最常見的電晶體為 <strong>MOSFET</strong> (Metal Oxide Silicon Field Effect Transistor)。</li><li>利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。</li></ul></li><li>電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機</li></ul><h2 id=計算機結構-vs-計算機組織>計算機結構 vs. 計算機組織<a hidden class=anchor aria-hidden=true href=#計算機結構-vs-計算機組織>#</a></h2><p><img loading=lazy src=/images/CA/Lec0/architecture.png alt=architecture></p><ul><li>計算機結構 Computer Architecture<ul><li><strong>處理器(processor)</strong><ul><li>控制器(Control)</li><li>資料路徑(Datapath)</li></ul></li><li><strong>記憶體(memory)</strong></li><li><strong>裝置(Devices)</strong><ul><li>輸入(Input): 鍵盤、滑鼠、磁碟</li><li>輸出(Output): 磁碟、顯示器、影印機
<img loading=lazy src=/images/CA/Lec0/organization.png alt=organization></li></ul></li></ul></li><li>計算機組織 Computer Organization(架構)<ul><li>功能元件的性能: 暫存器(registers)、算術邏輯單元(ALU)、移位器(shifters)</li><li>結構(Structure)</li><li>資料流(Dataflow)</li><li>控制邏輯(Control logic)</li><li><strong>暫存器傳輸階層(Register Transfer Level, RTL)</strong> 描述</li></ul></li></ul><p><img loading=lazy src=/images/CA/Lec0/arch.png alt=arch></p><ul><li>計算機結構<ul><li><strong>計算機結構(Computer Architecture) = 指令集架構(Instruction Set Architecture, ISA) + 機器組織(Machine Organization)</strong></li><li>軟體與硬體間的介面。(不同層級抽象化的協同)</li><li>因應不同的需求所設計出來的機械<strong>結構</strong>。<ul><li>選用的演算法</li><li>選用的程式語言或編譯器</li><li>選用的作業系統</li><li>處理器</li><li>I/O 系統與裝置</li></ul></li><li>指令集架構 Instruction Set Architecture(ISA)<ul><li>可編程的儲存量(programmable storage)</li><li>資料型別與結構：編碼與表現(Encodings and Representations)</li><li>指令集(Instruction Set)</li><li>指令形式(Instruction Formats)</li><li>讀寫資料的模式與指令</li><li>例外狀況</li></ul></li></ul></li></ul><h1 id=計算機的發展>計算機的發展<a hidden class=anchor aria-hidden=true href=#計算機的發展>#</a></h1><ul><li>電腦的分類與市場：歸因於行動裝置的崛起和技術的進步(CMOS、SoC、CAD tools等)。<ul><li>桌上型電腦(Desktop computers)</li><li>伺服器電腦(Server computers)</li><li>嵌入式電腦(Embedded computers)</li></ul></li><li>依指令集的長度、複雜度分為<ul><li>複雜指令集電腦(Complex Instruction Set Computer, CISC)</li><li>精簡指令集電腦(Reduced Instruction Set Computer, RISC)</li></ul></li><li>微處理器(Microprocessor) 的分類與市場：主要有兩大架構<ul><li><strong>ARM 架構</strong>：<ul><li>過去稱為進階精簡指令集機器(Advanced RISC Machine)。</li><li>32 位元 RISC 處理器架構。</li><li>低成本、高效能、低耗電。</li><li>廣泛使用在嵌入式系統設計。</li><li>適用於行動通訊領域。</li></ul></li><li><strong>MIPS 架構</strong>：<ul><li>Microprocessor without Interlocked Pipeline Stages</li><li>RISC 處理器架構，早年使用 32 位元，最新版本已變成 64 位元。</li><li>廣泛使用於電子產品、網路設備、個人娛樂裝置與商業裝置。</li><li>在 MIPS 架構中，指令被分為 <strong>R型</strong>、<strong>I型</strong>、<strong>J型</strong>，三種類型的指令的最高 6 位均為 6 位的 opcode 碼。</li></ul></li></ul></li><li>瓶頸<ul><li>摩爾定律(Moore&rsquo;s Law)<ul><li>積體電路晶片上所整合的電路數目，每隔 18 個月就增加一倍。</li><li>摩爾定律的時代將會結束，因為研究和實驗室的成本需求十分高昂，而有財力投資在建立和維護晶片工廠的企業很少。而且製程也愈來愈接近半導體的物理極限，將會難以再縮小下去。
<img loading=lazy src="https://th.bing.com/th/id/R.c313eb85d740e6ec761abaa48bda414e?rik=8GyS9kadkZKJPQ&riu=http%3a%2f%2fp2.ifengimg.com%2ffck%2f2018_52%2f5a0262c7429e118_w550_h332.png&ehk=oZRQP72tOXd0524Jx8pXPtwYknRJ7vm3zDIxraf6n2o%3d&risl=&pid=ImgRaw&r=0&sres=1&sresct=1" alt="moore&amp;rsquo;s law"></li></ul></li><li>能耗限制(The power wall)<ul><li>微處理器的效能提升一直仰賴提高處理器的操作頻率，但在提升操作步率的同時，也會帶來龐大的功耗，故形成 Power Wall。</li><li>散熱問題愈趨嚴重、電壓無法再下降。</li><li>\(\text{P}_\text{dynamic} = \text{IV} = \frac{1}{2}\text{CV}^2\times\frac{1}{\text{T}} = \frac{1}{2}\text{CVF}\)</li><li>多處理器(Multi-processor)開始發展<ul><li>反應時間(Response Time)不增加，但吞吐量(Throughput)增加。</li><li>程式設計師要開始考量平行運算程式設計。
<img loading=lazy src=https://2.bp.blogspot.com/-8nX3GzSWmDI/VL4CwKj7EzI/AAAAAAAAlhY/22pkbJnWdT0/s1600/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-01-20%2B%E4%B8%8B%E5%8D%882.40.17.png alt="power wall"></li></ul></li></ul></li><li>阿姆達爾定律(Amdahl&rsquo;s Law)<ul><li>它代表了<strong>處理器平行運算</strong>之後效率提升的能力，無論如何提升處理器的數目，加速比將會達到一個極限。(比方說導線的電導率決定電子傳遞速度的上限)</li><li>\(\text{T} _\text{improved}=\frac{\text{T} _\text{affected}
}{\text{improvement facetor}}+\text{T} _\text{unaffected}\)<ul><li>\(\text{T} _\text{improved} \rightarrow 0 + \text{T} _\text{unaffected}\)</li><li>unaffected term 會決定速度的上限
<img loading=lazy src=https://3.bp.blogspot.com/-5a4rccSHnls/VL4CuTBziAI/AAAAAAAAlg8/02boMKlAxI4/s1600/648px-AmdahlsLaw.svg.png alt="Amdahl&amp;rsquo;s law"></li></ul></li></ul></li></ul></li></ul><h1 id=效能performance>效能(Performance)<a hidden class=anchor aria-hidden=true href=#效能performance>#</a></h1><h2 id=效能的表示法>效能的表示法<a hidden class=anchor aria-hidden=true href=#效能的表示法>#</a></h2><ul><li>吞吐量(Throughput)：單位時間的工作量。適用於大型主機。</li><li>反應時間(Response time)：任務完成所需的時間。適用於個人電腦。<ul><li>I/O time</li><li>CPU time：任務的處理(processing)時間<ul><li>系統 CPU</li><li>使用者 CPU</li></ul></li><li>Elapsed time = Total Response time，包含處理器、I/O、OS overhaed、閒置時間</li></ul></li></ul><h2 id=cpu-time>CPU time<a hidden class=anchor aria-hidden=true href=#cpu-time>#</a></h2><ul><li>\(\boxed{\text{CPU Time} = \text{n}_ \text{clock}\times\text{t}_ \text{clock}}\)<ul><li>\(\text{n}_\text{clock}\)：clock 的數目</li><li>\(\text{t}_\text{clock}\)：單位 clock 的時間</li></ul></li><li>\(\boxed{\text{CPI}=\frac{\text{n}_\text{clock}}{\text{n} _\text{IC}}}\)<ul><li>\(\text{n}_\text{IC}\)：指令數目(Instruction Count, IC)</li><li>\(\text{CPI}\)：Cycle per instruction</li></ul></li><li>\(\boxed{\text{CPU Time} = \text{n}_ \text{IC}\times\text{CPI}\times\text{t}_ \text{clock}}\)</li><li>\(\boxed{\text{Clock Rate} = \frac{1}{\text{t}_\text{clock}} = \frac{\text{n} _\text{clock}}{\text{CPU time}}}\)</li></ul><h2 id=影響效能的因素>影響效能的因素<a hidden class=anchor aria-hidden=true href=#影響效能的因素>#</a></h2><ul><li>\(\boxed{\begin{array}{ccccccc}
\text{CPU Time}&=&\frac{\text{Instruct.}}{\text{{Program}}}&\times&\frac{\text{Clock cycles}}{\text{Instruct.}}&\times&\frac{\text{Seconds}}{\text{Clock cycle}}\\
&=&\text{n}_ \text{IC}&\times&\text{CPI}&\times&\text{t}_ \text{clock}
\end{array}}\)</li><li>\(\begin{array}{|l|c|c|c|}\hline
&\text{Instruction Count}&\text{CPI}&\text{Clock Rate}\\\hline
\text{程式、演算法}&\checkmark&\checkmark&\\\hline
\text{程式語言、編譯器}&\checkmark&\checkmark&\\\hline
\text{指令集}&\checkmark&\checkmark\\\hline
\text{計算機結構(ISA已定義好)}&&\checkmark&\checkmark\\\hline
\text{科技}&&&\checkmark\\\hline
\end{array}\)</li></ul><h2 id=效能的測量>效能的測量<a hidden class=anchor aria-hidden=true href=#效能的測量>#</a></h2><ul><li>不同程式需求，在不同的硬體設計架構上，會有不同的效能呈現。<ul><li>如矩陣相乘的程式，對有處理矩陣相乘的 ISA，workload 必定會比較小。</li><li>如數字相乘的程式，有乘法器的 ISA，必定優於只有加法器的 ISA。</li></ul></li><li>Benchmarks<ul><li>為不同程式需求，產生不同的標準程式。</li><li>Standard Performance Evaluation Corporation(SPEC)<ul><li>SPEC CPU performance benchmark<ul><li>High-performance computing</li><li>Client-server models</li><li>Mail systems</li><li>File systems</li><li>Web servers</li></ul></li><li>SPEC Power benchmark<ul><li>在不同 workload level 下測量功耗。</li><li>\(\sum\text{ssj\_ops} _\text{i}/\sum\text{power} _\text{i}\)</li></ul></li><li>MIPS 成為效能的指標<ul><li>MIPS(Millions of Instructions Per Second)<ul><li>注意這裡不是 <em>Microprocessor without Interlocked Pipeline Stages</em></li></ul></li></ul></li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/ca/>CA</a></li><li><a href=http://intervalrain.github.io/tags/cs/>CS</a></li></ul><nav class=paginav><a class=prev href=http://intervalrain.github.io/posts/cs/ca/abstraction/><span class=title>« Prev Page</span><br><span>[CA] 計算機抽象化</span></a>
<a class=next href=http://intervalrain.github.io/posts/algorithm/freqstack/><span class=title>Next Page »</span><br><span>[Algorithm] Maximum Frequency Stack 最大頻率堆疊</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>