<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Rain Hu's Workspace</title>
<meta name=keywords content><meta name=description content="Posts - Rain Hu's Workspace"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="Posts"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:type" content="website"><meta property="og:url" content="https://intervalrain.github.io/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://intervalrain.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/posts/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/posts/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>[Life] 原子習慣</h2></header><section class=entry-content><p>與這本書的相遇是某次在 Costco 瞎逛，隨手拿起來翻了幾頁，卻改變了我的人生觀。
戒菸的人 書中最令我印象深刻的一個例子是，書中提到，習慣的演成，在於你怎麼定義三個核心觀念，這三個核心便是：
目標：戒菸 過程：花費減半 角色定位：戒菸的人 以戒菸為例，我的目標是戒菸，所以我制定了一個戒菸的過程，比方說每個禮拜花費在買菸的錢減少一半，那麼有一天，我會達到戒菸的目的，而我的角色定位，是「戒菸的人」。
若某天，在某個應酬的場合，朋友遞上了菸。
「我在戒菸。」我說。
「哎呀！三八！明天再戒，難得聚在一起。」
「好吧！就一根。」我說。
那麼我便在這個戒菸的過程，因為壞的習慣而達成不了目標，因為在定義自己的角色定位是，「戒菸的人」，暗示了自己，還是在抽菸。
但若今天我將三個核心翻轉，我先定義自己的角色定位，再設定過程，最後自然而然的達成目標，那麼心境上便完全不一樣了。
角色定位：不抽菸的人 過程：我不碰菸 目標：戒菸
同樣地，在同樣的應酬場合，朋友遞上了菸。
「我不抽菸。」我說。 我說這樣的答案，應該很難有人會硬把菸塞到你手裡。 生病的人 自從大一下學期，被診斷出慢性腎炎，我便為自己貼上了「生病的人」的標籤，從此之後，我便開始把體力變差怪罪於生病的緣故，故開始怠惰於運動，而因為不運動，導致體力愈來愈差，惡性循環。直至今日，出社會四年，我幾乎沒有再碰過籃球，儘管我一直視籃球是我最喜愛的運動，甚至在大學前兩年，我都還很積極的參與系隊，且當了系隊的副隊長。但是因為一個念頭的差異，便會對一個人的生活產生重大的轉變。
「生病的人」這個標籤，對我的生活造成的影響，是全面的影響，甚至造成我個性上的歧變，從活潑外向變成陰陰鬱自卑，對很多事情都沒有信心，我害怕被異樣看待，所以把「秘密」封鎖起來，同時也把自己關起來，最終，心理的不健康與對疾病的抗拒，轉化成表象 – 我從外觀上看起來就變成一個生病的人。
直到我開始接受、認識它，我才感受到明顯的變化。我的確是生病的人，但它並不影響我是個什麼樣的人，的確生活會產生有些不便，但是人生要過得怎麼樣，還是由自己決定的。我只是一個需要比較多時間充電，當我充滿了電，其實就跟普通人沒什麼兩樣吧。
獨特的人 出社會第 4 年，我從半導體研發工程師轉職成軟體開發工程師。起初是因為我需要常常回診的緣故，我需要準時上下班，而繁忙的工作，可能會因為我的時間限制而拖延，所以我開始在放個的時間，研究怎麼將手上的工作自動化，加上小時候寫過遊戲外掛的經驗，很快的就對程式語言上手。我開始著手於自動將數據自動的變成報表、圖像，更甚至自動輸出成報告，在這過程中我開始感受到寫程式的美好，因為寫程式可以讓我突破時間的限制，讓我可以快速的統整數據，使我有更多的時間專注於其它的研究上。同時我也開始著迷於演算法，怎麼在快速的自動化中，再偷取更多時間，為自己爭取更多時間。我從小工具開始，到著手一個人進行專案的開發，到現在，著手一個團隊進行的專案，我想我已經可以稱作一個軟體開發工程師。
對社會而言，若相入為主的看待一個人是「生病的人」，往往會認為他沒有作為，需要被可憐。 在同樣的環境中，就算有著同樣的能力，也常常因為標籤而被眨視。但是我必須要撕掉標籤，致力於發展自己的獨特性，在生活也好、工作也好，在人生中當自己的主人。在同樣的環境中，我有著獨特的能力，那麼我的標籤就會被換掉。我不是生病的人，我是獨特的人。</p></section><footer class=entry-footer>&lt;span title='2023-02-18 14:28:24 +0800 +0800'>February 18, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Life] 原子習慣" href=https://intervalrain.github.io/posts/life/20230218/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2>[Algo] 2-4. 回溯法 Backtracking</h2></header><section class=entry-content><p>一、回溯法 回溯法與 dfs 相當類似，本質上都是暴力窮舉的演算法，但細微的差異在於： dfs 在遍歷節點。 backtracking 在遍歷樹枝。 站在回溯樹上的一個節點，需要考慮的只有三件事情： 路徑 選擇 終止條件 以全排列問題([Leetcode] 46. permutation)來舉例 全排列問題即給定一組數組 nums，需返回這些數字的所有排列組合，舉例來說，給定一個數組 nums = [1,2,3]，那麼它可能的排列會有： [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1] 對應上圖的回溯樹來看，我們在每個樹的節點，都會面臨一次決策，站在樹的根時，相當於我們要選擇排列的第一位，而我們有三個選擇，即 1 或 2 或 3。若我們的第一位選擇了 1，代表我們選擇了 \(\text{x}_1=1\) 的路徑，故接下來我們的選擇只剩下兩個，即 2 或 3。當我們繼續往下做，直到子葉節點時，代表我們已經沒有選擇可選，此時就是我們的終止條件。 回憶我們在二叉樹中練習過前序、中序、後序的思維，前序與後序代表我們在遍歷節點前與後的時間點，而在回溯法，這兩個時間點，各自代表了 將選擇加入路徑 從路徑中撤銷選擇 用二叉樹程式碼來說明即： void traverse(TreeNode* root){ if (!root) return; // preorder: do option traverse(root->left); traverse(root->right); // postorder: retrieve option } N-ary 樹： class Node{ int val; vector&lt;Node*> children; }; void traverse(Node* root){ if (!...</p></section><footer class=entry-footer>&lt;span title='2023-01-27 10:50:26 +0800 +0800'>January 27, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;4 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 2-4. 回溯法 Backtracking" href=https://intervalrain.github.io/posts/cs/algo/backtracking/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2>[Algo] 2-3. 分治法 Divide and Conquer</h2></header><section class=entry-content><p>一、分治法 分治法，簡而言之就是分而治之，把複雜的問題分成兩個或更多個相似或相似的子問題，直到子問題可以直接求解，最後再將子問題的解做合併。 三步驟：Divide、Conquer、Merge 以 pseudo code 來表示大概像： void func(collection set) { // 子問題求解 if (base_case) { // 根據要求將子問題解合併成母問題解 do_something return; } // 將母問題分解成子問題 for (collection subset : set) { func(subset); } } graph LR; 母問題-->子問題1; 母問題-->子問題2; subgraph Divide 子問題1-->最小子問題1; 子問題1-->最小子問題2; 子問題2-->最小子問題3; 子問題2-->最小子問題4; end subgraph Conquer 最小子問題1-->最小子問題解1; 最小子問題2-->最小子問題解2; 最小子問題3-->最小子問題解3; 最小子問題4-->最小子問題解4; end subgraph Merge 最小子問題解1-->合併; 最小子問題解2-->合併; 最小子問題解3-->合併; 最小子問題解4-->合併; end 合併-->母問題解 舉例說明，河內塔遊戲： 河內塔是由三根桿子以大小不同碟片所組成的遊戲，僧人一次可以從一根桿子移動一個碟片到另一根桿子，但是小的碟片若放憂大的碟片下面會使得小的碟片裂開(也就是碟片只能由上而下從小排到大)，試問將一座塔從一根桿子完整的移動到另一根桿子需要移動多少次。 思考上面的情形，以三個碟片為例，若我們要從 A 到 C 移動一座塔，我們可以將之分解成「如何把上面兩個碟片移動到 B」，因為剩下的一個大碟片，可以很簡單的從 A 移動到 C。也就是說 f3(A->C) = f2(A->B) + f1(A->C) + f2(B->C)。 再更進一步，f2(A->B) 和 f2(B->C) 其實就是移動兩個碟片到另一座塔，所以可以分解成 f2(A->C) = f1(A->B) + f1(A->C) + f1(B->C)，至此，我們已經把 f3 都分解成可以代表一次移動的最小子問題的解 f1 了： graph TD; A[f3,A->C] B[f2,A->B] C[f1,A->C] D[f2,B->C] E[f1,A->C] F[f1,A->B] G[f1,C->B] H[f1,B->A] I[f1,B->C] J[f1,A->C] A-->B A--->C A-->D B-->E B-->F B-->G D-->H D-->I D-->J 故我們可以以數學方式證明：...</p></section><footer class=entry-footer>&lt;span title='2023-01-27 10:48:42 +0800 +0800'>January 27, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;6 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 2-3. 分治法 Divide and Conquer" href=https://intervalrain.github.io/posts/cs/algo/divide_and_conquer/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2>[Algo] 2-2. 貪心演算法 Greedy</h2></header><section class=entry-content><p>一、貪心演算法 是一種在每一步都採前當下看起來最好的選擇的一種策略。 由於是當下看起來最好的選擇，故也有可能選到錯的路線，導致最終的答案不是最佳解。 先舉個生活中常見的例子： 今天小明的撲滿裡存滿了大大小小的1塊、5塊跟10塊，今天小明打算要要幫撲滿瘦身，令它的重量降低，那麼小明可以到銀行換鈔，將幣值小、重量重的硬幣集結起來換成幣值大、重量輕的紙鈔。 用貪心演算法的思維，我們一定是從幣值大的 1000 開始換起，再來 500、100、50、10，以此類推，有多少換多少。 // vector&lt;int>& nums = {1000, 500, 100, 50, 10, 5, 1}; vector&lt;int> coinChange(vector&lt;int>& nums, int money) { vector&lt;int> res(nums.size(), 0); for (int i = 0; i &lt; nums.size(); i++) { res[i] += (money / nums[i]); money %= nums[i]; } return res; } 但若我們新增了一個幣值是 23，那麼上面這個思路就有可能會導致錯誤。 貪心演算法的特點 直覺且快速 通常不是最佳的 需要會被要求證明 always stays ahead：跑者每個時間點都在第一名，最後結果會是第一名 用歸納法證明。 exchange argument 用反證法，找到原解的 inversions，並作交換，證明交換後並不影響最佳解。 二、貪心演算法的應用 0. 核心思維 貪心演算法是從某一個初始狀態出發，每次通過選取區域性最優解向目標前進，並最終期望取得整體最優解的一種演算法。由這個定義可知，貪心選擇標準就是選擇當前最好的決策，貪心演算法根據這個標準進行決策，將原問題變成一個相似但規模更小的子問題，而後每一步選出來的一定是原問題整體最優解的一部分。
如果一個問題貪心後只剩下一個子問題且有最優子結構，那麼該問題就可以使用貪心演算法。當一個問題的整體最優解包含其子問題的最優解時，我們稱次問題具有最優子結構性質。 解題一般步驟 設計資料結構並找規律 進心貪心猜想 正確性證明(歸納法證明或是列舉反例進行反證) 實現程式碼 1....</p></section><footer class=entry-footer>&lt;span title='2023-01-24 18:31:15 +0800 +0800'>January 24, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 2-2. 貪心演算法 Greedy" href=https://intervalrain.github.io/posts/cs/algo/greedy/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=https://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2>[Algo] 2-1. 暴力演算法 Brute Force</h2></header><section class=entry-content><p>一、暴力演算法 暴力演算法就是枚舉法，試想今天有一個行李箱的密碼鎖為四個一組，但你又忘記密碼，那要怎麼辦？你會試著從 0000 轉到 9999 共 10000 種組合都試過，必定會找出密碼，把所有可能都枚舉過一遍，遍是暴力演算法。
暴力演算法可以應用於很多問題，包含數論、樹、圖論等等，而暴力演算法的重點在於枚舉所有可能，以樹來說就是樹的遍歷。
舉例來說：
Leetcode 1. Two Sum
給定一個數列，找數列中任兩個數的和為 target，回傳兩個數的索引值。 在還沒有認識任何資料結構之前，我們能想到最簡單的方法就是遍歷整個數列，用兩個指標 i 與 j，各指向一個數，將所有可能檢查過一遍，直到找到目標。 vector&lt;int> twoSum(vector&lt;int>& nums, int target) { for (int i = 0; i &lt; nums.size() - 1; i++) for (int j = i + 1; j &lt; nums.size(); j++) if (nums[i] + nums[j] == target) return {i, j}; return {-1, -1}; } 以上例來說，用暴力破解法求解時，求兩數和的時候，我們需進行兩個維度的 for-loop 迴圈來求解。若進一步到三數和、四數和、五數和時，我們會發現，維度會隨著多少個數字和增加。也就是三數和為 3 個迴圈，四數和為 4 個迴圈，以此類推。 以 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis來分析，也就相當於 k 數和的時間複雜度為 \(O(n^k)\)，這個增長是相當恐怖的。 暴力演算法的特點...</p></section><footer class=entry-footer>&lt;span title='2023-01-24 15:57:40 +0800 +0800'>January 24, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 2-1. 暴力演算法 Brute Force" href=https://intervalrain.github.io/posts/cs/algo/brute_force/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/posts/page/12/>« Prev Page</a>
<a class=next href=https://intervalrain.github.io/posts/page/14/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>