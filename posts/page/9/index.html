<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Rain Hu's Workspace</title><meta name=keywords content><meta name=description content="Posts - Rain Hu's Workspace"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="Posts"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:type" content="website"><meta property="og:url" content="https://intervalrain.github.io/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://intervalrain.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/posts/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/posts/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>[Algo] 3-2. Binary Search</h2></header><section class=entry-content><p>Binary Search 二元搜索法 通常一般的二分搜是在解決以下這種問題：如果有一個遞增的函數 \(f\) 定義在區間 \([a, a + n)\) 上，請求出滿足 \(f(s)\ge c\)的最小整數\(s\)。 若用一般的 linear search 從 a 開始搜直到找到滿足條件的 s，那麼複雜度是 \(O(n)\)，而用二元搜索法可以優化時間複雜度變成 \(O(\log n)\)。
想法是對於某個在 \((a, a + n)\) 中的整數 \(k\)，如果 \(f(k − 1) \ge c\)，那麼 \(s &lt; k\)，也就是答案會落在區間 \([a, k)\) 中。
反之，如果 \(f(k − 1) &lt; c\)，那麼 \(s \ge k\)，也就是說你要求的答案會落在 \([k, a + n)\)。
為了讓兩種情況的可能性都盡量低， k 取愈接近 a + n/2 愈好。如此一來，每次候選區間的長度都會縮小一半，因此複雜度為 \(O(\log n)\)。 實務上，這種函數 \(f\) 常常不能直接得出某一點的值 \(f(a)\)（甚至只能確認它和 \(c\) 的大小關係），而需要 \(O(M)\) 的時間來計算。顯然地，這時複雜度是 \(O(M \log n)\)。 1....</p></section><footer class=entry-footer><span title='2023-05-07 18:46:56 +0800 +0800'>May 7, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 3-2. Binary Search" href=https://intervalrain.github.io/posts/cs/algo/binary_search/></a></article><article class=post-entry><header class=entry-header><h2>[C#] C#3、LINQ 及相關特性</h2></header><section class=entry-content><p>1. 屬性的自動實現 在 C#3 以前，每個屬性需要手動實現，也就是需要手動為屬性添加 get 訪問器與 set 訪問器，如： private string name; public string Name { get { return name; } set { name = value; } } 在 C#3 以後，可以透過自動實現的方式撰寫： 其中命名為 name 的變數由編譯器自動創建並為其賦予名稱。 public string Name { get; set; } 但在 C#3 時，不能宣告 readonly 的自動屬性，且不能在宣告時賦予初始值，在 C#6 做了修正。在 C#3 只能透過訪問子分離來模擬 readonly： public string Name { get; private set; } 2. 隱式類型(var) 靜態類型 vs. 動態類型：
靜態類型是面向編譯的的語言，故所有類型由編譯器決定，在編譯期就會完成綁定。 動態類型則是延遲綁定的時間，在執行期才進行類型綁定。 顯式類型 vs. 隱式類型：
顯式類型代表在程式碼表達式便給出具體的類型訊息。 隱式類型則允許了類型推斷，透過上下文判斷出類型． C#3 開始支援隱式類型的寫法，關鍵字是 var。...</p></section><footer class=entry-footer><span title='2023-05-01 14:10:48 +0800 +0800'>May 1, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C#] C#3、LINQ 及相關特性" href=https://intervalrain.github.io/posts/csharp/linq_props/></a></article><article class=post-entry><header class=entry-header><h2>[IT] Design Patterns</h2></header><section class=entry-content><p>設計模式 Design Pattern 什麼是設計模式? 設計模式是指在軟體設計中通常出現的問題的典型解決方案。它們就像是預先製作好的藍圖，您可以根據自己程式碼中出現的重複設計問題來進行自定義。 設計模式不是一個特定的程式碼，而是一個解決特定問題的一般概念。您可以按照模式的細節來實現適合自己程式的解決方案。值得注意的是，設計模式常與演算法混淆，因為這兩個概念都描述了解決某些已知問題的典型解決方案。模式是一個更高層次的解決方案描述。 模式通常包括模式意圖、動機、結構、程式碼示例等幾個方面，以便人們在多種情況下可以複製它們。模式目錄還列出了其他有用的細節，例如模式的適用性、實施步驟和與其他模式的關係。 誰發明了設計模式? 設計模式不是晦澀難懂、高深複雜的概念，相反地，它們是物件導向設計中解決常見問題的典型解決方案。當一個解決方案在不同的項目中反復出現，某人最終會給它命名並詳細描述解決方案。這基本上是模式的發現方式。 模式的概念最初是由Christopher Alexander在《模式語言：城鎮、建築、建設》中描述的。這本書描述了一種用於設計城市環境的“語言”。這種語言的單位是模式。它們可以描述窗戶應該有多高，建築物應該有多少層，社區中綠地的大小應該是多少等等。+ 這個想法被四位作者Erch Gamma、John Vlissides、Ralph Johnson和Richard Helm接受。在1994年，他們出版了《Design Patterns: Elements of + Reusable Object-Oriented Software》一書，將設計模式的概念應用於編程中。該書介紹了23個解決物件導向設計中各種問題的模式，並迅速成為暢銷書。由於書名過長，人們開始稱之為“四人幫的書(Gang of Four, GoF)”。 此後，發現了許多其他物件導向模式。模式方法在其他編程領域也變得非常流行，因此現在還存在許多與物件導向設計無關的模式。 為什麼要學習設計模式? 設計模式是解決軟體設計中常見問題的一套經過驗證的解決方案工具包。即使從未遇到這些問題，了解模式仍然有用，因為它可以使用物件導向設計原則解決各種問題。 設計模式定義了一個共通的語言，使團隊之間可以使用它更有效地進行溝通。 設計模式的分類 設計模式可以根據其複雜性、細節程度和應用於整個系統的規模進行分類。它們有點像道路建設的類比：通過安裝交通信號燈或建造整個多層立交橋和地下通道來使十字路口更安全。 最基本和低層次的模式通常被稱為 “idioms”。它們通常僅適用於單一程式語言。 最通用和高層次的模式是架構模式(architectural patterns)。開發人員可以在幾乎任何語言中實現這些模式。與其他模式不同，它們可用於設計整個應用程序的架構。 此外，所有模式都可以通過其意圖或目的進行分類。本文將涵蓋三個主要模式： 創建型模式(creational)：提供了增加彈性和重複使用現有代碼的物件創建機制。 結構型模式(structural)：解釋如何將物件和類組合成更大的結構，同時保持這些結構的靈活性和效率。 行為型模式(behavioral)：負責處理物件之間的有效溝通和職責分配。 SOLID 原則 在進入本文之前，來認識一下 SOLID 原則：(詳細的內容可以參考YC的部落格) S = Single-responsibility principle (SRP) = 單一職責原則 O = Open–closed principle (OCP) = 開放封閉原則 L = Liskov substitution principle (LSP) = 里氏替換原則 補充：jyt0532 I = Interface segregation principle (ISP) = 介面隔離原則 D = Dependency inversion principle (DIP) = 依賴反向原則 正文 Factory 簡介...</p></section><footer class=entry-footer><span title='2023-05-01 00:22:49 +0800 +0800'>May 1, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [IT] Design Patterns" href=https://intervalrain.github.io/posts/it/design_pattern/></a></article><article class=post-entry><header class=entry-header><h2>[ML] 簡單實作測試</h2></header><section class=entry-content><p>線性迴歸建模 載入資料 import pandas as pd import matplotlib.pyplot as plt import matplotlib as mlp url = "sample.csv" data = pd.read_csv(url) x = data["x-axis"] y = data["y-axis"] 畫圖 def plot(x, y, w, b): line = w * x + b plt.plot(x, line, color="red", label="prediction") plt.scatter(x, y, color="blue", label="data", marker="x") plt.title("Title") plt.xlabel("x Axis") plt.ylabel("y Axis") plt.xlim([0,12]) plt.ylim([20,140]) plt.show() plot(x, y, 10, 20) 定義 cost function def cost_function(x, y, w, b): y2 = w * x + b cost = (y - y2) ** 2 return cost....</p></section><footer class=entry-footer><span title='2023-04-30 00:35:59 +0800 +0800'>April 30, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [ML] 簡單實作測試" href=https://intervalrain.github.io/posts/ml/work/></a></article><article class=post-entry><header class=entry-header><h2>[Algo] 3-10. Binary Indexed Tree(Fenwick Tree, BIT)</h2></header><section class=entry-content><p>前言：
若要對一數組做範圍取值，那麼最快的方法是前綴數組(prefix sum)，可以做到\(O(1)\)的查詢，但若要做單點更新需要\(O(n)\)的時間來維護。
而數組則是做單點更新只需要\(O(1)\)的時間，而要範圍取值則需要\(O(n)\)的查詢時間。
故若是查詢遠大於更新的情境，則適用前綴數組；若更新遠大於查詢的情境，則適用一般數組。
那假如查詢與更新的次數一樣多呢(動態更新與查詢的情境)，這種情況就可以用到此章節要介紹的資料結構，Binary Indexed Tree 了。
此結構可以做到 \(O(n)\) 的初始化，\(\log(n)\) 的更新與 \(\log(n)\) 的查詢。
\( \begin{array}{|c|c|c|}\hline &\textsf{範圍查詢}&\textsf{單點更新}\\\hline \textsf{數組}&amp;O(n)&amp;O(1)\\\hline \textsf{前綴數組}&amp;O(1)&amp;O(n)\\\hline \textsf{BIT}&amp;O(\log n)&amp;O(\log n)\\\hline \end{array} \)
簡介 與線狀樹(Segment Tree)類似，但線狀樹可以看成是 BIT 的擴充版。 BIT 的好處是只需要 n 的數組空間便可以實作，且其指標移動是透過位元運算，計算相當快速，缺點是無法套用到取極大值、極小值的情境。 參考上圖，BIT 利用「部分presum」的特性，來達到平均 \(O\log n\)的查詢與更新的時間，而其實其結構就是 partition 的其中半顆樹。 \(\text{BIT[1]=arr[1]}\) \(\text{BIT[2]=arr[1]+arr[2]}\) \(\text{BIT[3]=arr[3]}\) \(\text{BIT[4]=arr[1]+arr[2]+arr[3]+arr[4]}\) … \(\text{BIT[8]=arr[1]+arr[2]+…+arr[8]}= \text{BIT[4]+BIT[6]+BIT[7]+arr[8]}\) 觀察以上結構， 查詢時，求 [0:n] 的值為把上圖的片段湊起來變成 n 的長度。 如 \(\text{SUM[0:7]=BIT[7]+BIT[6]+BIT[4]}\) 位元表示：\(\text{SUM[0:7]=BIT[1b'111]+BIT[1b'110]+BIT[1b'100]}\) 如 \(\text{SUM[0:11]=BIT[11]+BIT[10]+BIT[8]}\) 位元表示：\(\text{SUM[0:11]=BIT[1b'1011]+BIT[1b'1010]+BIT[1b'1000]}\) 可以發現位元的規律是每次把當前的 LSB(least significant bit) 扣掉。 更新時，需要把包含 n 的片段都更新。(設n=18) 如 \(\text{update(arr[7])=update(BIT[7])+update(BIT[8])+update(BIT[16])}\) 位元表示：\(\text{update(arr[7])=update(BIT[1b'111])+update(BIT[1b'1000])+update(BIT[1b'10000])}\) 如 \(\text{update(arr[11])=update(BIT[11])+update(BIT[12])+update(BIT[16])}\) 位元表示：\(\text{update(arr[7])=update(BIT[1b'1011])+update(BIT[1b'1100])+update(BIT[1b'10000])}\) 可以發現位元的規律是每次把當前的 LSB 加進來。 統整以上規律我們可以寫成以下的模版 將 BIT[0] 設為 dummy，可方便計算。 模板 class BIT { private: vector&lt;int> bit; int lowbit(int a) { return a & (-a); } public: BIT (int n) { bit....</p></section><footer class=entry-footer><span title='2023-04-08 17:46:12 +0800 +0800'>April 8, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Algo] 3-10. Binary Indexed Tree(Fenwick Tree, BIT)" href=https://intervalrain.github.io/posts/cs/algo/bit/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/posts/page/8/>« Prev Page</a>
<a class=next href=https://intervalrain.github.io/posts/page/10/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>