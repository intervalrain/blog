<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Rain's Blog</title><meta name=keywords content><meta name=description content="Posts - Rain's Blog"><meta name=author content><link rel=canonical href=http://intervalrain.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://intervalrain.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content="rainhu, intervalrain, 陣雨"><meta property="og:type" content="website"><meta property="og:url" content="http://intervalrain.github.io/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="rainhu, intervalrain, 陣雨"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://intervalrain.github.io/posts/csindex title=CS><span>CS</span></a></li><li><a href=http://intervalrain.github.io/posts/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>[Problem] Version Query</h2></header><section class=entry-content><p>Version Query
Hardness: \(\color{red}\textsf{Hard}\) Ralated Topics: Binary Search、Segment Tree、Heap (Priority Queue、Hash Table 一、題目 Given an information of application(APK) about its range of versions, find its corresponding OS version. If APK versions are probable for two or more OS versions, it must be belong to the latest OS version.
The given apk_info structure is given as below.
struct apk_info {
int apk_version;
int min_version = 1;
int max_version = INT_MAX;
}...</p></section><footer class=entry-footer><span title='2022-10-20 22:29:15 +0800 +0800'>October 20, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [Problem] Version Query" href=http://intervalrain.github.io/posts/leetcode/versionquery/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2>[C++] Segment Tree</h2></header><section class=entry-content><p>線段樹 Segment Tree 簡介 線段樹是演算法中常用來維護區間訊息的資料結構。 空間複雜度為 \(O(n)\)，\(n\) 代表區間數。 查詢的時間複雜度為 \(O(\log n+k)\)，\(k\) 代表符合條件的區間數量。 線段樹將每個長度為為 1 的區間劃分為左右兩個區間遞迴求解，把整個線段劃分為一個樹型結構，通過合併左右兩個區間訊息來求得該區間的訊息。 在實現時，我們考慮遞迴建樹，設當前的根節點為 root，如果根節點管轄的區間長度已經是 1，則可以直接根據數組上相應位置的值初始化該節點。否則需將該區間從中點處分割為兩個子區間，分別進入左右子節點遞迴建樹，最後合併兩個子節點的訊息， 建樹 build void build(int s, int t, int p, const vector&lt;int>& arr){ if (s == t){ tree[p] = SegmentItem(arr[s], 1); return; } int m = s + ((t - s) >> 1); build(s, m, p*2, arr); build(m+1, t, p*2+1, arr); // push_up tree[p] = tree[p*2] + tree[(p*2)+1]; } 查詢 query SegmentItem find(int l, int r, int s, int t, int p){ if (l &lt;= s && t &lt;= r){ return tree[p]; } int m = s + ((t - s) >> 1); SegmentItem sum; if (r &lt;= m) return find(l, r, s, m, p*2); if (l > m) return find(l, r, m+1, t, p*2+1); return find(l, r, s, m, p*2) + find(l, r, m+1, t, p*2+1); } zkw 線段樹 來自清華大學張昆瑋(zkw)-《統計的力量》 以非遞迴的方式構建，效率更高，程式更短。 普通的線段樹是從上到下做處理，容易定位根節點，卻不容易定位子節點。 zkw 線段樹是當二叉樹是滿二叉樹時，因為子節點的編號具有以下規律： 葉子節點(left) 全部退化為線段 \([x,x]\) 。 \(n\) 個數據點則取大於等 \(n\)且為 \(2\) 的冪次的兩倍作為數組大小。 \((m=2^a\ge n)\) for (int m = 1; m &lt;= n; m >>= 1) 維護點為 \(n\) 個。索引為\([m,m+n)\)。 子葉數目為 \(m\) 個。索引為\([m,2m)\) 節點數為 \(2m-1\) 個。(數組大小需設 \(2m\) 因為 zkw tree是 1-index的) 樹高 \(H=\log_2(m)+1\) 層。 第 \(h\) 層有 \(2^{h-1}\) 個節點， 該層線段長度為 \(2^{H-h}\)。 若某節點為 \(p\)，父節點為 \(p/2\)，子節點為 \(2p\) 和 \(2p+1\) int parent = p >> 1; int left = p &lt;&lt; 1; int right = p &lt;&lt; 1 | 1; 若兩節點為 \(p\) 與 \(q\)，且兩節點互為兄弟節點，則 \(p\oplus q=1\) if (left ^ right) // left 與 right 為兄弟節點 else // left 與 right 不為兄弟節點 除根節點外，左節點皆為偶數，右節點皆為奇數 if (i == 1) // i 為根節點 else if (i & 1) // i 為奇數，為右節點 else if (!...</p></section><footer class=entry-footer><span title='2022-10-18 23:14:38 +0800 +0800'>October 18, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] Segment Tree" href=http://intervalrain.github.io/posts/c++/segtree/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2>[C++] stringstream 類範例 - split 與 concat</h2></header><section class=entry-content><p>stringstream 需引用 &lt;sstream> , &lt;iostream>, &lt;string>函式庫 配合 str() 將 stringstream 類轉換成 string 類別。 split() vector&lt;string> split(string& str, char del){ stringstream ss(str); string item; vector&lt;string> res; while (getline(ss, item, del)){ if (!item.empty()){ res.push_back(item); } } return res; } concat() string concat(vector&lt;string>& svec, char del){ stringstream ss; for (const auto& s : svec){ ss &lt;&lt; s &lt;&lt; del; } return ss.str(); } [leetcode 1859. Sorting the Sentence] class Solution { public: string sortSentence(string s) { vector&lt;string> tmp = split(s, ' '); int n = tmp....</p></section><footer class=entry-footer><span title='2022-10-14 00:21:23 +0800 +0800'>October 14, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [C++] stringstream 類範例 - split 與 concat" href=http://intervalrain.github.io/posts/c++/stringstream/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2>[DS] 1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis</h2></header><section class=entry-content><p>一、Big O 表示法 Big O 的數學定義： \(\boxed{O(g(n)) = \lbrace{f(n):存在正常量\space c\space 和\space n_0，使得對所有\space n\ge n_0，有\space 0 \le f(n) \le cg(n)\rbrace}}\) 我們常用的 big O 表示法中的 \(O\) 其實代表了一個函數的集合，比方說 \(O(n^2)\) 代表著一個由 \(g(n) = n^2\) 派生出來的一個函數集合；我們說一個演算法的時間複雜度為 \(O(n^2)\)，意思就是描述該演算法的複雜度函數屬於這個函數集合之中。 分析複雜度時，常用的兩個特性： 只保留增長速率最快的項，其它省略 \(\boxed{O(2n+100) = O(n)}\) \(\boxed{O(2^{n+1}) = O(2^n)}\) \(\boxed{O(m+3n+99) = O(m+n)}\) \(\boxed{O(n^3+999\times n^2+999\times n) = O(n^3)}\) Big O 記號表示複雜度的「上限」 換句話說，只要給出的是一個上限，用 Big O 表示法都是正確的。 但在習慣上，我們特別取最緊臨的上限。但若複雜度會跟算法的輸入數據有關，沒辦法提前給出一個特別精確的時間複雜度時，擴大時間複雜度的上限就變得有意義了。 例如湊零錢問題中，金額 amount 的值為 n，coins 列表中的個數為 k，則這棵遞迴樹就是 K 叉樹。而節點的數量與樹的結構有關，而我們無法提前知道樹的結構，所以我們按照最壞情形來處理，高度為 n 的一棵滿 k 叉樹，其節點數為 \(\frac{k^n-1}{k-1}\)，用 big O 表示就是 \(O(k^n)\)。 回到目錄：[DS] 演算法筆記 接著閱讀：[DS] 2....</p></section><footer class=entry-footer><span title='2022-10-06 23:00:28 +0800 +0800'>October 6, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [DS] 1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis" href=http://intervalrain.github.io/posts/cs/algo/bigo/></a></article><article class=post-entry><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/faang.webp alt="Oh! You closed up the window, so you cannot see raining"></figure><header class=entry-header><h2>[DS] 4. 二叉樹(Binary Tree)</h2></header><section class=entry-content><p>一、二叉樹的思維模式 二叉樹的解題模式大致分為兩類： 是否可以通過遍歷一遍得解 是否可以定義一個遞迴函數，通過分治法推導出原問題的答案？ [LeetCode. 104] Maximum Depth of Binary Tree(Easy) 以此題為例，可以遍歷完整個樹，並比較當下的樹的深度，得以求解。 int depth = 0; int maxDepth(TreeNode* root){ traverse(root, 1); return depth; } void traverse(TreeNode* root, int currDepth){ if (!root) return; traverse(root->left, currDepth+1); depth = max(depth, currDepth); traverse(root->right, currDepth+1); } 若想辦法定義一個遞迴函數，通過分治法推導出原問題，換言之，就是先處理更小的樹，再藉由小的樹處理大的樹： int maxDepth(TreeNode* root) { if (root == NULL) return 0; return 1 + max(maxDepth(root->left), maxDepth(root->right)); } 事實上，兩個思維模式便對應著兩種演算法：回溯法(back tracking)與動態規劃(dynamic programming) 二、前序、中序、後序 無論使用哪種思維模式(遍歷或找出遞迴函數)，都要思考單獨抽出一個節點，它需要在何時(前、中、後序)做哪些事情，其它的節點交由遞迴函數去執行相同的操作。 以下我們以 quick sort 與 merge sort 為例，同樣是分治法，看看在數組上有什麼同樣的思維模式。 quick sort 從 sort() 函式便可見類似於前序的結構。 void sort(vector&lt;int>& nums, int left, int right){ if (left >= right) return; // 終止條件 int mid = partition(nums, left, right); // 做什麼事(pre-order) sort(nums, left, mid-1); // 左子樹 sort(nums, mid+1, right); // 右子樹 } int partition(vector&lt;int>& nums, int left, int right){ int pivot = right; while (left &lt; right){ while (nums[left] &lt; nums[pivot]) left++; while (nums[right] > nums[pivot]) right--; if (left &lt; right) swap(nums[left], nums[right]); } if (left == right && nums[left] > nums[pivot] || nums[right] &lt; nums[pivot]){ swap(nums[left], pivot); return left; } return pivot; } merge sort 從 sort() 函式便可見類似於後序的結構。 void sort(vector&lt;int>& nums, int left, int right){ if (left &lt;= right) return; // 終止條件 int mid = left + (right-left)/2; sort(nums, left, mid); // 左子樹 sort(nums, mid+1, right); // 右子樹 merge(nums, left, mid, right); // 做什麼事(post-order) } void merge(vector&lt;int>& nums, int left, int mid, int right){ vector&lt;int> vec; int i = left, j = right; while (i &lt;= mid && j &lt;= right){ int x = nums[i] &lt; nums[j] ?...</p></section><footer class=entry-footer><span title='2022-10-06 23:00:28 +0800 +0800'>October 6, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Rain Hu</footer><a class=entry-link aria-label="post link to [DS] 4. 二叉樹(Binary Tree)" href=http://intervalrain.github.io/posts/cs/algo/binary_tree/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=http://intervalrain.github.io/posts/page/8/>« Prev Page</a>
<a class=next href=http://intervalrain.github.io/posts/page/10/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>