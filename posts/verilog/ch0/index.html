<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[VHDL] IEEE 標準硬體描述語言 | Rain's Blog</title><meta name=keywords content="VHDL,Programming,Verilog"><meta name=description content="IEEE 標準硬體描述語言  IEEE Standard for Verilog Hardware Description Language  介紹  在 1995 年，Verilog hardware description language(HDL) 成為了 IEEE 的標準規範(IEEE Std 1364-1995)，它被設計成簡單、直覺、且有效率的標準規範語言，可應用於驗證模擬、時效分析、測試分析與合成。這些特性使得 Verilog 成為大量 ic 設計者的選擇。 Verilog 包含一組很豐富的內建型別(primitives)，包含邏輯閘(logic gates)、自定義型別(user-defined primitives)、開關(switches)與線邏輯(wired logic)，它還具備了元件接腳的延遲(pin-to-pin delay)和時間分析。具象化層級的混合本質上可以被兩種資料型態所描述：電路(nets) 與 變數(variables)，以變數與電路表示的連續賦值(continuous assignments)，可以將值驅動到電路上，形成基本的結構構造(structural construct)；而有序的賦值(procedural assignments)，其中牽涉了變數與電路值的運算，可以被存入變數，形成基本的行為構造(behavior construct)。一個設計包含了一組包含輸入與輸出介面的模組(module)，還有函式的描述，可以為結構構造的、行為構造的、或是混合的。這些模組形成有層級的結構(hierarchy)且被接通於不同電路之間。 Verilog 語言具備可擴展性，透過程式語言介面(programming language interface, PLI)、與 Verilog 程序介面(Verilog procedual interface, VPI)。PLI/VPI 是一種可允許外部函數訪問硬體描述語中的資料的一種組合，且可促進與模擬動態的互動。PLI/VPI 的應用包含將 VHDL 仿真器(simulator)與其他模擬與電腦輔助系統(computer-assisted design, CAD)、客製化的除錯任務(costomized debugging task)、延遲計算器(delay calculators)、注釋器(annotators)相接連。  目錄 1. Overview 2. Normative references 3. Lexical conventions 4. Data Types 5."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.7bdb1411b29ec9fed2b6395a081eabcb3262e7311bda855249d433c8b30a926e.css integrity="sha256-e9sUEbKeyf7StjlaCB6ryzJi5zEb2oVSSdQzyLMKkm4=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="[VHDL] IEEE 標準硬體描述語言"><meta property="og:description" content="IEEE 標準硬體描述語言  IEEE Standard for Verilog Hardware Description Language  介紹  在 1995 年，Verilog hardware description language(HDL) 成為了 IEEE 的標準規範(IEEE Std 1364-1995)，它被設計成簡單、直覺、且有效率的標準規範語言，可應用於驗證模擬、時效分析、測試分析與合成。這些特性使得 Verilog 成為大量 ic 設計者的選擇。 Verilog 包含一組很豐富的內建型別(primitives)，包含邏輯閘(logic gates)、自定義型別(user-defined primitives)、開關(switches)與線邏輯(wired logic)，它還具備了元件接腳的延遲(pin-to-pin delay)和時間分析。具象化層級的混合本質上可以被兩種資料型態所描述：電路(nets) 與 變數(variables)，以變數與電路表示的連續賦值(continuous assignments)，可以將值驅動到電路上，形成基本的結構構造(structural construct)；而有序的賦值(procedural assignments)，其中牽涉了變數與電路值的運算，可以被存入變數，形成基本的行為構造(behavior construct)。一個設計包含了一組包含輸入與輸出介面的模組(module)，還有函式的描述，可以為結構構造的、行為構造的、或是混合的。這些模組形成有層級的結構(hierarchy)且被接通於不同電路之間。 Verilog 語言具備可擴展性，透過程式語言介面(programming language interface, PLI)、與 Verilog 程序介面(Verilog procedual interface, VPI)。PLI/VPI 是一種可允許外部函數訪問硬體描述語中的資料的一種組合，且可促進與模擬動態的互動。PLI/VPI 的應用包含將 VHDL 仿真器(simulator)與其他模擬與電腦輔助系統(computer-assisted design, CAD)、客製化的除錯任務(costomized debugging task)、延遲計算器(delay calculators)、注釋器(annotators)相接連。  目錄 1. Overview 2. Normative references 3. Lexical conventions 4. Data Types 5."><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/verilog/ch0/"><meta property="og:image" content="http://intervalrain.github.io/images/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-01T17:37:22+08:00"><meta property="article:modified_time" content="2022-05-01T17:37:22+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[VHDL] IEEE 標準硬體描述語言"><meta name=twitter:description content="IEEE 標準硬體描述語言  IEEE Standard for Verilog Hardware Description Language  介紹  在 1995 年，Verilog hardware description language(HDL) 成為了 IEEE 的標準規範(IEEE Std 1364-1995)，它被設計成簡單、直覺、且有效率的標準規範語言，可應用於驗證模擬、時效分析、測試分析與合成。這些特性使得 Verilog 成為大量 ic 設計者的選擇。 Verilog 包含一組很豐富的內建型別(primitives)，包含邏輯閘(logic gates)、自定義型別(user-defined primitives)、開關(switches)與線邏輯(wired logic)，它還具備了元件接腳的延遲(pin-to-pin delay)和時間分析。具象化層級的混合本質上可以被兩種資料型態所描述：電路(nets) 與 變數(variables)，以變數與電路表示的連續賦值(continuous assignments)，可以將值驅動到電路上，形成基本的結構構造(structural construct)；而有序的賦值(procedural assignments)，其中牽涉了變數與電路值的運算，可以被存入變數，形成基本的行為構造(behavior construct)。一個設計包含了一組包含輸入與輸出介面的模組(module)，還有函式的描述，可以為結構構造的、行為構造的、或是混合的。這些模組形成有層級的結構(hierarchy)且被接通於不同電路之間。 Verilog 語言具備可擴展性，透過程式語言介面(programming language interface, PLI)、與 Verilog 程序介面(Verilog procedual interface, VPI)。PLI/VPI 是一種可允許外部函數訪問硬體描述語中的資料的一種組合，且可促進與模擬動態的互動。PLI/VPI 的應用包含將 VHDL 仿真器(simulator)與其他模擬與電腦輔助系統(computer-assisted design, CAD)、客製化的除錯任務(costomized debugging task)、延遲計算器(delay calculators)、注釋器(annotators)相接連。  目錄 1. Overview 2. Normative references 3. Lexical conventions 4. Data Types 5."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[VHDL] IEEE 標準硬體描述語言","item":"http://intervalrain.github.io/posts/verilog/ch0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[VHDL] IEEE 標準硬體描述語言","name":"[VHDL] IEEE 標準硬體描述語言","description":"IEEE 標準硬體描述語言  IEEE Standard for Verilog Hardware Description Language  介紹  在 1995 年，Verilog hardware description language(HDL) 成為了 IEEE 的標準規範(IEEE Std 1364-1995)，它被設計成簡單、直覺、且有效率的標準規範語言，可應用於驗證模擬、時效分析、測試分析與合成。這些特性使得 Verilog 成為大量 ic 設計者的選擇。 Verilog 包含一組很豐富的內建型別(primitives)，包含邏輯閘(logic gates)、自定義型別(user-defined primitives)、開關(switches)與線邏輯(wired logic)，它還具備了元件接腳的延遲(pin-to-pin delay)和時間分析。具象化層級的混合本質上可以被兩種資料型態所描述：電路(nets) 與 變數(variables)，以變數與電路表示的連續賦值(continuous assignments)，可以將值驅動到電路上，形成基本的結構構造(structural construct)；而有序的賦值(procedural assignments)，其中牽涉了變數與電路值的運算，可以被存入變數，形成基本的行為構造(behavior construct)。一個設計包含了一組包含輸入與輸出介面的模組(module)，還有函式的描述，可以為結構構造的、行為構造的、或是混合的。這些模組形成有層級的結構(hierarchy)且被接通於不同電路之間。 Verilog 語言具備可擴展性，透過程式語言介面(programming language interface, PLI)、與 Verilog 程序介面(Verilog procedual interface, VPI)。PLI/VPI 是一種可允許外部函數訪問硬體描述語中的資料的一種組合，且可促進與模擬動態的互動。PLI/VPI 的應用包含將 VHDL 仿真器(simulator)與其他模擬與電腦輔助系統(computer-assisted design, CAD)、客製化的除錯任務(costomized debugging task)、延遲計算器(delay calculators)、注釋器(annotators)相接連。  目錄 1. Overview 2. Normative references 3. Lexical conventions 4. Data Types 5.","keywords":["VHDL","Programming","Verilog"],"articleBody":"IEEE 標準硬體描述語言  IEEE Standard for Verilog Hardware Description Language  介紹  在 1995 年，Verilog hardware description language(HDL) 成為了 IEEE 的標準規範(IEEE Std 1364-1995)，它被設計成簡單、直覺、且有效率的標準規範語言，可應用於驗證模擬、時效分析、測試分析與合成。這些特性使得 Verilog 成為大量 ic 設計者的選擇。 Verilog 包含一組很豐富的內建型別(primitives)，包含邏輯閘(logic gates)、自定義型別(user-defined primitives)、開關(switches)與線邏輯(wired logic)，它還具備了元件接腳的延遲(pin-to-pin delay)和時間分析。具象化層級的混合本質上可以被兩種資料型態所描述：電路(nets) 與 變數(variables)，以變數與電路表示的連續賦值(continuous assignments)，可以將值驅動到電路上，形成基本的結構構造(structural construct)；而有序的賦值(procedural assignments)，其中牽涉了變數與電路值的運算，可以被存入變數，形成基本的行為構造(behavior construct)。一個設計包含了一組包含輸入與輸出介面的模組(module)，還有函式的描述，可以為結構構造的、行為構造的、或是混合的。這些模組形成有層級的結構(hierarchy)且被接通於不同電路之間。 Verilog 語言具備可擴展性，透過程式語言介面(programming language interface, PLI)、與 Verilog 程序介面(Verilog procedual interface, VPI)。PLI/VPI 是一種可允許外部函數訪問硬體描述語中的資料的一種組合，且可促進與模擬動態的互動。PLI/VPI 的應用包含將 VHDL 仿真器(simulator)與其他模擬與電腦輔助系統(computer-assisted design, CAD)、客製化的除錯任務(costomized debugging task)、延遲計算器(delay calculators)、注釋器(annotators)相接連。  目錄 1. Overview 2. Normative references 3. Lexical conventions 4. Data Types 5. Expressions 6. Assignments 7. Gate- and switch-level modeling 8. User-defined primitives(UDPs) 9. Behavioral modeling 10. Tasks and functions 11. Scheduling semantics 12. Hierachical structures 13. Configuraing the contents of a design 14. Specify blocks 15. Timing checks 16. Backannotation using the standard delay format(SDF) 17. System tasks and functions 18. Value change dump (VCD) files 19. Compiler directives 20. Programming language interface(PLI) overview 21. PLI TF and ACC interface mechanism (deprecated) 22. Using ACC routines(deprecated) 23. ACC routine definitions (deprecated) 24. Using TF routines (deprecated) 25. TF routines definitions (deprecated) 26. Using Verilog procedural interface (VPI) routines 27. VPI routine definitions 28. Protected envelopes 29. Appendix ","wordCount":"175","inLanguage":"en","image":"http://intervalrain.github.io/images/cover.jpg","datePublished":"2022-05-01T17:37:22+08:00","dateModified":"2022-05-01T17:37:22+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/verilog/ch0/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[VHDL] IEEE 標準硬體描述語言</h1><div class=post-meta><span title="2022-05-01 17:37:22 +0800 +0800">May 1, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/Verilog/ch0.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#ieee-%e6%a8%99%e6%ba%96%e7%a1%ac%e9%ab%94%e6%8f%8f%e8%bf%b0%e8%aa%9e%e8%a8%80 aria-label="IEEE 標準硬體描述語言">IEEE 標準硬體描述語言</a><ul><li><a href=#%e4%bb%8b%e7%b4%b9 aria-label=介紹>介紹</a></li><li><a href=#%e7%9b%ae%e9%8c%84 aria-label=目錄>目錄</a><ul><li><a href=#1-overviewpostsverilogch1 aria-label="1. Overview"><a href=/posts/verilog/ch1/>1. Overview</a></a></li><li><a href=#2-normative-referencespostsverilogch2 aria-label="2. Normative references"><a href=/posts/verilog/ch2/>2. Normative references</a></a></li><li><a href=#3-lexical-conventionspostsverilogch3 aria-label="3. Lexical conventions"><a href=/posts/verilog/ch3/>3. Lexical conventions</a></a></li><li><a href=#4-data-typespostsverilogch4 aria-label="4. Data Types"><a href=/posts/verilog/ch4/>4. Data Types</a></a></li><li><a href=#5-expressionspostsverilogch5 aria-label="5. Expressions"><a href=/posts/verilog/ch5/>5. Expressions</a></a></li><li><a href=#6-assignmentspostsverilogch6 aria-label="6. Assignments"><a href=/posts/verilog/ch6/>6. Assignments</a></a></li><li><a href=#7-gate--and-switch-level-modelingpostsverilogch7 aria-label="7. Gate- and switch-level modeling"><a href=/posts/verilog/ch7/>7. Gate- and switch-level modeling</a></a></li><li><a href=#8-user-defined-primitivesudpspostsverilogch8 aria-label="8. User-defined primitives(UDPs)"><a href=/posts/verilog/ch8/>8. User-defined primitives(UDPs)</a></a></li><li><a href=#9-behavioral-modelingpostsverilogch9 aria-label="9. Behavioral modeling"><a href=/posts/verilog/ch9/>9. Behavioral modeling</a></a></li><li><a href=#10-tasks-and-functionspostsverilogch10 aria-label="10. Tasks and functions"><a href=/posts/verilog/ch10/>10. Tasks and functions</a></a></li><li><a href=#11-scheduling-semanticspostsverilogch11 aria-label="11. Scheduling semantics"><a href=/posts/verilog/ch11/>11. Scheduling semantics</a></a></li><li><a href=#12-hierachical-structurespostsverilogch12 aria-label="12. Hierachical structures"><a href=/posts/verilog/ch12/>12. Hierachical structures</a></a></li><li><a href=#13-configuraing-the-contents-of-a-designpostsverilogch13 aria-label="13. Configuraing the contents of a design"><a href=/posts/verilog/ch13/>13. Configuraing the contents of a design</a></a></li><li><a href=#14-specify-blockspostsverilogch14 aria-label="14. Specify blocks"><a href=/posts/verilog/ch14/>14. Specify blocks</a></a></li><li><a href=#15-timing-checkspostsverilogch15 aria-label="15. Timing checks"><a href=/posts/verilog/ch15/>15. Timing checks</a></a></li><li><a href=#16-backannotation-using-the-standard-delay-formatsdfpostsverilogch16 aria-label="16. Backannotation using the standard delay format(SDF)"><a href=/posts/verilog/ch16/>16. Backannotation using the standard delay format(SDF)</a></a></li><li><a href=#17-system-tasks-and-functionspostsverilogch17 aria-label="17. System tasks and functions"><a href=/posts/verilog/ch17/>17. System tasks and functions</a></a></li><li><a href=#18-value-change-dump-vcd-filespostsverilogch18 aria-label="18. Value change dump (VCD) files"><a href=/posts/verilog/ch18/>18. Value change dump (VCD) files</a></a></li><li><a href=#19-compiler-directivespostsverilogch19 aria-label="19. Compiler directives"><a href=/posts/verilog/ch19/>19. Compiler directives</a></a></li><li><a href=#20-programming-language-interfacepli-overviewpostsverilogch20 aria-label="20. Programming language interface(PLI) overview"><a href=/posts/verilog/ch20/>20. Programming language interface(PLI) overview</a></a></li><li><a href=#21-pli-tf-and-acc-interface-mechanism-deprecated aria-label="21. PLI TF and ACC interface mechanism (deprecated)">21. PLI TF and ACC interface mechanism (deprecated)</a></li><li><a href=#22-using-acc-routinesdeprecated aria-label="22. Using ACC routines(deprecated)">22. Using ACC routines(deprecated)</a></li><li><a href=#23-acc-routine-definitions-deprecated aria-label="23. ACC routine definitions (deprecated)">23. ACC routine definitions (deprecated)</a></li><li><a href=#24-using-tf-routines-deprecated aria-label="24. Using TF routines (deprecated)">24. Using TF routines (deprecated)</a></li><li><a href=#25-tf-routines-definitions-deprecated aria-label="25. TF routines definitions (deprecated)">25. TF routines definitions (deprecated)</a></li><li><a href=#26-using-verilog-procedural-interface-vpi-routinespostsverilogch26 aria-label="26. Using Verilog procedural interface (VPI) routines"><a href=/posts/verilog/ch26/>26. Using Verilog procedural interface (VPI) routines</a></a></li><li><a href=#27-vpi-routine-definitionspostsverilogch27 aria-label="27. VPI routine definitions"><a href=/posts/verilog/ch27/>27. VPI routine definitions</a></a></li><li><a href=#28-protected-envelopespostsverilogch28 aria-label="28. Protected envelopes"><a href=/posts/verilog/ch28/>28. Protected envelopes</a></a></li><li><a href=#29-appendixpostsverilogch29 aria-label="29. Appendix"><a href=/posts/verilog/ch29/>29. Appendix</a></a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=ieee-標準硬體描述語言>IEEE 標準硬體描述語言<a hidden class=anchor aria-hidden=true href=#ieee-標準硬體描述語言>#</a></h1><ul><li>IEEE Standard for Verilog Hardware Description Language</li></ul><h2 id=介紹>介紹<a hidden class=anchor aria-hidden=true href=#介紹>#</a></h2><ul><li>在 1995 年，Verilog hardware description language(HDL) 成為了 IEEE 的標準規範(IEEE Std 1364-1995)，它被設計成簡單、直覺、且有效率的標準規範語言，可應用於驗證模擬、時效分析、測試分析與合成。這些特性使得 Verilog 成為大量 ic 設計者的選擇。</li><li>Verilog 包含一組很豐富的內建型別(primitives)，包含邏輯閘(logic gates)、自定義型別(user-defined primitives)、開關(switches)與線邏輯(wired logic)，它還具備了元件接腳的延遲(pin-to-pin delay)和時間分析。具象化層級的混合本質上可以被兩種資料型態所描述：<strong>電路(nets)</strong> 與 <strong>變數(variables)</strong>，以變數與電路表示的連續賦值(continuous assignments)，可以將值驅動到電路上，形成基本的<strong>結構構造(structural construct)</strong>；而有序的賦值(procedural assignments)，其中牽涉了變數與電路值的運算，可以被存入變數，形成基本的<strong>行為構造(behavior construct)</strong>。一個設計包含了一組包含輸入與輸出介面的模組(module)，還有函式的描述，可以為結構構造的、行為構造的、或是混合的。這些模組形成有層級的結構(hierarchy)且被接通於不同電路之間。</li><li>Verilog 語言具備可擴展性，透過<strong>程式語言介面(programming language interface, PLI)</strong>、與 <strong>Verilog 程序介面(Verilog procedual interface, VPI)</strong>。PLI/VPI 是一種可允許外部函數訪問硬體描述語中的資料的一種組合，且可促進與模擬動態的互動。PLI/VPI 的應用包含將 VHDL 仿真器(simulator)與其他模擬與電腦輔助系統(computer-assisted design, CAD)、客製化的除錯任務(costomized debugging task)、延遲計算器(delay calculators)、注釋器(annotators)相接連。</li></ul><h2 id=目錄>目錄<a hidden class=anchor aria-hidden=true href=#目錄>#</a></h2><h3 id=1-overviewpostsverilogch1><a href=/posts/verilog/ch1/>1. Overview</a><a hidden class=anchor aria-hidden=true href=#1-overviewpostsverilogch1>#</a></h3><h3 id=2-normative-referencespostsverilogch2><a href=/posts/verilog/ch2/>2. Normative references</a><a hidden class=anchor aria-hidden=true href=#2-normative-referencespostsverilogch2>#</a></h3><h3 id=3-lexical-conventionspostsverilogch3><a href=/posts/verilog/ch3/>3. Lexical conventions</a><a hidden class=anchor aria-hidden=true href=#3-lexical-conventionspostsverilogch3>#</a></h3><h3 id=4-data-typespostsverilogch4><a href=/posts/verilog/ch4/>4. Data Types</a><a hidden class=anchor aria-hidden=true href=#4-data-typespostsverilogch4>#</a></h3><h3 id=5-expressionspostsverilogch5><a href=/posts/verilog/ch5/>5. Expressions</a><a hidden class=anchor aria-hidden=true href=#5-expressionspostsverilogch5>#</a></h3><h3 id=6-assignmentspostsverilogch6><a href=/posts/verilog/ch6/>6. Assignments</a><a hidden class=anchor aria-hidden=true href=#6-assignmentspostsverilogch6>#</a></h3><h3 id=7-gate--and-switch-level-modelingpostsverilogch7><a href=/posts/verilog/ch7/>7. Gate- and switch-level modeling</a><a hidden class=anchor aria-hidden=true href=#7-gate--and-switch-level-modelingpostsverilogch7>#</a></h3><h3 id=8-user-defined-primitivesudpspostsverilogch8><a href=/posts/verilog/ch8/>8. User-defined primitives(UDPs)</a><a hidden class=anchor aria-hidden=true href=#8-user-defined-primitivesudpspostsverilogch8>#</a></h3><h3 id=9-behavioral-modelingpostsverilogch9><a href=/posts/verilog/ch9/>9. Behavioral modeling</a><a hidden class=anchor aria-hidden=true href=#9-behavioral-modelingpostsverilogch9>#</a></h3><h3 id=10-tasks-and-functionspostsverilogch10><a href=/posts/verilog/ch10/>10. Tasks and functions</a><a hidden class=anchor aria-hidden=true href=#10-tasks-and-functionspostsverilogch10>#</a></h3><h3 id=11-scheduling-semanticspostsverilogch11><a href=/posts/verilog/ch11/>11. Scheduling semantics</a><a hidden class=anchor aria-hidden=true href=#11-scheduling-semanticspostsverilogch11>#</a></h3><h3 id=12-hierachical-structurespostsverilogch12><a href=/posts/verilog/ch12/>12. Hierachical structures</a><a hidden class=anchor aria-hidden=true href=#12-hierachical-structurespostsverilogch12>#</a></h3><h3 id=13-configuraing-the-contents-of-a-designpostsverilogch13><a href=/posts/verilog/ch13/>13. Configuraing the contents of a design</a><a hidden class=anchor aria-hidden=true href=#13-configuraing-the-contents-of-a-designpostsverilogch13>#</a></h3><h3 id=14-specify-blockspostsverilogch14><a href=/posts/verilog/ch14/>14. Specify blocks</a><a hidden class=anchor aria-hidden=true href=#14-specify-blockspostsverilogch14>#</a></h3><h3 id=15-timing-checkspostsverilogch15><a href=/posts/verilog/ch15/>15. Timing checks</a><a hidden class=anchor aria-hidden=true href=#15-timing-checkspostsverilogch15>#</a></h3><h3 id=16-backannotation-using-the-standard-delay-formatsdfpostsverilogch16><a href=/posts/verilog/ch16/>16. Backannotation using the standard delay format(SDF)</a><a hidden class=anchor aria-hidden=true href=#16-backannotation-using-the-standard-delay-formatsdfpostsverilogch16>#</a></h3><h3 id=17-system-tasks-and-functionspostsverilogch17><a href=/posts/verilog/ch17/>17. System tasks and functions</a><a hidden class=anchor aria-hidden=true href=#17-system-tasks-and-functionspostsverilogch17>#</a></h3><h3 id=18-value-change-dump-vcd-filespostsverilogch18><a href=/posts/verilog/ch18/>18. Value change dump (VCD) files</a><a hidden class=anchor aria-hidden=true href=#18-value-change-dump-vcd-filespostsverilogch18>#</a></h3><h3 id=19-compiler-directivespostsverilogch19><a href=/posts/verilog/ch19/>19. Compiler directives</a><a hidden class=anchor aria-hidden=true href=#19-compiler-directivespostsverilogch19>#</a></h3><h3 id=20-programming-language-interfacepli-overviewpostsverilogch20><a href=/posts/verilog/ch20/>20. Programming language interface(PLI) overview</a><a hidden class=anchor aria-hidden=true href=#20-programming-language-interfacepli-overviewpostsverilogch20>#</a></h3><h3 id=21-pli-tf-and-acc-interface-mechanism-deprecated>21. PLI TF and ACC interface mechanism (deprecated)<a hidden class=anchor aria-hidden=true href=#21-pli-tf-and-acc-interface-mechanism-deprecated>#</a></h3><h3 id=22-using-acc-routinesdeprecated>22. Using ACC routines(deprecated)<a hidden class=anchor aria-hidden=true href=#22-using-acc-routinesdeprecated>#</a></h3><h3 id=23-acc-routine-definitions-deprecated>23. ACC routine definitions (deprecated)<a hidden class=anchor aria-hidden=true href=#23-acc-routine-definitions-deprecated>#</a></h3><h3 id=24-using-tf-routines-deprecated>24. Using TF routines (deprecated)<a hidden class=anchor aria-hidden=true href=#24-using-tf-routines-deprecated>#</a></h3><h3 id=25-tf-routines-definitions-deprecated>25. TF routines definitions (deprecated)<a hidden class=anchor aria-hidden=true href=#25-tf-routines-definitions-deprecated>#</a></h3><h3 id=26-using-verilog-procedural-interface-vpi-routinespostsverilogch26><a href=/posts/verilog/ch26/>26. Using Verilog procedural interface (VPI) routines</a><a hidden class=anchor aria-hidden=true href=#26-using-verilog-procedural-interface-vpi-routinespostsverilogch26>#</a></h3><h3 id=27-vpi-routine-definitionspostsverilogch27><a href=/posts/verilog/ch27/>27. VPI routine definitions</a><a hidden class=anchor aria-hidden=true href=#27-vpi-routine-definitionspostsverilogch27>#</a></h3><h3 id=28-protected-envelopespostsverilogch28><a href=/posts/verilog/ch28/>28. Protected envelopes</a><a hidden class=anchor aria-hidden=true href=#28-protected-envelopespostsverilogch28>#</a></h3><h3 id=29-appendixpostsverilogch29><a href=/posts/verilog/ch29/>29. Appendix</a><a hidden class=anchor aria-hidden=true href=#29-appendixpostsverilogch29>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/vhdl/>VHDL</a></li><li><a href=http://intervalrain.github.io/tags/programming/>Programming</a></li><li><a href=http://intervalrain.github.io/tags/verilog/>Verilog</a></li></ul><nav class=paginav><a class=prev href=http://intervalrain.github.io/posts/verilog/ch1/><span class=title>« Prev Page</span><br><span>[VHDL] Overview 概述</span></a>
<a class=next href=http://intervalrain.github.io/posts/java/java_mvc/><span class=title>Next Page »</span><br><span>[Java] 淺談 Java MVC</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>