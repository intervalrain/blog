<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[VHDL] Verilog Hardware Description Language | Rain's Blog</title><meta name=keywords content="VHDL,Programming,Verilog"><meta name=description content="1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \( \boxed{\text{Full Adder}} \begin{cases} \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{OR}} \end{cases}\\ \text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件} \) 1."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.7bdb1411b29ec9fed2b6395a081eabcb3262e7311bda855249d433c8b30a926e.css integrity="sha256-e9sUEbKeyf7StjlaCB6ryzJi5zEb2oVSSdQzyLMKkm4=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="[VHDL] Verilog Hardware Description Language"><meta property="og:description" content="1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \( \boxed{\text{Full Adder}} \begin{cases} \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{OR}} \end{cases}\\ \text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件} \) 1."><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/verilog/intro/"><meta property="og:image" content="http://intervalrain.github.io/images/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-01T17:37:22+08:00"><meta property="article:modified_time" content="2022-05-01T17:37:22+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[VHDL] Verilog Hardware Description Language"><meta name=twitter:description content="1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \( \boxed{\text{Full Adder}} \begin{cases} \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{OR}} \end{cases}\\ \text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件} \) 1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[VHDL] Verilog Hardware Description Language","item":"http://intervalrain.github.io/posts/verilog/intro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[VHDL] Verilog Hardware Description Language","name":"[VHDL] Verilog Hardware Description Language","description":"1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \\( \\boxed{\\text{Full Adder}} \\begin{cases} \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{OR}} \\end{cases}\\\\ \\text{設計目標}\\qquad\\qquad\\text{子模組}\\qquad\\text{元件} \\) 1.","keywords":["VHDL","Programming","Verilog"],"articleBody":"1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \\( \\boxed{\\text{Full Adder}} \\begin{cases} \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{Half Adder}} \\begin{cases} \\boxed{\\text{XOR}}\\\\ \\boxed{\\text{AND}} \\end{cases}\\\\ \\boxed{\\text{OR}} \\end{cases}\\\\ \\text{設計目標}\\qquad\\qquad\\text{子模組}\\qquad\\text{元件} \\) 1.3 Verilog 語法詞彙 由一連串的標記(token)所組成 識別字(identifiers) 關鍵字(keywords) 字串(strings) 註解(comments) 空白(whitespace) 數值(numbers) 1.3.1 識別字(identifiers) 描述電路行為所使用的自訂物件 不違反命名規則，工程師自行定義的物件名稱 命名規則 字母、數字、底線_或是錢字號$所組合而成。 開頭只能使用字母或底線。 識別字是有大小寫之分的。 舉例 Shift_reg_b (Valid) _bus123 (Valid) $error_condition (Invalid) NT$899 (Valid) 3_bit_data (Invalid) 1.3.2 關鍵字(keywords) 描述電路語法所保留的一組特殊名稱的標記 定義語言的結構來描述電路 輸入(input)、輸出(output) 資料型態、電路行為 所有關鍵字都必須使用小寫表示 不可當作識別字使用 常見關鍵字 \\(\\begin{array}{|l|l|l|l|l|l|}\\hline \\text{always}\u0026\\text{and}\u0026\\text{assign}\u0026\\text{begin}\u0026\\text{buf}\u0026\\text{bufif0}\\\\\\hline \\text{bufif1}\u0026\\text{case}\u0026\\text{casex}\u0026\\text{casez}\u0026\\text{cmos}\u0026\\text{default}\\\\\\hline \\text{defparam}\u0026\\text{else}\u0026\\text{end}\u0026\\text{endcase}\u0026\\text{endfunction}\u0026\\text{endmodule}\\\\\\hline \\text{endtask}\u0026\\text{event}\u0026\\text{for}\u0026\\text{forever}\u0026\\text{fork}\u0026\\text{function}\\\\\\hline \\text{highz0}\u0026\\text{highz1}\u0026\\text{if}\u0026\\text{initial}\u0026\\text{inout}\u0026\\text{input}\\\\\\hline \\text{integer}\u0026\\text{join}\u0026\\text{module}\u0026\\text{nand}\u0026\\text{negedge}\u0026\\text{nmos}\\\\\\hline \\text{nor}\u0026\\text{not}\u0026\\text{notif0}\u0026\\text{notif1}\u0026\\text{or}\u0026\\text{output}\\\\\\hline \\text{parameter}\u0026\\text{pmos}\u0026\\text{posedge}\u0026\\text{pull0}\u0026\\text{pull1}\u0026\\text{pulldown}\\\\\\hline \\text{pullup}\u0026\\text{rcmos}\u0026\\text{real}\u0026\\text{realtime}\u0026\\text{reg}\u0026\\text{repeat}\\\\\\hline \\text{rnmos}\u0026\\text{rpmos}\u0026\\text{rtran}\u0026\\text{rtranif0}\u0026\\text{rtranif1}\u0026\\text{strong0}\\\\\\hline \\text{string1}\u0026\\text{supply0}\u0026\\text{supply1}\u0026\\text{task}\u0026\\text{time}\u0026\\text{tran}\\\\\\hline \\text{tranif0}\u0026\\text{tranif1}\u0026\\text{tri}\u0026\\text{tri0}\u0026\\text{tri1}\u0026\\text{triand}\\\\\\hline \\text{trior}\u0026\\text{trireg}\u0026\\text{wait}\u0026\\text{wand}\u0026\\text{weak0}\u0026\\text{weak1}\\\\\\hline \\text{while}\u0026\\text{wire}\u0026\\text{wor}\u0026\\text{xnor}\u0026\\text{xor}\\\\\\hline \\end{array}\\) 1.3.3 字串(strings) 一連串字元(character)組成的單一個體 可含有字母、數字、及一些特殊字元 字串的所有字元必須在同一行上，並在雙引號之間 1.3.4 註解(comments) 程式碼中加入說明文字 可讀性(readability) 文件化(documentation) 版權宣告(license declaration) 以//開頭的單行註解(one-line comment) 以/*為開頭，並以*/為結尾的多行註解(multiple-line comment) 多行註解不支援巢狀結構 1.3.5 空白(whitespace) 區隔不同物件 空格(blank spaces，\\b) 欄位(tabs，\\t) 換行(newlines，\\n) 除字串內空白，註解與空白在編譯與合成時會被忽略 1.3.6 數值(numbers) Verilog 有兩種數值表示法 固定長度(\u0008sized): 定義位元寬度 ' ：十進位來表示此數的位元數(bits) ：定義進制 'H|'h：十六進制 'D|'d：十進制 'O|'p：八進制 'B|'b：二進制 ：用來表示數值 若為負號，將-放在前面 舉例： 18'h47CB：18 bits 的十六進位數 47CB 13'h47CB：13 bits 的十六進位數(因未給定高位元自動補0) 7CB 12'd1023：12 bits 的十進位數 1023 9'o723：9 bits 的八進位數 723 5'b11101：5bits 的二進位數 11101 5'b1xx01：含有 unknown values 的表示法 不定長度(unsized): 未定義位元寬度 ‘","wordCount":"769","inLanguage":"en","image":"http://intervalrain.github.io/images/cover.jpg","datePublished":"2022-05-01T17:37:22+08:00","dateModified":"2022-05-01T17:37:22+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/verilog/intro/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[VHDL] Verilog Hardware Description Language</h1><div class=post-meta><span title='2022-05-01 17:37:22 +0800 +0800'>May 1, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/Verilog/intro.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-verilog-hdl aria-label="1 Verilog HDL">1 Verilog HDL</a><ul><li><a href=#11-verilog-%e7%b0%a1%e4%bb%8b aria-label="1.1 Verilog 簡介">1.1 Verilog 簡介</a></li><li><a href=#12-verilog-%e7%9a%84%e6%a8%a1%e5%9e%8b aria-label="1.2 Verilog 的模型">1.2 Verilog 的模型</a><ul><li><a href=#121-%e9%9b%bb%e6%99%b6%e9%ab%94%e5%b1%a4%e7%b4%9a aria-label="1.2.1 電晶體層級">1.2.1 電晶體層級</a></li><li><a href=#122-%e9%82%8f%e8%bc%af%e9%96%98%e5%b1%a4%e7%b4%9a aria-label="1.2.2 邏輯閘層級">1.2.2 邏輯閘層級</a></li><li><a href=#123-%e8%b3%87%e6%96%99%e6%b5%81%e5%b1%a4%e7%b4%9a aria-label="1.2.3 資料流層級">1.2.3 資料流層級</a></li><li><a href=#124-%e8%a1%8c%e7%82%ba%e6%a8%a1%e5%9e%8b aria-label="1.2.4 行為模型">1.2.4 行為模型</a></li><li><a href=#125-%e7%b5%90%e6%a7%8b%e5%bc%8f%e6%a8%a1%e5%9e%8b aria-label="1.2.5 結構式模型">1.2.5 結構式模型</a></li></ul></li><li><a href=#13-verilog-%e8%aa%9e%e6%b3%95%e8%a9%9e%e5%bd%99 aria-label="1.3 Verilog 語法詞彙">1.3 Verilog 語法詞彙</a><ul><li><a href=#131-%e8%ad%98%e5%88%a5%e5%ad%97identifiers aria-label="1.3.1 識別字(identifiers)">1.3.1 識別字(identifiers)</a></li><li><a href=#132-%e9%97%9c%e9%8d%b5%e5%ad%97keywords aria-label="1.3.2 關鍵字(keywords)">1.3.2 關鍵字(keywords)</a></li><li><a href=#133-%e5%ad%97%e4%b8%b2strings aria-label="1.3.3 字串(strings)">1.3.3 字串(strings)</a></li><li><a href=#134-%e8%a8%bb%e8%a7%a3comments aria-label="1.3.4 註解(comments)">1.3.4 註解(comments)</a></li><li><a href=#135-%e7%a9%ba%e7%99%bdwhitespace aria-label="1.3.5 空白(whitespace)">1.3.5 空白(whitespace)</a></li><li><a href=#136-%e6%95%b8%e5%80%bcnumbers aria-label="1.3.6 數值(numbers)">1.3.6 數值(numbers)</a></li></ul></li><li><a href=#14-verilog-%e8%b3%87%e6%96%99%e7%89%a9%e4%bb%b6%e8%88%87%e5%9e%8b%e6%85%8b aria-label="1.4 Verilog 資料物件與型態">1.4 Verilog 資料物件與型態</a><ul><li><a href=#141-%e6%8e%a5%e7%b7%9anets aria-label="1.4.1 接線(Nets)">1.4.1 接線(Nets)</a></li><li><a href=#142-%e6%9a%ab%e5%ad%98%e5%99%a8registers aria-label="1.4.2 暫存器(Registers)">1.4.2 暫存器(Registers)</a></li><li><a href=#143-%e7%b4%94%e9%87%8f%e8%88%87%e5%90%91%e9%87%8fscalar-and-vector aria-label="1.4.3 純量與向量(scalar and vector)">1.4.3 純量與向量(scalar and vector)</a></li><li><a href=#144-%e9%99%a3%e5%88%97array aria-label="1.4.4 陣列(Array)">1.4.4 陣列(Array)</a></li></ul></li><li><a href=#145-%e5%8f%83%e6%95%b8parameter aria-label="1.4.5 參數(parameter)">1.4.5 參數(parameter)</a></li><li><a href=#15-%e6%a8%a1%e7%b5%84module%e5%9f%a0port aria-label="1.5 模組(Module)、埠(Port)">1.5 模組(Module)、埠(Port)</a><ul><li><a href=#151-%e6%a8%a1%e7%b5%84module aria-label="1.5.1 模組(Module)">1.5.1 模組(Module)</a></li><li><a href=#152-%e5%9f%a0port aria-label="1.5.2 埠(port)">1.5.2 埠(port)</a></li></ul></li><li><a href=#16-%e9%82%8f%e8%bc%af%e9%96%98%e5%b1%a4%e6%ac%a1%e6%a8%a1%e5%9e%8b aria-label="1.6 邏輯閘層次模型">1.6 邏輯閘層次模型</a><ul><li><a href=#161-%e5%a4%9a%e5%80%8b%e8%bc%b8%e5%85%a5%e9%82%8f%e8%bc%af%e9%96%98multiple-input-gates aria-label="1.6.1 多個輸入邏輯閘(Multiple-Input Gates)">1.6.1 多個輸入邏輯閘(Multiple-Input Gates)</a></li><li><a href=#162-%e5%a4%9a%e5%80%8b%e8%bc%b8%e5%87%ba%e9%82%8f%e8%bc%af%e9%96%98multiple-output-gates aria-label="1.6.2 多個輸出邏輯閘(Multiple-Output Gates)">1.6.2 多個輸出邏輯閘(Multiple-Output Gates)</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=1-verilog-hdl>1 Verilog HDL<a hidden class=anchor aria-hidden=true href=#1-verilog-hdl>#</a></h1><h2 id=11-verilog-簡介>1.1 Verilog 簡介<a hidden class=anchor aria-hidden=true href=#11-verilog-簡介>#</a></h2><ul><li>一套硬體描述語言<ul><li>輔助設計<strong>數位系統</strong></li><li>描述電路的行為</li><li>電子自動化工具</li></ul></li><li>類似C語言的硬體描述語言<ul><li>易學、容易接受</li><li>高階行為描述</li><li>切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的)</li></ul></li><li>支援多種硬體層級的描述方式<ul><li>從低階到高階模式</li><li>依照不同的方法設計</li></ul></li><li>支援階層式的設計方法<ul><li>樹狀式的設計結構</li><li>由繁化簡</li></ul></li></ul><h2 id=12-verilog-的模型>1.2 Verilog 的模型<a hidden class=anchor aria-hidden=true href=#12-verilog-的模型>#</a></h2><h3 id=121-電晶體層級>1.2.1 電晶體層級<a hidden class=anchor aria-hidden=true href=#121-電晶體層級>#</a></h3><ul><li>Transistor Level</li><li>或低階交換層次模型(Switch Level Model)</li><li>Verilog 最低階的層次模型</li><li>電路是由開關與電晶體所組成</li><li>一般不會採取低階的層級來進行設計</li></ul><h3 id=122-邏輯閘層級>1.2.2 邏輯閘層級<a hidden class=anchor aria-hidden=true href=#122-邏輯閘層級>#</a></h3><ul><li>Gate Level</li><li>使用基本的邏輯閘元件</li><li>AND、OR、NOT</li><li>邏輯電路圖</li></ul><h3 id=123-資料流層級>1.2.3 資料流層級<a hidden class=anchor aria-hidden=true href=#123-資料流層級>#</a></h3><ul><li>Data Flow Level</li><li>描述電路中資料的處理方式</li><li>資料如何在電路中運算及傳送</li><li>輸入持續驅動輸出</li><li>運算式<ul><li>如：<code>out = a + b + c</code></li></ul></li></ul><h3 id=124-行為模型>1.2.4 行為模型<a hidden class=anchor aria-hidden=true href=#124-行為模型>#</a></h3><ul><li>Behavior Level</li><li>Verilog 最高階的層次模型</li><li>不需考慮硬體元件的特型，只需放在模組的功能描述</li><li>很像 C 語言</li><li>合成軟體工具</li></ul><h3 id=125-結構式模型>1.2.5 結構式模型<a hidden class=anchor aria-hidden=true href=#125-結構式模型>#</a></h3><ul><li>Structure Level</li><li>引用硬體模組的模式</li><li>類似邏輯閘層次模型</li><li>支援階層式設計法<ul><li>將複雜電路分為層狀結構</li><li>架構上類似樹狀結構<ul><li>Bottom-up：元件→子模組→設計目標</li><li>Top-Down：設計目標→子模組→元件</li><li>Mixed：設計目標→子模組←元件(常用於大型複雜系統)<ul><li>\(
\boxed{\text{Full Adder}}
\begin{cases}
\boxed{\text{Half Adder}}
\begin{cases}
\boxed{\text{XOR}}\\
\boxed{\text{AND}}
\end{cases}\\
\boxed{\text{Half Adder}}
\begin{cases}
\boxed{\text{XOR}}\\
\boxed{\text{AND}}
\end{cases}\\
\boxed{\text{OR}}
\end{cases}\\
\text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件}
\)</li></ul></li></ul></li></ul></li></ul><h2 id=13-verilog-語法詞彙>1.3 Verilog 語法詞彙<a hidden class=anchor aria-hidden=true href=#13-verilog-語法詞彙>#</a></h2><ul><li>由一連串的標記(token)所組成<ul><li>識別字(identifiers)</li><li>關鍵字(keywords)</li><li>字串(strings)</li><li>註解(comments)</li><li>空白(whitespace)</li><li>數值(numbers)</li></ul></li></ul><h3 id=131-識別字identifiers>1.3.1 識別字(identifiers)<a hidden class=anchor aria-hidden=true href=#131-識別字identifiers>#</a></h3><ul><li>描述電路行為所使用的自訂物件<ul><li>不違反命名規則，工程師自行定義的物件名稱</li></ul></li><li>命名規則<ul><li>字母、數字、底線<code>_</code>或是錢字號<code>$</code>所組合而成。</li><li>開頭只能使用字母或底線。</li><li>識別字是有<strong>大小寫</strong>之分的。</li></ul></li><li>舉例<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Shift_reg_b         (Valid)
</span></span><span style=display:flex><span>_bus123             (Valid)
</span></span><span style=display:flex><span>$error_condition    (Invalid)
</span></span><span style=display:flex><span>NT$899              (Valid)
</span></span><span style=display:flex><span>3_bit_data          (Invalid)
</span></span></code></pre></div></li></ul><h3 id=132-關鍵字keywords>1.3.2 關鍵字(keywords)<a hidden class=anchor aria-hidden=true href=#132-關鍵字keywords>#</a></h3><ul><li>描述電路語法所保留的一組特殊名稱的標記</li><li>定義語言的結構來描述電路<ul><li>輸入(input)、輸出(output)</li><li>資料型態、電路行為</li></ul></li><li>所有關鍵字都必須使用小寫表示</li><li>不可當作識別字使用</li><li>常見關鍵字
\(\begin{array}{|l|l|l|l|l|l|}\hline
\text{always}&\text{and}&\text{assign}&\text{begin}&\text{buf}&\text{bufif0}\\\hline
\text{bufif1}&\text{case}&\text{casex}&\text{casez}&\text{cmos}&\text{default}\\\hline
\text{defparam}&\text{else}&\text{end}&\text{endcase}&\text{endfunction}&\text{endmodule}\\\hline
\text{endtask}&\text{event}&\text{for}&\text{forever}&\text{fork}&\text{function}\\\hline
\text{highz0}&\text{highz1}&\text{if}&\text{initial}&\text{inout}&\text{input}\\\hline
\text{integer}&\text{join}&\text{module}&\text{nand}&\text{negedge}&\text{nmos}\\\hline
\text{nor}&\text{not}&\text{notif0}&\text{notif1}&\text{or}&\text{output}\\\hline
\text{parameter}&\text{pmos}&\text{posedge}&\text{pull0}&\text{pull1}&\text{pulldown}\\\hline
\text{pullup}&\text{rcmos}&\text{real}&\text{realtime}&\text{reg}&\text{repeat}\\\hline
\text{rnmos}&\text{rpmos}&\text{rtran}&\text{rtranif0}&\text{rtranif1}&\text{strong0}\\\hline
\text{string1}&\text{supply0}&\text{supply1}&\text{task}&\text{time}&\text{tran}\\\hline
\text{tranif0}&\text{tranif1}&\text{tri}&\text{tri0}&\text{tri1}&\text{triand}\\\hline
\text{trior}&\text{trireg}&\text{wait}&\text{wand}&\text{weak0}&\text{weak1}\\\hline
\text{while}&\text{wire}&\text{wor}&\text{xnor}&\text{xor}\\\hline
\end{array}\)</li></ul><h3 id=133-字串strings>1.3.3 字串(strings)<a hidden class=anchor aria-hidden=true href=#133-字串strings>#</a></h3><ul><li>一連串字元(character)組成的單一個體</li><li>可含有字母、數字、及一些特殊字元</li><li>字串的所有字元必須在同一行上，並在<strong>雙引號</strong>之間</li></ul><h3 id=134-註解comments>1.3.4 註解(comments)<a hidden class=anchor aria-hidden=true href=#134-註解comments>#</a></h3><ul><li>程式碼中加入說明文字<ul><li>可讀性(readability)</li><li>文件化(documentation)</li><li>版權宣告(license declaration)</li></ul></li><li>以<code>//</code>開頭的單行註解(one-line comment)</li><li>以<code>/*</code>為開頭，並以<code>*/</code>為結尾的多行註解(multiple-line comment)</li><li>多行註解不支援巢狀結構</li></ul><h3 id=135-空白whitespace>1.3.5 空白(whitespace)<a hidden class=anchor aria-hidden=true href=#135-空白whitespace>#</a></h3><ul><li>區隔不同物件</li><li>空格(blank spaces，\b)</li><li>欄位(tabs，\t)</li><li>換行(newlines，\n)</li><li>除字串內空白，註解與空白在編譯與合成時會被忽略</li></ul><h3 id=136-數值numbers>1.3.6 數值(numbers)<a hidden class=anchor aria-hidden=true href=#136-數值numbers>#</a></h3><ul><li>Verilog 有兩種數值表示法<ul><li>固定長度(sized): 定義位元寬度<ul><li><code>&lt;size>'&lt;bsase format>&lt;number></code><ul><li><code>&lt;size></code>：十進位來表示此數的位元數(bits)</li><li><code>&lt;base format></code>：定義進制<ul><li><code>'H</code>|<code>'h</code>：十六進制</li><li><code>'D</code>|<code>'d</code>：十進制</li><li><code>'O</code>|<code>'p</code>：八進制</li><li><code>'B</code>|<code>'b</code>：二進制</li></ul></li><li><code>&lt;number></code>：用<code>&lt;base format></code>來表示數值</li><li>若為負號，將<code>-</code>放在<code>&lt;size></code>前面</li></ul></li><li>舉例：<ul><li><code>18'h47CB</code>：18 bits 的十六進位數 47CB</li><li><code>13'h47CB</code>：13 bits 的十六進位數(因未給定高位元自動補0) 7CB</li><li><code>12'd1023</code>：12 bits 的十進位數 1023</li><li><code>9'o723</code>：9 bits 的八進位數 723</li><li><code>5'b11101</code>：5bits 的二進位數 11101</li><li><code>5'b1xx01</code>：含有 unknown values 的表示法</li></ul></li></ul></li><li>不定長度(unsized): 未定義位元寬度<ul><li>&lsquo;<code>&lt;base format>&lt;number</code><ul><li>不使用<code>&lt;size></code>規定位元長度</li><li>使用 HDL 編譯器內定的長度(32bit的寬度)</li><li>沒有寫明<code>&lt;base format></code>，則<strong>內定為十進制</strong></li></ul></li><li>舉例：<ul><li><code>'h47CB</code>：32 bits 的十六進位數 47CB</li><li><code>1023</code>：32 bits 的十進位數 1023</li><li><code>'o723</code>：32 bits 的八進位數 723</li><li><code>'b11101</code>：32 bits 的二進位數 11101</li></ul></li></ul></li></ul></li><li>Verilog 有四種數值位準(value level)<ul><li>\(\begin{array}{|c|l|}\hline
\text{數值位準}&\text{實際電路狀態}\\\hline
\text{0}&\text{邏輯0，假(false)，接地}\\\hline
\text{1}&\text{邏輯1，真(true)，接壓電源}\\\hline
\text{x}&\text{不確定值(unknown value)}\\\hline
\text{z}&\text{高阻抗(high impedance)，浮接狀態(floating state)}\\\hline
\end{array}
\)</li></ul></li></ul><h2 id=14-verilog-資料物件與型態>1.4 Verilog 資料物件與型態<a hidden class=anchor aria-hidden=true href=#14-verilog-資料物件與型態>#</a></h2><ul><li>資料物件(data objects)<ul><li>描述行為過程中所使用的訊號載具</li><li>一個物件經過處理再傳到另一個物件</li></ul></li><li>資料型態(data type)<ul><li>定義資料物件的類型</li><li>接線、暫存器、參數等</li></ul></li></ul><h3 id=141-接線nets>1.4.1 接線(Nets)<a hidden class=anchor aria-hidden=true href=#141-接線nets>#</a></h3><ul><li>接線(nets)是連接實體元件的連接線</li><li>要被驅動才能改變其內部的值</li><li>最主要的關鍵字是 <code>wire</code><ul><li>一個位元的純量(scalar)</li><li>多位元長度的向量(vector)</li><li>內定值為 <code>z</code>(高阻抗、浮接)</li></ul></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>wire</span> w;         <span style=color:#75715e>// 宣告一條接線，命名為w，內定預設值為z
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>wire</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>;  <span style=color:#75715e>// 宣告一條接線，命名為x，並指定x為邏輯0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>wire</span> a, b, c    <span style=color:#75715e>// 宣告三條接線，命名為a, b, c
</span></span></span></code></pre></div></li></ul><h3 id=142-暫存器registers>1.4.2 暫存器(Registers)<a hidden class=anchor aria-hidden=true href=#142-暫存器registers>#</a></h3><ul><li>抽象的資料儲存物件(有別於實體暫存器 D flip-flop)</li><li>保留一個數值直到下一次指定新值為止</li><li>觀念類似 C 語言中的變數</li><li>主要的關鍵字是 <code>reg</code><ul><li>一個位元的純量(scalar)</li><li>多位元長度的向量(vector)</li><li>內定值為 <code>x</code>(未知)</li></ul></li><li>\(\begin{array}{|l|l|}\hline
\text{reg}&\text{可變動位元寬度的無號整數(unsigned integer variable)}\\\hline
\text{integer}&\text{32位元寬度的有號整數(signed 32-bit integer variable)，}\\
&\text{算術運算產生2補數結果(2&rsquo;s complement results))}\\\hline
\text{real}&\text{雙倍精確度之有號浮點數}\\
&\text{(signed floating-point variable with double precision)}\\\hline
\text{time}&\text{64位元寬度的無號整數(unsigned 64-bit integer variable)}\\\hline
\end{array}\)<ul><li>設計電路請以<code>reg</code>為主，其他類型合成器可能不支援。</li></ul></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>reg</span> a;          <span style=color:#75715e>// 宣告 1 個 1 位元暫存器為 a，定位值為 1 位元的 x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> x, y;       <span style=color:#75715e>// 宣告 2 個宣存器，命名為 x, y
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>integer</span> count;  <span style=color:#75715e>// 宣告 1 個整數為 count，值可以為正負
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>real</span> fraction;  <span style=color:#75715e>// 宣告 1 個浮點數為 fraction，值含小數點
</span></span></span></code></pre></div></li></ul><h3 id=143-純量與向量scalar-and-vector>1.4.3 純量與向量(scalar and vector)<a hidden class=anchor aria-hidden=true href=#143-純量與向量scalar-and-vector>#</a></h3><ul><li>純量(scalar)<ul><li>一個位元的物件</li></ul></li><li>向量(vector)<ul><li>多個位元的物件</li></ul></li><li>接線(ex. wire) 與 reg<ul><li>內定一位元</li><li><code>[大數字:小數字]</code>、<code>[小數字:大數字]</code>→<code>[MSB:LSB]</code></li></ul></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>wire</span> a;         <span style=color:#75715e>// 宣告 1 個 1-bits 接線
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] x;   <span style=color:#75715e>// 宣告 1 個 5-bits 接線
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> b;          <span style=color:#75715e>// 宣告 1 個 1-bits 暫存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>0</span><span style=color:#f92672>:</span><span style=color:#ae81ff>7</span>] y;    <span style=color:#75715e>// 宣告 1 個 8-bits 暫存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] z;   <span style=color:#75715e>// 宣告 1 個 32-bits 暫存器
</span></span></span></code></pre></div></li></ul><h3 id=144-陣列array>1.4.4 陣列(Array)<a hidden class=anchor aria-hidden=true href=#144-陣列array>#</a></h3><ul><li>多個暫存器、接線的聚合體</li><li>索引值(index)定義聚合體中的個別物件</li><li>支援多維度的陣列</li><li>記憶體(memory)、暫存器檔案(register file)</li><li>陣列中暫存器、接線的個數<ul><li><code>[大數字:小數字]</code>、<code>[小數字:大數字]</code></li></ul></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#75715e>// mem_block 是一個包含 128 個暫存器的陣列，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 每個暫存器皆為 32 位元寬
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] mem_block [<span style=color:#ae81ff>127</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span><span style=color:#75715e>// mem_2D 是一個 2 維 4x64 的暫存器陣列，
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 每個暫存器皆為 8 位元寬
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] mem_2D [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>63</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span></code></pre></div></li></ul><h2 id=145-參數parameter>1.4.5 參數(parameter)<a hidden class=anchor aria-hidden=true href=#145-參數parameter>#</a></h2><ul><li>定義編譯合成電路時的常數</li><li>每次編譯合成前更改，編譯合成器會根據參數值產生相對應的電路</li><li>重複使用</li><li>關鍵字 <code>parameter</code></li><li>宣告方式<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>parameter</span> width <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>wire</span> [width<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b;  <span style=color:#75715e>// 接線 a 和 b 的位元寬度，會隨著參數值的改變而變動
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span> [width<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] y;      <span style=color:#75715e>// 暫存器 y 的位元寬度，會隨著參數值的改變而變動
</span></span></span></code></pre></div></li></ul><h2 id=15-模組module埠port>1.5 模組(Module)、埠(Port)<a hidden class=anchor aria-hidden=true href=#15-模組module埠port>#</a></h2><h3 id=151-模組module>1.5.1 模組(Module)<a hidden class=anchor aria-hidden=true href=#151-模組module>#</a></h3><ul><li>一個電路區塊、可以由其他模組組成</li><li>連接模組時<ul><li>考慮模組的輸入與輸出介面</li><li>不需要考慮模組內部的詳細電路</li></ul></li><li>電路設計時<ul><li>只修改模組內部電路</li><li>不會改變電路外部及周遭的模組</li></ul></li><li>模組內部的電路描述可包含<ul><li>訊號資料型態宣告</li><li>引用其他模組(邏輯閘)</li><li><code>assign</code> 資料處理模型之描述</li><li><code>always</code> 行為模型之描述</li><li><strong>函數(function)</strong> 與 <strong>任務(task)</strong></li><li>除訊號宣告需先描述，其他部分撰寫的順序，不影響電路行為</li></ul></li><li>模組宣告<ul><li>以關鍵字 <code>module</code> 為開頭，在其後加一個識別用的模組名稱(module name)</li><li>再來是<strong>輸入與輸出埠列</strong>(module terminal list)和埠列宣告，接著是模組內部關於電路的描述</li><li>以關鍵字 <code>endmodule</code> 做為模組結尾</li><li>支援階層`式的設計概念</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> module_name(terminal_list)
</span></span><span style=display:flex><span>port_declaration(...)
</span></span><span style=display:flex><span>param_declaration(optional)
</span></span><span style=display:flex><span>data_type_declaration(<span style=color:#66d9ef>wire</span>, <span style=color:#66d9ef>reg</span>)
</span></span><span style=display:flex><span>other_module(logic_gate)
</span></span><span style=display:flex><span><span style=color:#66d9ef>assign</span> data_flow_model
</span></span><span style=display:flex><span><span style=color:#66d9ef>always</span> behavior_model
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span>, <span style=color:#66d9ef>task</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div></li></ul><h3 id=152-埠port>1.5.2 埠(port)<a hidden class=anchor aria-hidden=true href=#152-埠port>#</a></h3><ul><li>終端點、模組與外界溝通的介面接點(門)</li><li>一個模組通常是經由一串的輸入輸出埠稱為埠列(terminal list)來與外界溝通</li><li>若模組與外界不需要溝通，則埠列也就不存在(封閉系統)<ul><li>測試環境(test bench)</li></ul></li><li>埠的宣告<ul><li>埠的宣告可分為輸入埠(input)、輸出埠(output)、雙向埠(inout)三種。</li><li>埠的宣告型態內定為接線(net)的 <code>wire</code>，若需要將訊號儲存起來則埠號型態須宣告成暫存器 <code>reg</code>。</li><li>輸入埠和雙向埠只能是接線(net)，<strong>不可宣告成暫存器</strong>。</li><li>輸出埠可以宣告成接線(net)或暫存器。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> full_adder(a, b, carry, sum);    <span style=color:#75715e>// 埠列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>input</span>  [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b;                      <span style=color:#75715e>// 輸入埠(4位元向量)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>input</span>  carry                            <span style=color:#75715e>// 輸入埠(1位元純量)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum;                       <span style=color:#75715e>// 輸出埠(5位元向量)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>reg</span>    [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum;                       <span style=color:#75715e>// 因輸出sum需儲存資料，故宣告成暫存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div></li></ul><h2 id=16-邏輯閘層次模型>1.6 邏輯閘層次模型<a hidden class=anchor aria-hidden=true href=#16-邏輯閘層次模型>#</a></h2><ul><li>利用關鍵字即可引用基本的邏輯閘元件</li><li>基本的邏輯閘關鍵字<ul><li><code>and</code></li><li><code>nand</code></li><li><code>or</code></li><li><code>nor</code></li><li><code>not</code></li><li><code>xor</code></li><li><code>xnor</code></li></ul></li></ul><h3 id=161-多個輸入邏輯閘multiple-input-gates>1.6.1 多個輸入邏輯閘(Multiple-Input Gates)<a hidden class=anchor aria-hidden=true href=#161-多個輸入邏輯閘multiple-input-gates>#</a></h3><ul><li><code>and</code>、<code>nand</code>、<code>or</code>、<code>nor</code>、<code>xor</code>、<code>xnor</code></li><li>具有多個純量(scalar)的輸入，但是只有一個純量的輸出</li><li><strong>多個輸入邏輯閘的輸出總是放在埠列(post list)的第一個位置，而輸入則是跟在輸出的後面</strong>
輸出必須透過接線(wire)連接，輸入無規定</li><li>多個輸入邏輯閘的別名可以加或是不加</li><li>使用方法<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span>gate_type instance(out, in_1, in_2, in_3, ..., in_n);
</span></span><span style=display:flex><span>gate_type inst_1(out_1, in1_1, in1_2, in1_3, ..., in1_n),
</span></span><span style=display:flex><span>          inst_2(out_2, in2_1, in2_2, in2_3, ..., in2_n),
</span></span><span style=display:flex><span>          inst_3(out_3, in3_1, in3_2, in3_3, ..., in3_n),
</span></span><span style=display:flex><span>          ...
</span></span><span style=display:flex><span>          inst_m(out_m, in_m1, in_m2, in_m3, ..., in_mn);
</span></span></code></pre></div></li><li>\(\begin{array}{ccc}
\underbrace{\text{a, b, c, d}}_{\text{輸入}}
\rightarrow
\boxed{\text{Multiple-Input Gate}}
\rightarrow
\underbrace{\text{e}} _{\text{輸出}}
\end{array}
\)</li><li>\(\text{and\quad a1(}
\underbrace{\text{e}}_{\text{輸出}}
\text{, }
\underbrace{\text{a, b, c, d}} _{\text{輸入}}
\text{);}
\)</li></ul><h3 id=162-多個輸出邏輯閘multiple-output-gates>1.6.2 多個輸出邏輯閘(Multiple-Output Gates)<a hidden class=anchor aria-hidden=true href=#162-多個輸出邏輯閘multiple-output-gates>#</a></h3><ul><li><p><code>not</code>、<code>buf</code></p></li><li><p>具有一個或是多個純量(scalar)的輸出，但是只有一個純量的輸入</p></li><li><p><strong>多個輸出邏輯閘的輸出是放在埠列(port list)的前面位置，而輸入則是放在列後面位置</strong></p><ul><li>輸出必須透過接線(wire)連接，輸入無規定</li></ul></li><li><p>多個輸出邏輯閘的別名可以加或是不加</p></li><li><p>使用方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span>gate_type instance(out_1, out_2, out_3, ..., out_n, in);
</span></span><span style=display:flex><span>gate_type inst_1(out1_1, out1_2, out1_3, ..., out1_n, in1),
</span></span><span style=display:flex><span>          inst_2(out2_1, out2_2, out2_3, ..., out2_n, in2),
</span></span><span style=display:flex><span>          inst_3(out3_1, out3_2, out3_3, ..., out3_n, in3),
</span></span><span style=display:flex><span>          ...
</span></span><span style=display:flex><span>          inst_m(out_m1, out_m2, out_m3, ..., out_mn, in_m);
</span></span></code></pre></div></li><li><p>\(\begin{array}{ccc}
\underbrace{\text{d}}_{\text{輸入}}
\rightarrow
\boxed{\text{Multiple-Output Gate}}
\rightarrow
\underbrace{\text{a, b, c}} _{\text{輸出}}
\end{array}
\)</p></li><li><p>\(\text{not\quad n1(}
\underbrace{\text{a, b, c}}_{\text{輸出}}
\text{, }
\underbrace{\text{d}} _{\text{輸入}}
\text{);}
\)</p></li><li><p>邏輯閘層次模型範例</p><ul><li><img loading=lazy src=/posts/Verilog/images/sample1.png alt=sample1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> and_or_gate(in1, in2, in3, in4, out;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>input</span>  in1, in2, in3, in4;
</span></span><span style=display:flex><span><span style=color:#66d9ef>output</span> out;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>wire</span>   w1, w2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>and</span> a1(w1, in1, in2);
</span></span><span style=display:flex><span><span style=color:#66d9ef>and</span> a2(w2, in3, in4);
</span></span><span style=display:flex><span><span style=color:#66d9ef>or</span>  o1(out, w1, w2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/vhdl/>VHDL</a></li><li><a href=http://intervalrain.github.io/tags/programming/>Programming</a></li><li><a href=http://intervalrain.github.io/tags/verilog/>Verilog</a></li></ul><nav class=paginav><a class=prev href=http://intervalrain.github.io/posts/device/simulationconvergece/><span class=title>« Prev Page</span><br><span>[TCAD] 模擬收斂問題</span></a>
<a class=next href=http://intervalrain.github.io/posts/java/java_mvc/><span class=title>Next Page »</span><br><span>[Java] 淺談 Java MVC</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>