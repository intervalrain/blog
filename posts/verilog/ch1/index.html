<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[VHDL] Overview 概述 | Rain's Blog</title><meta name=keywords content="VHDL,Programming,Verilog"><meta name=description content="1、概述 1.1 範圍  Verilog 是一種硬體描述語言(HDL)，它在被標準化為 IEEE Std 1364™-1995 且被第一次修訂為 IEEE Std 1364-2001。此修訂更正並澄清了在 1995 年和 2001 年版本中定義模稜兩可。而 IEEE Std 1800™-2005 解決了 IEEE 1364-2001 的不兼容和不一致的問題。 該文件的目的是作為 Verilog HDL 的完整規範。本文件包含以下：  所有 Verilog HDL 結構的形式語法和語義 標準延遲格式 (standard delay format, SDF) 結構的形式語法和語義 模擬系統任務和函式，例如文本輸出顯示命令 編譯器指令，例如文本替換巨集和仿真時間縮放 程式語言介面 (Programming language interface, PLI) 綁定機制 Verilog 程序介面 (VPI) 的形式語法和語義 使用範例 SDF 的訊息延遲模型 VPI 表頭檔    1.2 本文件中使用的約定  該文件被組織成條款(clauses)，每個條款都著重於語言的特定領域。每個條款中的子條款討論各種結構和概念。從基本介紹和構造、概念的基本原理開始，再來是語法和語義描述，最後是範例和註釋。 在本文件中，以下術語會被時常用到，對不同的讀者會帶有不帶的意義：  shall 用於表示強制性規定(mandatory requirements)。 may 用於表示非必要(optional)。   對於處理 Verilog HDL 工具的開發人員，shall 表示標準強加(standard imposes)的規定，必須實現符合此要求的結果並且在不符合規定時指定相對應的報錯。 對於 Verilog HDL 模型開發人員，shall 表示其特徵遵循 Verilog HDL 的原生定義，模型開發者需要遵守其隱含的約束。may 表示模型開發人員可以自行決定其功能，但是一旦定義了功能，則模型開發人員必須遵循其定義的法則。 對於 Verilog HDL 模型使用者， shall 表示其特徵遵循模型開發者的定義。模型使用者可以參照其模型的 VHDL 文本的規定。    1."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.7bdb1411b29ec9fed2b6395a081eabcb3262e7311bda855249d433c8b30a926e.css integrity="sha256-e9sUEbKeyf7StjlaCB6ryzJi5zEb2oVSSdQzyLMKkm4=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="[VHDL] Overview 概述"><meta property="og:description" content="1、概述 1.1 範圍  Verilog 是一種硬體描述語言(HDL)，它在被標準化為 IEEE Std 1364™-1995 且被第一次修訂為 IEEE Std 1364-2001。此修訂更正並澄清了在 1995 年和 2001 年版本中定義模稜兩可。而 IEEE Std 1800™-2005 解決了 IEEE 1364-2001 的不兼容和不一致的問題。 該文件的目的是作為 Verilog HDL 的完整規範。本文件包含以下：  所有 Verilog HDL 結構的形式語法和語義 標準延遲格式 (standard delay format, SDF) 結構的形式語法和語義 模擬系統任務和函式，例如文本輸出顯示命令 編譯器指令，例如文本替換巨集和仿真時間縮放 程式語言介面 (Programming language interface, PLI) 綁定機制 Verilog 程序介面 (VPI) 的形式語法和語義 使用範例 SDF 的訊息延遲模型 VPI 表頭檔    1.2 本文件中使用的約定  該文件被組織成條款(clauses)，每個條款都著重於語言的特定領域。每個條款中的子條款討論各種結構和概念。從基本介紹和構造、概念的基本原理開始，再來是語法和語義描述，最後是範例和註釋。 在本文件中，以下術語會被時常用到，對不同的讀者會帶有不帶的意義：  shall 用於表示強制性規定(mandatory requirements)。 may 用於表示非必要(optional)。   對於處理 Verilog HDL 工具的開發人員，shall 表示標準強加(standard imposes)的規定，必須實現符合此要求的結果並且在不符合規定時指定相對應的報錯。 對於 Verilog HDL 模型開發人員，shall 表示其特徵遵循 Verilog HDL 的原生定義，模型開發者需要遵守其隱含的約束。may 表示模型開發人員可以自行決定其功能，但是一旦定義了功能，則模型開發人員必須遵循其定義的法則。 對於 Verilog HDL 模型使用者， shall 表示其特徵遵循模型開發者的定義。模型使用者可以參照其模型的 VHDL 文本的規定。    1."><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/verilog/ch1/"><meta property="og:image" content="http://intervalrain.github.io/images/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-01T19:00:13+08:00"><meta property="article:modified_time" content="2022-05-01T19:00:13+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[VHDL] Overview 概述"><meta name=twitter:description content="1、概述 1.1 範圍  Verilog 是一種硬體描述語言(HDL)，它在被標準化為 IEEE Std 1364™-1995 且被第一次修訂為 IEEE Std 1364-2001。此修訂更正並澄清了在 1995 年和 2001 年版本中定義模稜兩可。而 IEEE Std 1800™-2005 解決了 IEEE 1364-2001 的不兼容和不一致的問題。 該文件的目的是作為 Verilog HDL 的完整規範。本文件包含以下：  所有 Verilog HDL 結構的形式語法和語義 標準延遲格式 (standard delay format, SDF) 結構的形式語法和語義 模擬系統任務和函式，例如文本輸出顯示命令 編譯器指令，例如文本替換巨集和仿真時間縮放 程式語言介面 (Programming language interface, PLI) 綁定機制 Verilog 程序介面 (VPI) 的形式語法和語義 使用範例 SDF 的訊息延遲模型 VPI 表頭檔    1.2 本文件中使用的約定  該文件被組織成條款(clauses)，每個條款都著重於語言的特定領域。每個條款中的子條款討論各種結構和概念。從基本介紹和構造、概念的基本原理開始，再來是語法和語義描述，最後是範例和註釋。 在本文件中，以下術語會被時常用到，對不同的讀者會帶有不帶的意義：  shall 用於表示強制性規定(mandatory requirements)。 may 用於表示非必要(optional)。   對於處理 Verilog HDL 工具的開發人員，shall 表示標準強加(standard imposes)的規定，必須實現符合此要求的結果並且在不符合規定時指定相對應的報錯。 對於 Verilog HDL 模型開發人員，shall 表示其特徵遵循 Verilog HDL 的原生定義，模型開發者需要遵守其隱含的約束。may 表示模型開發人員可以自行決定其功能，但是一旦定義了功能，則模型開發人員必須遵循其定義的法則。 對於 Verilog HDL 模型使用者， shall 表示其特徵遵循模型開發者的定義。模型使用者可以參照其模型的 VHDL 文本的規定。    1."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[VHDL] Overview 概述","item":"http://intervalrain.github.io/posts/verilog/ch1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[VHDL] Overview 概述","name":"[VHDL] Overview 概述","description":"1、概述 1.1 範圍  Verilog 是一種硬體描述語言(HDL)，它在被標準化為 IEEE Std 1364™-1995 且被第一次修訂為 IEEE Std 1364-2001。此修訂更正並澄清了在 1995 年和 2001 年版本中定義模稜兩可。而 IEEE Std 1800™-2005 解決了 IEEE 1364-2001 的不兼容和不一致的問題。 該文件的目的是作為 Verilog HDL 的完整規範。本文件包含以下：  所有 Verilog HDL 結構的形式語法和語義 標準延遲格式 (standard delay format, SDF) 結構的形式語法和語義 模擬系統任務和函式，例如文本輸出顯示命令 編譯器指令，例如文本替換巨集和仿真時間縮放 程式語言介面 (Programming language interface, PLI) 綁定機制 Verilog 程序介面 (VPI) 的形式語法和語義 使用範例 SDF 的訊息延遲模型 VPI 表頭檔    1.2 本文件中使用的約定  該文件被組織成條款(clauses)，每個條款都著重於語言的特定領域。每個條款中的子條款討論各種結構和概念。從基本介紹和構造、概念的基本原理開始，再來是語法和語義描述，最後是範例和註釋。 在本文件中，以下術語會被時常用到，對不同的讀者會帶有不帶的意義：  shall 用於表示強制性規定(mandatory requirements)。 may 用於表示非必要(optional)。   對於處理 Verilog HDL 工具的開發人員，shall 表示標準強加(standard imposes)的規定，必須實現符合此要求的結果並且在不符合規定時指定相對應的報錯。 對於 Verilog HDL 模型開發人員，shall 表示其特徵遵循 Verilog HDL 的原生定義，模型開發者需要遵守其隱含的約束。may 表示模型開發人員可以自行決定其功能，但是一旦定義了功能，則模型開發人員必須遵循其定義的法則。 對於 Verilog HDL 模型使用者， shall 表示其特徵遵循模型開發者的定義。模型使用者可以參照其模型的 VHDL 文本的規定。    1.","keywords":["VHDL","Programming","Verilog"],"articleBody":"1、概述 1.1 範圍  Verilog 是一種硬體描述語言(HDL)，它在被標準化為 IEEE Std 1364™-1995 且被第一次修訂為 IEEE Std 1364-2001。此修訂更正並澄清了在 1995 年和 2001 年版本中定義模稜兩可。而 IEEE Std 1800™-2005 解決了 IEEE 1364-2001 的不兼容和不一致的問題。 該文件的目的是作為 Verilog HDL 的完整規範。本文件包含以下：  所有 Verilog HDL 結構的形式語法和語義 標準延遲格式 (standard delay format, SDF) 結構的形式語法和語義 模擬系統任務和函式，例如文本輸出顯示命令 編譯器指令，例如文本替換巨集和仿真時間縮放 程式語言介面 (Programming language interface, PLI) 綁定機制 Verilog 程序介面 (VPI) 的形式語法和語義 使用範例 SDF 的訊息延遲模型 VPI 表頭檔    1.2 本文件中使用的約定  該文件被組織成條款(clauses)，每個條款都著重於語言的特定領域。每個條款中的子條款討論各種結構和概念。從基本介紹和構造、概念的基本原理開始，再來是語法和語義描述，最後是範例和註釋。 在本文件中，以下術語會被時常用到，對不同的讀者會帶有不帶的意義：  shall 用於表示強制性規定(mandatory requirements)。 may 用於表示非必要(optional)。   對於處理 Verilog HDL 工具的開發人員，shall 表示標準強加(standard imposes)的規定，必須實現符合此要求的結果並且在不符合規定時指定相對應的報錯。 對於 Verilog HDL 模型開發人員，shall 表示其特徵遵循 Verilog HDL 的原生定義，模型開發者需要遵守其隱含的約束。may 表示模型開發人員可以自行決定其功能，但是一旦定義了功能，則模型開發人員必須遵循其定義的法則。 對於 Verilog HDL 模型使用者， shall 表示其特徵遵循模型開發者的定義。模型使用者可以參照其模型的 VHDL 文本的規定。    1.3 句法描述  Verilog HDL 的形式語法使用 Backus-Naur From (BNF) 進行描述。以下為使用規範：  小寫，可包含下底線(_)，用來表示句法類別(syntactic categories)。  例：module_declaration   粗體字用於保留關鍵字、運算子和語句必要的標點符號。  例：module 、 = 、 ;   豎線(|)用來分隔多個選項，除非它以粗體顯示，粗體表示其自身為一個整個。  例：一元運算符 ::= + | - | ！ | ~ | \u0026 | 〜\u0026 | | | ~| | ^ | ~^ | ^~   方括號([])包含可選項目。  例：input_declaration ::= input [range] list_of_variables ;   大括號 ({}) 將重複的項目括起來，除非它以粗體顯示，粗體表示其自身為一個整個。該項目可能出現零次或多次；重複從左到右發生等價的左遞迴規則。因此，以下兩條規則是等價的：  list_of_param_assignments ::= param_assignment { , param_assignment } list_of_param_assignments ::= param_assignment | list_of_param_assignment, param_assignment   如果任何類別的名稱以斜體開頭，則其除去斜體的部分即為類別名稱。斜體部分旨在傳達一些語義訊息。  例：“msb_index” 和 “lsb_index” 等價於 “index”。     在正文中，斜體字表示其術語被定義，寬字體 表示範例、檔名、常數，特別是 0,1,x,z。  1.4 本文件中顏色的使用  該文件使用最少的顏色來增強可讀性。著色不是必要的，且以純黑白格式查看時，不會影響本文件的準確性。當超連結到其他參考資料時，會出現下底線。  1.5 本文件的內容 1. Overview\n2. Normative references\n3. Lexical conventions\n4. Data Types\n5. Expressions\n6. Assignments\n7. Gate- and switch-level modeling\n8. User-defined primitives(UDPs)\n9. Behavioral modeling\n10. Tasks and functions\n11. Scheduling semantics\n12. Hierachical structures\n13. Configuraing the contents of a design\n14. Specify blocks\n15. Timing checks\n16. Backannotation using the standard delay format(SDF)\n17. System tasks and functions\n18. Value change dump (VCD) files\n19. Compiler directives\n20. Programming language interface(PLI) overview\n21. PLI TF and ACC interface mechanism (deprecated)\n22. Using ACC routines(deprecated)\n23. ACC routine definitions (deprecated)\n24. Using TF routines (deprecated)\n25. TF routines definitions (deprecated)\n26. Using Verilog procedural interface (VPI) routines\n27. VPI routine definitions\n28. Protected envelopes\n29. Appendix\n1.6 棄用的條款 (Deprecated Clauses)  \u0008IEEE Std 1364-2005 棄用了該標準先前版本中包含的 Verilog PLI TF 和 ACC 例程。這些例程在 Clause 21 到 Clause 25、部分Clause 29進行了描述。這些條款和附錄的文本已從該版本的文件中刪除。這些不推薦使用的條款和附件的文本可以在 IEEE Std 1364-2001 中找到。  1.7 表頭檔列表  Clause 29 中包含的 vpi_user.h 表頭檔列表是本文件的規範部分。所有相容的軟體工具都應該使用相同的函式宣告、常量定義和結構定義。  1.8 範例  VHDL 與 C 語言的小範例會時常出現在這份文件當中，這些範例提供了豐富的訊息，它們指在說明 VHDL 的結果與 PLI 的函式用法，並非定義完整的語法。  1.9 必備條件  Clause 20、Clause 26、Clause 27、Clause 29 預先假設了 C 語言為已備知識。  ","wordCount":"334","inLanguage":"en","image":"http://intervalrain.github.io/images/cover.jpg","datePublished":"2022-05-01T19:00:13+08:00","dateModified":"2022-05-01T19:00:13+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/verilog/ch1/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[VHDL] Overview 概述</h1><div class=post-meta><span title="2022-05-01 19:00:13 +0800 +0800">May 1, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/Verilog/ch1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1%e6%a6%82%e8%bf%b0 aria-label=1、概述>1、概述</a><ul><li><a href=#11-%e7%af%84%e5%9c%8d aria-label="1.1 範圍">1.1 範圍</a></li><li><a href=#12-%e6%9c%ac%e6%96%87%e4%bb%b6%e4%b8%ad%e4%bd%bf%e7%94%a8%e7%9a%84%e7%b4%84%e5%ae%9a aria-label="1.2 本文件中使用的約定">1.2 本文件中使用的約定</a></li><li><a href=#13-%e5%8f%a5%e6%b3%95%e6%8f%8f%e8%bf%b0 aria-label="1.3 句法描述">1.3 句法描述</a></li><li><a href=#14-%e6%9c%ac%e6%96%87%e4%bb%b6%e4%b8%ad%e9%a1%8f%e8%89%b2%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label="1.4 本文件中顏色的使用">1.4 本文件中顏色的使用</a></li><li><a href=#15-%e6%9c%ac%e6%96%87%e4%bb%b6%e7%9a%84%e5%85%a7%e5%ae%b9 aria-label="1.5 本文件的內容">1.5 本文件的內容</a></li><li><a href=#16-%e6%a3%84%e7%94%a8%e7%9a%84%e6%a2%9d%e6%ac%be-deprecated-clauses aria-label="1.6 棄用的條款 (Deprecated Clauses)">1.6 棄用的條款 (Deprecated Clauses)</a></li><li><a href=#17-%e8%a1%a8%e9%a0%ad%e6%aa%94%e5%88%97%e8%a1%a8 aria-label="1.7 表頭檔列表">1.7 表頭檔列表</a></li><li><a href=#18-%e7%af%84%e4%be%8b aria-label="1.8 範例">1.8 範例</a></li><li><a href=#19-%e5%bf%85%e5%82%99%e6%a2%9d%e4%bb%b6 aria-label="1.9 必備條件">1.9 必備條件</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=1概述>1、概述<a hidden class=anchor aria-hidden=true href=#1概述>#</a></h1><h2 id=11-範圍>1.1 範圍<a hidden class=anchor aria-hidden=true href=#11-範圍>#</a></h2><ul><li>Verilog 是一種硬體描述語言(HDL)，它在被標準化為 IEEE Std 1364™-1995 且被第一次修訂為 IEEE Std 1364-2001。此修訂更正並澄清了在
1995 年和 2001 年版本中定義模稜兩可。而 IEEE Std 1800™-2005 解決了 IEEE 1364-2001 的不兼容和不一致的問題。</li><li>該文件的目的是作為 Verilog HDL 的完整規範。本文件包含以下：<ul><li>所有 Verilog HDL 結構的形式語法和語義</li><li>標準延遲格式 (standard delay format, SDF) 結構的形式語法和語義</li><li>模擬系統任務和函式，例如文本輸出顯示命令</li><li>編譯器指令，例如文本替換巨集和仿真時間縮放</li><li>程式語言介面 (Programming language interface, PLI) 綁定機制</li><li>Verilog 程序介面 (VPI) 的形式語法和語義</li><li>使用範例</li><li>SDF 的訊息延遲模型</li><li>VPI 表頭檔</li></ul></li></ul><h2 id=12-本文件中使用的約定>1.2 本文件中使用的約定<a hidden class=anchor aria-hidden=true href=#12-本文件中使用的約定>#</a></h2><ul><li>該文件被組織成條款(clauses)，每個條款都著重於語言的特定領域。每個條款中的子條款討論各種結構和概念。從基本介紹和構造、概念的基本原理開始，再來是語法和語義描述，最後是範例和註釋。</li><li>在本文件中，以下術語會被時常用到，對不同的讀者會帶有不帶的意義：<ul><li><em><strong>shall</strong></em> 用於表示<strong>強制性規定(mandatory requirements)</strong>。</li><li><em><strong>may</strong></em> 用於表示<strong>非必要(optional)</strong>。</li></ul><ol><li>對於處理 Verilog HDL 工具的開發人員，<em><strong>shall</strong></em> 表示標準強加(standard imposes)的規定，必須實現符合此要求的結果並且在不符合規定時指定相對應的報錯。</li><li>對於 Verilog HDL 模型開發人員，<em><strong>shall</strong></em> 表示其特徵遵循 Verilog HDL 的原生定義，模型開發者需要遵守其隱含的約束。<em><strong>may</strong></em> 表示模型開發人員可以自行決定其功能，但是一旦定義了功能，則模型開發人員必須遵循其定義的法則。</li><li>對於 Verilog HDL 模型使用者， <em><strong>shall</strong></em> 表示其特徵遵循模型開發者的定義。模型使用者可以參照其模型的 VHDL 文本的規定。</li></ol></li></ul><h2 id=13-句法描述>1.3 句法描述<a hidden class=anchor aria-hidden=true href=#13-句法描述>#</a></h2><ul><li>Verilog HDL 的形式語法使用 Backus-Naur From (BNF) 進行描述。以下為使用規範：<ul><li>小寫，可包含下底線(_)，用來表示句法類別(syntactic categories)。<ul><li>例：<code>module_declaration</code></li></ul></li><li>粗體字用於保留關鍵字、運算子和語句必要的標點符號。<ul><li>例：<code>module</code> 、 <code>=></code> 、 <code>;</code></li></ul></li><li>豎線(<code>|</code>)用來分隔多個選項，除非它以粗體顯示，粗體表示其自身為一個整個。<ul><li>例：一元運算符 ::= + | - | ！ | ~ | & | <strong>〜&</strong> | | | <strong>~|</strong> | ^ | <strong>~^</strong> | <strong>^~</strong></li></ul></li><li>方括號(<code>[]</code>)包含可選項目。<ul><li>例：<code>input_declaration ::= input [range] list_of_variables ;</code></li></ul></li><li>大括號 ({}) 將重複的項目括起來，除非它以粗體顯示，粗體表示其自身為一個整個。該項目可能出現零次或多次；重複從左到右發生等價的左遞迴規則。因此，以下兩條規則是等價的：<ul><li><code>list_of_param_assignments ::= param_assignment { , param_assignment }</code></li><li><code>list_of_param_assignments ::= param_assignment | list_of_param_assignment, param_assignment</code></li></ul></li><li>如果任何類別的名稱以斜體開頭，則其除去斜體的部分即為類別名稱。斜體部分旨在傳達一些語義訊息。<ul><li>例：“<em>msb</em>_index” 和 “<em>lsb</em>_index” 等價於 “index”。</li></ul></li></ul></li><li>在正文中，<em>斜體字</em>表示其術語被定義，<code>寬字體</code> 表示範例、檔名、常數，特別是 <code>0</code>,<code>1</code>,<code>x</code>,<code>z</code>。</li></ul><h2 id=14-本文件中顏色的使用>1.4 本文件中顏色的使用<a hidden class=anchor aria-hidden=true href=#14-本文件中顏色的使用>#</a></h2><ul><li>該文件使用最少的顏色來增強可讀性。著色不是必要的，且以純黑白格式查看時，不會影響本文件的準確性。當超連結到其他參考資料時，會出現下底線。</li></ul><h2 id=15-本文件的內容>1.5 本文件的內容<a hidden class=anchor aria-hidden=true href=#15-本文件的內容>#</a></h2><p><a href=/posts/verilog/ch1/>1. Overview</a><br><a href=/posts/verilog/ch2/>2. Normative references</a><br><a href=/posts/verilog/ch3/>3. Lexical conventions</a><br><a href=/posts/verilog/ch4/>4. Data Types</a><br><a href=/posts/verilog/ch5/>5. Expressions</a><br><a href=/posts/verilog/ch6/>6. Assignments</a><br><a href=/posts/verilog/ch7/>7. Gate- and switch-level modeling</a><br><a href=/posts/verilog/ch8/>8. User-defined primitives(UDPs)</a><br><a href=/posts/verilog/ch9/>9. Behavioral modeling</a><br><a href=/posts/verilog/ch10/>10. Tasks and functions</a><br><a href=/posts/verilog/ch11/>11. Scheduling semantics</a><br><a href=/posts/verilog/ch12/>12. Hierachical structures</a><br><a href=/posts/verilog/ch13/>13. Configuraing the contents of a design</a><br><a href=/posts/verilog/ch14/>14. Specify blocks</a><br><a href=/posts/verilog/ch15/>15. Timing checks</a><br><a href=/posts/verilog/ch16/>16. Backannotation using the standard delay format(SDF)</a><br><a href=/posts/verilog/ch17/>17. System tasks and functions</a><br><a href=/posts/verilog/ch18/>18. Value change dump (VCD) files</a><br><a href=/posts/verilog/ch19/>19. Compiler directives</a><br><a href=/posts/verilog/ch20/>20. Programming language interface(PLI) overview</a><br>21. PLI TF and ACC interface mechanism (deprecated)<br>22. Using ACC routines(deprecated)<br>23. ACC routine definitions (deprecated)<br>24. Using TF routines (deprecated)<br>25. TF routines definitions (deprecated)<br><a href=/posts/verilog/ch26/>26. Using Verilog procedural interface (VPI) routines</a><br><a href=/posts/verilog/ch27/>27. VPI routine definitions</a><br><a href=/posts/verilog/ch28/>28. Protected envelopes</a><br><a href=/posts/verilog/ch29/>29. Appendix</a></p><h2 id=16-棄用的條款-deprecated-clauses>1.6 棄用的條款 (Deprecated Clauses)<a hidden class=anchor aria-hidden=true href=#16-棄用的條款-deprecated-clauses>#</a></h2><ul><li>IEEE Std 1364-2005 棄用了該標準先前版本中包含的 Verilog PLI TF 和 ACC 例程。這些例程在 Clause 21 到 Clause 25、部分<a href=/posts/verilog/ch29/>Clause 29</a>進行了描述。這些條款和附錄的文本已從該版本的文件中刪除。這些不推薦使用的條款和附件的文本可以在 IEEE Std 1364-2001 中找到。</li></ul><h2 id=17-表頭檔列表>1.7 表頭檔列表<a hidden class=anchor aria-hidden=true href=#17-表頭檔列表>#</a></h2><ul><li><a href=/posts/verilog/ch29/>Clause 29</a> 中包含的 <code>vpi_user.h</code> 表頭檔列表是本文件的規範部分。所有相容的軟體工具都應該使用相同的函式宣告、常量定義和結構定義。</li></ul><h2 id=18-範例>1.8 範例<a hidden class=anchor aria-hidden=true href=#18-範例>#</a></h2><ul><li>VHDL 與 C 語言的小範例會時常出現在這份文件當中，這些範例提供了豐富的訊息，它們指在說明 VHDL 的結果與 PLI 的函式用法，並非定義完整的語法。</li></ul><h2 id=19-必備條件>1.9 必備條件<a hidden class=anchor aria-hidden=true href=#19-必備條件>#</a></h2><ul><li><a href=/posts/verilog/ch20/>Clause 20</a>、<a href=/posts/verilog/ch26/>Clause 26</a>、<a href=/posts/verilog/ch27/>Clause 27</a>、<a href=/posts/verilog/ch29/>Clause 29</a> 預先假設了 C 語言為已備知識。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/vhdl/>VHDL</a></li><li><a href=http://intervalrain.github.io/tags/programming/>Programming</a></li><li><a href=http://intervalrain.github.io/tags/verilog/>Verilog</a></li></ul><nav class=paginav><a class=next href=http://intervalrain.github.io/posts/verilog/ch0/><span class=title>Next Page »</span><br><span>[VHDL] IEEE 標準硬體描述語言</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>