<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[VHDL] HDLbits | Rain's Blog</title><meta name=keywords content="VHDL,Programming,Verilog"><meta name=description content="Verilog tutorial"><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.7bdb1411b29ec9fed2b6395a081eabcb3262e7311bda855249d433c8b30a926e.css integrity="sha256-e9sUEbKeyf7StjlaCB6ryzJi5zEb2oVSSdQzyLMKkm4=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="[VHDL] HDLbits"><meta property="og:description" content="Verilog tutorial"><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/verilog/hdlbits/"><meta property="og:image" content="http://intervalrain.github.io/images/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-28T00:10:20+08:00"><meta property="article:modified_time" content="2022-05-28T00:10:20+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[VHDL] HDLbits"><meta name=twitter:description content="Verilog tutorial"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[VHDL] HDLbits","item":"http://intervalrain.github.io/posts/verilog/hdlbits/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[VHDL] HDLbits","name":"[VHDL] HDLbits","description":"Verilog tutorial","keywords":["VHDL","Programming","Verilog"],"articleBody":"HDLBits HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。 由教學的題型由淺入深，逐步建立起電路設計的技能。 每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。\n1 Getting Started \\(\\text{assign one}\\)\nBuild a circuit with no inputs and one output. The output should always drive 1 (or logic high). module top_module( output one); assign one = 1'b1; endmodule \\(\\text{assign zero}\\)\nBuild a circuit with no inputs and one output that outputs a constant 0. module top_module( output zero ); assign zero = 1'b0; endmodule 2 Verilog Language 2.1 Basics \\(\\text{wire}\\)\nCreate a module with one input and ont output that behaves like a wire module top_module( input in, output out); assign out = in; endmodule \\(\\text{multi-in-out}\\)\nCreate a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: module top_module( input a,b,c, output w,x,y,z ); assign w = a; assign x = b; assign y = b; assign z = c; endmodule \\(\\text{not gate}\\)\nCreate a module that implements a NOT gate. module top_module( input in, output out ); assign out = ~in; endmodule \\(\\text{and gate}\\)\nCreate a module that implments an AND gate. module top_module( input a,b, output out ); assign out = a \u0026 b; endmodule \\(\\text{nor gate}\\)\nCreate a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog. module top_module( input a,b, output out ); assign out = ~(a|b); endmodule \\(\\text{xnor gate}\\)\nCreate a module that implements a XNOR gate. module top_module( input a, b, output out ); assign out = ~(a^b); endmodule \\(\\text{wire declaration}\\)\nImplement following circuits. Create two intermediate wires to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire out, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs. module top_module( input a,b,c,d, output out, out_n ); wire w1, w2; assign w1 = a \u0026 b; assign w2 = c \u0026 d; assign out = w1 | w2; assign out_n = ~out; endmodule \\(\\text{7458}\\)\nThe 7458 is a chip with four AND gates and two OR gates. Create a module with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. module top_module( input p1a, p1b, p1c, p1d, p1e, p1f, output p1y, intput p2a, p2b, p2c, p2d, output p2y ); wire w1a, w1b; wire w2a, w2b; assign w1a = p1a \u0026 p1b \u0026 p1c; assign w1b = p1d \u0026 p1e \u0026 p1f; assign p1y = w1a | w1b; assign w2a = p2a \u0026 p2b; assign w2b = p2c \u0026 p2d; assign p2y = w2a | w2b; endmodule 2.2 Vectors \\(\\text{vector}\\)\nBuild a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect outputs o0 to the input vector’s position 0, o1 to position 1, etc.\nIn a diagram, a tick mark with a number next to it indicates the width of the vector (or “bus”), rather than drawing a separate line for each bit in the vector. module top_module ( input wire [2:0] vec, output wire [2:0] outv, output wire o2, output wire o1, output wire o0 ); assign outv = vec; assign o0 = vec[0]; assign o1 = vec[1]; assign o2 = vec[2]; endmodule \\(\\text{vector select}\\)\nBuild a combinational circuit that splits an input half-word (16 bits, [15:0]) into lower [7:0] and upper [15:8] bytes. module top_module ( input [15:0] in, output [7:0] out_hi, output [7:0] out_lo ); assign out_hi = in[15:8]; assign out_lo = in[7:0]; endmodule \\(\\text{vector swap}\\)\nA 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of the 4-byte word.\nAaaaaaaaBbbbbbbbCcccccccDddddddd =\u003e DdddddddCcccccccBbbbbbbbAaaaaaaa\nThis operation is often used when the endianness of a piece of data needs to be swapped, for example between little-endian x86 systems and the big-endian formats used in many Internet protocols. module top_module ( input [31:0] in, output [31:0] out ); assign out[31:24] = in[ 7: 0]; assign out[23:16] = in[15: 8]; assign out[15: 8] = in[23:16]; assign out[ 7: 0] = in[31:24]; endmodule \\(\\text{vector gates}\\)\nuild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half. module top_module ( input [2:0] a, input [2:0] b, output [2:0] out_or_bitwise, output out_or_logical, output [5:0] out_not ); assign out_or_bitwise = a | b; assign out_or_logical = a || b; assign out_not[2:0] = ~a; assign out_not[5:3] = ~b; endmodule \\(\\text{gate-prefix vector}\\)\nBuild a combinational circuit with four inputs, in[3:0]. There are 3 outputs: out_and: output of a 4-input AND gate. out_or: output of a 4-input OR gate. out_xor: outout of a 4-input XOR gate. module top_module ( input [3:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026 in; assign out_or = | in; assign out_xor = ^ in; endmodule \\(\\text{vector concatenate}\\)\nGiven several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for module top_module ( input [4:0] a, b, c, d, e, f, output [7:0] w, x, y, z ); assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11}; endmodule \\(\\text{vector reverse}\\)\nGiven an 8-bit input vector [7:0], reverse its bit ordering. module top_module( input [7:0] in, output [7:0] out ); assign {out[0], out[1], out[2], out[3], out[4], out[5], out[6], out[7]} = in endmodule module top_module( input [7:0] in, output [7:0] out ); always @(*) begin for (int i=0; i\u003c8; i++) out[i] = in[8-i-1]; end endmodule module top_module( input [7:0] in, output [7:0] out ); generate genvar i; for (i=0; i\u003c8; i = i+1) begin: my_block_name assign out[i] = in[8-i-1]; end endgenerate endmodule \\(\\text{vector replication}\\)\nBuild a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself. module top_module ( input [7:0] in, output [31:0] out ); assign out = {{24{in[7]}}, in}; endmodule \\(\\text{vector replication2}\\)\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. module top_module ( input a, b, c, d, e, output [24:0] out ); assign out = ~{{5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}}} ^ {5{a,b,c,d,e}}; endmodule 2.3 Modules: Hierarchy By now, you’re familiar with a module, which is a circuit that interacts with its outside through input and output ports. Larger, more complex circuits are built by composing bigger modules out of smaller modules and other pieces (such as assign statements and always blocks) connected together. This forms a hierarchy, as modules can contain instances of other modules.\nThe figure below shows a very simple circuit with a sub-module. In this exercise, create one instance of module mod_a, then connect the module’s three pins (in1, in2, and out) to your top-level module’s three ports (wires a, b, and out). The module mod_a is provided for you — you must instantiate it.\nWhen connecting modules, only the ports on the module are important. You do not need to know the code inside the module. The code for module mod_a looks like this:\nmodule mod_a ( input in1, input in2, output out ); // Module body endmodule The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written inside another module’s body (Code for different modules are not nested).\nYou may connect signals to the module by port name or port position. For extra practice, try both methods.\nConnecting Signals to Module Ports\nThere are two commonly-used methods to connect a wire to a port: by position or by name.\nBy position\nThe syntax to connect wires to ports by position should be familiar, as it uses a C-like syntax. When instantiating a module, ports are connected left to right according to the module’s declaration. For example:\nmod_a instance1 ( wa, wb, wc );\nThis instantiates a module of type mod_a and gives it an instance name of “instance1”, then connects signal wa (outside the new module) to the first port (in1) of the new module, wb to the second port (in2), and wc to the third port (out). One drawback of this syntax is that if the module’s port list changes, all instantiations of the module will also need to be found and changed to match the new module.\nBy name\nConnecting signals to a module’s ports by name allows wires to remain correctly connected even if the port list changes. This syntax is more verbose, however.\nmod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );\nThe above line instantiates a module of type mod_a named “instance2”, then connects signal wa (outside the module) to the port named in1, wb to the port named in2, and wc to the port named out. Notice how the ordering of ports is irrelevant here because the connection will be made to the correct name, regardless of its position in the sub-module’s port list. Also notice the period immediately preceding the port name in this syntax.\n\\(\\text{module}\\) module top_module ( input a, input b, output out ); mod_a u_mod_a ( .in1 (a), .in2 (b), .out (out) ); endmodule \\(\\text{module\\_pos}\\)\nThis problem is similar to the previous one (module). You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. You must connect the 6 ports by position to your top-level module’s ports out1, out2, a, b, c, and d, in that order. You are given the following module: module top_module ( input a, b, c, d, output out1, out2 ); mod_a u_mod_a(out1, out2, a, b, c, d); endmodule \\(\\text{module\\_name}\\)\nThis problem is similar to module. You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. You must connect the 6 ports by name to your top-level module’s ports:You are given the following module: module top_module ( input a, input b, input c, input d, output out1, output out2 ); mod_a u_mod_a( .out1 (out1), .out2 (out2), .in1 (a), .in2 (b), .in3 (c), .in4 (d) ); endmodule \\(\\text{module\\_shift}\\)\nYou are given a module my_dff with two inputs and one output (that implements a D flip-flop). Instantiate three of them, then chain them together to make a shift register of length 3. The clk port needs to be connected to all instances. Note that to make the internal connections, you will need to declare some wires. Be careful about naming your wires and module instances: the names must be unique.\nThe module provided to you is: module my_dff ( input clk, input d, output q ); module top_module ( input clk, input d, output q ); wire q1; wire q2; my_dff(clk, d, q1); my_dff(clk, q1, q2); my_dff(clk, q2, q); endmodule \\(\\text{module\\_shift8}\\)\nYou are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: The value at the input d, after the first, after the second, or after the third D flip-flop. (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.) The module provided to you is: module my_dff8 ( input clk, input [7:0] d, output [7:0] q );\nThe multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside. module top_module ( input clk, input [7:0] d, input [1:0] sel, output [7:0] q ); wire [7:0] q1; wire [7:0] q2; wire [7:0] q3; my_dff8 (clk, d, q1); my_dff8 (clk, q1, q2); my_dff8 (clk, q2, q3); // multiplexer: mux9to1v always@(*) begin case(sel) 2'd0: q = d; 2'd1: q = q1; 2'd2: q = q2; 2'd3: q = q3; endcase end endmodule \\(\\text{module\\_Half Adder}\\)\nYou are given a module add16 that performs a 16-bit addition. Instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result, after receiving the carry-out from the first adder. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored), but the internal modules need to in order to function correctly. (In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).\nConnect the modules together as shown in the diagram below. The provided module add16 has the following declaration: module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout ); module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire [15:0] sum1; wire [15:0] sum2; wire cout1; wire cout2; add16 (a[15:0], b[15:0], 1'b0, sum1, cout1); add16 (a[31:16], b[31:16], cout1, sum2, cout2); assign sum = {sum2, sum1}; endmodule \\(\\text{module\\_Full Adder}\\)\nYou are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).\nConnect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nWithin each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. You must write the full adder module that has the following declaration:\nmodule add1 ( input a, input b, input cin, output sum, output cout );\nRecall that a full adder computes the sum and carry-out of a+b+cin.\nIn summary, there are three modules in this design: top_module — Your top-level module that contains two of… add16, provided — A 16-bit adder module that is composed of 16 of… add1 — A 1-bit full adder module. module top_module ( input [31:0] a, input [31:0] b, output [31:0] sum ); wire [15:0] sum1; wire [15:0] sum2; wire cout1; wire cout2; add16 (a[15:0], b[15:0], 1'b0, sum1, cout1); add16 (a[31:16], b[31:16], cout1, sum2, cout2); assign sum = {sum2, sum1}; endmodule module add1 ( input a, input b, input cin, output sum, output cout ); assign sum = a ^ b ^ cin; assign cout = (a\u0026b)|(b\u0026cin)|(cin\u0026a); // assign {cout, sum} = a + b + cin; endmodule \\(\\text{Module\\_Carry Select Adder}\\)\nOne drawback of the ripple carry adder is that the delay for an adder to compute the carry out (from the carry-in, in the worst case) is fairly slow, and the second-stage adder cannot begin computing its carry-out until the first-stage adder has finished. This makes the adder slow. One improvement is a carry-select adder, shown below. The first-stage adder is the same as before, but we duplicate the second-stage adder, one assuming carry-in=0 and one assuming carry-in=1, then using a fast 2-to-1 multiplexer to select which result happened to be correct.\nYou are provided with the same module add16 as the previous exercise, which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. You must instantiate three of these to build the carry-select adder, using your own 16-bit 2-to-1 multiplexer.\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nConnect the modules together as shown in the diagram below. The provided module add16 has the following declaration: module top_module( input [31:0] a, input [31:0] b, output [31:0] sum ); wire sel; wire [15:0] wire0, wire1; add16 (a[15: 0], b[15: 0], 1'b0, sum[15:0], sel); add16 (a[31:16], b[31:16], 1'b0, wire0, ); add16 (a[31:16], b[31:16], 1'b1, wire1, ); // selector always@(*) begin case(sel) 1'b0: sum[31:16] = wire0; 1'b1: sum[31:16] = wire1; endcase end // ternary operator // assign sum[31:16] = sel ? wire1 : wire0; endmodule \\(\\text{Module\\_Adder-Subtractor}\\)\nAn adder-subtractor can be built from an adder by optionally negating one of the inputs, which is equivalent to inverting the input then adding 1. The net result is a circuit that can do two operations: (a + b + 0) and (a + ~b + 1). Build the adder-subtractor below. You are provided with a 16-bit adder module, which you need to instantiate twice:\nmodule add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );\nUse a 32-bit wide XOR gate to invert the b input whenever sub is 1. (This can also be viewed as b[31:0] XORed with sub replicated 32 times. See replication operator.). Also connect the sub input to the carry-in of the adder. module top_module( input [31:0] a, input [31:0] b, input sub, output [31:0] sum ); wire cout; wire [31:0] bin; assign bin = {32{sub}} ^ b; add16 (a[15: 0], bin[15: 0], sub, sum[15: 0], cout); add16 (a[31:16], bin[31:16], cout, sum[31:16], ); endmodule 2.4 Procedures \\(\\text{Alwaysblock}\\)\nFor synthesizing hardware, two types of always blocks are relevant: Combinational: always @(*) Clocked: always @(posedge clk) Combinational always blocks are equivalent to assign statements, thus there is always a way to express a combinational circuit both ways. The choice between which to use is mainly an issue of which syntax is more convenient. The syntax for code inside a procedural block is different from code that is outside. Procedural blocks have a richer set of statements (e.g., if-then, case), cannot contain continuous assignments*, but also introduces many new non-intuitive ways of making errors. (*Procedural continuous assignments do exist, but are somewhat different from continuous assignments, and are not synthesizable.) For combinational always blocks, always use a sensitivity list of (*). Explicitly listing out the signals is error-prone (if you miss one), and is ignored for hardware synthesis. If you explicitly specify the sensitivity list and miss a signal, the synthesized hardware will still behave as though (*) was specified, but the simulation will not and not match the hardware’s behaviour. (In SystemVerilog, use always_comb.) A note on wire vs. reg: The left-hand-side of an assign statement must be a net type (e.g., wire), while the left-hand-side of a procedural assignment (in an always block) must be a variable type (e.g., reg). These types (wire vs. reg) have nothing to do with what hardware is synthesized, and is just syntax left over from Verilog’s use as a hardware simulation language. Build an AND gate using both an assign statement and a combinational always block. module top_module( input a, input b, output wire out_assign, output reg out_alwaysblock ); assign out_assign = a \u0026 b; always @(*) begin out_alwaysblock = a \u0026 b; end endmodule \\(\\text{Clocked}\\)\nClocked always blocks create a blob of combinational logic just like combinational always blocks, but also creates a set of flip-flops (or “registers”) at the output of the blob of combinational logic. Instead of the outputs of the blob of logic being visible immediately, the outputs are visible only immediately after the next (posedge clk). Blocking vs. Non-Backing Assignment\nThere are three types of assignments in Verilog:\nContinuous assignments (assign x = y;): Can only be used when not inside a procedure (“always block”). Procedural blocking assignment (x = y;): Can only be used inside a procedure. Procedural non-blocking assignment (x \u003c= y;): Can only be used inside a procedure. In a combinational always block, use blocking assignments. In a clocked always block, used non-blocking assignments. A full understanding of why is not particularly usedful for hardware design and requires a good understanding of how Verilog simulators keep track of events. Not following this rule results in extremely hard to find errors that are both non-deterministic and differ between simulation and synthesized hardware.\nBuild an XOR gate three ways, using an assignment, a combinational always block, and a clocked always block. Note that the clocked always block precedures a different circuit from the other two: There is a flip-flop so the output is delayed. module top_module( input clk, input a, input b, output wire out_assign, output reg out_always_comb, output reg out_always_ff ); assign out_assign = a ^ b; always @(*) begin out_always_comb = a ^ b; end always @(posedge clk) begin out_always_ff \u003c= a ^ b; end endmodule \\(\\text{If statement}\\)\nAn if statement usually creates a 2-to-1 multiplexer, selecting one input if the condition is true, and the other input if the condition is false. always @(*) begin if (condition) begin out = x; end else begin out = y; end end This is equivalent to using a continuous assignment with a conditional operator:\nassign out = (condition) ? x : y;\nHowever, the procedural if statement provides a new way to make mistakes. The circuit is combinational only if out is always assigned a value.\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement. \\(\\begin{array}{|c|c|c|}\\hline \\text{sel\\_b1}\u0026\\text{sel\\_b2}\u0026\\text{out\\_assign, out\\_always} \\\\\\hline 0\u00260\u0026a\\\\\\hline 0\u00261\u0026a\\\\\\hline 1\u00260\u0026a\\\\\\hline 1\u00261\u0026b\\\\\\hline \\end{array}\\)\nmodule top_module( input a, input b, input sel_b1, input sel_b2, output wire out_assign, output reg out_always ); assign out_assign = sel_b1 \u0026 sel_b2 ? b : a; always @(*) begin if (sel_b1 \u0026 sel_b2) begin out_always = b; end else begin out_always = a; end end // always @(*) begin // case ({sel_b1, sel_b2}) //\t2'd0:begin //\tout_always = a; // end // 2'd1:begin //\tout_always = a; // end // 2'd2:begin //\tout_always = a; // end // 2'd3:begin //\tout_always = b; // end // endcase // end endmodule \\(\\text{If statement latches}\\)\nA common source of errors: How to avoid making latches\nWhen designing circuits, you must think first in terms of circuits:\nI want this logic gate I want a combinational blob of logic that has these inputs and produces these outputs I want a combinational blob of logic followed by a set of flip-flops What you must not do is write the code first, then hope it generates a proper circuit.\nIf (cpu_overheated) then shut_off_computer = 1; If (~arrived) then keep_driving = ~gas_tank_empty; Syntactically-correct code does not necessarily result in a reasonable circuit (combinational logic + flip-flops). The usual reason is: “What happens in the cases other than those you specified?”. Verilog’s answer is: Keep the outputs unchanged.\nThis behaviour of “keep outputs unchanged” means the current state needs to be remembered, and thus produces a latch. Combinational logic (e.g., logic gates) cannot remember any state. Watch out for Warning (10240): … inferring latch(es)\" messages. Unless the latch was intentional, it almost always indicates a bug. Combinational circuits must have a value assigned to all outputs under all conditions. This usually means you always need else clauses or a default value assigned to the outputs.\nDemonstration\nThe following code contains incorrect behaviour that creates a latch. Fix the bugs so that you will shut off the computer only if it’s really overheated, and stop driving if you’ve arrived at your destination or you need to refuel. always @(*) begin if (cpu_overheated) shut_off_computer = 1; end always @(*) begin if (~arrived) keep_driving = ~gas_tank_empty; end module top_module ( input cpu_overheated, output reg shut_off_computer, input arrived, input gas_tank_empty, output reg keep_driving ); // always @(*) begin if (cpu_overheated) shut_off_computer = 1; else shut_off_computer = 0; end always @(*) begin if (~arrived) keep_driving = ~gas_tank_empty; else keep_driving = 0; end endmodule \\(\\text{Case statement}\\)\nCase statements in Verilog are nearly equivalent to a sequence of if-elseif-else that compares one expression to a list of others. Its syntax and functionality differs from the switch statement in C. always @(*) begin // This is a combinational circuit case (in) 1'b1: begin out = 1'b1; // begin-end if \u003e1 statement end 1'b0: out = 1'b0; default: out = 1'bx; endcase end The case statement begins with case and each “case item” ends with a colon. There is no “switch”. Each case item can execute exactly one statement. This makes the “break” used in C unnecessary. But this means that if + you need more than one statement, you must use begin ... end.\nDuplicate (and partially overlapping) case items are permitted. The first one that matches is used. C does not allow duplicate case items.\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide. Be careful of inferring latches.\n// synthesis verilog_input_version verilog_2001 module top_module ( input [2:0] sel, input [3:0] data0, input [3:0] data1, input [3:0] data2, input [3:0] data3, input [3:0] data4, input [3:0] data5, output reg [3:0] out ); always @(*) begin case(sel) 0: out = data0; 1: out = data1; 2: out = data2; 3: out = data3; 4: out = data4; 5: out = data5; default: out = 0; endcase end endmodule \\(\\text{Priority encoder}\\)\nA priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3’d4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations. module top_module ( input [3:0] in, output reg [1:0] pos ); always @(*) begin case (in) 4'h0: pos = 2'h0; //0000 4'h1: pos = 2'h0; //0001 4'h2: pos = 2'h1; //0010 4'h3: pos = 2'h0; //0011 4'h4: pos = 2'h2; //0100 4'h5: pos = 2'h0; //0101 4'h6: pos = 2'h1; //0110 4'h7: pos = 2'h0; //0111 4'h8: pos = 2'h3; //1000 4'h9: pos = 2'h0; //1001 4'ha: pos = 2'h1; //1010 4'hb: pos = 2'h0; //1011 4'hc: pos = 2'h2; //1100 4'hd: pos = 2'h0; //1101 4'he: pos = 2'h1; //1110 4'hf: pos = 2'h0; //1111 default: pos = 2'b0; endcase end endmodule \\(\\text{Priority encoder with casez}\\)\nBuild previous problem with casez. If the case items in the case statement supported con’t care bits. This is what casez is for: It treats bits that have the value z as don’t care in the comparison. A case statement behaves as though each item is checked sequentially (in reality, a big combinational logic function). Notice how there are certain inputs (e.g., 4’b1111) that will match more than one case item. The first match is chosen (so 4’b1111 matches the first item, out = 0, but not any of the later ones). There is also a similar casex that treats both x and z as don’t-care. I don’t see much purpose to using it over casez. The digit ? is a synonym for z. so 2’bz0 is the same as 2’b?0 It may be less error-prone to explicitly specify the priority behaviour rather than rely on the ordering of the case items. For example, the following will still behave the same way if some of the case items were reordered, because any bit pattern can only match at most one case item: module top_module ( input [7:0] in, output reg [2:0] pos ); always @(*) begin casez(in) 8'bzzzzzzz1: pos = 3'd0; 8'bzzzzzz10: pos = 3'd1; 8'bzzzzz100: pos = 3'd2; 8'bzzzz1000: pos = 3'd3; 8'bzzz10000: pos = 3'd4; 8'bzz100000: pos = 3'd5; 8'bz1000000: pos = 3'd6; 8'b10000000: pos = 3'd7; default: pos = 2'd0; endcase end endmodule \\(\\text{Avoiding latches}\\)\nSuppose you’re building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n\\(\\begin{array}{|c|c|}\\hline \\text{Scancode [15:0]}\u0026\\text{Arrow key}\\\\\\hline \\text{16’he06b}\u0026\\text{left arrow}\\\\\\hline \\text{16’he072}\u0026\\text{down arrow}\\\\\\hline \\text{16’he074}\u0026\\text{right arrow}\\\\\\hline \\text{16’he075}\u0026\\text{up arrow}\\\\\\hline \\text{Anything else}\u0026\\text{none}\\\\\\hline \\end{array}\\) Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output. To avoid creating latches, all outputs must be assigned a value in all possible conditions. Simply having a default case is not enough. You must assign a value to all four outputs in all four cases and the default case. This can involve a lot of unnecessary typing. One easy way around this is to assign a “default value” to the outputs before the case statement: always @(*) begin up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0; case (scancode) ... // Set to 1 as necessary. endcase end This style of code ensures the outputs are assigned a value (of 0) in all possible cases unless the case statement overrides the assignment. This also means that a default: case item becomes unnecessary. Reminder: The logic synthesizer generates a combinational circuit that behaves equivalently to what the code describes.Hardware does not “execute” the lines of code in sequence. module top_module ( input [15:0] scancode, output reg left, output reg down, output reg right, output reg up ); always @(*) begin left = 0; down = 0; right = 0; up = 0; case(scancode) 16'he06b: left = 1; 16'he072: down = 1; 16'he074: right = 1; 16'he075: up = 1; endcase end endmodule 2.5 More Verilog Features \\(\\text{Conditional ternary operator}\\)\nVerilog has a ternary conditional operator ( ? : ) much like C: (condition ? if_true : if_false) Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a \u003c b). Use the conditional operator to make two-way min circuits, then compose a few of them to create a 4-way min circuit. You’ll probably want some wire vectors for the intermediate results. module top_module ( input [7:0] a, b, c, d, output [7:0] min);// wire [7:0] wire1; wire [7:0] wire2; assign wire1 = a \u003e b ? b : a; assign wire2 = c \u003e d ? d : c; assign min = wire1 \u003e wire2 ? wire2 : wire1; endmodule \\(\\text{Reduction operators}\\)\nSome syntactic sugar for reduction: \u0026 a[3:0] // AND: a[3] \u0026 a[2] \u0026 a[1] \u0026 a[0]. Equivalent to (a[3:0] == 4'hf) | b[3:0] // OR: b[3] | b[2] | b[1] | b[0]. Equivalent to (b[3:0] != 4'h0) ^ c[2:0] // XOR: c[2] ^ c[1] ^ c[0] Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use “even” parity, where the parity bit is just the XOR of all 8 data bits. module top_module ( input [7:0] in, output parity); assign parity = ^ in; endmodule \\(\\text{Reduction: Even wider gates}\\)\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: out_and: output of a 100-input AND gate. out_or: output of a 100-input OR gate. out_xor: output of a 100-input XOR gate. module top_module( input [99:0] in, output out_and, output out_or, output out_xor ); assign out_and = \u0026 in; assign out_or = | in; assign out_xor = ^ in; endmodule \\(\\text{Combinational for-loop: Vector reversal}\\)\nGiven a 100-bit input vector [99:0], reverse its bit ordering. module top_module( input [99:0] in, output [99:0] out ); always @(*) begin for (int i = 0; i \u003c 100; i++) begin out[i] = in[99 - i]; end end endmodule \\(\\text{Combinational for-loop: 255-bit population count}\\)\nA “population count” circuit counts the number of ‘1’s in an input vector. Build a population count circuit for a 255-bit input vector. module top_module( input [254:0] in, output [7:0] out ); always @(*) begin out = 0; for (int i = 0; i \u003c 255; i++) begin out += in[i]; end end endmodule \\(\\text{Generate for-loop: 100-bit binary adder}\\)\nCreate a 100-bit binary ripple-carry adder by instantiating 100 full adders. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see. module top_module( input [99:0] a, b, input cin, output [99:0] cout, output [99:0] sum ); always @(*) begin {cout[0], sum[0]} = a[0] + b[0] + cin; for (int i = 1; i \u003c 100; i++) begin {cout[i], sum[i]} = a[i] + b[i] + cout[i-1]; end end endmodule \\(\\text{Generate for-loop: 100-digit BCD adder}\\)\nYou are provided with a BCD one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out. module bcd_fadd ( input [3:0] a, input [3:0] b, input cin, output cout, output [3:0] sum ); Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) and a carry-in to produce a 100-digit sum and carry out. module top_module( input [399:0] a, b, input cin, output cout, output [399:0] sum ); wire[99:0] carryin; generate genvar i; bcd_fadd(a[3:0], b[3:0], cin, carryin[0], sum[3:0]); for (i = 4; i \u003c 400; i += 4) begin:adder bcd_fadd(a[i+3:i], b[i+3:i], carryin[i/4-1], carryin[i/4], sum[i+3:i]); end assign cout = carryin[99]; endgenerate endmodule 3 Circuits 3.1 Combinational Logic 3.1.1 Basic Gates \\(\\text{Wire}\\) module top_module ( input in, output out); assign out = in; endmodule \\(\\text{GND}\\) module top_module ( output out); assign out = 1'b0; endmodule \\(\\text{NOR}\\) module top_module ( input in1, input in2, output out); assign out = ~(in1|in2); endmodule \\(\\text{Another Gate}\\) module top_module ( input in1, input in2, output out); assign out = in1 \u0026 (~in2); endmodule \\(\\text{Two gates}\\) module top_module ( input in1, input in2, input in3, output out); wire w1; assign w1 = ~(in1^in2); assign out = w1^in3; endmodule \\(\\text{More logic gates}\\)\nmodule top_module( input a, b, output out_and, output out_or, output out_xor, output out_nand, output out_nor, output out_xnor, output out_anotb ); assign out_and = a \u0026 b; assign out_or = a | b; assign out_xor = a ^ b; assign out_nand = ~(a \u0026 b); assign out_nor = ~(a | b); assign out_xnor = ~(a ^ b); assign out_anotb = a \u0026 (~b); // and(out_and, a, b); // or(out_or, a, b); // xor(out_xor, a, b); // nand(out_nand, a, b); // nor(out_nor, a, b); // xnor(out_xnor, a, b); // and(out_anotb, a , ~b); endmodule \\(\\text{7420 chip}\\) module top_module ( input p1a, p1b, p1c, p1d, output p1y, input p2a, p2b, p2c, p2d, output p2y ); assign p1y = ~(p1a \u0026 p1b \u0026 p1c \u0026 p1d); assign p2y = ~(p2a \u0026 p2b \u0026 p2c \u0026 p2d); endmodule\\ \\(\\text{Truth tables}\\)\n\\(\\begin{array}{|c|ccc|c|}\\hline \\text{Row}\u0026\u0026\\text{Inputs}\u0026\u0026\\text{Outputs}\\\\\\hline \\text{number}\u0026\\text{x3}\u0026\\text{x2}\u0026\\text{x1}\u0026\\text{f}\\\\\\hline 0\u00260\u00260\u00260\u00260\\\\\\hline 1\u00260\u00260\u00261\u00260\\\\\\hline 2\u00260\u00261\u00260\u00261\\\\\\hline 3\u00260\u00261\u00261\u00261\\\\\\hline 4\u00261\u00260\u00260\u00260\\\\\\hline 5\u00261\u00260\u00261\u00261\\\\\\hline 6\u00261\u00261\u00260\u00260\\\\\\hline 7\u00261\u00261\u00261\u00261\\\\\\hline \\end{array}\\) module top_module( input x3, input x2, input x1, output f ); assign f = ((~x3)\u0026x2)|(x3\u0026x1); endmodule \\(\\text{Two-bit equality}\\)\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0. module top_module ( input [1:0] A, input [1:0] B, output z ); assign z = (A == B); endmodule \\(\\text{Simple circuit A}\\)\nmodule top_module (input x, input y, output z); assign z = (x^y) \u0026x; endmodule \\(\\text{Simple circuit B}\\) module top_module ( input x, input y, output z ); assign z = (x==y); // assign z = ~(x ^ y); endmodule \\(\\text{Combine circuits A and B}\\) module top_module (input x, input y, output z); wire o1, o2, o3, o4; A ia1(x,y,o1); B ib1(x,y,o2); A ia2(x,y,o3); B ib2(x,y,o4); assign z = (o1|o2)^(o3\u0026o4); endmodule module A( input x, y, output z); assign z = (x ^ y) \u0026 x; endmodule module B( input x, y, output z); assign z = x ~^ y; endmodule \\(\\text{Ringer}\\)\nSuppose you are designing a circuit to control a cellphone’s ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates. Design hint: When designing circuits, one often has to think of the problem “backwards”, starting from the outputs then working backwards towards the inputs. This is often the opposite of how one would think about a (sequential, imperative) programming problem, where one would look at the inputs first then decide on an action (or output). For sequential programs, one would often think “If (inputs are ___ ) then (output should be ___ )”. On the other hand, hardware designers often think “The (output should be ___ ) when (inputs are ___ )”. The above problem description is written in an imperative form suitable for software programming (if ring then do this), so you must convert it to a more declarative form suitable for hardware implementation (assign ringer = ___). Being able to think in, and translate between, both styles is one of the most important skills needed for hardware design. module top_module ( input ring, input vibrate_mode, output ringer, // Make sound output motor // Vibrate ); assign ringer = ring \u0026 (~vibrate_mode); assign motor = ring \u0026 (vibrate_mode); endmodule \\(\\text{Thermostat}\\)\nA heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off. Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates. 畫出真值表\n\\(\\begin{array}{|cccc|ccc|}\\hline \\text{mode}\u0026\\text{too\\_cold}\u0026\\text{too\\_hot}\u0026\\text{fan on}\u0026\\text{heater}\u0026\\text{aircon}\u0026\\text{fan}\\\\\\hline 0\u00260\u00260\u00260\u00260\u00260\u00260\\\\\\hline 0\u00260\u00260\u00261\u00260\u00260\u00261\\\\\\hline 0\u00260\u00261\u00260\u00260\u00261\u00261\\\\\\hline 0\u00260\u00261\u00261\u00260\u00261\u00261\\\\\\hline 0\u00261\u00260\u00260\u00260\u00260\u00260\\\\\\hline 0\u00261\u00260\u00261\u00260\u00260\u00261\\\\\\hline 0\u00261\u00261\u00260\u00260\u00261\u00261\\\\\\hline 0\u00261\u00261\u00261\u00260\u00261\u00261\\\\\\hline 1\u00260\u00260\u00260\u00260\u00260\u00260\\\\\\hline 1\u00260\u00260\u00261\u00260\u00260\u00261\\\\\\hline 1\u00260\u00261\u00260\u00260\u00260\u00260\\\\\\hline 1\u00260\u00261\u00261\u00260\u00260\u00261\\\\\\hline 1\u00261\u00260\u00260\u00261\u00260\u00261\\\\\\hline 1\u00261\u00260\u00261\u00261\u00260\u00261\\\\\\hline 1\u00261\u00261\u00260\u00261\u00260\u00261\\\\\\hline 1\u00261\u00261\u00261\u00261\u00260\u00261\\\\\\hline \\end{array}\\) module top_module ( input too_cold, input too_hot, input mode, input fan_on, output heater, output aircon, output fan); assign heater = mode \u0026 too_cold; assign aircon = (~mode) \u0026 too_hot; assign fan = heater|aircon|fan_on; endmodule \\(\\text{3-bit population count}\\)\nA “population count” circuit counts the number of ‘1’s in an input vector. Build a population count circuit for a 3-bit input vector. module top_module( input [2:0] in, output [1:0] out ); always @(*) begin out = 0; for (int i = 0; i \u003c= 2; i++) begin out += in[i]; end end endmodule 此解會產生鎖存器，不建議使用。 \\(\\text{Gates and vectors}\\)\nYou are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are ‘1’. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don’t need to know out_both[3]. out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are ‘1’. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don’t need to know out_any[0]. out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]’s neighbour to the left is in[0]. module top_module( input [3:0] in, output [2:0] out_both, output [3:1] out_any, output [3:0] out_different ); assign out_both[2:0] = in[2:0] \u0026 in[3:1]; assign out_any[3:1] = in[3:1] | in[2:0]; assign out_different[3:0] = in[3:0] ^ {in[0], in[3:1]}; // always @(*) begin // out_different[3] = (in[3] != in[0]); // for (int i = 0; i \u003c= 2; i++) begin // out_both[i] = in[i] \u0026 in[i+1]; // out_any[i+1] = in[i+1] | in[i]; // out_different[i] = (in[i] != in[i+1]); // end // end endmodule \\(\\text{Even longer vectors}\\)\nYou are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are ‘1’. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don’t need to know out_both[99]. out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are ‘1’. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don’t need to know out_any[0]. out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]’s neighbour to the left is in[0]. module top_module( input [99:0] in, output [98:0] out_both, output [99:1] out_any, output [99:0] out_different ); assign out_both[98:0] = in[98:0] \u0026 in[99:1]; assign out_any[99:1] = in[99:1] | in[98:0]; assign out_different[99:0] = in[99:0] ^ {in[0], in[99:1]}; endmodule 3.1.2 Multiplexers \\(\\text{2-to-1 multiplexer}\\)\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b. module top_module( input a, b, sel, output out ); assign out = sel ? b : a; endmodule \\(\\text{2-to-1 bus multiplexer}\\)\nCreate a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b. module top_module( input [99:0] a, b, input sel, output [99:0] out ); assign out = sel ? b : a; endmodule \\(\\text{9-to-1 multiplexer}\\)\nCreate a 16-bit 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to ‘1’. module top_module( input [15:0] a, b, c, d, e, f, g, h, i, input [3:0] sel, output [15:0] out ); always @(*) begin case(sel) 4'd0: out = a; 4'd1: out = b; 4'd2: out = c; 4'd3: out = d; 4'd4: out = e; 4'd5: out = f; 4'd6: out = g; 4'd7: out = h; 4'd8: out = i; default: out = '1; // special literal syntax with all bits set to 1 endcase end endmodule \\(\\text{256-to-1 multiplexer}\\)\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should be select in[0], sel1 selectes bits in[1], sel=2 selects bits in[2], etc. module top_module( input [255:0] in, input [7:0] sel, output out ); assign out = in[sel]; endmodule \\(\\text{256-to-1 4-bit multiplexer}\\)\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0],sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc. module top_module( input [1023:0] in, input [7:0] sel, output [3:0] out ); assign out = in[sel*4+:4]; // special syntax // assign out = in[sel*4+3-:4]; // assign out = {in[sel*4+3],in[sel*4+2],in[sel*4+1],in[sel*4+0]}; endmodule 3.1.3 Arithmetic Circuits \\(\\text{Half adder}\\)\nCreate a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out. module top_module( input a, b, output cout, sum ); assign {cout, sum} = a + b; endmodule \\(\\text{Full adder}\\)\nCreate a full adder. A full adder adds three bits (including carry-in) and produces a sum and a carry-out. module top_module( input a, b, cin, output cout, sum ); assign {cout, sum} = a + b + cin; endmodule \\(\\text{3-bit binary adder}\\)\nNow that you know how to build a full adder, make 3 instances of it to create a 3-bit binary ripple-carry adder. The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last full adder, and is the carry-out you usually see. module top_module( input [2:0] a, b, input cin, output [2:0] cout, output [2:0] sum ); fulladder f1(a[0], b[0], cin, cout[0], sum[0]); fulladder f2(a[1], b[1], cout[0], cout[1], sum[1]); fulladder f3(a[2], b[2], cout[1], cout[2], sum[2]); endmodule module fulladder( input a, b, cin, output cout, sum); assign {cout, sum} = a + b + cin; endmodule \\(\\text{Adder}\\)\nImplement the following circuit: module top_module ( input [3:0] x, input [3:0] y, output [4:0] sum); // assign sum = x + y; wire [2:0] cout; FA f1(x[0], y[0], 0, cout[0], sum[0]); FA f2(x[1], y[1], cout[0], cout[1], sum[1]); FA f3(x[2], y[2], cout[1], cout[2], sum[2]); FA f4(x[3], y[3], cout[2], sum[4], sum[3]); endmodule module FA ( input a, b, cin, output cout, sum); assign {cout, sum} = a + b + cin; endmodule \\(\\text{Signed addition overflow}\\)\nAssume that you have two 8-bit 2’s complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred. module top_module ( input [7:0] a, input [7:0] b, output [7:0] s, output overflow ); assign s = a + b; assign overflow = (a[7] == b[7] \u0026\u0026 a[7] != s[7]) ? 1 : 0; endmodule \\(\\text{100-bit binary adder}\\)\nCreate a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. module top_module( input [99:0] a, b, input cin, output cout, output [99:0] sum); assign {cout, sum} = cin + a + b; endmodule \\(\\text{4-digit BCD adder}\\)\nYou are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out. module bcd_fadd ( input [3:0] a, input [3:0] b, input cin, output cout, output [3:0] sum ); Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.\nmodule top_module ( input [15:0] a, b, input cin, output cout, output [15:0] sum ); wire [2:0] wl; bcd_fadd u0 (a[ 3: 0], b[ 3: 0], cin, wl[0], sum[ 3: 0]); bcd_fadd u1 (a[ 7: 4], b[ 7: 4], wl[0], wl[1], sum[ 7: 4]); bcd_fadd u2 (a[11: 8], b[11: 8], wl[1], wl[2], sum[11: 8]); bcd_fadd u3 (a[15:12], b[15:12], wl[2], cout, sum[15:12]); endmodule 3.1.4 Karnaugh Map to Circuit \\(\\text{Kmap1}\\)\nImplement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, output out ); assign out = a | b | c; endmodule \\(\\text{Kmap2}\\)\nImplement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); // a'd' + b'c' + acd + a'bc wire w1, w2, w3, w4; assign w1 = (~a)\u0026(~d); assign w2 = (~b)\u0026(~c); assign w3 = a\u0026c\u0026d; assign w4 = (~a)\u0026b\u0026c; assign out = w1|w2|w3|w4; endmodule \\(\\text{Kmap3}\\)\nImplement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); // a + b'c assign out = a | (~b\u0026c); endmodule \\(\\text{Kmap4}\\)\nImplement the circuit described by the Karnaugh map below. module top_module( input a, input b, input c, input d, output out ); always @(*) begin if (a == b \u0026\u0026 c != d) out = 1; else if (a != b \u0026\u0026 c == d) out = 1; else out = 0; end endmodule \\(\\text{Minimum SOP and POS}\\)\nA single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form. module top_module ( input a, input b, input c, input d, output out_sop, output out_pos ); // f = d3 + m7 + d11 + m15 + m2 // f = cd + a'b'c assign out_sop = (c \u0026 d) | (~a \u0026 ~b \u0026 c); // f' = m0 + m1 + m4 + m5 + m6 + d8 + m9 + m10 + d11 + d12 + m13 + m14 // f' = c' + ab' + bd' // f = (c)(a'+b)(b'+d) assign out_pos = c \u0026 (~a | b) \u0026 (~b | d); endmodule \\(\\text{Karnaugh map}\\)\nConsider the function f shown in the Karnaugh map below. Implement this function. d is don’t-care, which means you may choose to output whatever value is convenient. module top_module ( input [4:1] x, output f ); // x[2]x[4] + x[1]'x[3] assign f = (x[2] \u0026 x[4]) | (~x[1] \u0026 x[3]); endmodule \\(\\text{Karnaugh map}\\)\nConsider the function f shown in the Karnaugh map below. Implement this function. (The original exam question asked for simplified SOP and POS forms of the function.) module top_module ( input [4:1] x, output f ); // x[2]'x[4]' + x[1]'x[3] + x[2]x[3]x[4] assign f = (~x[2] \u0026 ~x[4]) | (~x[1] \u0026 x[3]) | (x[2] \u0026 x[3] \u0026 x[4]); endmodule \\(\\text{K-map implemented with a multiplexer}\\)\nFor the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below. You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map. (The requirement to use only 2-to-1 multiplexers exists because the original exam question also wanted to test logic function simplification using K-maps and how to synthesize logic functions using only multiplexers. If you wish to treat this as purely a Verilog exercise, you may ignore this constraint and write the module any way you wish.) module top_module ( input c, input d, output [3:0] mux_in ); assign mux_in[0] = c|d; // 0111 assign mux_in[1] = 1'b0; // 0000 assign mux_in[2] = ~d; // 1001 assign mux_in[3] = c\u0026d; // 0010 endmodule 3.2 Sequential Logic 3.2.1 Latches and Flip-Flops 3.2.2 Counters 3.2.3 Shift Registers 3.2.4 More Circuits 3.2.5 Finite State Machines 3.3 Building Larger Circuits 4 Verification: Reading Simulations 4.1 Finding bugs in code 4.2 Build a circuit from a simulation waveform 5 Verification: Writing Testbenches 6 CS450 ","wordCount":"8555","inLanguage":"en","image":"http://intervalrain.github.io/images/cover.jpg","datePublished":"2022-05-28T00:10:20+08:00","dateModified":"2022-05-28T00:10:20+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/verilog/hdlbits/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[VHDL] HDLbits</h1><div class=post-description>Verilog tutorial</div><div class=post-meta><span title='2022-05-28 00:10:20 +0800 +0800'>May 28, 2022</span>&nbsp;·&nbsp;41 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/Verilog/HDLbits.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#hdlbitshttpshdlbits01xznetwikimain_page aria-label=HDLBits><a href=https://hdlbits.01xz.net/wiki/Main_Page>HDLBits</a></a></li><li><a href=#1-getting-started aria-label="1 Getting Started">1 Getting Started</a></li><li><a href=#2-verilog-language aria-label="2 Verilog Language">2 Verilog Language</a><ul><li><a href=#21-basics aria-label="2.1 Basics">2.1 Basics</a></li><li><a href=#22-vectors aria-label="2.2 Vectors">2.2 Vectors</a></li><li><a href=#23-modules-hierarchy aria-label="2.3 Modules: Hierarchy">2.3 Modules: Hierarchy</a></li><li><a href=#24-procedures aria-label="2.4 Procedures">2.4 Procedures</a></li><li><a href=#25-more-verilog-features aria-label="2.5 More Verilog Features">2.5 More Verilog Features</a></li></ul></li><li><a href=#3-circuits aria-label="3 Circuits">3 Circuits</a><ul><li><a href=#31-combinational-logic aria-label="3.1 Combinational Logic">3.1 Combinational Logic</a><ul><li><a href=#311-basic-gates aria-label="3.1.1 Basic Gates">3.1.1 Basic Gates</a></li><li><a href=#312-multiplexers aria-label="3.1.2 Multiplexers">3.1.2 Multiplexers</a></li><li><a href=#313-arithmetic-circuits aria-label="3.1.3 Arithmetic Circuits">3.1.3 Arithmetic Circuits</a></li><li><a href=#314-karnaugh-map-to-circuit aria-label="3.1.4 Karnaugh Map to Circuit">3.1.4 Karnaugh Map to Circuit</a></li></ul></li><li><a href=#32-sequential-logic aria-label="3.2 Sequential Logic">3.2 Sequential Logic</a><ul><li><a href=#321-latches-and-flip-flops aria-label="3.2.1 Latches and Flip-Flops">3.2.1 Latches and Flip-Flops</a></li><li><a href=#322-counters aria-label="3.2.2 Counters">3.2.2 Counters</a></li><li><a href=#323-shift-registers aria-label="3.2.3 Shift Registers">3.2.3 Shift Registers</a></li><li><a href=#324-more-circuits aria-label="3.2.4 More Circuits">3.2.4 More Circuits</a></li><li><a href=#325-finite-state-machines aria-label="3.2.5 Finite State Machines">3.2.5 Finite State Machines</a></li></ul></li><li><a href=#33-building-larger-circuits aria-label="3.3 Building Larger Circuits">3.3 Building Larger Circuits</a></li></ul></li><li><a href=#4-verification-reading-simulations aria-label="4 Verification: Reading Simulations">4 Verification: Reading Simulations</a><ul><li><a href=#41-finding-bugs-in-code aria-label="4.1 Finding bugs in code">4.1 Finding bugs in code</a></li><li><a href=#42-build-a-circuit-from-a-simulation-waveform aria-label="4.2 Build a circuit from a simulation waveform">4.2 Build a circuit from a simulation waveform</a></li></ul></li><li><a href=#5-verification-writing-testbenches aria-label="5 Verification: Writing Testbenches">5 Verification: Writing Testbenches</a></li><li><a href=#6-cs450 aria-label="6 CS450">6 CS450</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=hdlbitshttpshdlbits01xznetwikimain_page><a href=https://hdlbits.01xz.net/wiki/Main_Page>HDLBits</a><a hidden class=anchor aria-hidden=true href=#hdlbitshttpshdlbits01xznetwikimain_page>#</a></h1><blockquote><p>HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。
由教學的題型由淺入深，逐步建立起電路設計的技能。
每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。</p></blockquote><h1 id=1-getting-started>1 Getting Started<a hidden class=anchor aria-hidden=true href=#1-getting-started>#</a></h1><p>\(\text{assign one}\)</p><ul><li>Build a circuit with no inputs and one output. The output should always drive 1 (or logic high).</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( <span style=color:#66d9ef>output</span> one);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> one <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{assign zero}\)</p><ul><li>Build a circuit with no inputs and one output that outputs a constant 0.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> zero );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> zero <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><h1 id=2-verilog-language>2 Verilog Language<a hidden class=anchor aria-hidden=true href=#2-verilog-language>#</a></h1><h2 id=21-basics>2.1 Basics<a hidden class=anchor aria-hidden=true href=#21-basics>#</a></h2><p>\(\text{wire}\)</p><ul><li>Create a module with one input and ont output that behaves like a wire
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/7/77/Wire.png alt=wire></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( <span style=color:#66d9ef>input</span> in, <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{multi-in-out}\)</p><ul><li>Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/1/15/Wire4.png alt=wire4></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,b,c, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> w,x,y,z );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> x <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> y <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{not gate}\)</p><ul><li>Create a module that implements a NOT gate.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/9/9e/Notgate.png alt=Notgate></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( <span style=color:#66d9ef>input</span> in, <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>in;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{and gate}\)</p><ul><li>Create a module that implments an AND gate.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/7/78/Andgate.png alt=Andgate></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{nor gate}\)</p><ul><li>Create a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/5/5b/Norgate.png alt=norgate></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a<span style=color:#f92672>|</span>b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{xnor gate}\)</p><ul><li>Create a module that implements a XNOR gate.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/6/6d/Xnorgate.png alt=xnorgate></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a<span style=color:#f92672>^</span>b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{wire declaration}\)</p><ul><li>Implement following circuits. Create two intermediate wires to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire out, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/3/3a/Wiredecl2.png alt=Wiredecl></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,b,c,d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out, out_n );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> w1, w2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1 <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w2 <span style=color:#f92672>=</span> c <span style=color:#f92672>&amp;</span> d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> w1 <span style=color:#f92672>|</span> w2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_n <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>out;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{7458}\)</p><ul><li>The 7458 is a chip with four AND gates and two OR gates. Create a module with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/e/e1/7458.png alt=7458></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> p1a, p1b, p1c, p1d, p1e, p1f,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> p1y,
</span></span><span style=display:flex><span>    intput p2a, p2b, p2c, p2d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> p2y );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> w1a, w1b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> w2a, w2b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1a <span style=color:#f92672>=</span> p1a <span style=color:#f92672>&amp;</span> p1b <span style=color:#f92672>&amp;</span> p1c;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1b <span style=color:#f92672>=</span> p1d <span style=color:#f92672>&amp;</span> p1e <span style=color:#f92672>&amp;</span> p1f;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> p1y <span style=color:#f92672>=</span> w1a <span style=color:#f92672>|</span> w1b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w2a <span style=color:#f92672>=</span> p2a <span style=color:#f92672>&amp;</span> p2b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w2b <span style=color:#f92672>=</span> p2c <span style=color:#f92672>&amp;</span> p2d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> p2y <span style=color:#f92672>=</span> w2a <span style=color:#f92672>|</span> w2b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><h2 id=22-vectors>2.2 Vectors<a hidden class=anchor aria-hidden=true href=#22-vectors>#</a></h2><p>\(\text{vector}\)</p><ul><li>Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect outputs o0 to the input vector&rsquo;s position 0, o1 to position 1, etc.<br>In a diagram, a tick mark with a number next to it indicates the width of the vector (or &ldquo;bus&rdquo;), rather than drawing a separate line for each bit in the vector.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/ae/Vector0.png alt=vector0></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] vec,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] outv,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> o2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> o1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> o0  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> outv <span style=color:#f92672>=</span> vec;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> o0 <span style=color:#f92672>=</span> vec[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> o1 <span style=color:#f92672>=</span> vec[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> o2 <span style=color:#f92672>=</span> vec[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector select}\)</p><ul><li>Build a combinational circuit that splits an input half-word (16 bits, [15:0]) into lower [7:0] and upper [15:8] bytes.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_hi,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_lo );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_hi <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_lo <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector swap}\)</p><ul><li>A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of the 4-byte word.<br>AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa<br>This operation is often used when the endianness of a piece of data needs to be swapped, for example between little-endian x86 systems and the big-endian formats used in many Internet protocols.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out 
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>24</span>] <span style=color:#f92672>=</span> in[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out[<span style=color:#ae81ff>23</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>23</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>24</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector gates}\)</p><ul><li>uild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/1/1b/Vectorgates.png alt=vectorgates></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_or_bitwise,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_or_logical,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>5</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_not
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_or_bitwise <span style=color:#f92672>=</span> a <span style=color:#f92672>|</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_or_logical <span style=color:#f92672>=</span> a <span style=color:#f92672>||</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_not[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_not[<span style=color:#ae81ff>5</span><span style=color:#f92672>:</span><span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{gate-prefix vector}\)</p><ul><li>Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs:<ul><li>out_and: output of a 4-input AND gate.</li><li>out_or: output of a 4-input OR gate.</li><li>out_xor: outout of a 4-input XOR gate.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_and,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_or,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_xor );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_and <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span> in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_or <span style=color:#f92672>=</span> <span style=color:#f92672>|</span> in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_xor <span style=color:#f92672>=</span> <span style=color:#f92672>^</span> in;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector concatenate}\)</p><ul><li>Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/0/0c/Vector3.png alt=vector3></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b, c, d, e, f,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] w, x, y, z );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {w, x, y, z} <span style=color:#f92672>=</span> {a, b, c, d, e, f, <span style=color:#ae81ff>2</span><span style=color:#ae81ff>&#39;b11</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector reverse}\)</p><ul><li>Given an 8-bit input vector [7:0], reverse its bit ordering.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out 
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {out[<span style=color:#ae81ff>0</span>], out[<span style=color:#ae81ff>1</span>], out[<span style=color:#ae81ff>2</span>], out[<span style=color:#ae81ff>3</span>], out[<span style=color:#ae81ff>4</span>], out[<span style=color:#ae81ff>5</span>], out[<span style=color:#ae81ff>6</span>], out[<span style=color:#ae81ff>7</span>]} <span style=color:#f92672>=</span> in
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out 
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>8</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            out[i] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>8</span><span style=color:#f92672>-</span>i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out 
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>generate</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>genvar</span> i;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>8</span>; i <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>begin</span><span style=color:#f92672>:</span> my_block_name
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>assign</span> out[i] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>8</span><span style=color:#f92672>-</span>i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>endgenerate</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector replication}\)</p><ul><li>Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>24</span>{in[<span style=color:#ae81ff>7</span>]}}, in};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector replication2}\)</p><ul><li>Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/ac/Vector5.png alt=vector5></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b, c, d, e,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>24</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>{{<span style=color:#ae81ff>5</span>{a}}, {<span style=color:#ae81ff>5</span>{b}}, {<span style=color:#ae81ff>5</span>{c}}, {<span style=color:#ae81ff>5</span>{d}}, {<span style=color:#ae81ff>5</span>{e}}} <span style=color:#f92672>^</span> {<span style=color:#ae81ff>5</span>{a,b,c,d,e}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><h2 id=23-modules-hierarchy>2.3 Modules: Hierarchy<a hidden class=anchor aria-hidden=true href=#23-modules-hierarchy>#</a></h2><p>By now, you&rsquo;re familiar with a module, which is a circuit that interacts with its outside through input and output ports. Larger, more complex circuits are built by composing bigger modules out of smaller modules and other pieces (such as assign statements and always blocks) connected together. This forms a hierarchy, as modules can contain instances of other modules.</p><p>The figure below shows a very simple circuit with a sub-module. In this exercise, create one instance of module mod_a, then connect the module&rsquo;s three pins (in1, in2, and out) to your top-level module&rsquo;s three ports (wires a, b, and out). The module mod_a is provided for you — you must instantiate it.</p><p>When connecting modules, only the ports on the module are important. You do not need to know the code inside the module. The code for module mod_a looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> mod_a ( <span style=color:#66d9ef>input</span> in1, <span style=color:#66d9ef>input</span> in2, <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Module body
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><p>The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written inside another module&rsquo;s body (Code for different modules are not nested).</p><p>You may connect signals to the module by port name or port position. For extra practice, try both methods.</p><p><strong>Connecting Signals to Module Ports</strong><br>There are two commonly-used methods to connect a wire to a port: by position or by name.</p><p><strong>By position</strong><br>The syntax to connect wires to ports by position should be familiar, as it uses a C-like syntax. When instantiating a module, ports are connected left to right according to the module&rsquo;s declaration. For example:</p><p><code>mod_a instance1 ( wa, wb, wc );</code></p><p>This instantiates a module of type mod_a and gives it an instance name of &ldquo;instance1&rdquo;, then connects signal wa (outside the new module) to the first port (in1) of the new module, wb to the second port (in2), and wc to the third port (out). One drawback of this syntax is that if the module&rsquo;s port list changes, all instantiations of the module will also need to be found and changed to match the new module.</p><p><strong>By name</strong><br>Connecting signals to a module&rsquo;s ports by name allows wires to remain correctly connected even if the port list changes. This syntax is more verbose, however.</p><p><code>mod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );</code></p><p>The above line instantiates a module of type mod_a named &ldquo;instance2&rdquo;, then connects signal wa (outside the module) to the port named in1, wb to the port named in2, and wc to the port named out. Notice how the ordering of ports is irrelevant here because the connection will be made to the correct name, regardless of its position in the sub-module&rsquo;s port list. Also notice the period immediately preceding the port name in this syntax.</p><hr><p>\(\text{module}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/c/c0/Module.png alt=module></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( <span style=color:#66d9ef>input</span> a, <span style=color:#66d9ef>input</span> b, <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mod_a u_mod_a (
</span></span><span style=display:flex><span>        .in1 (a),
</span></span><span style=display:flex><span>        .in2 (b),
</span></span><span style=display:flex><span>        .out (out)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{module\_pos}\)</p><ul><li>This problem is similar to the previous one (module). You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. You must connect the 6 ports by position to your top-level module&rsquo;s ports out1, out2, a, b, c, and d, in that order.
You are given the following module:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/b/b7/Module_pos.png alt=module_pos></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b, c, d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out1, out2 );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mod_a u_mod_a(out1, out2, a, b, c, d);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{module\_name}\)</p><ul><li>This problem is similar to module. You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. You must connect the 6 ports by name to your top-level module&rsquo;s ports:You are given the following module:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/d/dd/Module_name.png alt=module_name></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out2
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    mod_a u_mod_a(
</span></span><span style=display:flex><span>        .out1 (out1),
</span></span><span style=display:flex><span>        .out2 (out2),
</span></span><span style=display:flex><span>        .in1  (a),
</span></span><span style=display:flex><span>        .in2  (b),
</span></span><span style=display:flex><span>        .in3  (c),
</span></span><span style=display:flex><span>        .in4  (d)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{module\_shift}\)</p><ul><li>You are given a module my_dff with two inputs and one output (that implements a D flip-flop). Instantiate three of them, then chain them together to make a shift register of length 3. The clk port needs to be connected to all instances.
Note that to make the internal connections, you will need to declare some wires. Be careful about naming your wires and module instances: the names must be unique.<br>The module provided to you is: <code>module my_dff ( input clk, input d, output q );</code>
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/6/60/Module_shift.png alt=module_shift></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( <span style=color:#66d9ef>input</span> clk, <span style=color:#66d9ef>input</span> d, <span style=color:#66d9ef>output</span> q );
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> q1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> q2;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    my_dff(clk, d, q1);
</span></span><span style=display:flex><span>    my_dff(clk, q1, q2);
</span></span><span style=display:flex><span>    my_dff(clk, q2, q);
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{module\_shift8}\)</p><ul><li>You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: The value at the input d, after the first, after the second, or after the third D flip-flop. (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)
The module provided to you is: <code>module my_dff8 ( input clk, input [7:0] d, output [7:0] q );</code><br>The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/7/76/Module_shift8.png alt=module_shift8></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] d, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sel, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] q 
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] q1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] q2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] q3;
</span></span><span style=display:flex><span>    my_dff8 (clk, d, q1);
</span></span><span style=display:flex><span>    my_dff8 (clk, q1, q2);
</span></span><span style=display:flex><span>    my_dff8 (clk, q2, q3);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// multiplexer: mux9to1v
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always</span>@(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span>(sel)
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>2</span><span style=color:#ae81ff>&#39;d0</span><span style=color:#f92672>:</span> q <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>2</span><span style=color:#ae81ff>&#39;d1</span><span style=color:#f92672>:</span> q <span style=color:#f92672>=</span> q1;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>2</span><span style=color:#ae81ff>&#39;d2</span><span style=color:#f92672>:</span> q <span style=color:#f92672>=</span> q2;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>2</span><span style=color:#ae81ff>&#39;d3</span><span style=color:#f92672>:</span> q <span style=color:#f92672>=</span> q3;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{module\_Half Adder}\)</p><ul><li>You are given a module add16 that performs a 16-bit addition. Instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result, after receiving the carry-out from the first adder. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored), but the internal modules need to in order to function correctly. (In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).<br>Connect the modules together as shown in the diagram below. The provided module add16 has the following declaration:
<code>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );</code>
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/a3/Module_add.png alt=module_add></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> cout1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> cout2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    add16 (a[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>], b[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>, sum1, cout1);
</span></span><span style=display:flex><span>    add16 (a[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], b[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], cout1, sum2, cout2);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> sum <span style=color:#f92672>=</span> {sum2, sum1};
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{module\_Full Adder}\)</p><ul><li>You are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. One add16 module computes the lower 16 bits of the addition result, while the second add16 module computes the upper 16 bits of the result. Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).<br>Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:<br><code>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );</code><br>Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. You must write the full adder module that has the following declaration:<br><code>module add1 ( input a, input b, input cin, output sum, output cout );</code><br>Recall that a full adder computes the sum and carry-out of a+b+cin.<br>In summary, there are three modules in this design:<ul><li>top_module — Your top-level module that contains two of&mldr;</li><li>add16, provided — A 16-bit adder module that is composed of 16 of&mldr;</li><li>add1 — A 1-bit full adder module.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/f/f3/Module_fadd.png alt=module_fadd></li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> cout1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> cout2;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    add16 (a[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>], b[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>, sum1, cout1);
</span></span><span style=display:flex><span>    add16 (a[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], b[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], cout1, sum2, cout2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> sum <span style=color:#f92672>=</span> {sum2, sum1};
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> add1 ( <span style=color:#66d9ef>input</span> a, <span style=color:#66d9ef>input</span> b, <span style=color:#66d9ef>input</span> cin,   <span style=color:#66d9ef>output</span> sum, <span style=color:#66d9ef>output</span> cout );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> sum <span style=color:#f92672>=</span> a <span style=color:#f92672>^</span> b <span style=color:#f92672>^</span> cin;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> cout <span style=color:#f92672>=</span> (a<span style=color:#f92672>&amp;</span>b)<span style=color:#f92672>|</span>(b<span style=color:#f92672>&amp;</span>cin)<span style=color:#f92672>|</span>(cin<span style=color:#f92672>&amp;</span>a);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assign {cout, sum} = a + b + cin;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Module\_Carry Select Adder}\)</p><ul><li>One drawback of the ripple carry adder is that the delay for an adder to compute the carry out (from the carry-in, in the worst case) is fairly slow, and the second-stage adder cannot begin computing its carry-out until the first-stage adder has finished. This makes the adder slow. One improvement is a carry-select adder, shown below. The first-stage adder is the same as before, but we duplicate the second-stage adder, one assuming carry-in=0 and one assuming carry-in=1, then using a fast 2-to-1 multiplexer to select which result happened to be correct.<br>You are provided with the same module add16 as the previous exercise, which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. You must instantiate three of these to build the carry-select adder, using your own 16-bit 2-to-1 multiplexer.<br><code>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );</code><br>Connect the modules together as shown in the diagram below. The provided module add16 has the following declaration:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/3/3e/Module_cseladd.png alt=module_sceladd></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> sel;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] wire0, wire1;
</span></span><span style=display:flex><span>    add16 (a[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>], b[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>, sum[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>], sel);
</span></span><span style=display:flex><span>    add16 (a[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], b[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>, wire0, );
</span></span><span style=display:flex><span>    add16 (a[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], b[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b1</span>, wire1, );
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// selector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always</span>@(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span>(sel)
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span><span style=color:#f92672>:</span> sum[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>] <span style=color:#f92672>=</span> wire0;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b1</span><span style=color:#f92672>:</span> sum[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>] <span style=color:#f92672>=</span> wire1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ternary operator
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// assign sum[31:16] = sel ? wire1 : wire0;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Module\_Adder-Subtractor}\)</p><ul><li>An adder-subtractor can be built from an adder by optionally negating one of the inputs, which is equivalent to inverting the input then adding 1. The net result is a circuit that can do two operations: (a + b + 0) and (a + ~b + 1).
Build the adder-subtractor below.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/ae/Module_addsub.png alt=module_addsub>
You are provided with a 16-bit adder module, which you need to instantiate twice:<br><code>module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );</code><br>Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. (This can also be viewed as b[31:0] XORed with sub replicated 32 times. See replication operator.). Also connect the sub input to the carry-in of the adder.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> sub,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> cout;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] bin;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> bin <span style=color:#f92672>=</span> {<span style=color:#ae81ff>32</span>{sub}} <span style=color:#f92672>^</span> b;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    add16 (a[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>], bin[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>], sub,  sum[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>], cout);
</span></span><span style=display:flex><span>    add16 (a[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], bin[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>], cout, sum[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>],     );
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h2 id=24-procedures>2.4 Procedures<a hidden class=anchor aria-hidden=true href=#24-procedures>#</a></h2><p>\(\text{Alwaysblock}\)</p><ul><li>For synthesizing hardware, two types of always blocks are relevant:<ul><li>Combinational: <code>always @(*)</code></li><li>Clocked: <code>always @(posedge clk)</code></li></ul></li><li>Combinational always blocks are equivalent to assign statements, thus there is always a way to express a combinational circuit both ways. The choice between which to use is mainly an issue of which syntax is more convenient. <strong>The syntax for code inside a procedural block is different from code that is outside.</strong> Procedural blocks have a richer set of statements (e.g., if-then, case), cannot contain continuous assignments*, but also introduces many new non-intuitive ways of making errors. (*<em>Procedural continuous assignments do exist, but are somewhat different from continuous assignments, and are not synthesizable.</em>)</li><li>For combinational always blocks, always use a sensitivity list of (*). Explicitly listing out the signals is error-prone (if you miss one), and is ignored for hardware synthesis. If you explicitly specify the sensitivity list and miss a signal, the synthesized hardware will still behave as though (*) was specified, but the simulation will not and not match the hardware&rsquo;s behaviour. (In SystemVerilog, use always_comb.)</li><li>A note on wire vs. reg: The left-hand-side of an assign statement must be a <em>net</em> type (e.g., wire), while the left-hand-side of a procedural assignment (in an always block) must be a <em>variable</em> type (e.g., reg). These types (wire vs. reg) have nothing to do with what hardware is synthesized, and is just syntax left over from Verilog&rsquo;s use as a hardware <em>simulation</em> language.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/2/2b/Alwayscomb.png alt=alwayscomb></li><li>Build an AND gate using both an assign statement and a combinational always block.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> out_assign,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> out_alwaysblock
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>assign</span> out_assign <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> b;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    	out_alwaysblock <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Clocked}\)</p><ul><li><p>Clocked always blocks create a blob of combinational logic just like combinational always blocks, but also creates a set of flip-flops (or &ldquo;registers&rdquo;) at the output of the blob of combinational logic. Instead of the outputs of the blob of logic being visible immediately, the outputs are visible only immediately after the next (posedge clk).
<strong>Blocking vs. Non-Backing Assignment</strong></p></li><li><p>There are three types of assignments in Verilog:</p><ul><li><strong>Continuous</strong> assignments (<code>assign x = y;</code>): Can only be used when <strong>not</strong> inside a procedure (&ldquo;always block&rdquo;).</li><li>Procedural <strong>blocking</strong> assignment (<code>x = y;</code>): Can only be used inside a procedure.</li><li>Procedural <strong>non-blocking</strong> assignment (<code>x &lt;= y;</code>): Can only be used inside a procedure.</li></ul></li><li><p>In a <strong>combinational</strong> always block, use <strong>blocking</strong> assignments. In a <strong>clocked</strong> always block, used <strong>non-blocking</strong> assignments. A full understanding of why is not particularly usedful for hardware design and requires a good understanding of how Verilog simulators keep track of events. Not following this rule results in extremely hard to find errors that are both non-deterministic and differ between simulation and synthesized hardware.</p></li><li><p>Build an XOR gate three ways, using an assignment, a combinational always block, and a clocked always block. Note that the clocked always block precedures a different circuit from the other two: There is a flip-flop so the output is delayed.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/4/40/Alwaysff.png alt=alwaysff></p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> clk,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> out_assign,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> out_always_comb,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> out_always_ff   );
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_assign <span style=color:#f92672>=</span> a <span style=color:#f92672>^</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    	out_always_comb <span style=color:#f92672>=</span> a <span style=color:#f92672>^</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#66d9ef>posedge</span> clk) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>		out_always_ff <span style=color:#f92672>&lt;=</span> a <span style=color:#f92672>^</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{If statement}\)</p><ul><li>An if statement usually creates a 2-to-1 multiplexer, selecting one input if the condition is true, and the other input if the condition is false.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/9/9d/Always_if_mux.png alt=always_if_mux></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (condition) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        out <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        out <span style=color:#f92672>=</span> y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><ul><li><p>This is equivalent to using a continuous assignment with a conditional operator:<br><code>assign out = (condition) ? x : y;</code></p></li><li><p>However, the procedural if statement provides a new way to make mistakes. The circuit is combinational only if out is always assigned a value.</p></li><li><p>Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a.
Do the same twice, once using assign statements and once using a procedural if statement.
\(\begin{array}{|c|c|c|}\hline
\text{sel\_b1}&\text{sel\_b2}&\text{out\_assign, out\_always} \\\hline
0&0&a\\\hline
0&1&a\\\hline
1&0&a\\\hline
1&1&b\\\hline
\end{array}\)</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> sel_b1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> sel_b2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> out_assign,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> out_always   ); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_assign <span style=color:#f92672>=</span> sel_b1 <span style=color:#f92672>&amp;</span> sel_b2 <span style=color:#f92672>?</span> b <span style=color:#f92672>:</span> a;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (sel_b1 <span style=color:#f92672>&amp;</span> sel_b2) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        	out_always <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        	out_always <span style=color:#f92672>=</span> a;        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// always @(*) begin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    case ({sel_b1, sel_b2})
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//		2&#39;d0:begin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//			out_always = a;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        2&#39;d1:begin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//			out_always = a;                
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        2&#39;d2:begin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//			out_always = a;                
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        2&#39;d3:begin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//			out_always = b;                
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    endcase
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{If statement latches}\)</p><ul><li><p><strong>A common source of errors: How to avoid making latches</strong></p></li><li><p>When designing circuits, you must think first in terms of circuits:</p><ul><li>I want this logic gate</li><li>I want a combinational blob of logic that has these inputs and produces these outputs</li><li>I want a combinational blob of logic followed by a set of flip-flops</li></ul></li><li><p>What you <em>must not</em> do is write the code first, then hope it generates a proper circuit.</p><ul><li>If (cpu_overheated) then shut_off_computer = 1;</li><li>If (~arrived) then keep_driving = ~gas_tank_empty;</li></ul></li><li><p>Syntactically-correct code does not necessarily result in a reasonable circuit (combinational logic + flip-flops). The usual reason is: &ldquo;What happens in the cases other than those you specified?&rdquo;. Verilog&rsquo;s answer is: Keep the outputs unchanged.</p></li><li><p>This behaviour of &ldquo;keep outputs unchanged&rdquo; means the current state needs to be remembered, and thus produces a latch. Combinational logic (e.g., logic gates) cannot remember any state. Watch out for Warning (10240): &mldr; inferring latch(es)" messages. Unless the latch was intentional, it almost always indicates a bug. Combinational circuits must have a value assigned to all outputs under all conditions. This usually means you always need else clauses or a default value assigned to the outputs.</p></li></ul><p><strong>Demonstration</strong></p><ul><li>The following code contains incorrect behaviour that creates a latch. Fix the bugs so that you will shut off the computer only if it&rsquo;s really overheated, and stop driving if you&rsquo;ve arrived at your destination or you need to refuel.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cpu_overheated)
</span></span><span style=display:flex><span>        shut_off_computer <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>~</span>arrived)
</span></span><span style=display:flex><span>        keep_driving <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>gas_tank_empty;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p><img loading=lazy src=https://hdlbits.01xz.net/mw/images/d/d1/Always_if2.png alt=always_if2></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>      cpu_overheated,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> shut_off_computer,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>      arrived,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>      gas_tank_empty,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> keep_driving  ); <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cpu_overheated)
</span></span><span style=display:flex><span>            shut_off_computer <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            shut_off_computer <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>~</span>arrived)
</span></span><span style=display:flex><span>            keep_driving <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>gas_tank_empty;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            keep_driving <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Case statement}\)</p><ul><li>Case statements in Verilog are nearly equivalent to a sequence of if-elseif-else that compares one expression to a list of others. Its syntax and functionality differs from the switch statement in C.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>     <span style=color:#75715e>// This is a combinational circuit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> (in)
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b1</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>begin</span> 
</span></span><span style=display:flex><span>               out <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b1</span>;  <span style=color:#75715e>// begin-end if &gt;1 statement
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>&#39;bx;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><ul><li><p>The case statement begins with case and each &ldquo;case item&rdquo; ends with a colon. There is no &ldquo;switch&rdquo;.
Each case item can execute <em>exactly one</em> statement. This makes the &ldquo;break&rdquo; used in C unnecessary. But this means that if + you need more than one statement, you must use <code>begin ... end</code>.</p></li><li><p>Duplicate (and partially overlapping) case items are permitted. The first one that matches is used. C does not allow duplicate case items.</p></li><li><p>Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide. Be careful of inferring latches.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#75715e>// synthesis verilog_input_version verilog_2001
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>module</span> top_module ( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sel, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] data0,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] data1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] data2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] data3,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] data4,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] data5,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out   );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span>(sel)
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> data0;
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> data1;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>2</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> data2;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> data3;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> data4;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>5</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> data5;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Priority encoder}\)</p><ul><li>A <em>priority encoder</em> is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input <code>8'b10010000</code> would output 3&rsquo;d4, because bit[4] is first bit that is high.</li><li>Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] pos
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> (in)
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>4&#39;h0</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h0</span>;  <span style=color:#75715e>//0000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;h1</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h0</span>;  <span style=color:#75715e>//0001
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;h2</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h1</span>;  <span style=color:#75715e>//0010
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;h3</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h0</span>;  <span style=color:#75715e>//0011
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;h4</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h2</span>;  <span style=color:#75715e>//0100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;h5</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h0</span>;  <span style=color:#75715e>//0101
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;h6</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h1</span>;  <span style=color:#75715e>//0110
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;h7</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h0</span>;  <span style=color:#75715e>//0111
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;h8</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h3</span>;  <span style=color:#75715e>//1000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;h9</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h0</span>;  <span style=color:#75715e>//1001
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;ha</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h1</span>;  <span style=color:#75715e>//1010
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;hb</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h0</span>;  <span style=color:#75715e>//1011
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;hc</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h2</span>;  <span style=color:#75715e>//1100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;hd</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h0</span>;  <span style=color:#75715e>//1101
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;he</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h1</span>;  <span style=color:#75715e>//1110
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#ae81ff>4&#39;hf</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2&#39;h0</span>;  <span style=color:#75715e>//1111
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#ae81ff>&#39;b0</span>;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Priority encoder with casez}\)</p><ul><li>Build previous problem with <code>casez</code>. If the case items in the case statement supported con&rsquo;t care bits. This is what case<strong>z</strong> is for: It treats bits that have the value z as don&rsquo;t care in the comparison.</li><li>A case statement behaves as though each item is checked sequentially (in reality, a big combinational logic function). Notice how there are certain inputs (e.g., 4&rsquo;b1111) that will match more than one case item. The first match is chosen (so 4&rsquo;b1111 matches the first item, out = 0, but not any of the later ones).<ul><li>There is also a similar casex that treats both x and z as don&rsquo;t-care. I don&rsquo;t see much purpose to using it over casez.</li><li>The digit ? is a synonym for z. so 2&rsquo;bz0 is the same as 2&rsquo;b?0</li></ul></li><li>It may be less error-prone to explicitly specify the priority behaviour rather than rely on the ordering of the case items. For example, the following will still behave the same way if some of the case items were reordered, because any bit pattern can only match at most one case item:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] pos  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>casez</span>(in)
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>8</span>&#39;bzzzzzzz1: pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#ae81ff>&#39;d0</span>;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>8</span>&#39;bzzzzzz10: pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#ae81ff>&#39;d1</span>;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>8</span>&#39;bzzzzz100: pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#ae81ff>&#39;d2</span>;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>8</span>&#39;bzzzz1000: pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#ae81ff>&#39;d3</span>;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>8</span>&#39;bzzz10000: pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#ae81ff>&#39;d4</span>;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>8</span>&#39;bzz100000: pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#ae81ff>&#39;d5</span>;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>8</span>&#39;bz1000000: pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#ae81ff>&#39;d6</span>;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>8</span><span style=color:#ae81ff>&#39;b10000000</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#ae81ff>&#39;d7</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> pos <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span><span style=color:#ae81ff>&#39;d0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Avoiding latches}\)</p><ul><li>Suppose you&rsquo;re building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.<br>\(\begin{array}{|c|c|}\hline
\text{Scancode [15:0]}&\text{Arrow key}\\\hline
\text{16&rsquo;he06b}&\text{left arrow}\\\hline
\text{16&rsquo;he072}&\text{down arrow}\\\hline
\text{16&rsquo;he074}&\text{right arrow}\\\hline
\text{16&rsquo;he075}&\text{up arrow}\\\hline
\text{Anything else}&\text{none}\\\hline
\end{array}\)</li><li>Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.</li><li>To avoid creating latches, all outputs must be assigned a value in all possible conditions. Simply having a <code>default</code> case is not enough. You must assign a value to all four outputs in all four cases and the default case. This can involve a lot of unnecessary typing. One easy way around this is to assign a &ldquo;default value&rdquo; to the outputs <em>before</em> the case statement:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    up <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>; down <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>; left <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>; right <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> (scancode)
</span></span><span style=display:flex><span>        ... <span style=color:#75715e>// Set to 1 as necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><ul><li>This style of code ensures the outputs are assigned a value (of 0) in all possible cases unless the case statement overrides the assignment. This also means that a default: case item becomes unnecessary.</li><li><strong>Reminder</strong>: The logic synthesizer generates a combinational circuit that behaves equivalently to what the code describes.Hardware does not &ldquo;execute&rdquo; the lines of code in sequence.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] scancode,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> left,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> down,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> right,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>reg</span> up  ); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        down <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        up <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span>(scancode)
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>16&#39;he06b</span><span style=color:#f92672>:</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>16&#39;he072</span><span style=color:#f92672>:</span> down <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>16&#39;he074</span><span style=color:#f92672>:</span> right <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>16&#39;he075</span><span style=color:#f92672>:</span> up <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><h2 id=25-more-verilog-features>2.5 More Verilog Features<a hidden class=anchor aria-hidden=true href=#25-more-verilog-features>#</a></h2><p>\(\text{Conditional ternary operator}\)</p><ul><li>Verilog has a ternary conditional operator ( ? : ) much like C:
<code>(condition ? if_true : if_false)</code></li><li>Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a &lt; b). Use the conditional operator to make two-way min circuits, then compose a few of them to create a 4-way min circuit. You&rsquo;ll probably want some wire vectors for the intermediate results.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b, c, d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] min);<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] wire1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] wire2;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> wire1 <span style=color:#f92672>=</span> a <span style=color:#f92672>&gt;</span> b <span style=color:#f92672>?</span> b <span style=color:#f92672>:</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> wire2 <span style=color:#f92672>=</span> c <span style=color:#f92672>&gt;</span> d <span style=color:#f92672>?</span> d <span style=color:#f92672>:</span> c;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> min <span style=color:#f92672>=</span> wire1 <span style=color:#f92672>&gt;</span> wire2 <span style=color:#f92672>?</span> wire2 <span style=color:#f92672>:</span> wire1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><p>\(\text{Reduction operators}\)</p><ul><li>Some syntactic sugar for reduction:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#f92672>&amp;</span> a[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]    <span style=color:#75715e>// AND: a[3] &amp; a[2] &amp; a[1] &amp; a[0]. Equivalent to (a[3:0] == 4&#39;hf)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|</span> b[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]    <span style=color:#75715e>// OR: b[3] | b[2] | b[1] | b[0]. Equivalent to (b[3:0] != 4&#39;h0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>^</span> c[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]    <span style=color:#75715e>// XOR: c[2] ^ c[1] ^ c[0]
</span></span></span></code></pre></div><ul><li>Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use &ldquo;even&rdquo; parity, where the parity bit is just the XOR of all 8 data bits.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> parity); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> parity <span style=color:#f92672>=</span> <span style=color:#f92672>^</span> in;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Reduction: Even wider gates}\)</p><ul><li>Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs:<ul><li>out_and: output of a 100-input AND gate.</li><li>out_or: output of a 100-input OR gate.</li><li>out_xor: output of a 100-input XOR gate.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_and,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_or,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_xor );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_and <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span> in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_or <span style=color:#f92672>=</span> <span style=color:#f92672>|</span> in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_xor <span style=color:#f92672>=</span> <span style=color:#f92672>^</span> in;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Combinational for-loop: Vector reversal}\)</p><ul><li>Given a 100-bit input vector [99:0], reverse its bit ordering.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>100</span>; i<span style=color:#f92672>++</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            out[i] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>99</span> <span style=color:#f92672>-</span> i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Combinational for-loop: 255-bit population count}\)</p><ul><li>A &ldquo;population count&rdquo; circuit counts the number of &lsquo;1&rsquo;s in an input vector. Build a population count circuit for a 255-bit input vector.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>254</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        out <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>255</span>; i<span style=color:#f92672>++</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            out <span style=color:#f92672>+=</span> in[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Generate for-loop: 100-bit binary adder}\)</p><ul><li>Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        {cout[<span style=color:#ae81ff>0</span>], sum[<span style=color:#ae81ff>0</span>]} <span style=color:#f92672>=</span> a[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> b[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> cin;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>100</span>; i<span style=color:#f92672>++</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            {cout[i], sum[i]} <span style=color:#f92672>=</span> a[i] <span style=color:#f92672>+</span> b[i] <span style=color:#f92672>+</span> cout[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Generate for-loop: 100-digit BCD adder}\)</p><ul><li>You are provided with a BCD one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> bcd_fadd (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>     cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span>   cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum );
</span></span></code></pre></div><ul><li>Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) and a carry-in to produce a 100-digit sum and carry out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>399</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>399</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span>[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] carryin;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>generate</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>genvar</span> i;
</span></span><span style=display:flex><span>        bcd_fadd(a[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>], b[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>], cin, carryin[<span style=color:#ae81ff>0</span>], sum[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>400</span>; i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>begin</span><span style=color:#f92672>:</span>adder
</span></span><span style=display:flex><span>            bcd_fadd(a[i<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>i], b[i<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>i], carryin[i<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], carryin[i<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>], sum[i<span style=color:#f92672>+</span><span style=color:#ae81ff>3</span><span style=color:#f92672>:</span>i]);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assign</span> cout <span style=color:#f92672>=</span> carryin[<span style=color:#ae81ff>99</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>endgenerate</span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><h1 id=3-circuits>3 Circuits<a hidden class=anchor aria-hidden=true href=#3-circuits>#</a></h1><h2 id=31-combinational-logic>3.1 Combinational Logic<a hidden class=anchor aria-hidden=true href=#31-combinational-logic>#</a></h2><h3 id=311-basic-gates>3.1.1 Basic Gates<a hidden class=anchor aria-hidden=true href=#311-basic-gates>#</a></h3><p>\(\text{Wire}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/d/d7/Exams_m2014q4h.png alt=q4h></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{GND}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/5/54/Exams_m2014q4i.png alt=GND></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{NOR}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/e/e9/Exams_m2014q4e.png alt=NOR></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(in1<span style=color:#f92672>|</span>in2);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Another Gate}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/b/b6/Exams_m2014q4f.png alt=AnotherGate></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in1 <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>in2);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Two gates}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/e/e6/Exams_m2014q4g.png alt=TwoGates></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> in3,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> w1;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1 <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(in1<span style=color:#f92672>^</span>in2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> w1<span style=color:#f92672>^</span>in3;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{More logic gates}\)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_and,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_or,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_xor,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_nand,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_nor,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_xnor,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_anotb
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_and <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_or <span style=color:#f92672>=</span> a <span style=color:#f92672>|</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_xor <span style=color:#f92672>=</span> a <span style=color:#f92672>^</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_nand <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a <span style=color:#f92672>&amp;</span> b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_nor <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a <span style=color:#f92672>|</span> b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_xnor <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a <span style=color:#f92672>^</span> b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_anotb <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>b);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#75715e>//    and(out_and, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    or(out_or, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    xor(out_xor, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    nand(out_nand, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    nor(out_nor, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    xnor(out_xnor, a, b);
</span></span></span><span style=display:flex><span><span style=color:#75715e>//    and(out_anotb, a , ~b);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{7420 chip}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/4/48/7420.png alt=7420></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> p1a, p1b, p1c, p1d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> p1y,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> p2a, p2b, p2c, p2d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> p2y );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> p1y <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(p1a <span style=color:#f92672>&amp;</span> p1b <span style=color:#f92672>&amp;</span> p1c <span style=color:#f92672>&amp;</span> p1d);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> p2y <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(p2a <span style=color:#f92672>&amp;</span> p2b <span style=color:#f92672>&amp;</span> p2c <span style=color:#f92672>&amp;</span> p2d);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>\
</span></span></code></pre></div><hr><p>\(\text{Truth tables}\)<br>\(\begin{array}{|c|ccc|c|}\hline
\text{Row}&&\text{Inputs}&&\text{Outputs}\\\hline
\text{number}&\text{x3}&\text{x2}&\text{x1}&\text{f}\\\hline
0&0&0&0&0\\\hline
1&0&0&1&0\\\hline
2&0&1&0&1\\\hline
3&0&1&1&1\\\hline
4&1&0&0&0\\\hline
5&1&0&1&1\\\hline
6&1&1&0&0\\\hline
7&1&1&1&1\\\hline
\end{array}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/f/f6/Truthtable1.png alt=truthtable1></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x3,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> f );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> f <span style=color:#f92672>=</span> ((<span style=color:#f92672>~</span>x3)<span style=color:#f92672>&amp;</span>x2)<span style=color:#f92672>|</span>(x3<span style=color:#f92672>&amp;</span>x1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Two-bit equality}\)</p><ul><li>Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] A, <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] B, <span style=color:#66d9ef>output</span> z ); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (A <span style=color:#f92672>==</span> B);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Simple circuit A}\)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (<span style=color:#66d9ef>input</span> x, <span style=color:#66d9ef>input</span> y, <span style=color:#66d9ef>output</span> z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (x<span style=color:#f92672>^</span>y) <span style=color:#f92672>&amp;</span>x;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Simple circuit B}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/6/6a/Mt2015_q4b.png alt=q4b></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( <span style=color:#66d9ef>input</span> x, <span style=color:#66d9ef>input</span> y, <span style=color:#66d9ef>output</span> z );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (x<span style=color:#f92672>==</span>y);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assign z = ~(x ^ y);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Combine circuits A and B}\)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/f/f5/Mt2015_q4.png alt=q4></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (<span style=color:#66d9ef>input</span> x, <span style=color:#66d9ef>input</span> y, <span style=color:#66d9ef>output</span> z);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> o1, o2, o3, o4;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    A ia1(x,y,o1);
</span></span><span style=display:flex><span>    B ib1(x,y,o2);
</span></span><span style=display:flex><span>    A ia2(x,y,o3);
</span></span><span style=display:flex><span>    B ib2(x,y,o4);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (o1<span style=color:#f92672>|</span>o2)<span style=color:#f92672>^</span>(o3<span style=color:#f92672>&amp;</span>o4);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> A(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x, y,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> z);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> (x <span style=color:#f92672>^</span> y) <span style=color:#f92672>&amp;</span> x; 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> B(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> x, y,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> z);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> x <span style=color:#f92672>~^</span> y;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Ringer}\)</p><ul><li>Suppose you are designing a circuit to control a cellphone&rsquo;s ringer and vibration motor. Whenever the phone needs to ring from an incoming call (<code>input ring</code>), your circuit must either turn on the ringer (<code>output ringer = 1</code>) or the motor (<code>output motor = 1</code>), but not both. If the phone is in vibrate mode (<code>input vibrate_mode = 1</code>), turn on the motor. Otherwise, turn on the ringer.</li><li>Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.</li><li><strong>Design hint</strong>: When designing circuits, one often has to think of the problem &ldquo;backwards&rdquo;, starting from the outputs then working backwards towards the inputs. This is often the opposite of how one would think about a (sequential, imperative) programming problem, where one would look at the inputs first then decide on an action (or output). For sequential programs, one would often think &ldquo;If (inputs are ___ ) then (output should be ___ )&rdquo;. On the other hand, hardware designers often think &ldquo;The (output should be ___ ) when (inputs are ___ )&rdquo;.</li><li>The above problem description is written in an imperative form suitable for software programming (<em>if ring then do this</em>), so you must convert it to a more declarative form suitable for hardware implementation (<code>assign ringer = ___</code>). Being able to think in, and translate between, both styles is one of the most important skills needed for hardware design.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/9/96/Ringer.png alt=ringer></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> ring,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> vibrate_mode,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> ringer,       <span style=color:#75715e>// Make sound
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span> motor         <span style=color:#75715e>// Vibrate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> ringer <span style=color:#f92672>=</span> ring <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>vibrate_mode);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> motor <span style=color:#f92672>=</span> ring <span style=color:#f92672>&amp;</span> (vibrate_mode);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Thermostat}\)</p><ul><li>A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.</li><li>The thermostat can be in one of two modes: <strong>heating</strong> (<code>mode = 1</code>) and <strong>cooling</strong> (<code>mode = 0</code>). In heating mode, turn the heater on when it is too cold (<code>too_cold = 1</code>) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (<code>too_hot = 1</code>), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.</li><li>Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.</li><li>畫出真值表<br>\(\begin{array}{|cccc|ccc|}\hline
\text{mode}&\text{too\_cold}&\text{too\_hot}&\text{fan on}&\text{heater}&\text{aircon}&\text{fan}\\\hline
0&0&0&0&0&0&0\\\hline
0&0&0&1&0&0&1\\\hline
0&0&1&0&0&1&1\\\hline
0&0&1&1&0&1&1\\\hline
0&1&0&0&0&0&0\\\hline
0&1&0&1&0&0&1\\\hline
0&1&1&0&0&1&1\\\hline
0&1&1&1&0&1&1\\\hline
1&0&0&0&0&0&0\\\hline
1&0&0&1&0&0&1\\\hline
1&0&1&0&0&0&0\\\hline
1&0&1&1&0&0&1\\\hline
1&1&0&0&1&0&1\\\hline
1&1&0&1&1&0&1\\\hline
1&1&1&0&1&0&1\\\hline
1&1&1&1&1&0&1\\\hline
\end{array}\)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> too_cold,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> too_hot,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> mode,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> fan_on,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> heater,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> aircon,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> fan);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> heater <span style=color:#f92672>=</span> mode <span style=color:#f92672>&amp;</span> too_cold;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> aircon <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>mode) <span style=color:#f92672>&amp;</span> too_hot;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> fan <span style=color:#f92672>=</span> heater<span style=color:#f92672>|</span>aircon<span style=color:#f92672>|</span>fan_on;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{3-bit population count}\)</p><ul><li>A &ldquo;population count&rdquo; circuit counts the number of &lsquo;1&rsquo;s in an input vector. Build a population count circuit for a 3-bit input vector.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        out <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>2</span>; i<span style=color:#f92672>++</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            out <span style=color:#f92672>+=</span> in[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><ul><li><em>此解會產生鎖存器，不建議使用。</em></li></ul><hr><p>\(\text{Gates and vectors}\)</p><ul><li>You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour:<ul><li><strong>out_both</strong>: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the <strong>left</strong> (higher index) are &lsquo;1&rsquo;. For example, <code>out_both[2]</code> should indicate if <code>in[2]</code> and <code>in[3]</code> are both 1. Since <code>in[3]</code> has no neighbour to the left, the answer is obvious so we don&rsquo;t need to know <code>out_both[3]</code>.</li><li><strong>out_any</strong>: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the <strong>right</strong> are &lsquo;1&rsquo;. For example, <code>out_any[2]</code> should indicate if either <code>in[2]</code> or <code>in[1]</code> are 1. Since <code>in[0]</code> has no neighbour to the right, the answer is obvious so we don&rsquo;t need to know <code>out_any[0]</code>.</li><li><strong>out_different</strong>: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the <strong>left</strong>. For example, <code>out_different[2]</code> should indicate if <code>in[2]</code> is different from <code>in[3]</code>. For this part, treat the vector as wrapping around, so <code>in[3]</code>&rsquo;s neighbour to the left is <code>in[0]</code>.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_both,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] out_any,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_different );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_both[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;</span> in[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_any[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>|</span> in[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_different[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>^</span> {in[<span style=color:#ae81ff>0</span>], in[<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>]};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// always @(*) begin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    out_different[3] = (in[3] != in[0]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    for (int i = 0; i &lt;= 2; i++) begin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        out_both[i] = in[i] &amp; in[i+1];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        out_any[i+1] = in[i+1] | in[i];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//        out_different[i] = (in[i] != in[i+1]);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//    end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// end
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Even longer vectors}\)</p><ul><li>You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour:<ul><li><strong>out_both</strong>: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the <strong>left</strong> are &lsquo;1&rsquo;. For example, <code>out_both[98]</code> should indicate if <code>in[98]</code> and <code>in[99]</code> are both 1. Since <code>in[99]</code> has no neighbour to the left, the answer is obvious so we don&rsquo;t need to know <code>out_both[99]</code>.</li><li><strong>out_any</strong>: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the <strong>right</strong> are &lsquo;1&rsquo;. For example, <code>out_any[2]</code> should indicate if either <code>in[2]</code> or <code>in[1]</code> are 1. Since <code>in[0]</code> has no neighbour to the right, the answer is obvious so we don&rsquo;t need to know <code>out_any[0]</code>.</li><li><strong>out_different</strong>: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the <strong>left</strong>. For example, <code>out_different[98]</code> should indicate if <code>in[98]</code> is different from <code>in[99]</code>. For this part, treat the vector as wrapping around, so <code>in[99]</code>&rsquo;s neighbour to the left is <code>in[0]</code>.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>98</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_both,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] out_any,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_different );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_both[<span style=color:#ae81ff>98</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>98</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;</span> in[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_any[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>|</span> in[<span style=color:#ae81ff>98</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_different[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>^</span> {in[<span style=color:#ae81ff>0</span>], in[<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>]};    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h3 id=312-multiplexers>3.1.2 Multiplexers<a hidden class=anchor aria-hidden=true href=#312-multiplexers>#</a></h3><p>\(\text{2-to-1 multiplexer}\)</p><ul><li>Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b, sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out ); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> sel <span style=color:#f92672>?</span> b <span style=color:#f92672>:</span> a;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{2-to-1 bus multiplexer}\)</p><ul><li>Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> sel <span style=color:#f92672>?</span> b <span style=color:#f92672>:</span> a;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{9-to-1 multiplexer}\)</p><ul><li>Create a 16-bit 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to &lsquo;1&rsquo;.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b, c, d, e, f, g, h, i,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span>(sel)
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d0</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d1</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d2</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d3</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> d;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d4</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d5</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> f;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d6</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> g;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d7</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> h;
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>4</span><span style=color:#ae81ff>&#39;d8</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> out <span style=color:#f92672>=</span> <span style=color:#ae81ff>&#39;1</span>;  <span style=color:#75715e>// special literal syntax with all bits set to 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>endcase</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{256-to-1 multiplexer}\)</p><ul><li>Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should be select <code>in[0]</code>, sel1 selectes bits <code>in[1]</code>, sel=2 selects bits <code>in[2]</code>, etc.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>255</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in[sel];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{256-to-1 4-bit multiplexer}\)</p><ul><li>Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits <code>in[3:0]</code>,sel=1 selects bits <code>in[7:4]</code>, sel=2 selects bits <code>in[11:8]</code>, etc.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>1023</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sel,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in[sel<span style=color:#f92672>*</span><span style=color:#ae81ff>4</span><span style=color:#f92672>+:</span><span style=color:#ae81ff>4</span>];  <span style=color:#75715e>// special syntax
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// assign out = in[sel*4+3-:4];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// assign out = {in[sel*4+3],in[sel*4+2],in[sel*4+1],in[sel*4+0]};
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h3 id=313-arithmetic-circuits>3.1.3 Arithmetic Circuits<a hidden class=anchor aria-hidden=true href=#313-arithmetic-circuits>#</a></h3><p>\(\text{Half adder}\)</p><ul><li>Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout, sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Full adder}\)</p><ul><li>Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and a carry-out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b, cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout, sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>+</span> cin;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{3-bit binary adder}\)</p><ul><li>Now that you know how to build a full adder, make 3 instances of it to create a 3-bit binary ripple-carry adder. The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last full adder, and is the carry-out you usually see.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fulladder f1(a[<span style=color:#ae81ff>0</span>], b[<span style=color:#ae81ff>0</span>], cin,     cout[<span style=color:#ae81ff>0</span>], sum[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    fulladder f2(a[<span style=color:#ae81ff>1</span>], b[<span style=color:#ae81ff>1</span>], cout[<span style=color:#ae81ff>0</span>], cout[<span style=color:#ae81ff>1</span>], sum[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    fulladder f3(a[<span style=color:#ae81ff>2</span>], b[<span style=color:#ae81ff>2</span>], cout[<span style=color:#ae81ff>1</span>], cout[<span style=color:#ae81ff>2</span>], sum[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> fulladder(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b, cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout, sum);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>+</span> cin;
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Adder}\)</p><ul><li>Implement the following circuit:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/d/d2/Exams_m2014q4j.png alt=Adder></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] x,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] y, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// assign sum = x + y;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    FA f1(x[<span style=color:#ae81ff>0</span>], y[<span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>0</span>,       cout[<span style=color:#ae81ff>0</span>], sum[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    FA f2(x[<span style=color:#ae81ff>1</span>], y[<span style=color:#ae81ff>1</span>], cout[<span style=color:#ae81ff>0</span>], cout[<span style=color:#ae81ff>1</span>], sum[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    FA f3(x[<span style=color:#ae81ff>2</span>], y[<span style=color:#ae81ff>2</span>], cout[<span style=color:#ae81ff>1</span>], cout[<span style=color:#ae81ff>2</span>], sum[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    FA f4(x[<span style=color:#ae81ff>3</span>], y[<span style=color:#ae81ff>3</span>], cout[<span style=color:#ae81ff>2</span>], sum[<span style=color:#ae81ff>4</span>],  sum[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> FA (
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>input</span> a, b, cin,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>output</span> cout, sum);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>+</span> cin;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Signed addition overflow}\)</p><ul><li>Assume that you have two 8-bit 2&rsquo;s complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] s,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> overflow
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> s <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> overflow <span style=color:#f92672>=</span> (a[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>==</span> b[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>&amp;&amp;</span> a[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>!=</span> s[<span style=color:#ae81ff>7</span>]) <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{100-bit binary adder}\)</p><ul><li>Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>99</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {cout, sum} <span style=color:#f92672>=</span> cin <span style=color:#f92672>+</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{4-digit BCD adder}\)</p><ul><li>You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> bcd_fadd (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>     cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span>   cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum );
</span></span></code></pre></div><p>Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> cin,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> cout,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sum );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] wl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bcd_fadd u0 (a[ <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>], b[ <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>],   cin, wl[<span style=color:#ae81ff>0</span>], sum[ <span style=color:#ae81ff>3</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    bcd_fadd u1 (a[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>4</span>], b[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>4</span>], wl[<span style=color:#ae81ff>0</span>], wl[<span style=color:#ae81ff>1</span>], sum[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>4</span>]);
</span></span><span style=display:flex><span>    bcd_fadd u2 (a[<span style=color:#ae81ff>11</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>], b[<span style=color:#ae81ff>11</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>], wl[<span style=color:#ae81ff>1</span>], wl[<span style=color:#ae81ff>2</span>], sum[<span style=color:#ae81ff>11</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>]);
</span></span><span style=display:flex><span>    bcd_fadd u3 (a[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>], b[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>], wl[<span style=color:#ae81ff>2</span>],  cout, sum[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>12</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h3 id=314-karnaugh-map-to-circuit>3.1.4 Karnaugh Map to Circuit<a hidden class=anchor aria-hidden=true href=#314-karnaugh-map-to-circuit>#</a></h3><p>\(\text{Kmap1}\)</p><ul><li>Implement the circuit described by the Karnaugh map below.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/2/20/Kmap1.png alt=kmap1></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> a <span style=color:#f92672>|</span> b <span style=color:#f92672>|</span> c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Kmap2}\)</p><ul><li>Implement the circuit described by the Karnaugh map below.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/4/4d/Kmap2.png alt=kmap2></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a&#39;d&#39; + b&#39;c&#39; + acd + a&#39;bc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>wire</span> w1, w2, w3, w4;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1 <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>a)<span style=color:#f92672>&amp;</span>(<span style=color:#f92672>~</span>d);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w2 <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>b)<span style=color:#f92672>&amp;</span>(<span style=color:#f92672>~</span>c);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w3 <span style=color:#f92672>=</span> a<span style=color:#f92672>&amp;</span>c<span style=color:#f92672>&amp;</span>d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w4 <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>a)<span style=color:#f92672>&amp;</span>b<span style=color:#f92672>&amp;</span>c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> w1<span style=color:#f92672>|</span>w2<span style=color:#f92672>|</span>w3<span style=color:#f92672>|</span>w4;
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Kmap3}\)</p><ul><li>Implement the circuit described by the Karnaugh map below.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/1/1f/Kmap3.png alt=kmap3></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a + b&#39;c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> a <span style=color:#f92672>|</span> (<span style=color:#f92672>~</span>b<span style=color:#f92672>&amp;</span>c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Kmap4}\)</p><ul><li>Implement the circuit described by the Karnaugh map below.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/9/98/Kmap4.png alt=kmap4></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> b <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>!=</span> d)
</span></span><span style=display:flex><span>            out <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>!=</span> b <span style=color:#f92672>&amp;&amp;</span> c <span style=color:#f92672>==</span> d)
</span></span><span style=display:flex><span>            out <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            out <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Minimum SOP and POS}\)</p><ul><li>A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.</li><li>Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_sop,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_pos
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// f = d3 + m7 + d11 + m15 + m2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// f = cd + a&#39;b&#39;c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> out_sop <span style=color:#f92672>=</span> (c <span style=color:#f92672>&amp;</span> d) <span style=color:#f92672>|</span> (<span style=color:#f92672>~</span>a <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>b <span style=color:#f92672>&amp;</span> c);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// f&#39; = m0 + m1 + m4 + m5 + m6 + d8 + m9 + m10 + d11 + d12 + m13 + m14
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// f&#39; = c&#39; + ab&#39; + bd&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// f = (c)(a&#39;+b)(b&#39;+d)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> out_pos <span style=color:#f92672>=</span> c <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>a <span style=color:#f92672>|</span> b) <span style=color:#f92672>&amp;</span> (<span style=color:#f92672>~</span>b <span style=color:#f92672>|</span> d);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Karnaugh map}\)</p><ul><li>Consider the function f shown in the Karnaugh map below.</li><li>Implement this function. <strong>d</strong> is don&rsquo;t-care, which means you may choose to output whatever value is convenient.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/a2/Exams_m2014q3.png alt=q3></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] x,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> f );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// x[2]x[4] + x[1]&#39;x[3]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> f <span style=color:#f92672>=</span> (x[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>4</span>]) <span style=color:#f92672>|</span> (<span style=color:#f92672>~</span>x[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{Karnaugh map}\)</p><ul><li>Consider the function f shown in the Karnaugh map below. Implement this function.
(The original exam question asked for simplified SOP and POS forms of the function.)
<img loading=lazy src="https://hdlbits.01xz.net/mw/thumb.php?f=Exams_2012q1g.png&width=195" alt=q1g></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>] x,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> f
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// x[2]&#39;x[4]&#39; + x[1]&#39;x[3] + x[2]x[3]x[4]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> f <span style=color:#f92672>=</span> (<span style=color:#f92672>~</span>x[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>x[<span style=color:#ae81ff>4</span>]) <span style=color:#f92672>|</span> (<span style=color:#f92672>~</span>x[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>3</span>]) <span style=color:#f92672>|</span> (x[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>&amp;</span> x[<span style=color:#ae81ff>4</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{K-map implemented with a multiplexer}\)</p><ul><li>For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.</li><li>You are implementing just the portion labelled <strong>top_module</strong>, such that the entire circuit (including the 4-to-1 mux) implements the K-map.</li><li>(The requirement to use only 2-to-1 multiplexers exists because the original exam question also wanted to test logic function simplification using K-maps and how to synthesize logic functions using only multiplexers. If you wish to treat this as purely a Verilog exercise, you may ignore this constraint and write the module any way you wish.)
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/a6/Ece241_2014_q3.png alt=q3>
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/b/bc/Ece241_2014_q3mux.png alt=q3mux></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> c,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] mux_in
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> mux_in[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> c<span style=color:#f92672>|</span>d;  <span style=color:#75715e>// 0111
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> mux_in[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>; <span style=color:#75715e>// 0000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> mux_in[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>d;   <span style=color:#75715e>// 1001
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>assign</span> mux_in[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> c<span style=color:#f92672>&amp;</span>d;  <span style=color:#75715e>// 0010
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h2 id=32-sequential-logic>3.2 Sequential Logic<a hidden class=anchor aria-hidden=true href=#32-sequential-logic>#</a></h2><h3 id=321-latches-and-flip-flops>3.2.1 Latches and Flip-Flops<a hidden class=anchor aria-hidden=true href=#321-latches-and-flip-flops>#</a></h3><h3 id=322-counters>3.2.2 Counters<a hidden class=anchor aria-hidden=true href=#322-counters>#</a></h3><h3 id=323-shift-registers>3.2.3 Shift Registers<a hidden class=anchor aria-hidden=true href=#323-shift-registers>#</a></h3><h3 id=324-more-circuits>3.2.4 More Circuits<a hidden class=anchor aria-hidden=true href=#324-more-circuits>#</a></h3><h3 id=325-finite-state-machines>3.2.5 Finite State Machines<a hidden class=anchor aria-hidden=true href=#325-finite-state-machines>#</a></h3><h2 id=33-building-larger-circuits>3.3 Building Larger Circuits<a hidden class=anchor aria-hidden=true href=#33-building-larger-circuits>#</a></h2><h1 id=4-verification-reading-simulations>4 Verification: Reading Simulations<a hidden class=anchor aria-hidden=true href=#4-verification-reading-simulations>#</a></h1><h2 id=41-finding-bugs-in-code>4.1 Finding bugs in code<a hidden class=anchor aria-hidden=true href=#41-finding-bugs-in-code>#</a></h2><h2 id=42-build-a-circuit-from-a-simulation-waveform>4.2 Build a circuit from a simulation waveform<a hidden class=anchor aria-hidden=true href=#42-build-a-circuit-from-a-simulation-waveform>#</a></h2><h1 id=5-verification-writing-testbenches>5 Verification: Writing Testbenches<a hidden class=anchor aria-hidden=true href=#5-verification-writing-testbenches>#</a></h1><h1 id=6-cs450>6 CS450<a hidden class=anchor aria-hidden=true href=#6-cs450>#</a></h1></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/vhdl/>VHDL</a></li><li><a href=http://intervalrain.github.io/tags/programming/>Programming</a></li><li><a href=http://intervalrain.github.io/tags/verilog/>Verilog</a></li></ul><nav class=paginav><a class=prev href=http://intervalrain.github.io/posts/c++/stl_pair/><span class=title>« Prev Page</span><br><span>[C++] The C++ Standard Template Library(STL) - pair</span></a>
<a class=next href=http://intervalrain.github.io/posts/device/simulationconvergece/><span class=title>Next Page »</span><br><span>[TCAD] 模擬收斂問題</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>