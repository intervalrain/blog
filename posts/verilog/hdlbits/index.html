<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[VHDL] HDLbits | Rain's Blog</title><meta name=keywords content="VHDL,Programming,Verilog"><meta name=description content="Desc Text."><meta name=author content="Rain Hu"><link rel=canonical href=https://intervalrain.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.7bdb1411b29ec9fed2b6395a081eabcb3262e7311bda855249d433c8b30a926e.css integrity="sha256-e9sUEbKeyf7StjlaCB6ryzJi5zEb2oVSSdQzyLMKkm4=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://intervalrain.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://intervalrain.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://intervalrain.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://intervalrain.github.io/apple-touch-icon.png><link rel=mask-icon href=http://intervalrain.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="[VHDL] HDLbits"><meta property="og:description" content="Desc Text."><meta property="og:type" content="article"><meta property="og:url" content="http://intervalrain.github.io/posts/verilog/hdlbits/"><meta property="og:image" content="http://intervalrain.github.io/images/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-28T00:10:20+08:00"><meta property="article:modified_time" content="2022-05-28T00:10:20+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://intervalrain.github.io/images/cover.jpg"><meta name=twitter:title content="[VHDL] HDLbits"><meta name=twitter:description content="Desc Text."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://intervalrain.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[VHDL] HDLbits","item":"http://intervalrain.github.io/posts/verilog/hdlbits/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[VHDL] HDLbits","name":"[VHDL] HDLbits","description":"Desc Text.","keywords":["VHDL","Programming","Verilog"],"articleBody":"HDLBits  HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。 由教學的題型由淺入深，逐步建立起電路設計的技能。 每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。\n 1 Getting Started \\(\\text{assign one}\\)\n Build a circuit with no inputs and one output. The output should always drive 1 (or logic high).  module top_module( output one);   assign one = 1'b1;  endmodule  \\(\\text{assign zero}\\)\n Build a circuit with no inputs and one output that outputs a constant 0.  module top_module(  output zero );   assign zero = 1'b0;  endmodule 2 Verilog Language 2.1 Basics \\(\\text{wire}\\)\n Create a module with one input and ont output that behaves like a wire   module top_module( input in, output out);   assign out = in;  endmodule  \\(\\text{multi-in-out}\\)\n Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:   module top_module(  input a,b,c,  output w,x,y,z );   assign w = a;  assign x = b;  assign y = b;  assign z = c;  endmodule  \\(\\text{not gate}\\)\n Create a module that implements a NOT gate.   module top_module( input in, output out );   assign out = ~in;  endmodule  \\(\\text{and gate}\\)\n Create a module that implments an AND gate.   module top_module(  input a,b,  output out );   assign out = a \u0026 b;  endmodule  \\(\\text{nor gate}\\)\n Create a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog.   module top_module(  input a,b,  output out );   assign out = ~(a|b);  endmodule  \\(\\text{xnor gate}\\)\n Create a module that implements a XNOR gate.   module top_module(  input a, b,  output out );   assign out = ~(a^b);  endmodule  \\(\\text{wire declaration}\\)\n Implement following circuits. Create two intermediate wires to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire out, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.   module top_module(  input a,b,c,d,  output out, out_n );   wire w1, w2;  assign w1 = a \u0026 b;  assign w2 = c \u0026 d;  assign out = w1 | w2;  assign out_n = ~out;  endmodule  \\(\\text{7458}\\)\n The 7458 is a chip with four AND gates and two OR gates. Create a module with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs.   module top_module(  input p1a, p1b, p1c, p1d, p1e, p1f,  output p1y,  intput p2a, p2b, p2c, p2d,  output p2y );   wire w1a, w1b;  wire w2a, w2b;   assign w1a = p1a \u0026 p1b \u0026 p1c;  assign w1b = p1d \u0026 p1e \u0026 p1f;  assign p1y = w1a | w1b;  assign w2a = p2a \u0026 p2b;  assign w2b = p2c \u0026 p2d;  assign p2y = w2a | w2b;  endmodule 2.2 Vectors \\(\\text{vector}\\)\n Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect outputs o0 to the input vector’s position 0, o1 to position 1, etc.\nIn a diagram, a tick mark with a number next to it indicates the width of the vector (or “bus”), rather than drawing a separate line for each bit in the vector.   module top_module (  input wire [2:0] vec,  output wire [2:0] outv,  output wire o2,  output wire o1,  output wire o0 );   assign outv = vec;  assign o0 = vec[0];  assign o1 = vec[1];  assign o2 = vec[2];  endmodule  \\(\\text{vector select}\\)\n Build a combinational circuit that splits an input half-word (16 bits, [15:0]) into lower [7:0] and upper [15:8] bytes.  module top_module (  input [15:0] in,  output [7:0] out_hi,  output [7:0] out_lo );   assign out_hi = in[15:8];  assign out_lo = in[7:0];  endmodule  \\(\\text{vector swap}\\)\n A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of the 4-byte word.\nAaaaaaaaBbbbbbbbCcccccccDddddddd = DdddddddCcccccccBbbbbbbbAaaaaaaa\nThis operation is often used when the endianness of a piece of data needs to be swapped, for example between little-endian x86 systems and the big-endian formats used in many Internet protocols.  module top_module (  input [31:0] in,  output [31:0] out );  assign out[31:24] = in[ 7: 0];  assign out[23:16] = in[15: 8];  assign out[15: 8] = in[23:16];  assign out[ 7: 0] = in[31:24];  endmodule  \\(\\text{vector gates}\\)\n uild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.   module top_module (  input [2:0] a,  input [2:0] b,  output [2:0] out_or_bitwise,  output out_or_logical,  output [5:0] out_not );   assign out_or_bitwise = a | b;  assign out_or_logical = a || b;  assign out_not[2:0] = ~a;  assign out_not[5:3] = ~b;  endmodule  \\(\\text{gate-prefix vector}\\)\n Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs:  out_and: output of a 4-input AND gate. out_or: output of a 4-input OR gate. out_xor: outout of a 4-input XOR gate.    module top_module (  input [3:0] in,  output out_and,  output out_or,  output out_xor );   assign out_and = \u0026 in;  assign out_or = | in;  assign out_xor = ^ in;  endmodule  \\(\\text{vector concatenate}\\)\n Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for   module top_module (  input [4:0] a, b, c, d, e, f,  output [7:0] w, x, y, z );   assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};  endmodule  \\(\\text{vector reverse}\\)\n Given an 8-bit input vector [7:0], reverse its bit ordering.  module top_module(  input [7:0] in,  output [7:0] out );   assign {out[0], out[1], out[2], out[3], out[4], out[5], out[6], out[7]} = in  endmodule module top_module(  input [7:0] in,  output [7:0] out );   always @(*) begin  for (int i=0; i8; i++)  out[i] = in[8-i-1];  end  endmodule module top_module(  input [7:0] in,  output [7:0] out );  \tgenerate \tgenvar i; \tfor (i=0; i8; i = i+1) begin: my_block_name \tassign out[i] = in[8-i-1]; \tend \tendgenerate  endmodule  \\(\\text{vector replication}\\)\n Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.  module top_module (  input [7:0] in,  output [31:0] out );   assign out = {{24{in[7]}}, in};  endmodule  \\(\\text{vector replication2}\\)\n Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.   module top_module (  input a, b, c, d, e,  output [24:0] out );   assign out = ~{{5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}}} ^ {5{a,b,c,d,e}};  endmodule 2.3 Modules: Hierarchy By now, you’re familiar with a module, which is a circuit that interacts with its outside through input and output ports. Larger, more complex circuits are built by composing bigger modules out of smaller modules and other pieces (such as assign statements and always blocks) connected together. This forms a hierarchy, as modules can contain instances of other modules.\nThe figure below shows a very simple circuit with a sub-module. In this exercise, create one instance of module mod_a, then connect the module’s three pins (in1, in2, and out) to your top-level module’s three ports (wires a, b, and out). The module mod_a is provided for you — you must instantiate it.\nWhen connecting modules, only the ports on the module are important. You do not need to know the code inside the module. The code for module mod_a looks like this:\nmodule mod_a ( input in1, input in2, output out );  // Module body endmodule The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written inside another module’s body (Code for different modules are not nested).\nYou may connect signals to the module by port name or port position. For extra practice, try both methods. Connecting Signals to Module Ports\nThere are two commonly-used methods to connect a wire to a port: by position or by name.\nBy position\nThe syntax to connect wires to ports by position should be familiar, as it uses a C-like syntax. When instantiating a module, ports are connected left to right according to the module’s declaration. For example:\nmod_a instance1 ( wa, wb, wc );\nThis instantiates a module of type mod_a and gives it an instance name of “instance1”, then connects signal wa (outside the new module) to the first port (in1) of the new module, wb to the second port (in2), and wc to the third port (out). One drawback of this syntax is that if the module’s port list changes, all instantiations of the module will also need to be found and changed to match the new module.\nBy name\nConnecting signals to a module’s ports by name allows wires to remain correctly connected even if the port list changes. This syntax is more verbose, however.\nmod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );\nThe above line instantiates a module of type mod_a named “instance2”, then connects signal wa (outside the module) to the port named in1, wb to the port named in2, and wc to the port named out. Notice how the ordering of ports is irrelevant here because the connection will be made to the correct name, regardless of its position in the sub-module’s port list. Also notice the period immediately preceding the port name in this syntax. module top_module ( input a, input b, output out );   mod_a u_mod_a (  .in1 (a),  .in2 (b),  .out (out)  );  endmodule  2.4 Procedures 2.5 More Verilog Features 3 Circuits 3.1 Combinational Logic 3.1.1 Basic Gates 3.1.2 Multiplexers 3.1.3 Arithmetic Circuits 3.1.4 Karnaugh Map to Circuit 3.2 Sequential Logic 3.2.1 Latches and Flip-Flops 3.2.2 Counters 3.2.3 Shift Registers 3.2.4 More Circuits 3.2.5 Finite State Machines 3.3 Building Larger Circuits 4 Verification: Reading Simulations 4.1 Finding bugs in code 4.2 Build a circuit from a simulation waveform 5 Verification: Writing Testbenches 6 CS450 ","wordCount":"1682","inLanguage":"en","image":"http://intervalrain.github.io/images/cover.jpg","datePublished":"2022-05-28T00:10:20+08:00","dateModified":"2022-05-28T00:10:20+08:00","author":{"@type":"Person","name":"Rain Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://intervalrain.github.io/posts/verilog/hdlbits/"},"publisher":{"@type":"Organization","name":"Rain's Blog","logo":{"@type":"ImageObject","url":"http://intervalrain.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://intervalrain.github.io/ accesskey=h title="Rain's Blog (Alt + H)"><img src=http://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://intervalrain.github.io/posts/aboutme title="About me"><span>About me</span></a></li><li><a href=http://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=http://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://intervalrain.github.io/posts/>Posts</a></div><h1 class=post-title>[VHDL] HDLbits</h1><div class=post-description>Desc Text.</div><div class=post-meta><span title="2022-05-28 00:10:20 +0800 +0800">May 28, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Rain Hu&nbsp;|&nbsp;<a href=https://github.com/intervalrain/intervalrain.github.io/tree/main/content//posts/Verilog/HDLbits.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=http://intervalrain.github.io/images/cover.jpg alt="Oh! You closed up the window, so you cannot see raining"></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#hdlbitshttpshdlbits01xznetwikimain_page aria-label=HDLBits><a href=https://hdlbits.01xz.net/wiki/Main_Page>HDLBits</a></a></li><li><a href=#1-getting-started aria-label="1 Getting Started">1 Getting Started</a></li><li><a href=#2-verilog-language aria-label="2 Verilog Language">2 Verilog Language</a><ul><li><a href=#21-basics aria-label="2.1 Basics">2.1 Basics</a></li><li><a href=#22-vectors aria-label="2.2 Vectors">2.2 Vectors</a></li><li><a href=#23-modules-hierarchy aria-label="2.3 Modules: Hierarchy">2.3 Modules: Hierarchy</a></li><li><a href=#24-procedures aria-label="2.4 Procedures">2.4 Procedures</a></li><li><a href=#25-more-verilog-features aria-label="2.5 More Verilog Features">2.5 More Verilog Features</a></li></ul></li><li><a href=#3-circuits aria-label="3 Circuits">3 Circuits</a><ul><li><a href=#31-combinational-logic aria-label="3.1 Combinational Logic">3.1 Combinational Logic</a><ul><li><a href=#311-basic-gates aria-label="3.1.1 Basic Gates">3.1.1 Basic Gates</a></li><li><a href=#312-multiplexers aria-label="3.1.2 Multiplexers">3.1.2 Multiplexers</a></li><li><a href=#313-arithmetic-circuits aria-label="3.1.3 Arithmetic Circuits">3.1.3 Arithmetic Circuits</a></li><li><a href=#314-karnaugh-map-to-circuit aria-label="3.1.4 Karnaugh Map to Circuit">3.1.4 Karnaugh Map to Circuit</a></li></ul></li><li><a href=#32-sequential-logic aria-label="3.2 Sequential Logic">3.2 Sequential Logic</a><ul><li><a href=#321-latches-and-flip-flops aria-label="3.2.1 Latches and Flip-Flops">3.2.1 Latches and Flip-Flops</a></li><li><a href=#322-counters aria-label="3.2.2 Counters">3.2.2 Counters</a></li><li><a href=#323-shift-registers aria-label="3.2.3 Shift Registers">3.2.3 Shift Registers</a></li><li><a href=#324-more-circuits aria-label="3.2.4 More Circuits">3.2.4 More Circuits</a></li><li><a href=#325-finite-state-machines aria-label="3.2.5 Finite State Machines">3.2.5 Finite State Machines</a></li></ul></li><li><a href=#33-building-larger-circuits aria-label="3.3 Building Larger Circuits">3.3 Building Larger Circuits</a></li></ul></li><li><a href=#4-verification-reading-simulations aria-label="4 Verification: Reading Simulations">4 Verification: Reading Simulations</a><ul><li><a href=#41-finding-bugs-in-code aria-label="4.1 Finding bugs in code">4.1 Finding bugs in code</a></li><li><a href=#42-build-a-circuit-from-a-simulation-waveform aria-label="4.2 Build a circuit from a simulation waveform">4.2 Build a circuit from a simulation waveform</a></li></ul></li><li><a href=#5-verification-writing-testbenches aria-label="5 Verification: Writing Testbenches">5 Verification: Writing Testbenches</a></li><li><a href=#6-cs450 aria-label="6 CS450">6 CS450</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=hdlbitshttpshdlbits01xznetwikimain_page><a href=https://hdlbits.01xz.net/wiki/Main_Page>HDLBits</a><a hidden class=anchor aria-hidden=true href=#hdlbitshttpshdlbits01xznetwikimain_page>#</a></h1><blockquote><p>HDLBits 是一系列小型電路設計的練習，用於使用 Verilog 硬體描述語言(HDL)進行數位硬體設計。
由教學的題型由淺入深，逐步建立起電路設計的技能。
每個問題都會要求讀者使用 Verilog 設計一個小電路。HDLBits 會對提交的程式碼作判讀。透過一組測試碼來進行向量模擬，並與解答比較，檢查正確性。</p></blockquote><h1 id=1-getting-started>1 Getting Started<a hidden class=anchor aria-hidden=true href=#1-getting-started>#</a></h1><p>\(\text{assign one}\)</p><ul><li>Build a circuit with no inputs and one output. The output should always drive 1 (or logic high).</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( <span style=color:#66d9ef>output</span> one);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> one <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{assign zero}\)</p><ul><li>Build a circuit with no inputs and one output that outputs a constant 0.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> zero );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> zero <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><h1 id=2-verilog-language>2 Verilog Language<a hidden class=anchor aria-hidden=true href=#2-verilog-language>#</a></h1><h2 id=21-basics>2.1 Basics<a hidden class=anchor aria-hidden=true href=#21-basics>#</a></h2><p>\(\text{wire}\)</p><ul><li>Create a module with one input and ont output that behaves like a wire
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/7/77/Wire.png alt=wire></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( <span style=color:#66d9ef>input</span> in, <span style=color:#66d9ef>output</span> out);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> in;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{multi-in-out}\)</p><ul><li>Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/1/15/Wire4.png alt=wire4></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,b,c, 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> w,x,y,z );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> x <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> y <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> z <span style=color:#f92672>=</span> c;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{not gate}\)</p><ul><li>Create a module that implements a NOT gate.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/9/9e/Notgate.png alt=Notgate></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( <span style=color:#66d9ef>input</span> in, <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>in;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{and gate}\)</p><ul><li>Create a module that implments an AND gate.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/7/78/Andgate.png alt=Andgate></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module( 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{nor gate}\)</p><ul><li>Create a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/5/5b/Norgate.png alt=norgate></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a<span style=color:#f92672>|</span>b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{xnor gate}\)</p><ul><li>Create a module that implements a XNOR gate.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/6/6d/Xnorgate.png alt=xnorgate></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>(a<span style=color:#f92672>^</span>b);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{wire declaration}\)</p><ul><li>Implement following circuits. Create two intermediate wires to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire out, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/3/3a/Wiredecl2.png alt=Wiredecl></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a,b,c,d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out, out_n );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> w1, w2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1 <span style=color:#f92672>=</span> a <span style=color:#f92672>&amp;</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w2 <span style=color:#f92672>=</span> c <span style=color:#f92672>&amp;</span> d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> w1 <span style=color:#f92672>|</span> w2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_n <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>out;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{7458}\)</p><ul><li>The 7458 is a chip with four AND gates and two OR gates. Create a module with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/e/e1/7458.png alt=7458></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> p1a, p1b, p1c, p1d, p1e, p1f,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> p1y,
</span></span><span style=display:flex><span>    intput p2a, p2b, p2c, p2d,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> p2y );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> w1a, w1b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>wire</span> w2a, w2b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1a <span style=color:#f92672>=</span> p1a <span style=color:#f92672>&amp;</span> p1b <span style=color:#f92672>&amp;</span> p1c;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w1b <span style=color:#f92672>=</span> p1d <span style=color:#f92672>&amp;</span> p1e <span style=color:#f92672>&amp;</span> p1f;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> p1y <span style=color:#f92672>=</span> w1a <span style=color:#f92672>|</span> w1b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w2a <span style=color:#f92672>=</span> p2a <span style=color:#f92672>&amp;</span> p2b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> w2b <span style=color:#f92672>=</span> p2c <span style=color:#f92672>&amp;</span> p2d;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> p2y <span style=color:#f92672>=</span> w2a <span style=color:#f92672>|</span> w2b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><h2 id=22-vectors>2.2 Vectors<a hidden class=anchor aria-hidden=true href=#22-vectors>#</a></h2><p>\(\text{vector}\)</p><ul><li>Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect outputs o0 to the input vector&rsquo;s position 0, o1 to position 1, etc.<br>In a diagram, a tick mark with a number next to it indicates the width of the vector (or &ldquo;bus&rdquo;), rather than drawing a separate line for each bit in the vector.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/ae/Vector0.png alt=vector0></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] vec,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] outv,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> o2,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> o1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> <span style=color:#66d9ef>wire</span> o0  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> outv <span style=color:#f92672>=</span> vec;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> o0 <span style=color:#f92672>=</span> vec[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> o1 <span style=color:#f92672>=</span> vec[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> o2 <span style=color:#f92672>=</span> vec[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector select}\)</p><ul><li>Build a combinational circuit that splits an input half-word (16 bits, [15:0]) into lower [7:0] and upper [15:8] bytes.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_hi,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_lo );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_hi <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span><span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_lo <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector swap}\)</p><ul><li>A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the byte ordering of the 4-byte word.<br>AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa<br>This operation is often used when the endianness of a piece of data needs to be swapped, for example between little-endian x86 systems and the big-endian formats used in many Internet protocols.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out 
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>24</span>] <span style=color:#f92672>=</span> in[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out[<span style=color:#ae81ff>23</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out[<span style=color:#ae81ff>15</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>8</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>23</span><span style=color:#f92672>:</span><span style=color:#ae81ff>16</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out[ <span style=color:#ae81ff>7</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>24</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector gates}\)</p><ul><li>uild a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/1/1b/Vectorgates.png alt=vectorgates></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] b,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_or_bitwise,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_or_logical,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>5</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out_not
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_or_bitwise <span style=color:#f92672>=</span> a <span style=color:#f92672>|</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_or_logical <span style=color:#f92672>=</span> a <span style=color:#f92672>||</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_not[<span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_not[<span style=color:#ae81ff>5</span><span style=color:#f92672>:</span><span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{gate-prefix vector}\)</p><ul><li>Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs:<ul><li>out_and: output of a 4-input AND gate.</li><li>out_or: output of a 4-input OR gate.</li><li>out_xor: outout of a 4-input XOR gate.</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_and,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_or,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> out_xor );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_and <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span> in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_or <span style=color:#f92672>=</span> <span style=color:#f92672>|</span> in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out_xor <span style=color:#f92672>=</span> <span style=color:#f92672>^</span> in;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector concatenate}\)</p><ul><li>Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/0/0c/Vector3.png alt=vector3></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>4</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] a, b, c, d, e, f,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] w, x, y, z );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {w, x, y, z} <span style=color:#f92672>=</span> {a, b, c, d, e, f, <span style=color:#ae81ff>2</span><span style=color:#ae81ff>&#39;b11</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector reverse}\)</p><ul><li>Given an 8-bit input vector [7:0], reverse its bit ordering.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out 
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> {out[<span style=color:#ae81ff>0</span>], out[<span style=color:#ae81ff>1</span>], out[<span style=color:#ae81ff>2</span>], out[<span style=color:#ae81ff>3</span>], out[<span style=color:#ae81ff>4</span>], out[<span style=color:#ae81ff>5</span>], out[<span style=color:#ae81ff>6</span>], out[<span style=color:#ae81ff>7</span>]} <span style=color:#f92672>=</span> in
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out 
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always</span> @(<span style=color:#f92672>*</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>8</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            out[i] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>8</span><span style=color:#f92672>-</span>i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out 
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>generate</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>genvar</span> i;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>8</span>; i <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>begin</span><span style=color:#f92672>:</span> my_block_name
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>assign</span> out[i] <span style=color:#f92672>=</span> in[<span style=color:#ae81ff>8</span><span style=color:#f92672>-</span>i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>endgenerate</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector replication}\)</p><ul><li>Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> [<span style=color:#ae81ff>7</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] in,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>31</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> {{<span style=color:#ae81ff>24</span>{in[<span style=color:#ae81ff>7</span>]}}, in};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><p>\(\text{vector replication2}\)</p><ul><li>Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/a/ac/Vector5.png alt=vector5></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span> a, b, c, d, e,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>output</span> [<span style=color:#ae81ff>24</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assign</span> out <span style=color:#f92672>=</span> <span style=color:#f92672>~</span>{{<span style=color:#ae81ff>5</span>{a}}, {<span style=color:#ae81ff>5</span>{b}}, {<span style=color:#ae81ff>5</span>{c}}, {<span style=color:#ae81ff>5</span>{d}}, {<span style=color:#ae81ff>5</span>{e}}} <span style=color:#f92672>^</span> {<span style=color:#ae81ff>5</span>{a,b,c,d,e}};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><h2 id=23-modules-hierarchy>2.3 Modules: Hierarchy<a hidden class=anchor aria-hidden=true href=#23-modules-hierarchy>#</a></h2><p>By now, you&rsquo;re familiar with a module, which is a circuit that interacts with its outside through input and output ports. Larger, more complex circuits are built by composing bigger modules out of smaller modules and other pieces (such as assign statements and always blocks) connected together. This forms a hierarchy, as modules can contain instances of other modules.</p><p>The figure below shows a very simple circuit with a sub-module. In this exercise, create one instance of module mod_a, then connect the module&rsquo;s three pins (in1, in2, and out) to your top-level module&rsquo;s three ports (wires a, b, and out). The module mod_a is provided for you — you must instantiate it.</p><p>When connecting modules, only the ports on the module are important. You do not need to know the code inside the module. The code for module mod_a looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> mod_a ( <span style=color:#66d9ef>input</span> in1, <span style=color:#66d9ef>input</span> in2, <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Module body
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><p>The hierarchy of modules is created by instantiating one module inside another, as long as all of the modules used belong to the same project (so the compiler knows where to find the module). The code for one module is not written inside another module&rsquo;s body (Code for different modules are not nested).</p><p>You may connect signals to the module by port name or port position. For extra practice, try both methods.
<strong>Connecting Signals to Module Ports</strong><br>There are two commonly-used methods to connect a wire to a port: by position or by name.</p><p><strong>By position</strong><br>The syntax to connect wires to ports by position should be familiar, as it uses a C-like syntax. When instantiating a module, ports are connected left to right according to the module&rsquo;s declaration. For example:</p><p><code>mod_a instance1 ( wa, wb, wc );</code></p><p>This instantiates a module of type mod_a and gives it an instance name of &ldquo;instance1&rdquo;, then connects signal wa (outside the new module) to the first port (in1) of the new module, wb to the second port (in2), and wc to the third port (out). One drawback of this syntax is that if the module&rsquo;s port list changes, all instantiations of the module will also need to be found and changed to match the new module.</p><p><strong>By name</strong><br>Connecting signals to a module&rsquo;s ports by name allows wires to remain correctly connected even if the port list changes. This syntax is more verbose, however.</p><p><code>mod_a instance2 ( .out(wc), .in1(wa), .in2(wb) );</code></p><p>The above line instantiates a module of type mod_a named &ldquo;instance2&rdquo;, then connects signal wa (outside the module) to the port named in1, wb to the port named in2, and wc to the port named out. Notice how the ordering of ports is irrelevant here because the connection will be made to the correct name, regardless of its position in the sub-module&rsquo;s port list. Also notice the period immediately preceding the port name in this syntax.
<img loading=lazy src=https://hdlbits.01xz.net/mw/images/c/c0/Module.png alt=module></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Verilog data-lang=Verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_module ( <span style=color:#66d9ef>input</span> a, <span style=color:#66d9ef>input</span> b, <span style=color:#66d9ef>output</span> out );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mod_a u_mod_a (
</span></span><span style=display:flex><span>        .in1 (a),
</span></span><span style=display:flex><span>        .in2 (b),
</span></span><span style=display:flex><span>        .out (out)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><hr><h2 id=24-procedures>2.4 Procedures<a hidden class=anchor aria-hidden=true href=#24-procedures>#</a></h2><h2 id=25-more-verilog-features>2.5 More Verilog Features<a hidden class=anchor aria-hidden=true href=#25-more-verilog-features>#</a></h2><h1 id=3-circuits>3 Circuits<a hidden class=anchor aria-hidden=true href=#3-circuits>#</a></h1><h2 id=31-combinational-logic>3.1 Combinational Logic<a hidden class=anchor aria-hidden=true href=#31-combinational-logic>#</a></h2><h3 id=311-basic-gates>3.1.1 Basic Gates<a hidden class=anchor aria-hidden=true href=#311-basic-gates>#</a></h3><h3 id=312-multiplexers>3.1.2 Multiplexers<a hidden class=anchor aria-hidden=true href=#312-multiplexers>#</a></h3><h3 id=313-arithmetic-circuits>3.1.3 Arithmetic Circuits<a hidden class=anchor aria-hidden=true href=#313-arithmetic-circuits>#</a></h3><h3 id=314-karnaugh-map-to-circuit>3.1.4 Karnaugh Map to Circuit<a hidden class=anchor aria-hidden=true href=#314-karnaugh-map-to-circuit>#</a></h3><h2 id=32-sequential-logic>3.2 Sequential Logic<a hidden class=anchor aria-hidden=true href=#32-sequential-logic>#</a></h2><h3 id=321-latches-and-flip-flops>3.2.1 Latches and Flip-Flops<a hidden class=anchor aria-hidden=true href=#321-latches-and-flip-flops>#</a></h3><h3 id=322-counters>3.2.2 Counters<a hidden class=anchor aria-hidden=true href=#322-counters>#</a></h3><h3 id=323-shift-registers>3.2.3 Shift Registers<a hidden class=anchor aria-hidden=true href=#323-shift-registers>#</a></h3><h3 id=324-more-circuits>3.2.4 More Circuits<a hidden class=anchor aria-hidden=true href=#324-more-circuits>#</a></h3><h3 id=325-finite-state-machines>3.2.5 Finite State Machines<a hidden class=anchor aria-hidden=true href=#325-finite-state-machines>#</a></h3><h2 id=33-building-larger-circuits>3.3 Building Larger Circuits<a hidden class=anchor aria-hidden=true href=#33-building-larger-circuits>#</a></h2><h1 id=4-verification-reading-simulations>4 Verification: Reading Simulations<a hidden class=anchor aria-hidden=true href=#4-verification-reading-simulations>#</a></h1><h2 id=41-finding-bugs-in-code>4.1 Finding bugs in code<a hidden class=anchor aria-hidden=true href=#41-finding-bugs-in-code>#</a></h2><h2 id=42-build-a-circuit-from-a-simulation-waveform>4.2 Build a circuit from a simulation waveform<a hidden class=anchor aria-hidden=true href=#42-build-a-circuit-from-a-simulation-waveform>#</a></h2><h1 id=5-verification-writing-testbenches>5 Verification: Writing Testbenches<a hidden class=anchor aria-hidden=true href=#5-verification-writing-testbenches>#</a></h1><h1 id=6-cs450>6 CS450<a hidden class=anchor aria-hidden=true href=#6-cs450>#</a></h1></div><footer class=post-footer><ul class=post-tags><li><a href=http://intervalrain.github.io/tags/vhdl/>VHDL</a></li><li><a href=http://intervalrain.github.io/tags/programming/>Programming</a></li><li><a href=http://intervalrain.github.io/tags/verilog/>Verilog</a></li></ul><nav class=paginav><a class=next href=http://intervalrain.github.io/posts/device/simulationconvergece/><span class=title>Next Page »</span><br><span>[TCAD] 模擬收斂問題</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://intervalrain.github.io/>Rain's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>