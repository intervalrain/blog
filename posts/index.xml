<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Rain's Blog</title><link>http://intervalrain.github.io/posts/</link><description>Recent content in Posts on Rain's Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 05 Jul 2022 21:56:32 +0800</lastBuildDate><atom:link href="http://intervalrain.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>[nachos] 概述</title><link>http://intervalrain.github.io/posts/csnotes/nachos/intro/</link><pubDate>Tue, 05 Jul 2022 21:56:32 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/nachos/intro/</guid><description>Nachos 概述 簡介 Nachos 是一個教學用的作業系統，建立在一個軟件模擬的通用虛擬機(virtual machine)，模擬 MIPS R2/3000 的指令集、主存、中斷系統、網路以及磁碟系統等作業系統所必須的硬體系統。 R2/3000 的指令集為 RISC 指令集，指令數目比較少，Nachos 模擬了其中的 63 條指令，許多現有的編譯器如 g++ 能直接將 C 或 C++ 源始碼編譯成該指令集的機械碼，省去編寫編譯器的工夫，所有讀者可以直接用 C/C++ 語言編寫該應用程式，使得在 Nachos 上開發大型的應用程式成為可能。 使用並實現了作業系統中的一些新的概念。包括網路、執行緒、分散式應用。並且 Nachos 中以**執行緒(thread)**作為一個基本概念講述，取代原本進程(process) 在作業系統教學中的地位。 nachos 虛擬機使得網路的實現相當簡單，nachos 只是一個在宿主機上運行的一個進程。在同一個宿主機上可以運行多個 nachos 進程，各個進程間可以相互通訊，作為一個為互連網路的一個節點；進程之間通過 Socket 進行通訊，模擬一個全互連發路。 確定性調試比較方便。隨機因素使系統運行更加真實。因為作業系統的不確定性，所以在一個實際的系統中進行多執行緒調試是比較困難的。由於 Nachos 是在宿主機上運行的進程，它提供了確定性調試的手段。 確定性調試就是在同樣的輸入順序、輸入參數的情況下，Nachos 運行的結果是完全一樣的。在多執行緒的調試中，可以將注意力集中在某一個實際問題上，而不受作業系統不確定性的干擾。 另外，Nachos 採用了隨機因子來模擬真實作業系統的不確定性。 簡單而易於擴展。Nachos 的目的不是展示一個成功的作業系統，而是提供一個框架使讀者可以發揮自己的創造性進行擴展。 例如一個完整的類似於 UNIX 的文件系統是很複雜的，但是對於文件系統而言，無非是需要實現文件的邏輯地址到物理地址的映射以及實現文件 inode、打開文件結構、執行緒打開文件表等重要的數據結構以及維護它們之間的觀係。Nachos 具有以上所有這些內容，但是在很多方面做了一定的限制，比如只有一級索引結構限制了系統中最大文件的大小。讀者可對文件系統進行擴展，逐步消除這些限制。 物件導向性。Nachos 的主體是用 C++ 的一個子集來實現的。物件導向可以清楚地描述作業系統各個部分的介面(interface)。但 Nachos 並未用到物件導向的所有特徵，如繼承性、多態性等，使得其程式碼更容易理解與閱讀。</description></item><item><title>[作業系統] Nachos</title><link>http://intervalrain.github.io/posts/csnotes/nachos/</link><pubDate>Sun, 03 Jul 2022 18:01:57 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/nachos/</guid><description>Nachos 概述</description></item><item><title>[CA] 記憶體</title><link>http://intervalrain.github.io/posts/csnotes/ca/memory/</link><pubDate>Sun, 03 Jul 2022 01:54:06 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/ca/memory/</guid><description>準備中</description></item><item><title>[CA] Pipeline</title><link>http://intervalrain.github.io/posts/csnotes/ca/pipeline/</link><pubDate>Sun, 03 Jul 2022 01:54:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/ca/pipeline/</guid><description>準備中</description></item><item><title>[CA] 處理器</title><link>http://intervalrain.github.io/posts/csnotes/ca/processor/</link><pubDate>Sun, 03 Jul 2022 01:53:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/ca/processor/</guid><description>準備中</description></item><item><title>[CA] 計算機算術</title><link>http://intervalrain.github.io/posts/csnotes/ca/arithmetic/</link><pubDate>Sun, 03 Jul 2022 01:53:50 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/ca/arithmetic/</guid><description>準備中</description></item><item><title>[CA] 指令集架構</title><link>http://intervalrain.github.io/posts/csnotes/ca/isa/</link><pubDate>Sun, 03 Jul 2022 01:53:45 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/ca/isa/</guid><description>準備中</description></item><item><title>[作業系統] 計算機組織與結構</title><link>http://intervalrain.github.io/posts/csnotes/ca/</link><pubDate>Sun, 03 Jul 2022 01:39:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/ca/</guid><description>計算機組織與結構 概述 計算機抽象化 指令集架構 計算機算術 處理器 Pipeline 記憶體 參考資料 黃婷婷 清大開放式課程 計算機結構 Mr. opengate</description></item><item><title>CPU 個數、CPU 核心數、CPU 執行緒數</title><link>http://intervalrain.github.io/posts/csnotes/os/cpucorethread/</link><pubDate>Sat, 02 Jul 2022 21:43:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/os/cpucorethread/</guid><description>Introduction to CPU, core and thread</description></item><item><title>[作業系統] Linux</title><link>http://intervalrain.github.io/posts/csnotes/linux/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/linux/</guid><description>準備中</description></item><item><title>[作業系統] 計算機作業系統</title><link>http://intervalrain.github.io/posts/csnotes/os/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/os/</guid><description>計算機作業系統 概述 進程管理 死鎖 記憶體管理 設備管理 鏈接 參考資料 cyc2018 Mr. opengate</description></item><item><title>[計算機作業系統] 概述</title><link>http://intervalrain.github.io/posts/csnotes/os/intro/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/os/intro/</guid><description>作業系統 簡介 電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)
硬體(hardware)：為系統提供基本的計算資源。 中央處理器(central processing unit, CPU) 記憶體(memory) I/O 裝置 應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。 使用者(users) 作業系統(Operating system, OS)： 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。
OS 最主要的兩個功能是：
資源分配：根據需求調配資源分配率(resource utilization)與效能(performance) 監控使用者程式的執行，避免不正常的運作造成對系統的危害。 一個標準的 PC 作業系統應該提供以下的功能：
行程管理(Processing management) 記憶體管理(Memory management) 檔案系統(File system) 網路通訊(Networking) 安全機制(Security) 使用者介面(User interface) 驅動程式(Device drivers) PC 基本特徵 1. 並行計算(Concurrent computing) Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 分享(Sharing) 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬(Virtual) 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4.</description></item><item><title>[計算機作業系統] 死鎖</title><link>http://intervalrain.github.io/posts/csnotes/os/deadlock/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/os/deadlock/</guid><description>準備中</description></item><item><title>[計算機作業系統] 記憶體管理</title><link>http://intervalrain.github.io/posts/csnotes/os/memorymanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/os/memorymanagement/</guid><description>準備中</description></item><item><title>[計算機作業系統] 設備管理</title><link>http://intervalrain.github.io/posts/csnotes/os/equipmentmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/os/equipmentmanagement/</guid><description>準備中</description></item><item><title>[計算機作業系統] 進程管理</title><link>http://intervalrain.github.io/posts/csnotes/os/processmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/os/processmanagement/</guid><description>進程管理 進程與執行緒 1. 進程(process) 進程是資源分配的基本單位。 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。 2. 執行緒(thread) 執行緒又稱線程，是獨立調度的基本單位。 一個進程可以有多個執行緒，它們共享進程資源。 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。 3. 區別 擁有資源 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。 調度 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。 系統開銷 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。 溝通 執行緒可以通過直接讀寫同一個進程中的數據進行溝通，但是進程的溝通需要借助 IPC(inter-process communication)。 進程狀態的切換 就緒就態(ready)：等待被調度 執行狀態(running) 阻塞狀態(waiting)：等待資源 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。 進程調度演算法 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。 1. 批次處理系統(batch system) 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。 1.1 先來先服務(first-come first-served, FCFS) 非搶占式的調度，按照請求的順序進行調度。 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長 1.2 短作業優先(shortest job first, SJF) 非搶占式的調度算法，按估計運行時間最短的順序進行調度。 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。 1.</description></item><item><title>[計算機作業系統] 鏈接</title><link>http://intervalrain.github.io/posts/csnotes/os/link/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/os/link/</guid><description>準備中</description></item><item><title>CS 學習筆記</title><link>http://intervalrain.github.io/posts/csnotes/</link><pubDate>Sat, 02 Jul 2022 03:01:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/</guid><description> 演算法 Leetcode 演算法 計算機結構 計算機結構 作業系統 計算機作業系統 Linux Nachos 網路 計算機網路 HTTP Socket 資料庫 資料庫系統原理 SQL 語法 SQL 練習 MySQL Redis Java Java 基礎 Java 容器 Java 開發 Java 虛擬機 Java I/O 系統設計 系統設計基礎 分布式 集群 駭客技術 緩存 訊息佇列 物件導向 物件導向概念 設計模式 工具 Git Docker 框架 正則表達式 程式碼實踐 程式碼可讀性 程式碼格規範</description></item><item><title>[ML] introduction</title><link>http://intervalrain.github.io/posts/ml/lec0/</link><pubDate>Sun, 19 Jun 2022 18:18:52 +0800</pubDate><guid>http://intervalrain.github.io/posts/ml/lec0/</guid><description>Introduction to Machine Learning</description></item><item><title>[Life] Some change of road to SWE</title><link>http://intervalrain.github.io/posts/life/nikita_kothari/</link><pubDate>Tue, 14 Jun 2022 22:43:59 +0800</pubDate><guid>http://intervalrain.github.io/posts/life/nikita_kothari/</guid><description>Suggestion from Nikita Kothari at LinkedIn</description></item><item><title>[C++] The C++ Standard Template Library(STL) - deque</title><link>http://intervalrain.github.io/posts/c++/stl_deque/</link><pubDate>Sun, 12 Jun 2022 01:36:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_deque/</guid><description>Introduction to deque</description></item><item><title>[C++] Custom Comparator</title><link>http://intervalrain.github.io/posts/c++/custom_comparator/</link><pubDate>Sat, 11 Jun 2022 10:07:49 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/custom_comparator/</guid><description>Custom comparator for sorting algorithm and priority_queue</description></item><item><title>[C++] The C++ Standard Template Library(STL) - pair</title><link>http://intervalrain.github.io/posts/c++/stl_pair/</link><pubDate>Thu, 02 Jun 2022 01:23:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_pair/</guid><description>Introduction to pair</description></item><item><title>[VHDL] HDLbits 1 - Getting Started</title><link>http://intervalrain.github.io/posts/verilog/hdlbits1/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits1/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 2 - Verilog Language</title><link>http://intervalrain.github.io/posts/verilog/hdlbits2/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits2/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 3 - Circuits</title><link>http://intervalrain.github.io/posts/verilog/hdlbits3/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits3/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 4 - Verification: Reading Simulations</title><link>http://intervalrain.github.io/posts/verilog/hdlbits4/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits4/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 5 - Verification: Writing Testbenches</title><link>http://intervalrain.github.io/posts/verilog/hdlbits5/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits5/</guid><description>Verilog tutorial</description></item><item><title>[VHDL] HDLbits 6 - CS450</title><link>http://intervalrain.github.io/posts/verilog/hdlbits6/</link><pubDate>Sat, 28 May 2022 00:10:20 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/hdlbits6/</guid><description>Verilog tutorial</description></item><item><title>[TCAD] 模擬收斂問題</title><link>http://intervalrain.github.io/posts/device/simulationconvergece/</link><pubDate>Wed, 25 May 2022 22:52:15 +0800</pubDate><guid>http://intervalrain.github.io/posts/device/simulationconvergece/</guid><description>TCAD simulation convergence problem</description></item><item><title>[VHDL] Verilog Hardware Description Language</title><link>http://intervalrain.github.io/posts/verilog/intro/</link><pubDate>Sun, 01 May 2022 17:37:22 +0800</pubDate><guid>http://intervalrain.github.io/posts/verilog/intro/</guid><description>1 Verilog HDL 1.1 Verilog 簡介 一套硬體描述語言 輔助設計數位系統 描述電路的行為 電子自動化工具 類似C語言的硬體描述語言 易學、容易接受 高階行為描述 切勿使用軟體思維(循序)撰寫(硬體描述語言多是並行的) 支援多種硬體層級的描述方式 從低階到高階模式 依照不同的方法設計 支援階層式的設計方法 樹狀式的設計結構 由繁化簡 1.2 Verilog 的模型 1.2.1 電晶體層級 Transistor Level 或低階交換層次模型(Switch Level Model) Verilog 最低階的層次模型 電路是由開關與電晶體所組成 一般不會採取低階的層級來進行設計 1.2.2 邏輯閘層級 Gate Level 使用基本的邏輯閘元件 AND、OR、NOT 邏輯電路圖 1.2.3 資料流層級 Data Flow Level 描述電路中資料的處理方式 資料如何在電路中運算及傳送 輸入持續驅動輸出 運算式 如：out = a + b + c 1.2.4 行為模型 Behavior Level Verilog 最高階的層次模型 不需考慮硬體元件的特型，只需放在模組的功能描述 很像 C 語言 合成軟體工具 1.2.5 結構式模型 Structure Level 引用硬體模組的模式 類似邏輯閘層次模型 支援階層式設計法 將複雜電路分為層狀結構 架構上類似樹狀結構 Bottom-up：元件→子模組→設計目標 Top-Down：設計目標→子模組→元件 Mixed：設計目標→子模組←元件(常用於大型複雜系統) \( \boxed{\text{Full Adder}} \begin{cases} \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{Half Adder}} \begin{cases} \boxed{\text{XOR}}\\ \boxed{\text{AND}} \end{cases}\\ \boxed{\text{OR}} \end{cases}\\ \text{設計目標}\qquad\qquad\text{子模組}\qquad\text{元件} \) 1.</description></item><item><title>[Java] 淺談 Java MVC</title><link>http://intervalrain.github.io/posts/java/java_mvc/</link><pubDate>Fri, 29 Apr 2022 15:38:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/java_mvc/</guid><description>Introduction to Java MVC.</description></item><item><title>[IT] Introduction to Microservices, Docker and Kubernetes</title><link>http://intervalrain.github.io/posts/it/microservices_docker_kubernetes/</link><pubDate>Fri, 29 Apr 2022 11:40:10 +0800</pubDate><guid>http://intervalrain.github.io/posts/it/microservices_docker_kubernetes/</guid><description>Desc Text.</description></item><item><title>[C++] The C++ Standard Template Library(STL) - map</title><link>http://intervalrain.github.io/posts/c++/stl_map/</link><pubDate>Sat, 23 Apr 2022 22:24:21 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_map/</guid><description>Introduction to map.</description></item><item><title>[C++] 如何產生 random 值</title><link>http://intervalrain.github.io/posts/c++/random/</link><pubDate>Sat, 23 Apr 2022 17:46:23 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/random/</guid><description>How to generate a random value</description></item><item><title>[Java] HashMap中的hashCode設計原理</title><link>http://intervalrain.github.io/posts/java/hashmap/hashcode/</link><pubDate>Fri, 22 Apr 2022 11:22:39 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/hashmap/hashcode/</guid><description>why hashcode &amp;gt;&amp;gt;&amp;gt; 16</description></item><item><title>[C++]易錯題目收集</title><link>http://intervalrain.github.io/posts/c++/question/</link><pubDate>Sun, 17 Apr 2022 17:34:39 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/question/</guid><description>Collections of C++ problems</description></item><item><title>[C++] The C++ Standard Template Library(STL) - list, forward_list</title><link>http://intervalrain.github.io/posts/c++/stl_list/</link><pubDate>Sun, 17 Apr 2022 11:45:58 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_list/</guid><description>Introduction to list and forward_list</description></item><item><title>[C++] The C++ Standard Template Library(STL) - vector</title><link>http://intervalrain.github.io/posts/c++/stl_vector/</link><pubDate>Sat, 16 Apr 2022 22:08:37 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_vector/</guid><description>Introduction to vector</description></item><item><title>[C++] The C++ Standard Template Library(STL) - Container</title><link>http://intervalrain.github.io/posts/c++/stl_container/</link><pubDate>Fri, 15 Apr 2022 01:09:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_container/</guid><description>Introduction to containers in STL</description></item><item><title>[IDAS+] Optimize Summary Table Function</title><link>http://intervalrain.github.io/posts/vba/idas+_record/</link><pubDate>Thu, 14 Apr 2022 00:39:50 +0800</pubDate><guid>http://intervalrain.github.io/posts/vba/idas+_record/</guid><description>An implementation of dictionary in VBA for searching algorithm</description></item><item><title>[C++] Cout functions</title><link>http://intervalrain.github.io/posts/c++/cout/</link><pubDate>Fri, 08 Apr 2022 10:20:38 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/cout/</guid><description>Functions for cout lib</description></item><item><title>[C++] The C++ Standard Template Library(STL) - Algorithm</title><link>http://intervalrain.github.io/posts/c++/stl_algo/</link><pubDate>Wed, 06 Apr 2022 16:04:36 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl_algo/</guid><description>Introduction to algorithms in STL</description></item><item><title>[C++] The C++ Standard Template Library(STL)</title><link>http://intervalrain.github.io/posts/c++/stl/</link><pubDate>Tue, 05 Apr 2022 01:09:42 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/stl/</guid><description>Introduction to STL</description></item><item><title>[C++] STL: Vector 的使用與實作</title><link>http://intervalrain.github.io/posts/c++/vector/</link><pubDate>Sun, 03 Apr 2022 18:14:14 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/vector/</guid><description>STL整理</description></item><item><title>[TCAD] 工具語言</title><link>http://intervalrain.github.io/posts/device/tcad/</link><pubDate>Sat, 26 Mar 2022 21:46:26 +0800</pubDate><guid>http://intervalrain.github.io/posts/device/tcad/</guid><description>TCAD learning notes</description></item><item><title>[CA] 計算機抽象化</title><link>http://intervalrain.github.io/posts/csnotes/ca/abstraction/</link><pubDate>Thu, 24 Mar 2022 01:12:11 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/ca/abstraction/</guid><description>計算機的抽象化與科技 電腦的定義 一種可以進行計算的裝置，特指可編程(programmable) 且可執行高速的數學或邏輯的運算，或可收集、儲存、處理資料的電子器械。 一般用途 or 特別用途 可編程 or 不可編程 科學用 or 商務 機械械 or 電子式 or 電機 &amp;hellip; Instruction 與 data 分開儲存的結構稱為 哈佛架構Harvard Architecture 電腦的歷史 ENIAC (Electronic Numberical Integrator and Calculator) 1943 - 1946 at the University of Pennsylvania 約 25 公尺長、2.5 公尺高 由真空管製成: 耗能、易燒壞KJKKI 1900個加法/每秒 商業化、電晶體的發現 in 1947 使用電晶體的電腦 (IBM 14001, Big Blue) in 1959 IC(Integrated Circuit) in 1958 at 德儀 微處理器(Intel 4004) in 1971 Apple II in 1977 個人電腦(IBM PC) in 1981 IBM 開放式系統(open system)使得周邊設備大量的發展 Xerox PARC Alto: 具備滑鼠、以太網路、點陣圖、按鍵、菜單、WYSIWYG編輯器 區域網路 雷射列印 client / server 分散式計算 應用程式 VisiCalc for Applie II in 1979 超大型積體電路 VLSI(Very-Large-Scale Integration) RISC(Reduced Instruction Set Computer) 的出現，對應於 CISC(Complex Instruction Set Computer) RISC: MIPS CISC: Intel x86 processor Post PC Era: Embedded Computer 冰箱、手機、手錶… 電腦的發展 應用 行動電腦 手機 人類基因體計畫 世界網路 搜尋引擎 摩爾定律 Moore&amp;rsquo;s Law Line Width/Feature Size: 電晶體的 Source 與 Drain 的距離，約是 gate length。 電腦的分類 通用電腦 特性： 軟體相容性 產品生命週期短 更好的效能(more transistors)與人機介面 個人電腦 Personal Computers 一般用途、軟體多樣性 取決於成本與效能的權衡 伺服器電腦 Server Computers 基於網路的 高容量、效能、可靠度 範圍可小至伺服，大至建築 超級電腦 Supercomputers 高端的科學與工程計算 最高的效能，但小的市佔 特殊用途電腦 特性： 通常沒有浮點數、記憶體管理 會與各種功能的外部裝置(peripherals)協作 e.</description></item><item><title>[計算機組織與結構] 概述</title><link>http://intervalrain.github.io/posts/csnotes/ca/intro/</link><pubDate>Wed, 23 Mar 2022 00:18:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/csnotes/ca/intro/</guid><description>前言 二進制 從真實世界的 類比訊號 到方便儲存與傳送的 數位訊號 (Analog to Digital)。 訊號容易用 二進制 表達，在電子電路上，可以用 電子開關(Switch) 來描述(bit)。 利用 電晶體(Transistor) 其特性，可以作為一個電子開關。 現今的積體電路最常見的電晶體為 MOSFET (Metal Oxide Silicon Field Effect Transistor)。 利用閘極(Gate)控制源極(Source)與汲極(Drain)的電子通道。 電子開關 → 邏輯閘 → 邏輯電路、記憶元件 → 計算機 計算機結構 vs. 計算機組織 計算機結構 Computer Architecture 處理器(processor) 控制器(Control) 資料路徑(Datapath) 記憶體(memory) 裝置(Devices) 輸入(Input): 鍵盤、滑鼠、磁碟 輸出(Output): 磁碟、顯示器、影印機 計算機組織 Computer Organization(架構) 功能元件的性能: 暫存器(registers)、算術邏輯單元(ALU)、移位器(shifters) 結構(Structure) 資料流(Dataflow) 控制邏輯(Control logic) 暫存器傳輸階層(Register Transfer Level, RTL) 描述 計算機結構 計算機結構(Computer Architecture) = 指令集架構(Instruction Set Architecture, ISA) + 機器組織(Machine Organization) 軟體與硬體間的介面。(不同層級抽象化的協同) 因應不同的需求所設計出來的機械結構。 選用的演算法 選用的程式語言或編譯器 選用的作業系統 處理器 I/O 系統與裝置 指令集架構 Instruction Set Architecture(ISA) 可編程的儲存量(programmable storage) 資料型別與結構：編碼與表現(Encodings and Representations) 指令集(Instruction Set) 指令形式(Instruction Formats) 讀寫資料的模式與指令 例外狀況 計算機的發展 電腦的分類與市場：歸因於行動裝置的崛起和技術的進步(CMOS、SoC、CAD tools等)。 桌上型電腦(Desktop computers) 伺服器電腦(Server computers) 嵌入式電腦(Embedded computers) 依指令集的長度、複雜度分為 複雜指令集電腦(Complex Instruction Set Computer, CISC) 精簡指令集電腦(Reduced Instruction Set Computer, RISC) 微處理器(Microprocessor) 的分類與市場：主要有兩大架構 ARM 架構： 過去稱為進階精簡指令集機器(Advanced RISC Machine)。 32 位元 RISC 處理器架構。 低成本、高效能、低耗電。 廣泛使用在嵌入式系統設計。 適用於行動通訊領域。 MIPS 架構： Microprocessor without Interlocked Pipeline Stages RISC 處理器架構，早年使用 32 位元，最新版本已變成 64 位元。 廣泛使用於電子產品、網路設備、個人娛樂裝置與商業裝置。 在 MIPS 架構中，指令被分為 R型、I型、J型，三種類型的指令的最高 6 位均為 6 位的 opcode 碼。 瓶頸 摩爾定律(Moore&amp;rsquo;s Law) 積體電路晶片上所整合的電路數目，每隔 18 個月就增加一倍。 摩爾定律的時代將會結束，因為研究和實驗室的成本需求十分高昂，而有財力投資在建立和維護晶片工廠的企業很少。而且製程也愈來愈接近半導體的物理極限，將會難以再縮小下去。 能耗限制(The power wall) 微處理器的效能提升一直仰賴提高處理器的操作頻率，但在提升操作步率的同時，也會帶來龐大的功耗，故形成 Power Wall。 散熱問題愈趨嚴重、電壓無法再下降。 \(\text{P}_\text{dynamic} = \text{IV} = \frac{1}{2}\text{CV}^2\times\frac{1}{\text{T}} = \frac{1}{2}\text{CVF}\) 多處理器(Multi-processor)開始發展 反應時間(Response Time)不增加，但吞吐量(Throughput)增加。 程式設計師要開始考量平行運算程式設計。 阿姆達爾定律(Amdahl&amp;rsquo;s Law) 它代表了處理器平行運算之後效率提升的能力，無論如何提升處理器的數目，加速比將會達到一個極限。(比方說導線的電導率決定電子傳遞速度的上限) \(\text{T} _\text{improved}=\frac{\text{T} _\text{affected} }{\text{improvement facetor}}+\text{T} _\text{unaffected}\) \(\text{T} _\text{improved} \rightarrow 0 + \text{T} _\text{unaffected}\) unaffected term 會決定速度的上限 效能(Performance) 效能的表示法 吞吐量(Throughput)：單位時間的工作量。適用於大型主機。 反應時間(Response time)：任務完成所需的時間。適用於個人電腦。 I/O time CPU time：任務的處理(processing)時間 系統 CPU 使用者 CPU Elapsed time = Total Response time，包含處理器、I/O、OS overhaed、閒置時間 CPU time \(\boxed{\text{CPU Time} = \text{n}_ \text{clock}\times\text{t}_ \text{clock}}\) \(\text{n}_\text{clock}\)：clock 的數目 \(\text{t}_\text{clock}\)：單位 clock 的時間 \(\boxed{\text{CPI}=\frac{\text{n}_\text{clock}}{\text{n} _\text{IC}}}\) \(\text{n}_\text{IC}\)：指令數目(Instruction Count, IC) \(\text{CPI}\)：Cycle per instruction \(\boxed{\text{CPU Time} = \text{n}_ \text{IC}\times\text{CPI}\times\text{t}_ \text{clock}}\) \(\boxed{\text{Clock Rate} = \frac{1}{\text{t}_\text{clock}} = \frac{\text{n} _\text{clock}}{\text{CPU time}}}\) 影響效能的因素 \(\boxed{\begin{array}{ccccccc} \text{CPU Time}&amp;amp;=&amp;amp;\frac{\text{Instruct.</description></item><item><title>[Algorithm] Maximum Frequency Stack 最大頻率堆疊</title><link>http://intervalrain.github.io/posts/algorithm/freqstack/</link><pubDate>Sat, 19 Mar 2022 16:53:23 +0800</pubDate><guid>http://intervalrain.github.io/posts/algorithm/freqstack/</guid><description>Maximum Frequency Stack algorithm</description></item><item><title>[Java] 面試常見問題</title><link>http://intervalrain.github.io/posts/java/interviewq/</link><pubDate>Wed, 16 Mar 2022 02:45:45 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/interviewq/</guid><description>針對Java常見面試考題整理，持續更新。</description></item><item><title>[CS50] Lec 1 - C</title><link>http://intervalrain.github.io/posts/cs50/lec1/</link><pubDate>Thu, 10 Mar 2022 02:39:12 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs50/lec1/</guid><description>Introduction to programming language C</description></item><item><title>[Java] transient 關鍵字</title><link>http://intervalrain.github.io/posts/java/transient/</link><pubDate>Tue, 08 Mar 2022 23:53:27 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/transient/</guid><description>Introduction to keyword transient</description></item><item><title>[Device] Mismatch Introduction</title><link>http://intervalrain.github.io/posts/device/mismatch/</link><pubDate>Sat, 05 Mar 2022 21:40:03 +0800</pubDate><guid>http://intervalrain.github.io/posts/device/mismatch/</guid><description>Device mismatch intro.</description></item><item><title>[C++] How to Initialize vector in C++</title><link>http://intervalrain.github.io/posts/c++/newvector/</link><pubDate>Thu, 03 Mar 2022 01:33:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/c++/newvector/</guid><description>Desc Text.</description></item><item><title>[Java] Integer.bitCount 解析</title><link>http://intervalrain.github.io/posts/java/bitcount/</link><pubDate>Tue, 01 Mar 2022 20:37:02 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/bitcount/</guid><description>Desc Text.</description></item><item><title>[OS] Lec 1 - Introduction</title><link>http://intervalrain.github.io/posts/os/lec1/</link><pubDate>Thu, 24 Feb 2022 02:43:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/os/lec1/</guid><description>概觀作業系統的歷史發展與進程</description></item><item><title>[Java] Java 的中 HashMap.comparableClassFor(Object x) 的函式解讀</title><link>http://intervalrain.github.io/posts/java/hashmap/hashmap/</link><pubDate>Wed, 23 Feb 2022 01:36:40 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/hashmap/hashmap/</guid><description>認識泛型 generic type、類別 class</description></item><item><title>[CS50] Lec 0 - Introduction to Computer Science</title><link>http://intervalrain.github.io/posts/cs50/lec0/</link><pubDate>Wed, 23 Feb 2022 00:43:18 +0800</pubDate><guid>http://intervalrain.github.io/posts/cs50/lec0/</guid><description>Intoduction to Computer Science</description></item><item><title>[ghpage] 在 GitHub Pages 中渲染 KaTex 公式</title><link>http://intervalrain.github.io/posts/ghpage/latexrendering/</link><pubDate>Tue, 22 Feb 2022 01:38:30 +0800</pubDate><guid>http://intervalrain.github.io/posts/ghpage/latexrendering/</guid><description>如何讓 GitHub Pages 中支援 Latex 語法</description></item><item><title>[Device] Ring Oscillator 環形振盪器</title><link>http://intervalrain.github.io/posts/device/ringoscillator/</link><pubDate>Mon, 21 Feb 2022 01:29:24 +0800</pubDate><guid>http://intervalrain.github.io/posts/device/ringoscillator/</guid><description>A ring circuit with an odd numbers of inverters</description></item><item><title>[Java] List of list of something equality</title><link>http://intervalrain.github.io/posts/java/listequal/</link><pubDate>Fri, 18 Feb 2022 08:59:45 +0800</pubDate><guid>http://intervalrain.github.io/posts/java/listequal/</guid><description>Common Test methodology in Leetcode</description></item><item><title>About me</title><link>http://intervalrain.github.io/posts/aboutme/</link><pubDate>Thu, 17 Feb 2022 17:54:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/aboutme/</guid><description>Who am I?</description></item><item><title>Hello World</title><link>http://intervalrain.github.io/posts/helloworld/</link><pubDate>Thu, 17 Feb 2022 15:15:36 +0800</pubDate><guid>http://intervalrain.github.io/posts/helloworld/</guid><description>How to hello world?</description></item><item><title>[Logic Design] Lec 1 - 數字系統與轉換</title><link>http://intervalrain.github.io/posts/logicdesign/lec1/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec1/</guid><description>Introduction to number systems in computer</description></item><item><title>[Logic Design] Lec 2 - 布林代數</title><link>http://intervalrain.github.io/posts/logicdesign/lec2/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec2/</guid><description>Boolean Algebra operation and theory</description></item><item><title>[Logic Design] Lec 3 - Minterm 與 Maxterm 展開</title><link>http://intervalrain.github.io/posts/logicdesign/lec3/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec3/</guid><description>Minterm and Maxterm expression</description></item><item><title>[Logic Design] Lec 4 - 卡諾圖 Karnaugh Maps</title><link>http://intervalrain.github.io/posts/logicdesign/lec4/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec4/</guid><description>Simplify Boolean function with K-map</description></item><item><title>[Logic Design] Lec 5 - Quine-McClusky Method</title><link>http://intervalrain.github.io/posts/logicdesign/lec5/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec5/</guid><description>Quine-McClusky method - systematic method to simplify boolean algebra for computer.</description></item><item><title>[Logic Design] Lec 6 - Multi-Level Gate Circuits / NAND and NOR Gates</title><link>http://intervalrain.github.io/posts/logicdesign/lec6/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec6/</guid><description>Multi-level gate circuits. nand gates and nor gates introduction.</description></item><item><title>[Logic Design] Lec 7 - 組合電路設計與模擬</title><link>http://intervalrain.github.io/posts/logicdesign/lec7/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec7/</guid><description>Combinational Circuit Design and Simulation Using Gates</description></item><item><title>[Logic Design] Lec 8 - 多工器、編碼器、可程式化邏輯元件</title><link>http://intervalrain.github.io/posts/logicdesign/lec8/</link><pubDate>Sat, 18 Sep 2021 03:11:35 +0800</pubDate><guid>http://intervalrain.github.io/posts/logicdesign/lec8/</guid><description>Combinational Circuit Design and Simulation</description></item><item><title>[Washam] Way to Software Engineer</title><link>http://intervalrain.github.io/posts/washam/</link><pubDate>Sat, 25 May 2019 22:35:48 +0800</pubDate><guid>http://intervalrain.github.io/posts/washam/</guid><description>Desc Text.</description></item></channel></rss>