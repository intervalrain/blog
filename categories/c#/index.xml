<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>C# on Rain's Blog</title><link>http://intervalrain.github.io/categories/c#/</link><description>Recent content in C# on Rain's Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 23 Feb 2023 21:40:03 +0800</lastBuildDate><atom:link href="http://intervalrain.github.io/categories/c#/index.xml" rel="self" type="application/rss+xml"/><item><title>[C#] Nullable 可空值類型</title><link>http://intervalrain.github.io/posts/csharp/nullable/</link><pubDate>Thu, 23 Feb 2023 21:40:03 +0800</pubDate><guid>http://intervalrain.github.io/posts/csharp/nullable/</guid><description>1. 簡寫 以後綴 ? 之前接在類型名稱後面，也就是 T? 可以視同為 Nullable&amp;lt;T&amp;gt; 舉例來說，下列四個變數類型名稱完全等價： Nullable&amp;lt;int&amp;gt; Nullable&amp;lt;int32&amp;gt; int? int32 2. 定義 Nullable 的核心程式碼為: public struct Nullable&amp;lt;T&amp;gt; where struct // 類型約束為非空值類型 { private readonly T value; private readonly bool hasValue; public Nullable(T value) { this.value = value; this.hasValue = true; } public bool HasValue { get { return hasValue; } } public T Value { get { if (!hasValue) { threw new InvalidOperationException(); } return value; } } } 由於 Nullable 的空值定義為 hasValue == false, 故以下兩者為等價 int?</description></item><item><title>[C#] Generic 泛型</title><link>http://intervalrain.github.io/posts/csharp/generic/</link><pubDate>Wed, 22 Feb 2023 21:39:56 +0800</pubDate><guid>http://intervalrain.github.io/posts/csharp/generic/</guid><description>1. 數組到泛型集合 數組缺少初始化時大小的彈性 string[] names = new string[4]; // 需指定大小 普通對象集合缺少類型安全 ArrayList names = new ArrayList(); names.AddRange(new object[] { &amp;#34;Rose&amp;#34;, &amp;#34;Jack&amp;#34;, new int?(5) // 可合法進行編譯, 因為符合 object }); foreach (string name in names) Console.WriteLine(name); // 缺少型別檢查, 在執行隱性類型轉換(int? 轉 string)時會出錯 專用對象集合缺少撰寫程式碼的靈活性(如無法以靜態方式寫通用方法)、且維護成本較高 StringCollection names = new StringCollection(); names.AddRange(new string[] { &amp;#34;Rose&amp;#34;, &amp;#34;Jack&amp;#34;, &amp;#34;Gozilla&amp;#34; }); static void printNames(StringCollection names) { foreach (string name in names) Console.WriteLine(name); } 泛型可以解決以上問題 在初始化時不須先設定大小 在添加錯誤型別的元素，在編譯時期就會報錯 兼容各種類型，省去撰寫與維護的成本 List&amp;lt;string&amp;gt; names = new List&amp;lt;string&amp;gt;{ &amp;#34;Rose&amp;#34;, &amp;#34;Jack&amp;#34;, &amp;#34;Gozilla&amp;#34; }; static void printList(List&amp;lt;T&amp;gt; list) { foreach (T item in list) Console.</description></item></channel></rss>