<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>IT on Rain Hu's Workspace</title><link>https://intervalrain.github.io/categories/it/</link><description>Recent content in IT on Rain Hu's Workspace</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 14 Oct 2023 02:09:18 +0800</lastBuildDate><atom:link href="https://intervalrain.github.io/categories/it/index.xml" rel="self" type="application/rss+xml"/><item><title>[IT] 程式語言的演進 Programming Language Evolution</title><link>https://intervalrain.github.io/posts/hgraca/programming-language-evolution/</link><pubDate>Sat, 14 Oct 2023 02:09:18 +0800</pubDate><guid>https://intervalrain.github.io/posts/hgraca/programming-language-evolution/</guid><description>程式設計語言本身並非架構的產物，但如果我不寫關於它，我會覺得《軟體架構編年史》似乎缺少了些什麼。
那麼，讓我們快速回顧一下程式語言的歷史，它的演變，並檢查我們可以從中學到什麼。我在文章中加入了一些日期，僅作為參考，它們應被視為大致的估計，重要的是演變的順序和他們試圖解決的問題。
1950s - Non-structured Programming Assembly ~1951
軟體開發曾是一項非常晦澀的活動，只在世界上少數地方進行。當時流行的語言是組合語言，它使用了非常低階的操作，如 add, sub, goto，並直接操作記憶體地址。建立一個簡單的應用程式既緩慢又困難。要創建一個簡單的 if 語句，我們需要幾行程式碼，對於一個迴圈，則需要超過幾行的程式碼&amp;hellip;稍後才出現了將程式碼分組和重用的可能性，所以當時的編碼風格非常線性，程式碼的重用僅限於在檔案內或檔案間複製和貼上程式碼。
1960s – Structured Programming Algol ~1958, Fortran
結構化程式設計出現了，引入了 code blocks 概念，控制結構 if, then, else, case, for, while, do, &amp;hellip;，和子程序的構造。然後，我們可以創建更有趣的程式流程，更重要的是，我們可以將程式碼指令分組並重用它，儘管有一些限制，例如子程序總是對同一全域變數進行操作。但就在這個時候，重用性 (reusability) 的概念開始被使用。
1970s – Procedural &amp;amp; Functional Programming Pascal ~1970, C ~1972
程序和函數式程式設計在1970年代開始活躍起來。到了這個時候，我們終於有了：
程序(Procedures)：一組不返回數據的指令 函式(Functions)：一組會回傳資料的指令集 資料結構(Data structures)：記錄，類似於關聯式陣列 模組(Modules)：可以被導入到其他程式碼檔案的程式碼檔案。 在1970年代，「Spaghetti code」這個詞也被創造出來，這是在Edsger W. Dijkstra於1968年寫給「計算機機構通訊」(CACM)的信中提出的，該信的標題為「Go To Statement Considered Harmful」。
在1970年代晚期，事件導向程式設計(Event Oriented Programming)的初步概念首次浮現，而Trygve Reenskaug則撰寫了他關於MVC（使用事件）的論文。
有了這些改進，因此我們有更好的重用性(reusability)，因為子程序（程序和函式），我們可以使用不同的數據執行相同的邏輯。我們也可以通過將相關數據分組到複雜的數據結構中來模擬領域概念(domain concepts)。最後，我們在**解耦(decoupling)和模組化(modularity)**方面邁出了第一步，我們可以創建在其他程式碼文件和事件中可重用的程式碼，以將客戶端程式碼與正在執行的邏輯解耦。
1980s – Object Oriented Programming Simula ~1965, Smalltalk-71 ~1971, C++ ~1980, Erlang ~1986, Perl ~1987, Python ~1991, Ruby ~1993, Delphi, Java, Javascript, PHP ~1995</description></item><item><title>[IT] 軟體架構前提 The Software Architecture Premises</title><link>https://intervalrain.github.io/posts/hgraca/software-architecture-premises/</link><pubDate>Sat, 14 Oct 2023 01:14:17 +0800</pubDate><guid>https://intervalrain.github.io/posts/hgraca/software-architecture-premises/</guid><description>在這篇文章中，我將建立有關軟體架構的最初概念，這將有助於更好地理解接下來的文章。
沒有萬靈丹 無論你如何理解我在《軟體架構編年史》中所談論的內容，最重要的是要明白，並不存在萬能的解決方案。儘可能多學習不同的方法，理解每種方法的優點和缺點，以及它們解決的具體技術問題。
然後，在接受新的挑戰時，首先要理解業務和終端用戶的需求。只有在清楚理解這些需求之後，您才能理智地思考應該使用哪種架構風格和模式來更好地解決手頭的問題。
最後，做出你自己的選擇，也許實施其中一種已知的解決方案，或者創建你自己的設計來適應你特定的問題。
Some architectural styles are often portrayed as ‘silver bullet’ solutions for all forms of software. However, a good designer should select a style that matches the needs of the particular problem being solved. - Roy Fielding, 2000
有些架構風格常被描繪為所有軟體問題的「萬靈丹」解決方案。然而，一個優秀的設計師應該選擇一種與特定問題需求相匹配的風格。 - 羅伊·菲爾丁，2000
Terminology 術語 在軟體開發的世界裡，使用的術語充滿了模糊性，因此，在繼續之前，澄清我所使用的一些術語的意義是非常重要的。
Functional 功能性的 這是任何一段程式碼、方法、類別、類別群組，它在應用程式中擔任純粹的技術角色。它與領域無關，僅代表應用程式中的技術能力。例如：
Layers Factories Repositories Value Objects Views ViewModels Conceptual 概念性的 這是任何一段代碼、方法、類別、一組類別，都反映了應用程式中的領域概念。它與領域直接相關，代表了應用程式中的業務能力。例如：
User Product Stock Management Product Variants Checkout Upsells 這種分離並不意味著一個程式碼單元不能以兩種方式（功能性和概念性）被引用。例如，一個 Money 類別可以代表一個 domain concept，也可以是一個 value object。</description></item><item><title>[IT] 軟體架構編年史 The Software Architecture Chronicles</title><link>https://intervalrain.github.io/posts/hgraca/the-software-architecture-chronicles/</link><pubDate>Fri, 13 Oct 2023 23:41:57 +0800</pubDate><guid>https://intervalrain.github.io/posts/hgraca/the-software-architecture-chronicles/</guid><description>前言：這系列文章為翻譯自作者 hgraca。
這篇文章是關於軟體架構系列文章的第一篇。在這些文章中，我將分享我所學習到的軟體架構知識，我如何看待它，以及我如何運用這些知識。
我這一系列的文章稱為「軟體架構編年史」，並非因為我自認為是一位偉大的作家，而是因為我覺得這個名字有點俗氣，又帶點趣味。
在這篇首篇文章中，我將會談論我為何要撰寫這一系列的文章，以及接下來將會有什麼內容。
認識歷史的重要性 Those who fail to learn History are doomed to repeat it. - George Santayana, The Life of Reason, 1905
未能學習歷史的人注定要重蹈覆轍。 - 喬治‧桑塔亞納《理性的生活》，1905
我認為從歷史中學習是非常重要的，它能教導我們事情。在個人層面上，我們終究需要（也希望）能從錯誤中學習。從國家的角度來看，歷史幫助塑造我們的文化、創造群體的概念，因此有了「台灣人」的觀念，一種國家認同。同時，歷史也幫助我們從祖先的錯誤中學習，比如信仰那些有著怪異思想的人，如二戰…
對程式開發者而言，歷史有助於我們仰靠前人的經驗上，少走許多錯的道路，並讓我們「站在巨人的肩膀上」達到更高的境界！
在我成為更好的開發者路上，我閱讀了很多文章，觀看了許多演講，我盡我所能的站在巨人的肩膀上。
有一件事情使我感到困惑，那就是許多意見是基於意見之上的意見…這就像是以訛傳訛，我們最終得到是對於一篇論文、文章或書籍真正內容的扭曲理解。
因此，我開始在網路上搜尋原始的論文、文章和書籍，這些都是我認為對我的工作最重要的概念，並自己對它們進行思考。
這些文章是這種推理的結果，因為我試圖理解這些概念是如何產生的，以某種程度上的時間順序來看。
撰寫這些文章迫使我大量閱讀和思考所有議題，並幫助我理解當代在軟體開發中使用的技術。我希望這些文章能對更多開發者有所幫助。
然而，如果你讀到一些你不理解或是不認同的內容，請告訴我，我非常願意討論這些議題，並從討論中學習，也願意修正我錯誤的觀點。
文章列表 1. 軟體架構前提 (Software Architecture Premises)
2. 程式語言的演進 (Programming Languages Evolution)
3. 架構風格 / 架構模式 / 設計模式 (Architectural Styles vs. Architectural Patterns vs. Design Patterns)
4. 單體架構 (Monolithic Architecture)
5. 分層架構 (Layered Architecture)</description></item><item><title>[IT] Clean Architecture - 第4章 - 結構化程式設計</title><link>https://intervalrain.github.io/posts/clean_arch/ch4/</link><pubDate>Tue, 03 Oct 2023 22:28:44 +0800</pubDate><guid>https://intervalrain.github.io/posts/clean_arch/ch4/</guid><description>structured programming</description></item><item><title>[IT] Clean Architecture</title><link>https://intervalrain.github.io/posts/clean_arch/clean_arch/</link><pubDate>Fri, 29 Sep 2023 02:03:47 +0800</pubDate><guid>https://intervalrain.github.io/posts/clean_arch/clean_arch/</guid><description>乾淨架構 設計(design)與架構(architecture)為何重要？ 軟體架構的目標是將開發與維護軟體系統所需的人力最小化。 不好的設計會使維護的成本愈來愈高。 每次版本的發布時的生產力。 良好的開發模式(TDD)大幅減少開發時間。 行為(behavior)與架構(architecture) 行為：緊迫但並非特別重要 架構：重要不緊迫
∵ 緊急且重要 &amp;gt; 不緊急但重要 &amp;gt; 緊急但不重要 &amp;gt; 不緊急且不重要
∴ 大多情況下，架構(設計)比行為(開發)更重要。 程式設計範式(paradigms) 結構化程式設計(structed programming) 不要使用 goto，使用結構化的設計模式。(順序、選擇、迭代) 總結：對直接控制權施加限制。 關注點：功能 物件導向程式設計(object-oriented programming) 使用多型來避免函數指針的濫用。 總結：對間接控制權施加限制。 關注點：組件分離 函式程式設計(functional programming) λ演算的概念是不可變性，符號的值不會改變，意味著沒有賦值。 總結：對賦值施加限制。 關注點：數據管理 物件導向設計： 依賴反轉： 商業邏輯不依賴於 UI 與 DB，UI 與 DB 可以做為商業邏輯的插件。 小結： 三種範式都在約束你寫 code 的某些行為。這些約束就是在制定規則。 SOLID 設計原則 SRP: 單一職責原則(The Single Responsibility Principle) 一個模組只有一個原因(用戶/利益相關者)需要改變。 OCP: 開放封閉原則(The Open-Closed Principle) 軟體工程應對擴展開放，但對修改封閉。 LSP: 里氏替體原則(The Liskov Substitution Principle) 避免簡單的可替代性違規導致大量的額外機制。 ISP: 介面隔離原則(The Interface Segregation Principle) 關注點分離。將一個多功能的物件拆成繼承三個不同功能介面的物件。 DIP: 依賴反轉原則(The Dependency Inversion Principle) 組件原則 組件是部署的單位，他們是系統的最小單元。 在 Java，他們是 jar 檔。 在 Ruby，他們是 gem 檔。 在 .</description></item><item><title>[IT] 事件總線 EventBus</title><link>https://intervalrain.github.io/posts/it/eventbus/</link><pubDate>Mon, 25 Sep 2023 23:50:02 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/eventbus/</guid><description>EventBus EventBus 用於維護一個事件源與事件處理的映射字典 通過 Singleton，確保 EventBus 的唯一入口 利用反射完成事件源與件事處理的初始化綁定 提供統一的事件注冊(register)、取消注冊(unsubscribe)和觸發(trigger)。 Interfaces IEventData public interface IEventData { DateTime EventTime { get; set; } object EventSource {get; set; } } IEventHandler public interface IEventHandler { } IEventHandler`1 public interface IEventHandler&amp;lt;TEventData&amp;gt; : IEventHandler where TEventData : IEventData { void HandlerEvent(TEventData eventData); } base class EventData public class EventData : IEventData { public DateTime EventTIme { get; set; } object EventSource { get; set; } public EventData() { EventTime = DateTime.</description></item><item><title>[IT] Clean Architecture - 重點整理</title><link>https://intervalrain.github.io/posts/it/ca/</link><pubDate>Sat, 23 Sep 2023 20:03:55 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/ca/</guid><description>乾淨架構(Clean Architecture) 筆記 分層 乾淨架構中從外而內依序為 Framework Layer Interface Adapter Layer Application Layer Domain Layer Models 一般來說會有四個 Models View Model(給前端) App Model(App Layer 隔離 Domain Layer 所用，aka DTO) Domain Model Data Model(for DBMS) Usecase App Layer 中的 Usecase 做四件事： 查 改 存 推 單向依賴原則 依賴的方向必為單向且為
\(\boxed{\text{Interface Adapter}} \rightarrow \boxed{\text{Application Layer}} \rightarrow \boxed{\text{Domain Layer}}\) Repository Application Layer 為了遵守單向依賴，與 ORM 解耦會做一次依賴反轉，翠取 Repository 介面。 套用乾淨架構的效益衡量 Model Mapping 的成本 vs. 獨立出「領域模型」的價值 省下更換技術的成本(migration cost) 「領域層」的部分通常會結合 DDD</description></item><item><title>[IT] LINQ: IQueryable Provider</title><link>https://intervalrain.github.io/posts/it/iq1/</link><pubDate>Thu, 21 Sep 2023 11:34:15 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/iq1/</guid><description>一系列關於如何建立 LINQ IQueryable Provider 的文章，每篇都是建立在前一篇的基礎上。</description></item><item><title>[IT] Clean Architecture - 第3章 - 程式設計範式總覽</title><link>https://intervalrain.github.io/posts/clean_arch/ch3/</link><pubDate>Thu, 07 Sep 2023 22:07:54 +0800</pubDate><guid>https://intervalrain.github.io/posts/clean_arch/ch3/</guid><description>paradigm overview</description></item><item><title>[IT] Clean Architecture - 第二部分 從基礎構件開始: 程式設計範式(Paradigms)</title><link>https://intervalrain.github.io/posts/clean_arch/sec2/</link><pubDate>Tue, 05 Sep 2023 21:43:11 +0800</pubDate><guid>https://intervalrain.github.io/posts/clean_arch/sec2/</guid><description>軟體架構始於程式碼，因此我們將從程式碼的角度開始討論架構，看看自從程式碼被寫下以來我們所學到的內容。
1938年，艾倫·圖靈(Alan Turing)奠定了計算機編程的基礎。他並不是第一個構想可編程機器的人，但他是第一個理解程式即數據(programs are simply data)的人。到了1945年，圖靈已經在真正的電腦上用我們現在能夠認出的程式碼編寫真正的程式了。這些程式使用了循環(loops)、分支(branches)、賦值(assignment)、子程序(subroutines)、堆棧(stacks)和其他熟悉的結構。但，圖靈的語言是二進制的。
自從那些日子以來，程式設計界發生了許多革命。其中一個我們都非常熟悉的革命就是語言的革命。首先，在1940年代末期，出現了組合語言(assemblers)。這些「語言」解放了程式設計師將他們的程式轉換成二進制的苦差。1951年，格雷斯·霍珀(Grace Hopper)發明了第一個編譯器 A0。事實上，她創造了「編譯器(compiler)」這個詞彙。Fortran 在1953年被發明出來。接著，一股源源不斷的新程式語言湧入 - COBOL、PL/1、SNOBOL、C、Pascal、C++、Java等等，無窮無盡。
另一個可能更重要的革命是在程式設計範式方面。範式是編程的方式，與語言相對無關。範式指導了開發人員應該使用哪些程式結構，以及何時使用它們。
迄今為止，已經有三種這樣的範式，也不太可能再有其它的範式，原因後述。</description></item><item><title>[IT] Clean Architecture - 第2章 - 兩個價值維度</title><link>https://intervalrain.github.io/posts/clean_arch/ch2/</link><pubDate>Mon, 04 Sep 2023 15:18:12 +0800</pubDate><guid>https://intervalrain.github.io/posts/clean_arch/ch2/</guid><description>two values</description></item><item><title>[IT] Clean Architecture - 第1章 - 設計與架構到底是什麼</title><link>https://intervalrain.github.io/posts/clean_arch/ch1/</link><pubDate>Sun, 03 Sep 2023 23:14:07 +0800</pubDate><guid>https://intervalrain.github.io/posts/clean_arch/ch1/</guid><description>What is design and architecture?</description></item><item><title>[IT] Clean Architecture - 第一部分 概述</title><link>https://intervalrain.github.io/posts/clean_arch/sec1/</link><pubDate>Sun, 03 Sep 2023 22:48:22 +0800</pubDate><guid>https://intervalrain.github.io/posts/clean_arch/sec1/</guid><description>採用好的軟體架構可以大大節省軟體項目構建與維護的人力成本。讓每次變更都短小簡單，易於實施，並且避免缺陷，用最小的成本，最大程度地滿足功能性和靈活性的要求。</description></item><item><title>[IT] Clean Architecture - Catalog</title><link>https://intervalrain.github.io/posts/clean_arch/toc/</link><pubDate>Sun, 03 Sep 2023 22:32:22 +0800</pubDate><guid>https://intervalrain.github.io/posts/clean_arch/toc/</guid><description> Clean Architecture
A Craftsman&amp;rsquo;s Guide to Software Structure and Design
中文翻譯: 無瑕的程式碼 - 整潔的軟體設計與架構
原著: Robert C. Martin(Uncle Bob)
目錄 第一部分 概述 第1章 - 設計與架構到底是什麼 第2章 - 兩個價值維度 第二部分 從基礎構件開始: 程式設計範式 第3章 - 程式設計範式總覽 第4章 - 結構化程式設計 第5章 - 物件導向程式設計 第6章 - 函數式程式設計 第三部分 設計原則 第7章 - SRP 單一職責原則 第8章 - OCP 開放封則原則 第9章 - LSP 里氏替換原則 第10章 - ISP 介面隔離原則 第11章 - DIP 依賴反轉原則 [第四部分 組件構建原則)(/posts/clean_arch/sec4) 第12章 - 元件 第13章 - 元件聚合 第14章 - 元件耦合 第五部分 軟體架構 第15章 - 什麼是軟體架構 第16章 - 獨立性 第17章 - 劃分邊界 第18章 - 邊界剖析 第19章 - 策略與層次 第20章 - 業務邏輯 第21章 - 尖叫的軟體架構 第22章 - 整潔架構 第23章 - 展示器和謙卑物件 第24章 - 不完全邊界 第25章 - 層次與邊界 第26章 - Main 元件 第27章 - 服務: 宏觀與微觀 第28章 - 測試邊界 第29章 - 整潔的嵌入式架構 第六部分 實現細節] 第30章 - 數據庫只是實現細節 第31章 - Web 是實現細節 第32章 - 應用程式框架是實現細節 第33章 - 案例分析: 影片銷售網站 第34章 - 拾遺</description></item><item><title>[CS] Sample cost for performance test</title><link>https://intervalrain.github.io/posts/csharp/performancetest/</link><pubDate>Tue, 16 May 2023 21:26:24 +0800</pubDate><guid>https://intervalrain.github.io/posts/csharp/performancetest/</guid><description>Sample code for stop watch using System; using System.Collections.Generic; using System.Data; using System.Linq; using System.Runtime.CompilerServices; using System.Data.Common; using System.Diagnostics; using System.Drawing; using System.Text; using System.Threading.Tasks; namespace Rainspace.PlayGround { public class Program { public static void Main(string[] args) { Stopwatch sw = new Stopwatch(); sw.Start(); System.Console.WriteLine(&amp;#34;==============Accumulate1==============&amp;#34;); System.Console.WriteLine(&amp;#34;Result: &amp;#34; + Accumulate(0, 100, 0)); sw.Stop(); System.Console.WriteLine(&amp;#34;Time cost: &amp;#34; + (sw.ElapsedTicks/1.0e6).ToString() + &amp;#34;ms&amp;#34;); sw.Reset(); sw.Start(); System.Console.WriteLine(&amp;#34;==============Accumulate2==============&amp;#34;); System.Console.WriteLine(&amp;#34;Result: &amp;#34; + Accumulate(0, 100, 0)); sw.Stop(); System.Console.WriteLine(&amp;#34;Time cost: &amp;#34; + (sw.</description></item><item><title>[IT] 關聯模式的五大鍵 Super key、Candidate Key、Primary Key、Alternate Key、Foreign Key</title><link>https://intervalrain.github.io/posts/it/keysinrelation/</link><pubDate>Thu, 11 May 2023 21:50:43 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/keysinrelation/</guid><description>關聯模式的五大鍵介紹</description></item><item><title>[IT] Design Patterns</title><link>https://intervalrain.github.io/posts/it/design_pattern/</link><pubDate>Mon, 01 May 2023 00:22:49 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/design_pattern/</guid><description>簡介設計模式</description></item><item><title>[IT] C# Depth Ch.2 C# 2</title><link>https://intervalrain.github.io/posts/it/csharp_depth_ch2/</link><pubDate>Fri, 20 Jan 2023 10:10:46 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/csharp_depth_ch2/</guid><description>C# 2 一、泛型 使用泛型(generic type)可以在編寫在編譯時類型安全的通用程式碼，無須事先知道要使用的具體類型。 示例1: array類型: 大小需預先設定，若要添加需要重新分配 public static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(string[] names) { foreach (string name in names) { Console.WriteLine(name); } } public static string[] GenerateNames() { string[] names = new string[4]; names[0] = &amp;#34;Mike&amp;#34;; names[1] = &amp;#34;Rain&amp;#34;; names[2] = &amp;#34;Jessica&amp;#34;; names[3] = &amp;#34;Billy&amp;#34;; return names; } 示例2: ArrayList類型: ArrayList.Add是Object的方法，但如果塞入不適合的參數類型，可能會引發InvalidCastException
public static void Main(string[] args) { PrintNames(GenerateNames()); } public static void PrintNames(ArrayList names) { foreach (object name in names) { Console.</description></item><item><title>[IT] C# Depth Ch.1 與時俱進的語言</title><link>https://intervalrain.github.io/posts/it/csharp_depth_ch1/</link><pubDate>Tue, 17 Jan 2023 22:27:58 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/csharp_depth_ch1/</guid><description>與時俱進的語言 一、System Class 1. 泛型(genric) 可更清楚的描述序列中每個元素的類型。 C#1 示例
public class Bookshelf { public IEnumerable Books { get { ... } } } C#2 示例：泛型
public class Bookshelf { public IEnumerable&amp;lt;Book&amp;gt; Books { get { ... } } } 2. 可空值類型(nullable value type) 可有效的表示未定的變量值，以擺脫魔數(用-1當集合索引，用 MinValue 或 MaxValue 做為初始值)。 示例
string? a = null; Console.WriteLine(a ?? &amp;#34;null&amp;#34;); // null a = &amp;#34;abc&amp;#34;; Console.WriteLine(a ?? &amp;#34;null&amp;#34;); // abc 3. 匿名類型(anonymous type)、隱式局部變數(var) 兩者皆可解決靜態類型語言的缺陷：程式碼冗長。 示例1: 匿名類型(anonymous type)</description></item><item><title>[IT] Shell 筆記</title><link>https://intervalrain.github.io/posts/it/shell/</link><pubDate>Thu, 12 Jan 2023 23:34:41 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/shell/</guid><description>Reference
https://blog.csdn.net/w918589859/article/details/108752592
https://www.w3cschool.cn/linux/linux-Shell.html
一、Shell 簡介 什麼是 Shell?
Shell 是一個用 C 語言編寫的程式，它是使用者使用 Linux 的橋樑。Shell 既是一種命令語言，又是一種程式設計語言。
Shell 是指一種應用程式，這個應用程式提供了一個界面，使用者通過這個界面訪問作業系統核心(kernel)的服務。 為什麼要學習和使用 Shell?
Shell 屬於內建的腳本，程序開發的效率非常高，依賴於功能強大的命令可以迅速的完成開發任務(批次處理)。 Shell 腳本(Shell script)
是一種為 Shell 編寫的腳本程式。業界所說的 Shell 通常都是指 Shell 腳本。 二、 Shell 入門 1. Shell 環境 Shell 編程需要能編寫程式碼的文本編輯器和一個能解釋執行的腳本解釋器。 在 linux 中有很多類型的 Shell，不同的 Shell 具備不同的功能，Shell 還決定了腳本中函數的語法。 Bash 是 Linux 中默認的 Shell。一般情況下，人們不區分 Bourne Shell 和 Bourne Again Shell，所以 #!/bin/sh 也可以被替換成 #!/bin/bash Linux 的 Shell 種類眾多，不同的 Shell 都有自己的特點以及用途，常見的有： Bourne Shell (/usr/bin/sh 或 /bin/sh) Bourne Again Shell (/bin/bash) C Shell (/usr/bin/csh) K Shell (/usr/bin/ksh) Shell for Root(sbin/sh) &amp;hellip;&amp;hellip; 2.</description></item><item><title>[IT] 動態鏈結庫(DDL)</title><link>https://intervalrain.github.io/posts/it/ddl/</link><pubDate>Sun, 18 Sep 2022 22:45:56 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/ddl/</guid><description>Command to construct DDL</description></item><item><title>[IT] MySQL Functions</title><link>https://intervalrain.github.io/posts/it/mysql/</link><pubDate>Thu, 01 Sep 2022 13:28:14 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/mysql/</guid><description>Built-in function in MySQL</description></item><item><title>[IT] SQL</title><link>https://intervalrain.github.io/posts/it/sql/</link><pubDate>Thu, 01 Sep 2022 13:28:14 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/sql/</guid><description>Base command of SQL</description></item><item><title>[IT] Introduction to Microservices, Docker and Kubernetes</title><link>https://intervalrain.github.io/posts/it/microservices_docker_kubernetes/</link><pubDate>Fri, 29 Apr 2022 11:40:10 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/microservices_docker_kubernetes/</guid><description>Desc Text.</description></item><item><title>[IT] 在 GitHub Pages 中渲染 KaTex 公式</title><link>https://intervalrain.github.io/posts/it/latexrendering/</link><pubDate>Tue, 22 Feb 2022 01:38:30 +0800</pubDate><guid>https://intervalrain.github.io/posts/it/latexrendering/</guid><description>如何讓 GitHub Pages 中支援 Latex 語法</description></item></channel></rss>