<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>IT | Rain Hu's Workspace</title>
<meta name=keywords content><meta name=description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta name=author content="Rain Hu, intervarrain, 陣雨"><link rel=canonical href=https://intervalrain.github.io/categories/it/><meta name=google-site-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.62544d021d74c1d1215183b216a7ce71465bcb05e8768851d5c6d332d9672210.css integrity="sha256-YlRNAh10wdEhUYOyFqfOcUZbywXodohR1cbTMtlnIhA=" rel="preload stylesheet" as=style><link rel=preload href=/images/rain.png as=image><link rel=icon href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=16x16 href=https://intervalrain.github.io/images/rain.png><link rel=icon type=image/png sizes=32x32 href=https://intervalrain.github.io/images/rain.png><link rel=apple-touch-icon href=https://intervalrain.github.io/images/rain.png><link rel=mask-icon href=https://intervalrain.github.io/images/rain.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://intervalrain.github.io/categories/it/index.xml><link rel=alternate hreflang=en href=https://intervalrain.github.io/categories/it/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://utteranc.es/client.js repo=intervalrain.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script><meta property="og:title" content="IT"><meta property="og:description" content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"><meta property="og:type" content="website"><meta property="og:url" content="https://intervalrain.github.io/categories/it/"><meta name=twitter:card content="summary"><meta name=twitter:title content="IT"><meta name=twitter:description content="Rain Hu 記錄生活、工作、學習、個人創作的空間，包含了音樂創作、文字創作、演算法筆記、資工學習資料、架站資料、程式語言筆記、Leetcode 解題分析等各式各樣的資訊"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://intervalrain.github.io/ accesskey=h title="Rain Hu's Workspace (Alt + H)"><img src=https://intervalrain.github.io/images/rain.png alt=logo aria-label=logo height=35>Rain Hu's Workspace</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://intervalrain.github.io/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://intervalrain.github.io/aboutme title="About me"><span>About me</span></a></li><li><a href=https://intervalrain.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://intervalrain.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://intervalrain.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://intervalrain.github.io/csharp/csharp title=C#><span>C#</span></a></li><li><a href=https://intervalrain.github.io/csindex title=CS><span>CS</span></a></li><li><a href=https://intervalrain.github.io/leetcode title=LeetCode><span>LeetCode</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://intervalrain.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://intervalrain.github.io/categories/>Categories</a></div><h1>IT</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] 套件與命名空間 packaging & namespacing</h2></header><section class=entry-content><p>系統的架構是該系統的高層視圖、大局觀，以粗略的筆觸描繪的系統設計。架構決策是系統中的結構性決策，影響整個程式庫的決策，也是定義其他所有元素將在其上建立的決策。
架構決定系統的許多元素，包含：
組件 Components 組件之間的關係 Relationships between components 指導組件與組件間關係如何設計與如何演化 Principles guiding the design and evolution of components and relationships 換句話說，這些是隨著系統演進更難改變的設計決策，它們是支撐功能開發的基礎。
義大利麵架構 Spaghetti Architecture 有些專案，結構隨機，既不反映架構，也不反映領域。如果我問「我應該把這個 value object 放在哪裡？」結果得到「把它放在 src 資料夾的某個地方」這樣的回答；如果我問「執行這個邏輯的 service 在哪裡？」卻得到「用你的 IDE 進行搜索」這樣的回答。這意味著專案沒有經過組織，這樣鬆散的結構就稱為義大利麵架構(Spaghetti Architecture)。
這是一個大問題，因為這意味著沒有套件模組化，高階的程式碼關係和流程並沒有可以遵循的邏輯結構，導致模組之間高度耦合且低內聚，實際上可能代表根本沒有模組，應該屬於模組的程式碼散佈在整個程式碼庫中。
可維護的程式碼庫 擁有一個可維護的程式庫意味著我們可以變更最少的程式碼來實現最大的概念變更。換句話說，當我們需要對一個程式碼單元進行變更時，我們應該盡可能少地對其他程式碼單元進行變更。
這樣帶來的優點有：
程式碼的修改變得簡單，因為它們對較少的程式碼產生影響。 程式碼的修改會更快，因為需要修改的程式碼較少。 因為修改的程式碼變少，出現錯誤的可能性也更低。 封裝(encapsulation)、**低耦合(low coupling)和高內聚(high cohesion)**是使程式碼隔離的核心原則，使得我們能夠擁有可維護的程式碼基礎。
封裝 Encapsulation 這是隱藏類別的內部訊息與實作的過程。
也就是說，它對外隱藏了實作的方式，使得一個類別的內部結構可以自由變更，而不會影響使用這個特定類別的其他類別。
低耦合 Low coupling 耦合是指一個程式碼單元與另一個程式碼單元的關係。如果對一個模組的更改將導致對另一個模組的更改，則該模組被認為與另一個模組高度耦合。而如果一個模組獨立於任何其他模組，則該模組被認為是低耦合的。這可以通過擁有一個穩定的介面來實現，有效地隱藏了對其他模組的實現。
低耦合的好處 可維護性(maintainability) - 變更僅限於單一模組 可測試性(testability) - 可以將單元測試涉及的模塊限制到最小 可讀性(readability) - 需要分析的類別被保持在最小範圍內 高內聚 High Cohesion 內聚性是指一個模塊的功能之間的緊密相關程度的衡量。低內聚是指模組間具有許多不相關的職責；高內聚是指模組間有類似的概念。
高內聚的好處 可讀性(readability) - 相關的功能都包含在單一模塊中 可維護性(maintainability) - bug 通常會被限制在單一模組中 重用性(reusability) - 專注於類別的功能，不被無用的功能污染 結構上的影響 前述的原則通常與類別相關，然而，它們對於類別群組也同樣適用。類別群組在一般情況下被稱為套件(package)，但如果它們具有純粹的功能性目標(例如 ORM)，我們可以更具體地稱呼它們為模組(module)；如果它們具有領域目標(例如 AccountManagement)，我們可以稱呼它們為組件(components)。這與 Bass, Clements 和 Kazman 在他們的書《實踐軟體架構(Software Architecture in Practice)》中解釋的定義是一致的。...</p></section><footer class=entry-footer>&lt;span title='2023-10-23 23:14:14 +0800 +0800'>October 23, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;hgraca</footer><a class=entry-link aria-label="post link to [IT] 套件與命名空間 packaging & namespacing" href=https://intervalrain.github.io/hgraca/packaging-code/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] EBI 架構</h2></header><section class=entry-content><p>EBI 架構全名是 Entity-Boundary-Interactor Architecture，第一次由 Robert C. Martin 在他乾淨架構(Clean Architecture)中的演講中提到。
然而，EBI 架構正式的發布是來自 Ivar Jacobson 在 1992 年所出版的 《物件導向的軟體工程：用例驅動方法(Object-Oriented Software Engineering: A use case driven approach)》。當時，Jacobson 實際上稱之為 Entity-Interface-Control，爾後才進行更名，為了避免將 Interface 與程式語言中的 Interface 或 User Interface 混淆；也避免將 Control 與 MVC 中的 Controller 混淆。
Entity 實體 Entity objects 持有所有系統使用的數據且持有所有與數據耦合的行為。每個 Entity object 代表一個與問題領域相關的概念，同時具備身份(identity)與永久性(persistence)。Jacobson 告訴我們，Entity object 應該要包含那些會因 entity 自身變化而變化的邏輯，也就是說，如果它持有的數據結構改變，則對該數據的操作也將需要變化，因此它們應該位於 entity中。
值得注意的是，Jacobson在1992年就已經發出了一個警告：
Beginners may sometime only use entity object as data carriers and place all dynamic behaviour in control objects […]....</p></section><footer class=entry-footer>&lt;span title='2023-10-22 23:54:36 +0800 +0800'>October 22, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;hgraca</footer><a class=entry-link aria-label="post link to [IT] EBI 架構" href=https://intervalrain.github.io/hgraca/ebi-architecture/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] Model1 & Model2</h2></header><section class=entry-content><p>Java Server Pages (JSP) 是一種技術，這種腳本語言與 PHP、ASP，甚至 Python 相當，用於創建由 JVM 解釋的伺服器端頁面，並可以使用 Java 物件。
首次由 Sun Microsystems 於 1998 年發布的 JSP 規範，定義了兩種結構化應用程式的方式，使得呈現邏輯能與業務邏輯，甚至是在 HTTP 請求/回應範疇中的使用案例，進行解耦。
有些人認為這些"Model1"和"Model2"是首次嘗試將原本為桌面軟體開發環境而設計的 MVC 模式，適配到網路 HTTP 請求/回應範疇的嘗試。
Model1 JSP 規範 v0.92 的首次提議，是將 JSP 作為唯一的呈現工具，其中包含所有的呈現和用例邏輯。 這種方法對當時的大多數使用情況可能已經足夠好，因為當時的網路大部分是由簡單的動態頁面組成，而不是我們今天所熟知的複雜的網路企業應用程式。
Model2 關於如何使用 JSP 的第二個建議，當時是針對被視為複雜的網路應用程式而設計的。然而，請記住，如今的網路應用程式的規模和複雜度已經更高了。 在“Model2”中，一個 HTTP 請求會到達一個 servlet，該 servlet 會解釋 HTTP 請求，使用 Java 物件和 EJBs（repositories）執行一些用例邏輯，收集結果數據，並將該數據傳遞給一個 JSP，該 JSP 再渲染頁面，並發送回客戶端。在“Model2”中，JSPs 僅作為模板引擎使用。
在1999年，Govind Seshadri 發表了一篇文章，其中他將"Model2"對應到 MVC：
servelet 是 Controller，它控制應如何處理用戶的請求。 JSP 是 View，它決定了顯示給使用者的內容。 在 MVC 和"Model2"中，Model 指的都是一整個領域模型(domain model)。 我的看法 這兩種方法至今只能說是堪用，但對今日的網路企業應用程式而言，我們需要更好的東西，因為這兩種模式都不遵守單一職責原則(Single Respoinsibility Pinciple, RSP)。...</p></section><footer class=entry-footer>&lt;span title='2023-10-19 22:47:32 +0800 +0800'>October 19, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;hgraca</footer><a class=entry-link aria-label="post link to [IT] Model1 & Model2" href=https://intervalrain.github.io/hgraca/model-1-model-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] Action-Domain-Responder(ADR) 架構</h2></header><section class=entry-content><p>這篇文章將討論 MVC 的另一種變體：由 Paul M. Jones 創建的 Action-Domain-Responder。
2014 – Action-Domain-Responder(ADR) ADR 模式是由 Paul M. Jones 於 2014 年創建的，其想法就像 RMR 一樣，是為了將 MVC 調整到網路 REST APIs的 情境中。ADR 的原始解釋非常簡單明瞭，我實在無法更好地改述它，所以我將在這裡複製/貼上部分內容，並只添加一些更多的評論。
Action 行動 Is the logic to connect the Domain and Responder. It invokes the Domain with inputs collected from the HTTP request, then invokes the Responder with the data it needs to build an HTTP response. 這是連接 domain 和 responder 的邏輯，它會用從 HTTP 收集來的請求來觸發 domain，接著使用需要構建 HTTP 響應的數據來調用 responder。...</p></section><footer class=entry-footer>&lt;span title='2023-10-19 22:43:08 +0800 +0800'>October 19, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;4 min&amp;nbsp;·&amp;nbsp;hgraca</footer><a class=entry-link aria-label="post link to [IT] Action-Domain-Responder(ADR) 架構" href=https://intervalrain.github.io/hgraca/action-domain-responder/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>[IT] Resource-Method-Representation(RMR) 架構</h2></header><section class=entry-content><p>MVC 於 1979 年在桌面應用程式與 CLI 使用者介面的背景下出現，這意味著如果資料庫因使用者以外的某些因素發生變化，則使用者介面將自動更改。同樣的模式後來在具有 GUI 的桌面應用程式上也完全可用。
然而，其在網路應用程式中的使用一直都是一種調適，因為大多數的網路應用程式並不會因為伺服器端的變更而改變使用者介面，使用者介面總是會呼叫伺服器端要求更新畫面。
我之前已經談過 MVC 模式的變體，這篇文章將討論另一種變體：Resource-Method-Representation。
我覺得有必要談論這個議題，是因為我曾對它產生誤解，認為它與 ADR 模式一樣，而我很快就會寫到這一點。
2008 – Resource-Method-Representation(RMR) RMR 模式是由 Paul James 在 2008 年創建的，它將 MVC 模式適配到 REST APIs 的情境中。
Resource 資源 The idea is that the Entities are modelled as REST resources (the first R in the pattern name), with its only public methods mapping to an HTTP method: 這個概念是將實體模型化為 REST resources 資源（RMR中的第一個R），與其唯一的公開方法映射到一個 HTTP 方法：
&lt;?php // taken from http://www....</p></section><footer class=entry-footer>&lt;span title='2023-10-19 22:17:59 +0800 +0800'>October 19, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;hgraca</footer><a class=entry-link aria-label="post link to [IT] Resource-Method-Representation(RMR) 架構" href=https://intervalrain.github.io/hgraca/resource-method-representation/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://intervalrain.github.io/categories/it/page/3/>« Prev Page</a>
<a class=next href=https://intervalrain.github.io/categories/it/page/5/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://intervalrain.github.io/>Rain Hu's Workspace</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>