<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>CS on Rain Hu's Workspace</title><link>https://intervalrain.github.io/categories/cs/</link><description>Recent content in CS on Rain Hu's Workspace</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 07 May 2023 18:46:56 +0800</lastBuildDate><atom:link href="https://intervalrain.github.io/categories/cs/index.xml" rel="self" type="application/rss+xml"/><item><title>[Algo] 3-2. Binary Search</title><link>https://intervalrain.github.io/posts/cs/algo/binary_search/</link><pubDate>Sun, 07 May 2023 18:46:56 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/binary_search/</guid><description>介紹二元搜索法，並介紹其適用情境</description></item><item><title>[Algo] 3-10. Binary Indexed Tree(Fenwick Tree, BIT)</title><link>https://intervalrain.github.io/posts/cs/algo/bit/</link><pubDate>Sat, 08 Apr 2023 17:46:12 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/bit/</guid><description>利用 Binary Indexed Tree 做數組的動態更新與查詢，中譯為樹狀樹組</description></item><item><title>[Algo] 3-1. Two Pointer/Sliding Window</title><link>https://intervalrain.github.io/posts/cs/algo/two_pointer/</link><pubDate>Sun, 19 Mar 2023 22:56:03 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/two_pointer/</guid><description>使用雙指標或是更進階的滑動窗口的技巧，對資料集合(可能是array，可能是list)做搜尋。</description></item><item><title>[Algo] 3-0. Sorting</title><link>https://intervalrain.github.io/posts/cs/algo/sorting/</link><pubDate>Thu, 16 Mar 2023 19:50:21 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/sorting/</guid><description>從排序開始，練習將想法實踐，All start from sorting</description></item><item><title>[C#] C# 筆記</title><link>https://intervalrain.github.io/posts/csharp/csharp/</link><pubDate>Tue, 28 Feb 2023 18:49:39 +0800</pubDate><guid>https://intervalrain.github.io/posts/csharp/csharp/</guid><description>Notes for C#</description></item><item><title>[Algo] 2-4. 回溯法 Backtracking</title><link>https://intervalrain.github.io/posts/cs/algo/backtracking/</link><pubDate>Fri, 27 Jan 2023 10:50:26 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/backtracking/</guid><description>演算法設計，介紹什麼是回溯法，並示範運用回溯法的思維解題</description></item><item><title>[Algo] 2-2. 貪心演算法 Greedy</title><link>https://intervalrain.github.io/posts/cs/algo/greedy/</link><pubDate>Tue, 24 Jan 2023 18:31:15 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/greedy/</guid><description>演算法設計，介紹什麼是貪心法，貪心法的解題思維</description></item><item><title>[Algo] 2-1. 暴力演算法 Brute Force</title><link>https://intervalrain.github.io/posts/cs/algo/brute_force/</link><pubDate>Tue, 24 Jan 2023 15:57:40 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/brute_force/</guid><description>演算法設計，介紹什麼是暴力演算法，並示範幾種資料結構的遍歷與枚舉</description></item><item><title>[Algo] 1-9. Algorithm</title><link>https://intervalrain.github.io/posts/cs/algo/algorithm/</link><pubDate>Tue, 03 Jan 2023 21:49:42 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/algorithm/</guid><description>C++ 的內建演算法庫使用與範例</description></item><item><title>[Algo] 2-5. 動態規劃 Dynamic Programming</title><link>https://intervalrain.github.io/posts/cs/algo/dp/</link><pubDate>Tue, 15 Nov 2022 16:10:53 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/dp/</guid><description>演算法設計，介紹什麼是動態規劃，並介紹幾種動態規劃常見的題型，與解題框架</description></item><item><title>[Algo] 0-1. 複雜度分析 Algorithmic complexity / Big-O / Asymptotic analysis</title><link>https://intervalrain.github.io/posts/cs/algo/bigo/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/bigo/</guid><description>演算法的複雜度分析，與複雜度的表示法</description></item><item><title>[Algo] 0-4. 二叉樹(Binary Tree)</title><link>https://intervalrain.github.io/posts/cs/algo/binary_tree/</link><pubDate>Thu, 06 Oct 2022 23:00:28 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/binary_tree/</guid><description>演算法思維，介紹二叉樹這種資料結構以及如何使用它與 Leetcode 相關範例介紹</description></item><item><title>[Algo] 0-3. 鏈表(Linked List)</title><link>https://intervalrain.github.io/posts/cs/algo/linked_list/</link><pubDate>Thu, 06 Oct 2022 22:30:28 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/linked_list/</guid><description>演算法結構介紹，介紹鏈表的遍歷，與常見的經典考題與常用到的操作手法</description></item><item><title>[Algo] 0-2. 算法思維</title><link>https://intervalrain.github.io/posts/cs/algo/concept/</link><pubDate>Thu, 06 Oct 2022 22:15:28 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/concept/</guid><description>演算法的思維，在深入 Leetcode 世界前的一些基礎引導</description></item><item><title>CS 學習筆記</title><link>https://intervalrain.github.io/posts/csindex/</link><pubDate>Thu, 06 Oct 2022 22:01:48 +0800</pubDate><guid>https://intervalrain.github.io/posts/csindex/</guid><description>rainhu的資工學習筆記</description></item><item><title>[DS] 演算法筆記</title><link>https://intervalrain.github.io/posts/cs/algo/</link><pubDate>Thu, 06 Oct 2022 22:00:28 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/algo/</guid><description>演算法筆記，提供各式各樣的程式設計演算法，並以 leetcode 題目或是實際案例出發，介紹並分析解法。</description></item><item><title>[作業系統] 計算機組織與結構</title><link>https://intervalrain.github.io/posts/cs/ca/</link><pubDate>Sun, 03 Jul 2022 01:39:35 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/ca/</guid><description>計算機組織與結構 計算機抽象化與科技 指令集架構 計算機算術 處理器 Pipeline 記憶體 參考資料 黃婷婷 清大開放式課程 計算機結構 Mr. opengate</description></item><item><title>[作業系統] 計算機作業系統</title><link>https://intervalrain.github.io/posts/cs/os/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/os/</guid><description>計算機作業系統 概述 進程管理 死鎖 記憶體管理 設備管理 鏈接 參考資料 cyc2018 Mr. opengate</description></item><item><title>[計算機作業系統] 概述</title><link>https://intervalrain.github.io/posts/cs/os/intro/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/os/intro/</guid><description>作業系統 簡介 電腦系統主要可分成四個部分，或分成硬體(hardware)、軟體(software)、數據(data)
硬體(hardware)：為系統提供基本的計算資源。 中央處理器(central processing unit, CPU) 記憶體(memory) I/O 裝置 應用程式(Application programs)：定義資源如何用來解決使用者的計算問題。 使用者(users) 作業系統(Operating system, OS)： 作業系統(Operating system, OS) 是管理電腦硬體與軟體資源的電腦程式，同時也是電腦系統的核心與基石。
OS 最主要的兩個功能是：
資源分配：根據需求調配資源分配率(resource utilization)與效能(performance) 監控使用者程式的執行，避免不正常的運作造成對系統的危害。 一個標準的 PC 作業系統應該提供以下的功能：
行程管理(Processing management) 記憶體管理(Memory management) 檔案系統(File system) 網路通訊(Networking) 安全機制(Security) 使用者介面(User interface) 驅動程式(Device drivers) PC 基本特徵 1. 並行計算(Concurrent computing) Concurrent computing 是指宏觀上在一段時間內能同時運行多個進程，微觀上是交替發生的；而平行計算(parallel computing) 則指同一個時間內能運行多個指令。 平行計算需要硬體支持，如多線程(multi-thread)、多核處理器(multi-core processor)或者分散式計算機系統(distributed OS)。 作業系統通過引入進程(process)與線程(thread)，使程式能夠並行運作。 2. 分享(Sharing) 共享是指系統中的資源可以被多個並行進程共同使用。 有兩種共享方式：互斥共享(mutual exclusion)與同時訪問(time sharing)。 互斥共享的資源稱為臨界資源(critical resources)，例如印表機等，在同一時間內只允許一個進程訪問，需要用同步機制來實現互斥訪問。 3. 虛擬(Virtual) 虛擬技術把一個物理實體轉換為多個邏輯實體。 主要有兩種虛擬技術：分時技術(time sharing)、空間分享技術。 多個進程能在同一個處理器上並行處理使用了分時技術，讓每個進程輪流占用處理器，每次只執行一小個時間片段並快速切換。 虛擬記憶體使用了空間分享技術，它將物理記憶體抽象化為地址空間，每個進程都有各自的地址空間。地址空間的頁被映射到物理記憶體中，地址空間的頁並不需要全部在物理記憶體中，當使用到一個沒有物理記憶體的頁時，執行頁面置換演算法，將該頁置換到記憶體中。 4.</description></item><item><title>[計算機作業系統] 死鎖</title><link>https://intervalrain.github.io/posts/cs/os/deadlock/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/os/deadlock/</guid><description>準備中</description></item><item><title>[計算機作業系統] 記憶體管理</title><link>https://intervalrain.github.io/posts/cs/os/memorymanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/os/memorymanagement/</guid><description>準備中</description></item><item><title>[計算機作業系統] 設備管理</title><link>https://intervalrain.github.io/posts/cs/os/equipmentmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/os/equipmentmanagement/</guid><description>準備中</description></item><item><title>[計算機作業系統] 進程管理</title><link>https://intervalrain.github.io/posts/cs/os/processmanagement/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/os/processmanagement/</guid><description>進程管理 進程與執行緒 1. 進程(process) 進程是資源分配的基本單位。 進程控制塊(Process Control Block, PCB)描述進程的基本訊息和運行狀態，所謂的創建進程和撤銷進程，都是指對 PCB 的操作。 2. 執行緒(thread) 執行緒又稱線程，是獨立調度的基本單位。 一個進程可以有多個執行緒，它們共享進程資源。 以瀏覽器(browser)為例，瀏覽器進程有很多執行緒，如 HTTP 請求(request)、事件響應、渲染。執行緒的並行處理(concurrent)使得瀏覽器中點擊一個新的超連結從而發起 HTTP 請求時，瀏覽器還可以響應用戶的其它事件。 3. 區別 擁有資源 進程是資源分配的基本單位，但是執行緒不擁有資源，而是訪問隸屬進程的資源。 調度 執行緒是獨立調度的基本單位，在同一進程中，執行緒的切換不會引起進程切換，從一個進程中的執行緒切換到另一個進程中的執行緒時，才會進行進程的切換。 系統開銷 由於創建或撤銷進程時，系統都要為之分配或回收資源，如硬碟中的記憶體、I/O 設備等，所付出的開銷遠大於創建或撤銷執行緒時的開銷。 同樣的，在進行進程切換時，涉及當前執行進程 CPU 環境的保存及新調度進程 CPU 環境的設置，而執行緒切換只需保存和設置少量暫存器的內容，開銷較小。 通訊 執行緒可以通過直接讀寫同一個進程中的數據進行通訊，但是進程的通訊需要借助 IPC(inter-process communication)。 進程狀態的切換 就緒就態(ready)：等待被調度 執行狀態(running) 阻塞狀態(waiting)：等待資源 只有就緒狀態和執行狀態可以相互轉換，其它的都是單向轉換。就緒狀態的進程通過調度演算法從而獲得 CPU Time，轉為執行狀態；而執行狀態的進程，在分配給它的 CPU Time 片段用完之後就會轉為就緒狀態，等待下一次調度。 阻塞狀態是缺少需要的資源從而由執行狀態轉換而來，但是該資源不包括 CPU Time, 缺少 CPU Time 會從執行狀態轉換為就緒狀態。 進程調度演算法 不同環境的調度演算法目標不同，因此需要針對不同環境來討論調度演算法。 1. 批次處理系統(batch system) 批次處理系統沒有太多的用戶操作，在該系統中，調度演算法目標是保証吞吐量和周轉時間(從提交到終止的時間)。 1.1 先來先服務(first-come first-served, FCFS) 非搶占式的調度，按照請求的順序進行調度。 有利於長作業，不利於短作業，因為短作業必須一直等待前面的長作業執行完畢才能執行，而長作業又需要執行很長時間，造成短作業等待時間過長 1.2 短作業優先(shortest job first, SJF) 非搶占式的調度算法，按估計運行時間最短的順序進行調度。 長作業有可能會永遠做不完，處於一直等待短作業執行完畢的狀態。因為如果一直有短作業到來，那麼長作業永遠得不到調度。 1.</description></item><item><title>[計算機作業系統] 鏈接</title><link>https://intervalrain.github.io/posts/cs/os/link/</link><pubDate>Sat, 02 Jul 2022 04:00:55 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs/os/link/</guid><description>準備中</description></item><item><title>[CS50] Lec 1 - C</title><link>https://intervalrain.github.io/posts/cs50/lec1/</link><pubDate>Thu, 10 Mar 2022 02:39:12 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs50/lec1/</guid><description>Introduction to programming language C</description></item><item><title>[CS50] Lec 0 - Introduction to Computer Science</title><link>https://intervalrain.github.io/posts/cs50/lec0/</link><pubDate>Wed, 23 Feb 2022 00:43:18 +0800</pubDate><guid>https://intervalrain.github.io/posts/cs50/lec0/</guid><description>Intoduction to Computer Science</description></item></channel></rss>